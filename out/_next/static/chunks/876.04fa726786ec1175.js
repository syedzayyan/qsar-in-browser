(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[876],{18166:function(F,$,V){"use strict";V.d($,{H:function(){return assertNotComplex}});var G=V(15949);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertNotComplex(F,$){Array.isArray(F)||(F=[F]),F.forEach(F=>{null!=F&&G.D5U.assert("complex64"!==F.dtype,()=>`${$} does not support complex64 tensors in the CPU backend.`)})}},60224:function(F,$,V){"use strict";V.d($,{bk:function(){return simpleAbsImpl},fC:function(){return K}});var G=V(15949),H=V(18166);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function simpleAbsImpl(F){let $=new Float32Array(F.length);for(let V=0;V<F.length;++V)$[V]=Math.abs(F[V]);return $}let abs=F=>{let{x:$}=F.inputs,V=F.backend;(0,H.H)($,"abs");let K=new Float32Array(G.D5U.sizeFromShape($.shape)),Z=V.data.get($.dataId).values;return K=simpleAbsImpl(Z),V.makeOutput(K,$.shape,$.dtype)},K={kernelName:G.SYM,backendName:"cpu",kernelFunc:abs}},32779:function(F,$,V){"use strict";V.d($,{EH:function(){return Z},IH:function(){return et},j4:function(){return en}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>F+$),ee=(0,K.H)((F,$,V,G)=>({real:F+V,imag:$+G})),et=(0,K.j)(G.mm_,Z,ee),en={kernelName:G.mm_,backendName:"cpu",kernelFunc:et}},58607:function(F,$,V){"use strict";V.d($,{W:function(){return bincountImpl},i:function(){return bincountReduceImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bincountImpl(F,$,V,H,K){let Z=G.D5U.sizeFromShape(H),ee=G.D5U.makeZerosTypedArray(K,V);for(let V=0;V<F.length;V++){let G=F[V];if(G<0)throw Error("Input x must be non-negative!");G>=K||(Z>0?ee[G]+=$[V]:ee[G]+=1)}return ee}function bincountReduceImpl(F,$,V,H=!1){let K=F.shape[0],Z=F.shape[1],ee=(0,G.f3b)([K,V],$.dtype);for(let G=0;G<K;G++)for(let K=0;K<Z;K++){let Z=F.get(G,K);if(Z<0)throw Error("Input x must be non-negative!");Z>=V||(H?ee.set(1,G,Z):$.size>0?ee.set(ee.get(G,Z)+$.get(G,K),G,Z):ee.set(ee.get(G,Z)+1,G,Z))}return ee}},5003:function(F,$,V){"use strict";V.d($,{T0:function(){return et},nv:function(){return Z}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>F&$),ee=(0,K.j)(G.hCO,Z),et={kernelName:G.hCO,backendName:"cpu",kernelFunc:ee}},29258:function(F,$,V){"use strict";V.d($,{Mq:function(){return en},pj:function(){return cast},sJ:function(){return castImpl}});var G=V(15949),H=V(33533),K=V(24391),Z=V(26961),ee=V(41775),et=V(82186);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function castImpl(F,$,V,K){if("int32"===K){let V=Int32Array.from(F);return[$,"int32",V]}if("bool"===K){let K=G.D5U.toTypedArray([0],V),[Z,ee]=(0,H.b)((F,$)=>F!==$?1:0)($,[],F,K,"bool");return[ee,"bool",Z]}throw Error(`Error in Cast: failed to cast ${V} to ${K}`)}function cast(F){let{inputs:$,backend:V,attrs:H}=F,{x:en}=$,{dtype:ea}=H;if("complex64"===ea){if("complex64"===en.dtype)return(0,ee.y)({inputs:{x:en},backend:V});let F=(0,K.l)(V,en.shape,en.dtype),$=cast({inputs:{x:en},backend:V,attrs:{dtype:"float32"}}),G=(0,Z.P)({inputs:{real:$,imag:F},backend:V});return V.disposeIntermediateTensorInfo(F),V.disposeIntermediateTensorInfo($),G}if("complex64"===en.dtype){let F=(0,et.k)({inputs:{input:en},backend:V}),$=cast({inputs:{x:F},backend:V,attrs:{dtype:ea}});return V.disposeIntermediateTensorInfo(F),$}if(!G.D5U.hasEncodingLoss(en.dtype,ea)){let F=(0,ee.y)({inputs:{x:en},backend:V});return{dataId:F.dataId,shape:F.shape,dtype:ea}}let ei=V.data.get(en.dataId).values,[eo,es,eu]=castImpl(ei,en.shape,en.dtype,ea);return V.makeTensorInfo(eo,es,eu)}let en={kernelName:G.RFZ,backendName:"cpu",kernelFunc:cast}},34769:function(F,$,V){"use strict";V.d($,{__:function(){return Z},y2:function(){return et}});var G=V(15949),H=V(18029),K=V(76738);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.a)(F=>Math.ceil(F)),ee=(0,K.O)(G.gJX,Z),et={kernelName:G.gJX,backendName:"cpu",kernelFunc:ee}},26961:function(F,$,V){"use strict";V.d($,{P:function(){return complex},z:function(){return H}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex(F){let{inputs:$,backend:V}=F,{real:G,imag:H}=$,K=V.data.get(G.dataId).values,Z=V.data.get(H.dataId).values,ee=V.makeTensorInfo(G.shape,"complex64"),et=V.data.get(ee.dataId);return et.complexTensorInfos={real:V.makeTensorInfo(G.shape,"float32",K),imag:V.makeTensorInfo(H.shape,"float32",Z)},ee}let H={kernelName:G.Zz9,backendName:"cpu",kernelFunc:complex}},48926:function(F,$,V){"use strict";V.d($,{j:function(){return concatImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concatImpl(F,$,V,H){let K=G.D5U.getArrayFromDType(V,G.D5U.sizeFromShape($));if(H&&"string"!==V){let $=0;F.forEach(F=>{let V=G.D5U.sizeFromShape(F.shape);K.set(F.vals,$),$+=V})}else{let H=0;F.forEach(F=>{let Z="string"===V?G.backend_util.fromUint8ToStringArray(F.vals):F.vals,ee=0;for(let V=0;V<F.shape[0];++V){let G=V*$[1]+H;for(let $=0;$<F.shape[1];++$)K[G+$]=Z[ee++]}H+=F.shape[1]})}return K}},7679:function(F,$,V){"use strict";V.d($,{Dg:function(){return ee},Kx:function(){return et},tW:function(){return Z}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>F===$?1:0),ee=(0,K.j)(G.hdR,Z,null,"bool"),et={kernelName:G.hdR,backendName:"cpu",kernelFunc:ee}},31211:function(F,$,V){"use strict";V.d($,{Qq:function(){return ee},Ro:function(){return Z},SX:function(){return et}});var G=V(15949),H=V(18029),K=V(76738);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.a)(F=>Math.exp(F)),ee=(0,K.O)(G.NEP,Z,"float32"),et={kernelName:G.NEP,backendName:"cpu",kernelFunc:ee}},30969:function(F,$,V){"use strict";V.d($,{OF:function(){return Z},Vu:function(){return et}});var G=V(15949),H=V(18029),K=V(76738);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.a)(F=>Math.expm1(F)),ee=(0,K.O)(G.Y0y,Z),et={kernelName:G.Y0y,backendName:"cpu",kernelFunc:ee}},76574:function(F,$,V){"use strict";V.d($,{Ao:function(){return et},r6:function(){return Z}});var G=V(15949),H=V(18029),K=V(76738);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.a)(F=>Math.floor(F)),ee=(0,K.O)(G.OR,Z),et={kernelName:G.OR,backendName:"cpu",kernelFunc:ee}},44892:function(F,$,V){"use strict";V.d($,{EE:function(){return et},JP:function(){return Z}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>Math.floor(F/$)),ee=(0,K.j)(G.jeX,Z,null,"int32"),et={kernelName:G.jeX,backendName:"cpu",kernelFunc:ee}},31820:function(F,$,V){"use strict";V.d($,{m:function(){return gatherNdImpl}});var G=V(15949);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherNdImpl(F,$,V,H,K,Z,ee,et,en){let ea=(0,G.f3b)([H,Z],V);for(let V=0;V<H;V++){let G=[],H=0;for(let $=0;$<K;$++){let Z=F[V*K+$];H+=Z*ee[$],G.push(Z)}if(H<0||H>=en/Z)throw Error(`Invalid indices: ${G} does not index into ${et}`);for(let F=0;F<Z;F++)ea.values[V*Z+F]=$.get(...$.indexToLoc(H*Z+F))}return ea}},54468:function(F,$,V){"use strict";V.d($,{i:function(){return gatherV2Impl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2Impl(F,$,V){let H=(0,G.f3b)(V,F.dtype);for(let V=0;V<H.size;++V){let G=H.indexToLoc(V),K=G.slice(),Z=K[0],ee=K[2],et=$.locToIndex([Z,ee]);K[2]=$.values[et];let en=F.locToIndex(K);0<=en&&en<F.values.length&&(H.values[V]=F.values[en])}return H}},36272:function(F,$,V){"use strict";V.d($,{Ce:function(){return et},o:function(){return Z}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>F>$?1:0),ee=(0,K.j)(G.iZT,Z,null,"bool"),et={kernelName:G.iZT,backendName:"cpu",kernelFunc:ee}},26259:function(F,$,V){"use strict";V.d($,{HL:function(){return Z},V:function(){return et}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>F>=$?1:0),ee=(0,K.j)(G.Acj,Z,null,"bool"),et={kernelName:G.Acj,backendName:"cpu",kernelFunc:ee}},41775:function(F,$,V){"use strict";V.d($,{I:function(){return H},y:function(){return identity}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function identity(F){let{inputs:$,backend:V}=F,{x:G}=$;return V.incRef(G.dataId),{dataId:G.dataId,shape:G.shape,dtype:G.dtype}}let H={kernelName:G.iJz,backendName:"cpu",kernelFunc:identity}},88405:function(F,$,V){"use strict";V.d($,{rO:function(){return Z},zh:function(){return et}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>F<$?1:0),ee=(0,K.j)(G.vtC,Z,null,"bool"),et={kernelName:G.vtC,backendName:"cpu",kernelFunc:ee}},40635:function(F,$,V){"use strict";V.d($,{lx:function(){return Z},m3:function(){return et}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>F<=$?1:0),ee=(0,K.j)(G.CAk,Z,null,"bool"),et={kernelName:G.CAk,backendName:"cpu",kernelFunc:ee}},61325:function(F,$,V){"use strict";V.d($,{b:function(){return linSpaceImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function linSpaceImpl(F,$,V){let H=($-F)/(V-1),K=G.D5U.makeZerosTypedArray(V,"float32");K[0]=F;for(let F=1;F<K.length;F++)K[F]=K[F-1]+H;return K}},55223:function(F,$,V){"use strict";V.d($,{vX:function(){return Z},xM:function(){return et}});var G=V(15949),H=V(18029),K=V(76738);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.a)(F=>Math.log(F)),ee=(0,K.O)(G.ZbH,Z),et={kernelName:G.ZbH,backendName:"cpu",kernelFunc:ee}},55126:function(F,$,V){"use strict";V.d($,{B:function(){return maxImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxImpl(F,$,V,H){let K=G.D5U.getTypedArrayFromDType(H,G.D5U.sizeFromShape(V));for(let V=0;V<K.length;++V){let G=V*$,H=F[G];for(let V=0;V<$;++V){let $=F[G+V];(Number.isNaN($)||$>H)&&(H=$)}K[V]=H}return K}},71717:function(F,$,V){"use strict";V.d($,{eJ:function(){return et},wS:function(){return Z}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>Math.max(F,$)),ee=(0,K.j)(G.BMI,Z),et={kernelName:G.BMI,backendName:"cpu",kernelFunc:ee}},612:function(F,$,V){"use strict";V.d($,{u0:function(){return et},vP:function(){return Z}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>Math.min(F,$)),ee=(0,K.j)(G.q8u,Z),et={kernelName:G.q8u,backendName:"cpu",kernelFunc:ee}},1917:function(F,$,V){"use strict";V.d($,{$3:function(){return Z},Jp:function(){return et},f$:function(){return en}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>F*$),ee=(0,K.H)((F,$,V,G)=>({real:F*V-$*G,imag:F*G+$*V})),et=(0,K.j)(G.wYn,Z,ee),en={kernelName:G.wYn,backendName:"cpu",kernelFunc:et}},70854:function(F,$,V){"use strict";V.d($,{AF:function(){return Z},uC:function(){return negImpl}});var G=V(15949),H=V(18166),K=V(1917);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function negImpl(F,$,V){let H=G.D5U.createScalarValue(-1,V);return(0,K.$3)([],$,H,F,V)}function neg(F){let{inputs:$,backend:V}=F,{x:G}=$;(0,H.H)(G,"neg");let K=V.data.get(G.dataId).values,[Z,ee]=negImpl(K,G.shape,G.dtype);return V.makeTensorInfo(ee,G.dtype,Z)}let Z={kernelName:G.kuV,backendName:"cpu",kernelFunc:neg}},98584:function(F,$,V){"use strict";V.d($,{Gj:function(){return Z},nP:function(){return et}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>F!==$?1:0),ee=(0,K.j)(G.yQU,Z,null,"bool"),et={kernelName:G.yQU,backendName:"cpu",kernelFunc:ee}},29560:function(F,$,V){"use strict";V.d($,{Iz:function(){return Z},Qg:function(){return prodImpl}});var G=V(15949),H=V(18166),K=V(44802);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prodImpl(F,$,V,H){let[K,Z]=G.backend_util.computeOutAndReduceShapes(F,H),ee=(0,G.x8V)($,"int32"),et=G.D5U.makeZerosTypedArray(G.D5U.sizeFromShape(K),ee),en=G.D5U.sizeFromShape(Z);for(let F=0;F<et.length;++F){let $=F*en,G=1;for(let F=0;F<en;++F)G*=V[$+F];et[F]=G}return{outVals:et,outShape:K,outDtype:ee}}function prod(F){let{inputs:$,backend:V,attrs:Z}=F,{x:ee}=$,{axis:et,keepDims:en}=Z;(0,H.H)(ee,"prod");let ea=ee.shape.length,ei=G.D5U.parseAxisParam(et,ee.shape),eo=G.backend_util.getAxesPermutation(ei,ea),es=ei,eu=ee,ec=[];null!=eo&&(ec.push(eu=(0,K.p)({inputs:{x:ee},backend:V,attrs:{perm:eo}})),es=G.backend_util.getInnerMostAxes(es.length,ea));let ep=V.data.get(eu.dataId).values,{outVals:eh,outShape:ef,outDtype:ed}=prodImpl(eu.shape,eu.dtype,ep,es),em=ef;return en&&(em=G.backend_util.expandShapeToKeepDim(ef,ei)),ec.forEach(F=>V.disposeIntermediateTensorInfo(F)),V.makeTensorInfo(em,ed,eh)}let Z={kernelName:G.DlI,backendName:"cpu",kernelFunc:prod}},59885:function(F,$,V){"use strict";V.d($,{c:function(){return raggedGatherImpl}});var G=V(15949);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function validateIndices(F,$,V){F.forEach((F,H)=>{if(F<0||F>=V){let K=G.D5U.indexToLoc(H,$.length,G.D5U.computeStrides($)).join(",");throw Error(`indices[${K}] = ${F} is not in [0, ${V})`)}})}function validateSplits(F,$){for(let V=0;V<F.length;++V){let G=F[V],H=V===F.length-1?$:F[V+1].length;if(0===G.length)throw Error("Ragged splits may not be empty");if(G[0]<0)throw Error("Ragged splits must be non-negative");if(G[G.length-1]>H)throw Error("Ragged splits must not point past values");for(let F=1;F<G.length;++F)if(G[F-1]>G[F])throw Error("Ragged splits must be sorted in ascending order")}}function makeSplits(F,$,V,G){let H=[],K=0,Z=$.length-1+V.length,ee=Array(Z).fill(null).map(()=>[0]);validateSplits(V,G);let et=1;for(let F=0;F<$.length-1;++F){et*=$[F];let V=$[F+1];for(let $=1;$<et+1;++$)ee[F].push($*V)}for(let G=0;G<F.length;++G){let Z=F[G],et=F[G]+1;for(let F=0;F<V.length;++F){let G=V[F],H=F+$.length-1;if(H>=0){let F=ee[H],$=F[F.length-1]-G[Z];for(let F=Z;F<et;++F)ee[H].push(G[F+1]+$)}Z=G[Z],et=G[et]}et!==Z&&(H.push([Z,et]),K+=et-Z)}return{outSplits:ee,valueSlices:H,numValues:K}}function getSplits(F){let $=[];for(let V=0;V<F.length;++V){let H=F[V].length,K=G.D5U.getArrayFromDType("int32",H);$.push(K),F[V].forEach((F,$)=>K[$]=F)}return $}function computeFlatOuterDims(F,$){let V=F.slice(0,$);for(;V.length<$;)V.push(1);for(let G=$;G<F.length;G++)V[$-1]*=F[G];return V}function writeValueSlices(F,$,V,G,H,K){let Z=computeFlatOuterDims($,2)[1],ee=computeFlatOuterDims(K,2)[1],et=0;for(let $ of V)for(let V=$[0];V<$[1];++V){for(let $=0;$<G;++$)H[et*ee+$]=F[V*Z+$];++et}}function getValues(F,$,V,H,K){let Z=$.slice();Z[0]=K;let ee=G.D5U.getArrayFromDType(V,G.D5U.sizeFromShape(Z)),et=F.length,en=0===et?0:et/$[0];return writeValueSlices(F,$,H,en,ee,Z),[ee,Z]}function raggedGatherImpl(F,$,V,G,H,K,Z,ee){if(0===F.length)throw Error("paramsNestedSplits must be non empty");if(0===$[0].length)throw Error("Split tensors must not be scalars");let et=$[0][0]-1;if(validateIndices(K,Z,et),0===G.length)throw Error("params.rank must be nonzero");let en=G[0],{outSplits:ea,valueSlices:ei,numValues:eo}=makeSplits(K,Z,F,en),es=getSplits(ea),eu=getValues(V,G,H,ei,eo);return[es,eu[0],eu[1]]}},36486:function(F,$,V){"use strict";V.d($,{S:function(){return raggedRangeImpl}});var G=V(15949);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let H=2147483647;function raggedRangeImpl(F,$,V,K,Z,ee,et){if($.length>1)throw Error("starts must be a scalar or vector");if(Z.length>1)throw Error("limits must be a scalar or vector");if(et.length>1)throw Error("deltas must be a scalar or vector");let en=0===$.length,ea=0===Z.length,ei=0===et.length,eo=[];en||eo.push($[0]),ea||eo.push(Z[0]),ei||eo.push(et[0]);for(let F=1;F<eo.length;++F)if(eo[F]!==eo[F-1])throw Error("starts, limits, and deltas must have the same shape");let es=0===eo.length?1:eo[0],eu=G.D5U.getArrayFromDType("int32",es+1);eu[0]=0;for(let $=0;$<es;++$){let V;let G=en?F[0]:F[$],Z=ea?K[0]:K[$],et=ei?ee[0]:ee[$];if(0===et)throw Error("Requires delta != 0");if(et>0&&Z<G||et<0&&Z>G)V=0;else if((V=Math.ceil(Math.abs((Z-G)/et)))>H)throw Error(`Requires ((limit - start) / delta) <= ${H}`);eu[$+1]=eu[$]+V}let ec=eu[es],ep=G.D5U.getArrayFromDType(V,ec),eh=0;for(let $=0;$<es;++$){let V=eu[$+1]-eu[$],G=en?F[0]:F[$],H=ei?ee[0]:ee[$];for(let F=0;F<V;++F)ep[eh++]=G,G+=H}return[eu,ep]}},8306:function(F,$,V){"use strict";V.d($,{p:function(){return raggedTensorToTensorImpl}});var G=V(15949),H=G.backend_util.RowPartitionType;let RaggedTensorToTensorOp=class RaggedTensorToTensorOp{constructor(F,$,V,H,K,Z,ee,et,en,ea){this.shape=F,this.shapeShape=$,this.values=V,this.valuesShape=H,this.valuesDType=K,this.defaultValue=Z,this.defaultValueShape=ee,this.rowPartitionValues=et,this.rowPartitionValuesShapes=en,this.rowPartitionTypes=G.backend_util.getRowPartitionTypesHelper(ea),this.raggedRank=G.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(F){return this.rowPartitionTypes[0]===H.FIRST_DIM_SIZE?this.rowPartitionTypes[F+1]:this.rowPartitionTypes[F]}getRowPartitionTensor(F){return this.rowPartitionTypes[0]===H.FIRST_DIM_SIZE?this.rowPartitionValues[F+1]:this.rowPartitionValues[F]}getMaxWidth(F){let $=this.getRowPartitionTensor(F-1);switch(this.getRowPartitionTypeByDimension(F-1)){case H.VALUE_ROWIDS:return RaggedTensorToTensorOp.getMaxWidthValueRowID($);case H.ROW_SPLITS:return RaggedTensorToTensorOp.getMaxWidthRowSplit($);default:throw Error(`Cannot handle partition type ${H[this.getRowPartitionTypeByDimension(F-1)]}`)}}static getMaxWidthRowSplit(F){let $=F.length;if(0===$||1===$)return 0;let V=0;for(let G=0;G<$-1;++G){let $=F[G+1]-F[G];$>V&&(V=$)}return V}static getMaxWidthValueRowID(F){let $=F.length;if(0===$)return 0;let V=0,G=F[0],H=0;for(let K=1;K<$;++K){let $=F[K];$!==G&&(G=$,H=Math.max(K-V,H),V=K)}return Math.max($-V,H)}tensorShapeFromTensor(F,$,V=!0){if(0===$.length){if(-1===F[0])return[];throw Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return makeShape(F,V)}calculateOutputSize(F){let $=this.valuesShape,V=this.defaultValueShape;G.backend_util.validateDefaultValueShape(V,$);let H=this.tensorShapeFromTensor(this.shape,this.shapeShape),K=G.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,H,$),Z=K;Z[0]<0&&(Z[0]=F);for(let F=1;F<=this.raggedRank;++F)Z[F]<0&&(Z[F]=this.getMaxWidth(F));return Z}calculateFirstParentOutputIndex(F,$,V){let H=Math.min(F,V),K=[],Z=0;for(let F=0;F<H;++F,Z+=$)K.push(Z);for(let $=H;$<F;++$)K.push(-1);return G.D5U.assert(K.length===F,()=>"Final length of result must be equal to firstDimension."),K}calculateOutputIndexRowSplit(F,$,V,G){let H=F.length,K=[];for(let Z=0;Z<H-1;++Z){let H=F[Z+1]-F[Z],ee=Math.min(G,H),et=$[Z];-1===et&&(ee=0);for(let F=0;F<ee;++F)K.push(et),et+=V;for(let F=0;F<H-ee;++F)K.push(-1)}if(H>0&&K.length!==F[H-1])throw Error("Invalid row split size.");return K}calculateOutputIndexValueRowID(F,$,V,G){let H=F.length,K=[];if(0===H)return[];let Z=0,ee=F[0];if(ee>=$.length)throw Error(`Got currentValueRowId=${ee}, which is not less than ${$.length}`);let et=$[ee];K.push(et);for(let en=1;en<H;++en){let H=F[en];if(H===ee)et>=0&&(++Z<G?et+=V:et=-1);else{if(Z=0,ee=H,H>=$.length)throw Error(`Got nextValueRowId=${H} which is not less than ${$.length}`);et=$[H]}K.push(et)}if(K.length!==F.length)throw Error("Invalid row ids.");return K}calculateOutputIndex(F,$,V,G){let K=this.getRowPartitionTensor(F),Z=this.getRowPartitionTypeByDimension(F);switch(Z){case H.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(K,$,V,G);case H.ROW_SPLITS:if(K.length-1>$.length)throw Error(`Row partition size is greater than output size: ${K.length-1} > ${$.length}`);return this.calculateOutputIndexRowSplit(K,$,V,G);default:throw Error(`Unsupported partition type: ${H[Z]}`)}}getFirstDimensionSize(){let F=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw Error("No row_partition_types given.");let $=this.rowPartitionTypes[0];switch($){case H.FIRST_DIM_SIZE:return F[0];case H.VALUE_ROWIDS:throw Error("Cannot handle VALUE_ROWIDS in first dimension.");case H.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw Error(`Cannot handle type ${H[$]}`)}}compute(){let F=this.rowPartitionValues[0];if(F.length<=0)throw Error("Invalid first partition input. Tensor requires at least one element.");let $=this.getFirstDimensionSize(),V=this.calculateOutputSize($),H=Array(this.raggedRank+1);H[H.length-1]=1;for(let F=H.length-2;F>=0;--F)H[F]=H[F+1]*V[F+1];let K=makeShape(V,!1),Z=G.D5U.getArrayFromDType(this.valuesDType,G.D5U.sizeFromShape(K)),ee=H[0]*V[0];if(ee>0){let F=this.calculateFirstParentOutputIndex($,H[0],V[0]);for(let $=1;$<=this.raggedRank;++$){let G=this.calculateOutputIndex($-1,F,H[$],V[$]);F=G}this.setOutput(this.raggedRank,F,Z,K)}return[K,Z]}setOutput(F,$,V,H){if(0===V.length)return;let K=this.values,Z=V,ee=H.slice();ee=ee.slice(F+1);let et=G.D5U.sizeFromShape(ee),en=$.length,ea=this.defaultValue;if(ea.length!==et&&1!==ea.length){let F=this.defaultValueShape;(0,G.lub)(()=>{let $=(0,G.XLQ)(ea,F),V=(0,G.UFq)($,ee);ea=V.dataSync()})}let ei=0,eo=0,es=0;for(let F=0;F<=en;++F){let G=F<en?$[F]:-1;if(G===es){++es;continue}if(eo<es){let F=K.subarray(ei*et),$=Z.subarray(eo*et),V=(es-eo)*et;copyArray($,F,V)}if(F>=en){let F=V.length;G=Math.floor(F/et)}if(G>es){if(1===this.defaultValue.length)Z.subarray(es*et,G*et).fill(this.defaultValue[0]),es=G;else for(;G>es;){let F=Z.slice(es*et);copyArray(F,ea,et),++es}}G<0?(ei=F+1,eo=es):(ei=F,es=(eo=es)+1)}}};function copyArray(F,$,V){for(let G=0;G<V;G++)F[G]=$[G]}function makeShape(F,$){let V=[];for(let G of F){if(G<0){if(!$)throw Error(`Dimension ${G} must be >= 0`);if(G<-1)throw Error(`Dimension ${G} must be >= -1`);G=-1}V.push(G)}return V}function raggedTensorToTensorImpl(F,$,V,G,H,K,Z,ee,et,en){return new RaggedTensorToTensorOp(F,$,V,G,H,K,Z,ee,et,en).compute()}},99230:function(F,$,V){"use strict";V.d($,{b:function(){return rangeImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rangeImpl(F,$,V,H){let K=F===$,Z=F<$&&V<0,ee=$<F&&V>1;if(K||Z||ee)return G.D5U.makeZerosTypedArray(0,H);let et=Math.abs(Math.ceil(($-F)/V)),en=G.D5U.makeZerosTypedArray(et,H);$<F&&1===V&&(V=-1),en[0]=F;for(let F=1;F<en.length;F++)en[F]=en[F-1]+V;return en}},82186:function(F,$,V){"use strict";V.d($,{O:function(){return H},k:function(){return real}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real(F){let{inputs:$,backend:V}=F,{input:G}=$,H=V.data.get(G.dataId).complexTensorInfos.real,K=V.data.get(H.dataId).values;return V.makeTensorInfo(H.shape,H.dtype,K)}let H={kernelName:G.xJR,backendName:"cpu",kernelFunc:real}},7742:function(F,$,V){"use strict";V.d($,{FY:function(){return et},zd:function(){return Z}});var G=V(15949),H=V(18029),K=V(76738);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.a)(F=>1/Math.sqrt(F)),ee=(0,K.O)(G.bV0,Z),et={kernelName:G.bV0,backendName:"cpu",kernelFunc:ee}},60001:function(F,$,V){"use strict";V.d($,{N:function(){return scatterImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scatterImpl(F,$,V,H,K,Z,ee,et,en,ea){let ei=[H/K,K],eo=F.values,es=$.values;if(0===H)return(0,G.f3b)(V,$.dtype);let eu=en instanceof G.YDk?en:(0,G.f3b)(ei,$.dtype);"string"==typeof en?eu.values.fill(en):"number"==typeof en?eu.values.fill(en):"boolean"==typeof en&&eu.values.fill(+en);for(let F=0;F<Z;F++){let G=[],Z=0;for(let $=0;$<ee;$++){let V=eo[F*ee+$];G.push(V),Z+=V*et[$]}if(Z<0||Z>=H/K)throw Error(`Invalid indices: ${G} does not index into ${V}`);for(let V=0;V<K;V++)ea?eu.values[Z*K+V]+=es[F*K+V]:eu.values[Z*K+V]=0===$.rank?es[0]:es[F*K+V]}return eu}},40108:function(F,$,V){"use strict";V.d($,{BP:function(){return et},VY:function(){return Z},XD:function(){return ee}});var G=V(15949),H=V(18029),K=V(76738);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.a)(F=>1/(1+Math.exp(-F))),ee=(0,K.A)(G.a5O,F=>1/(1+Math.exp(-F))),et={kernelName:G.a5O,backendName:"cpu",kernelFunc:ee}},82578:function(F,$,V){"use strict";V.d($,{C6:function(){return K},rT:function(){return sliceImpl},tP:function(){return slice}});var G=V(15949),H=V(18166);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sliceImpl(F,$,V,H,K){let Z=G.kuN.isSliceContinous(H,$,V),ee=G.D5U.sizeFromShape(V),et=G.D5U.computeStrides(H);if(Z){let V=G.kuN.computeFlatOffset($,et);return"string"===K?F.slice(V,V+ee):F.subarray(V,V+ee)}let en="string"===K?G.backend_util.fromUint8ToStringArray(F):F,ea=(0,G.f3b)(H,K,en),ei=(0,G.f3b)(V,K);for(let F=0;F<ei.size;++F){let V=ei.indexToLoc(F),G=V.map((F,V)=>F+$[V]);ei.set(ea.get(...G),...V)}return"string"===K?G.backend_util.fromStringArrayToUint8(ei.values):ei.values}function slice(F){let{inputs:$,backend:V,attrs:K}=F,{x:Z}=$,{begin:ee,size:et}=K;(0,H.H)(Z,"slice");let[en,ea]=G.kuN.parseSliceParams(Z,ee,et);G.kuN.assertParamsValid(Z,en,ea);let ei=V.data.get(Z.dataId).values,eo=sliceImpl(ei,en,ea,Z.shape,Z.dtype);return V.makeTensorInfo(ea,Z.dtype,eo)}let K={kernelName:G.p2w,backendName:"cpu",kernelFunc:slice}},42123:function(F,$,V){"use strict";V.d($,{c:function(){return sparseFillEmptyRowsImpl}});var G=V(15949);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseFillEmptyRowsImpl(F,$,V,H,K,Z,ee){let et=$[0],en=Z[0],ea=Array(en),ei=Array(et),eo=$[1];if(0===en){if(0!==et)throw Error(G.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(et));let F=G.D5U.getArrayFromDType(V,0),$=G.D5U.getArrayFromDType(K,0);return[F,[0,eo],$,ea,ei]}let es=!0,eu=0,ec=Array(en).fill(0);for(let $=0;$<et;++$){let V=F[$*eo];if(V<0)throw Error(G.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage($,V));if(V>=en)throw Error(G.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage($,V,en));++ec[V],es=es&&V>=eu,eu=V}let ep=!0;for(let F=0;F<en;++F){let $=0===ec[F];ea[F]=$,ep=ep&&!$,ec[F]=Math.max(ec[F],1),F>0&&(ec[F]+=ec[F-1])}if(ep&&es){let $=F,V=H;for(let F=0;F<et;++F)ei[F]=F;return[$,[et,eo],V,ea,ei]}{let $=ec[en-1],Z=G.D5U.getArrayFromDType(V,$*eo),es=G.D5U.getArrayFromDType(K,$),eu=Array(en).fill(0);for(let $=0;$<et;++$){let V=F[$*eo],G=eu[V],K=(0===V?0:ec[V-1])+G;eu[V]++;for(let V=0;V<eo;++V)Z[K*eo+V]=F[$*eo+V];es[K]=H[$],ei[$]=K}for(let F=0;F<en;++F){let $=eu[F];if(0===$){let $=0===F?0:ec[F-1];Z[$*eo+0]=F;for(let F=1;F<eo;++F)Z[$*eo+F]=0;es[$]=ee}}return[Z,[$,eo],es,ea,ei]}}},3849:function(F,$,V){"use strict";V.d($,{U:function(){return sparseReshapeImpl}});var G=V(15949);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseReshapeImpl(F,$,V,H,K){let Z=G.D5U.sizeFromShape(H),ee=$[0],et=K.length,en=[],ea=1,ei=-1;for(let F=0;F<et;++F){let $=K[F];if(-1===$){if(-1!==ei)throw Error(G.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(ei,F));ei=F,en.push(1)}else{if($<0)throw Error(G.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(F,$));ea*=$,en.push($)}}if(-1!==ei){if(ea<=0)throw Error(G.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let F=Math.trunc(Z/ea);if(ea*F!==Z)throw Error(G.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(H,en));en[ei]=F}let eo=G.D5U.sizeFromShape(en);if(eo!==Z)throw Error(G.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(H,en));let es=H.length,eu=[];if(es>0){eu[es-1]=1;for(let F=es-2;F>=0;--F)eu[F]=eu[F+1]*H[F+1]}let ec=[];if(et>0){ec[et-1]=1;for(let F=et-2;F>=0;--F)ec[F]=ec[F+1]*en[F+1]}let ep=G.D5U.getArrayFromDType(V,ee*et);for(let $=0;$<ee;++$){let V=0;for(let G=0;G<es;++G)V+=F[$*es+G]*eu[G];for(let F=0;F<et;++F)ep[$*et+F]=Math.trunc(V/ec[F]),V%=ec[F]}return[ep,[ee,et],en]}},13989:function(F,$,V){"use strict";V.d($,{V:function(){return sparseSegmentReductionImpl}});var G=V(15949);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentReductionImpl(F,$,V,H,K,Z=!1,ee=0){let et=H.length,en=[$[0],F.length/$[0]],ea=en[1],ei=et>0?K[et-1]+1:0,eo=ei;if(eo<0)throw Error(G.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let es=$.slice();es[0]=eo;let eu=es.reduce((F,$)=>F*$,1),ec=G.D5U.getArrayFromDType(V,eu);if(0===et)return eo>0&&ec.fill(ee),[ec,es];if(eo<=0)throw Error(G.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let ep=0,eh=1,ef=0,ed=K[0];for(;;){let $=0;if(eh<et){if(ed===($=K[eh])){++eh;continue}if(ed>=$)throw Error(G.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(ed<0||ed>=eo)throw Error(G.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(ed,eo));ed>ef&&ec.fill(ee,ef*ea,ed*ea);for(let $=ep;$<eh;++$){let V=H[$];if(V<0||V>=en[0])throw Error(G.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage($,H[$],en[0]));for(let $=0;$<ea;$++)ec[ed*ea+$]+=F[V*ea+$]}if(Z)for(let F=0;F<ea;F++)ec[ed*ea+F]/=eh-ep;if(ep=eh,++eh,ef=ed+1,ed=$,eh>et)break}return ef<eo&&ec.fill(ee,ef*ea,eo*ea),[ec,es]}},10440:function(F,$,V){"use strict";V.d($,{cz:function(){return et},zT:function(){return Z}});var G=V(15949),H=V(18029),K=V(76738);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.a)(F=>Math.sqrt(F)),ee=(0,K.A)(G.FKq,F=>Math.sqrt(F)),et={kernelName:G.FKq,backendName:"cpu",kernelFunc:ee}},40212:function(F,$,V){"use strict";V.d($,{Hz:function(){return Z},MS:function(){return et}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>{let V=F-$;return V*V}),ee=(0,K.j)(G._tC,Z),et={kernelName:G._tC,backendName:"cpu",kernelFunc:ee}},27693:function(F,$,V){"use strict";V.d($,{P:function(){return Z},j:function(){return et}});var G=V(15949),H=V(18029),K=V(76738);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.a)((F,$)=>{let{pattern:V,replaceGlobal:G,rewrite:H}=$;return F.replace(new RegExp(V,G?"g":""),H)}),ee=(0,K.O)(G.e0R,Z),et={kernelName:G.e0R,backendName:"cpu",kernelFunc:ee}},62210:function(F,$,V){"use strict";V.d($,{t:function(){return stridedSliceImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stridedSliceImpl(F,$,V,H){let K=(0,G.f3b)(F,$.dtype);for(let F=0;F<K.size;F++){let G=K.indexToLoc(F),Z=Array(G.length);for(let F=0;F<Z.length;F++)Z[F]=G[F]*V[F]+H[F];K.set($.get(...Z),...G)}return K}},66841:function(F,$,V){"use strict";V.d($,{A:function(){return stringNGramsImpl}});var G=V(15949);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let StringNGramsOp=class StringNGramsOp{constructor(F,$,V,H,K,Z){this.separator=G.D5U.encodeString(F),this.nGramWidths=$,this.leftPad=G.D5U.encodeString(V),this.rightPad=G.D5U.encodeString(H),this.padWidth=K,this.preserveShort=Z}getPadWidth(F){return Math.min(this.padWidth<0?F-1:this.padWidth,F-1)}getNumNGrams(F,$){let V=this.getPadWidth($);return Math.max(0,F+2*V-$+1)}createNGrams(F,$,V,G,H,K){for(let Z=0;Z<H;++Z){let ee;let et=this.getPadWidth(K),en=Math.max(0,et-Z),ea=Math.max(0,et-(H-(Z+1))),ei=K-(en+ea),eo=$+(en>0?0:Z-et);ee=0+en*this.leftPad.length;for(let $=0;$<ei;++$)ee+=F[eo+$].length;ee+=ea*this.rightPad.length;let es=en+ea+ei-1;ee+=es*this.separator.length,V[G+Z]=new Uint8Array(ee);let eu=V[G+Z],ec=0,appendToNGram=F=>F.forEach(F=>eu[ec++]=F);for(let F=0;F<en;++F)appendToNGram(this.leftPad),appendToNGram(this.separator);for(let $=0;$<ei-1;++$)appendToNGram(F[eo+$]),appendToNGram(this.separator);if(ei>0){appendToNGram(F[eo+ei-1]);for(let F=0;F<ea;++F)appendToNGram(this.separator),appendToNGram(this.rightPad)}else{for(let F=0;F<ea-1;++F)appendToNGram(this.rightPad),appendToNGram(this.separator);appendToNGram(this.rightPad)}}}compute(F,$){let V=F.length,H=$.length;if(H>0){let F=$[0];if(0!==F)throw Error(`First split value must be 0, got ${F}`);for(let G=1;G<H;++G){let H=$[G]>=F;if(!(H=H&&$[G]<=V))throw Error(`Invalid split value ${$[G]}, must be in [${F}, ${V}]`);F=$[G]}if(F!==V)throw Error(`Last split value must be data size. Expected ${V}, got ${F}`)}let K=H-1,Z=G.D5U.getArrayFromDType("int32",H);if(0===V||0===H){let F=Array(V);for(let F=0;F<=K;++F)Z[F]=0;return[F,Z]}Z[0]=0;for(let F=1;F<=K;++F){let V=$[F]-$[F-1],G=0;this.nGramWidths.forEach(F=>{G+=this.getNumNGrams(V,F)}),this.preserveShort&&V>0&&0===G&&(G=1),Z[F]=Z[F-1]+G}let ee=Array(Z[K]);for(let V=0;V<K;++V){let G=$[V],H=Z[V];if(this.nGramWidths.forEach(K=>{let Z=$[V+1]-$[V],et=this.getNumNGrams(Z,K);this.createNGrams(F,G,ee,H,et,K),H+=et}),this.preserveShort&&H===Z[V]){let K=$[V+1]-$[V];if(0===K)continue;let Z=K+2*this.padWidth,et=1;this.createNGrams(F,G,ee,H,et,Z)}}return[ee,Z]}};function stringNGramsImpl(F,$,V,G,H,K,Z,ee){return new StringNGramsOp(V,G,H,K,Z,ee).compute(F,$)}},38639:function(F,$,V){"use strict";V.d($,{Q:function(){return stringSplitImpl}});var G=V(15949);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function split(F,$,V,G){if(!F.length)return;if(0===$.length){for(let $=0;$<F.length;++$)G.push(F.subarray($,$+1));return}if(1===$.length){let H=$[0],K=F.indexOf(H);for(;-1!==K;){let $=F.subarray(0,K);V&&0===$.length||G.push($),K=(F=F.subarray(K+1)).indexOf(H)}V&&0===F.length||G.push(F);return}let H=0;for(let K=0;K<F.length+1;K++)if(K===F.length||-1!==$.indexOf(F[K])){let $=F.subarray(H,K);V&&0===$.length||G.push($),H=K+1}}function stringSplitImpl(F,$,V){let H=F.length,K=[],Z=0,ee=0,et=Array(H);for(let G=0;G<H;++G){let H=K.length;split(F[G],$,V,K);let en=K.length-H;et[G]=en,Z+=en,ee=Math.max(ee,en)}let en=G.D5U.getArrayFromDType("int32",2*Z),ea=Array(Z),ei=[H,ee],eo=0;for(let F=0;F<H;++F)for(let $=0;$<et[F];++$)en[2*eo]=F,en[2*eo+1]=$,ea[eo]=K[eo],++eo;return[en,ea,ei]}},26626:function(F,$,V){"use strict";V.d($,{h:function(){return stringToHashBucketFastImpl}});var G=V(15949);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringToHashBucketFastImpl(F,$){let V=G.D5U.getArrayFromDType("int32",F.length);for(let H=0;H<F.length;++H)V[H]=G.D5U.fingerPrint64(F[H]).modulo($).getLowBitsUnsigned();return V}},71649:function(F,$,V){"use strict";V.d($,{GR:function(){return en},VY:function(){return Z},lu:function(){return et}});var G=V(15949),H=V(33533),K=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.b)((F,$)=>F-$),ee=(0,K.H)((F,$,V,G)=>({real:F-V,imag:$-G})),et=(0,K.j)(G.Tr8,Z,ee),en={kernelName:G.Tr8,backendName:"cpu",kernelFunc:et}},27723:function(F,$,V){"use strict";V.d($,{R:function(){return tileImpl}});var G=V(15949);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tileImpl(F,$){let V=Array(F.rank);for(let G=0;G<V.length;G++)V[G]=F.shape[G]*$[G];let H=(0,G.f3b)(V,F.dtype);for(let $=0;$<H.values.length;++$){let V=H.indexToLoc($),G=Array(F.rank);for(let $=0;$<G.length;$++)G[$]=V[$]%F.shape[$];let K=F.locToIndex(G);H.values[$]=F.values[K]}return H}},69556:function(F,$,V){"use strict";V.d($,{W:function(){return topKImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let comparePair=(F,$)=>{let V=$.value-F.value;return 0===V?F.index-$.index:V};function select(F,$,V=0,H=F.length-1){for(;H>V;){if(H-V>600){let G=H-V+1,K=$-V+1,Z=Math.log(G),ee=.5*Math.exp(2*Z/3),et=.5*Math.sqrt(Z*ee*(G-ee)/G)*Math.sign(K-G/2),en=Math.max(V,Math.floor($-K*ee/G+et)),ea=Math.min(H,Math.floor($+(G-K)*ee/G+et));select(F,$,en,ea)}let K=F[$],Z=V,ee=H;for(G.D5U.swap(F,V,$),comparePair(F[H],K)>0&&G.D5U.swap(F,V,H);Z<ee;){for(G.D5U.swap(F,Z,ee),Z++,ee--;0>comparePair(F[Z],K);)Z+=1;for(;comparePair(F[ee],K)>0;)ee-=1}0===comparePair(F[V],K)?G.D5U.swap(F,V,ee):(ee+=1,G.D5U.swap(F,ee,H)),ee<=$&&(V=ee+1),$<=ee&&(H=ee-1)}}function topKImpl(F,$,V,H,K){let Z=$[$.length-1],[ee,et]=[F.length/Z,Z],en=G.D5U.getTypedArrayFromDType(V,ee*H),ea=G.D5U.getTypedArrayFromDType("int32",ee*H);for(let $=0;$<ee;$++){let V=$*et,G=F.subarray(V,V+et),Z=Array(G.length);G.forEach((F,$)=>Z[$]={value:F,index:$}),H<Z.length&&(select(Z,H),Z=Z.slice(0,H)),K&&Z.sort(comparePair);let ee=$*H,ei=en.subarray(ee,ee+H),eo=ea.subarray(ee,ee+H);for(let F=0;F<H;F++)ei[F]=Z[F].value,eo[F]=Z[F].index}let ei=$.slice();return ei[ei.length-1]=H,[(0,G.f3b)(ei,V,en),(0,G.f3b)(ei,"int32",ea)]}},44802:function(F,$,V){"use strict";V.d($,{b:function(){return Z},p:function(){return transpose}});var G=V(15949),H=V(18166),K=V(77107);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose(F){let{inputs:$,attrs:V,backend:G}=F,{x:Z}=$,{perm:ee}=V;(0,H.H)(Z,"transpose");let et=Z.shape.length,en=Array(et);for(let F=0;F<en.length;F++)en[F]=Z.shape[ee[F]];let ea=G.data.get(Z.dataId).values,ei=(0,K.H)(ea,Z.shape,Z.dtype,ee,en),eo=G.write(ei,en,Z.dtype);return{dataId:eo,shape:en,dtype:Z.dtype}}let Z={kernelName:G.G3Y,backendName:"cpu",kernelFunc:transpose}},77107:function(F,$,V){"use strict";V.d($,{H:function(){return transposeImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transposeImpl(F,$,V,H,K){let Z=$.length,ee=G.D5U.sizeFromShape($),et=G.D5U.computeStrides($),en=G.D5U.computeStrides(K),ea=G.D5U.getTypedArrayFromDType(V,G.D5U.sizeFromShape(K));for(let $=0;$<ee;++$){let V=G.D5U.indexToLoc($,Z,et),K=Array(V.length);for(let F=0;F<K.length;F++)K[F]=V[H[F]];let ee=G.D5U.locToIndex(K,Z,en);ea[ee]=F[$]}return ea}},75638:function(F,$,V){"use strict";V.d($,{S:function(){return uniqueImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uniqueImpl(F,$,V,H){let K=G.D5U.parseAxisParam($,V)[0],Z=[1,V[0],1];for(let F=0;F<K;F++)Z[0]*=V[F];Z[1]=V[K];for(let F=K+1;F<V.length;F++)Z[2]*=V[F];let ee=new Map,et=new Int32Array(V[K]),en=new G.YDk(Z,H,F),ea=[],ei=1===Z[0]&&1===Z[2];for(let $=0;$<V[K];$++){let V;if(ei)V=F[$].toString();else{let F=[];for(let V=0;V<Z[0];V++)for(let G=0;G<Z[2];G++)F.push(en.get(V,$,G));V=F.join(",")}let G=ee.get(V);if(null!=G)et[$]=G;else{let F=ee.size;ee.set(V,F),et[$]=F,ea.push($)}}let eo=Z.slice();eo[1]=ee.size;let es=new G.YDk(eo,H);ea.forEach((F,$)=>{for(let V=0;V<Z[0];V++)for(let G=0;G<Z[2];G++)es.set(en.get(V,F,G),V,$,G)});let eu=V.slice();return eu[K]=eo[1],{outputValues:es.values,outputShape:eu,indices:et}}},45226:function(F,$,V){"use strict";V.r($),V.d($,{addImpl:function(){return H.EH},bincountImpl:function(){return K.W},bincountReduceImpl:function(){return K.i},bitwiseAndImpl:function(){return Z.nv},castImpl:function(){return ee.sJ},ceilImpl:function(){return et.__},concatImpl:function(){return en.j},equalImpl:function(){return ea.tW},expImpl:function(){return ei.Ro},expm1Impl:function(){return eo.OF},floorDivImpl:function(){return eu.JP},floorImpl:function(){return es.r6},gatherNdImpl:function(){return ec.m},gatherV2Impl:function(){return ep.i},greaterEqualImpl:function(){return ef.HL},greaterImpl:function(){return eh.o},lessEqualImpl:function(){return em.lx},lessImpl:function(){return ed.rO},linSpaceImpl:function(){return eg.b},logImpl:function(){return ey.vX},maxImpl:function(){return eb.B},maximumImpl:function(){return ew.wS},minimumImpl:function(){return eS.vP},multiplyImpl:function(){return e_.$3},negImpl:function(){return eN.uC},notEqualImpl:function(){return ek.Gj},prodImpl:function(){return eI.Qg},raggedGatherImpl:function(){return eT.c},raggedRangeImpl:function(){return eC.S},raggedTensorToTensorImpl:function(){return eE.p},rangeImpl:function(){return eA.b},rsqrtImpl:function(){return eD.zd},scatterImpl:function(){return eM.N},sigmoidImpl:function(){return eR.VY},simpleAbsImpl:function(){return G.bk},sliceImpl:function(){return eF.rT},sparseFillEmptyRowsImpl:function(){return eO.c},sparseReshapeImpl:function(){return eP.U},sparseSegmentReductionImpl:function(){return eB.V},sqrtImpl:function(){return e$.zT},squaredDifferenceImpl:function(){return eL.Hz},staticRegexReplaceImpl:function(){return ez.P},stridedSliceImpl:function(){return eV.t},stringNGramsImpl:function(){return eU.A},stringSplitImpl:function(){return eW.Q},stringToHashBucketFastImpl:function(){return ej.h},subImpl:function(){return eG.VY},tileImpl:function(){return eH.R},topKImpl:function(){return eX.W},transposeImpl:function(){return eK.H},uniqueImpl:function(){return eQ.S}});var G=V(60224),H=V(32779),K=V(58607),Z=V(5003),ee=V(29258),et=V(34769),en=V(48926),ea=V(7679),ei=V(31211),eo=V(30969),es=V(76574),eu=V(44892),ec=V(31820),ep=V(54468),eh=V(36272),ef=V(26259),ed=V(88405),em=V(40635),eg=V(61325),ey=V(55223),eb=V(55126),ew=V(71717),eS=V(612),e_=V(1917),eN=V(70854),ek=V(98584),eI=V(29560),eT=V(59885),eC=V(36486),eE=V(8306),eA=V(99230),eD=V(7742),eM=V(60001),eR=V(40108),eF=V(82578),eO=V(42123),eP=V(3849),eB=V(13989),e$=V(10440),eL=V(40212),ez=V(27693),eV=V(62210),eU=V(66841),eW=V(38639),ej=V(26626),eG=V(71649),eH=V(27723),eX=V(69556),eK=V(77107),eQ=V(75638);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},33533:function(F,$,V){"use strict";V.d($,{b:function(){return createSimpleBinaryKernelImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleBinaryKernelImpl(F){return($,V,H,K,Z)=>{let ee=G.backend_util.assertAndGetBroadcastShape($,V),et=ee.length,en=G.D5U.computeStrides(ee),ea=G.D5U.sizeFromShape(ee),ei=G.D5U.getTypedArrayFromDType(Z,ea),eo=$.length,es=V.length,eu=G.D5U.computeStrides($),ec=G.D5U.computeStrides(V),ep=G.backend_util.getBroadcastDims($,ee),eh=G.backend_util.getBroadcastDims(V,ee);if(ep.length+eh.length===0)for(let $=0;$<ei.length;++$)ei[$]=F(H[$%H.length],K[$%K.length]);else for(let $=0;$<ei.length;++$){let V=G.D5U.indexToLoc($,et,en),Z=V.slice(-eo);ep.forEach(F=>Z[F]=0);let ee=G.D5U.locToIndex(Z,eo,eu),ea=V.slice(-es);eh.forEach(F=>ea[F]=0);let ef=G.D5U.locToIndex(ea,es,ec);ei[$]=F(H[ee],K[ef])}return[ei,ee]}}},46205:function(F,$,V){"use strict";V.d($,{H:function(){return createComplexBinaryKernelImpl},j:function(){return binaryKernelFunc}});var G=V(15949),H=V(18166),K=V(29258),Z=V(26961);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function binaryKernelFunc(F,$,V,ee){return null==V?({inputs:V,backend:K})=>{let{a:Z,b:et}=V,en=K;(0,H.H)([Z,et],F);let ea=en.data.get(Z.dataId).values,ei=en.data.get(et.dataId).values,eo="string"===Z.dtype?G.backend_util.fromUint8ToStringArray(ea):ea,es="string"===Z.dtype?G.backend_util.fromUint8ToStringArray(ei):ei,eu=ee||Z.dtype,[ec,ep]=$(Z.shape,et.shape,eo,es,eu);return en.makeTensorInfo(ep,eu,ec)}:({inputs:F,backend:G})=>{let{a:H,b:et}=F,en=G;if("complex64"===H.dtype||"complex64"===et.dtype){let F=(0,K.pj)({inputs:{x:H},backend:en,attrs:{dtype:"complex64"}}),$=en.data.get(F.dataId),G=$.complexTensorInfos.real,ee=$.complexTensorInfos.imag,ea=en.data.get(G.dataId).values,ei=en.data.get(ee.dataId).values,eo=(0,K.pj)({inputs:{x:et},backend:en,attrs:{dtype:"complex64"}}),es=en.data.get(eo.dataId),eu=es.complexTensorInfos.real,ec=es.complexTensorInfos.imag,ep=en.data.get(eu.dataId).values,eh=en.data.get(ec.dataId).values,[ef,ed,em]=V(H.shape,et.shape,ea,ei,ep,eh),eg=en.makeTensorInfo(em,"float32",ef),ey=en.makeTensorInfo(em,"float32",ed),eb=(0,Z.P)({inputs:{real:eg,imag:ey},backend:en});return en.disposeIntermediateTensorInfo(F),en.disposeIntermediateTensorInfo(eo),en.disposeIntermediateTensorInfo(eg),en.disposeIntermediateTensorInfo(ey),eb}{let F=en.data.get(H.dataId).values,V=en.data.get(et.dataId).values,G=ee||H.dtype,[K,Z]=$(H.shape,et.shape,F,V,G);return en.makeTensorInfo(Z,G,K)}}}function createComplexBinaryKernelImpl(F){return($,V,H,K,Z,ee)=>{let et=G.backend_util.assertAndGetBroadcastShape($,V),en=G.D5U.sizeFromShape(et),ea=et.length,ei=G.D5U.computeStrides(et),eo=G.D5U.getTypedArrayFromDType("float32",en),es=G.D5U.getTypedArrayFromDType("float32",en),eu=G.backend_util.getBroadcastDims($,et),ec=G.backend_util.getBroadcastDims(V,et),ep=G.backend_util.mergeRealAndImagArrays(H,K),eh=G.backend_util.mergeRealAndImagArrays(Z,ee),ef=$.length,ed=G.D5U.computeStrides($),em=V.length,eg=G.D5U.computeStrides(V);if(eu.length+ec.length===0)for(let $=0;$<eo.length;$++){let V=$%ep.length,G=$%eh.length,H=F(ep[2*V],ep[2*V+1],eh[2*G],eh[2*G+1]);eo[$]=H.real,es[$]=H.imag}else for(let $=0;$<eo.length;$++){let V=G.D5U.indexToLoc($,ea,ei),H=V.slice(-ef);eu.forEach(F=>H[F]=0);let K=G.D5U.locToIndex(H,ef,ed),Z=V.slice(-em);ec.forEach(F=>Z[F]=0);let ee=G.D5U.locToIndex(Z,em,eg),et=F(ep[2*K],ep[2*K+1],eh[2*ee],eh[2*ee+1]);eo[$]=et.real,es[$]=et.imag}return[eo,es,et]}}},18029:function(F,$,V){"use strict";V.d($,{a:function(){return createSimpleUnaryImpl}});var G=V(15949);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleUnaryImpl(F){return($,V,H)=>{let K=G.D5U.getArrayFromDType(V,$.length);for(let V=0;V<$.length;++V)K[V]=F($[V],H);return K}}},76738:function(F,$,V){"use strict";V.d($,{A:function(){return unaryKernelFunc},O:function(){return unaryKernelFuncFromImpl}});var G=V(15949),H=V(18166),K=V(18029);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unaryKernelFunc(F,$,V){let G=(0,K.a)($);return unaryKernelFuncFromImpl(F,G,V)}function unaryKernelFuncFromImpl(F,$,V){return({inputs:K,attrs:Z,backend:ee})=>{let et;let{x:en}=K;(0,H.H)(en,F);let ea=ee,ei=ea.data.get(en.dataId).values;if("string"===en.dtype){if(!Array.isArray(ei))throw Error("String tensor's value was not an instance of Array");et=G.backend_util.fromUint8ToStringArray(ei)}else et=ei;let eo=V||en.dtype,es=$(et,eo,Z);return ea.makeTensorInfo(en.shape,eo,es)}}},24391:function(F,$,V){"use strict";V.d($,{l:function(){return zeros}});var G=V(15949),H=V(26961);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zeros(F,$,V="float32"){if("complex64"===V){let V=zeros(F,$,"float32"),G=zeros(F,$,"float32");return(0,H.P)({inputs:{real:V,imag:G},backend:F})}let K=G.D5U.makeZerosTypedArray(G.D5U.sizeFromShape($),V);return F.makeTensorInfo($,V,K)}},90740:function(F,$,V){"use strict";V.d($,{jl:function(){return getWebGLContext},nd:function(){return setWebGLContext}});var G=V(15949);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let H={},K={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function setWebGLContext(F,$){H[F]=$}function getWebGLContext(F,$){if(!(F in H)||null!=$){let V=getWebGLRenderingContext(F,$);if(null===V)return console.log("Could not get context for WebGL version",F),null;H[F]=V}let V=H[F];return null==V||V.isContextLost()?(delete H[F],getWebGLContext(F)):(V.disable(V.DEPTH_TEST),V.disable(V.STENCIL_TEST),V.disable(V.BLEND),V.disable(V.DITHER),V.disable(V.POLYGON_OFFSET_FILL),V.disable(V.SAMPLE_COVERAGE),V.enable(V.SCISSOR_TEST),V.enable(V.CULL_FACE),V.cullFace(V.BACK),H[F])}function createCanvas(F){if(!(0,G.OBj)().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===F)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw Error("Cannot create a canvas in this context")}function getWebGLRenderingContext(F,$){if(1!==F&&2!==F)throw Error("Cannot get WebGL rendering context, WebGL is disabled.");let V=null==$?createCanvas(F):$;return(V.addEventListener("webglcontextlost",$=>{$.preventDefault(),delete H[F]},!1),(0,G.OBj)().getBool("SOFTWARE_WEBGL_ENABLED")&&(K.failIfMajorPerformanceCaveat=!1),1===F)?V.getContext("webgl",K)||V.getContext("experimental-webgl",K):V.getContext("webgl2",K)}},92860:function(F,$,V){"use strict";V.d($,{_:function(){return DecodeMatrixProgram}});var G=V(29610),H=V(16697),K=V(38110),Z=V(18378);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DecodeMatrixProgram=class DecodeMatrixProgram{constructor(F){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Z.m1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let $=(0,G.A)();this.outputShape=F,this.enableShapeUniforms=(0,H.C9)(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?K.Kn(["r","c","d"],F):K.RW(["r","c","d"],F)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${$.output} = result;
      }
    `}}},23207:function(F,$,V){"use strict";V.d($,{G:function(){return DecodeMatrixPackedProgram}});var G=V(29610),H=V(16697),K=V(38110),Z=V(18378);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DecodeMatrixPackedProgram=class DecodeMatrixPackedProgram{constructor(F){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Z.m1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let $=(0,G.A)();this.outputShape=F,this.enableShapeUniforms=(0,H.C9)(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?K.Kn(["r","c","d"],F):K.RW(["r","c","d"],F)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${$.output} = result;
      }
    `}}},4443:function(F,$,V){"use strict";V.d($,{q:function(){return EncodeFloatProgram}});var G=V(29610),H=V(38110),K=V(18378);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let EncodeFloatProgram=class EncodeFloatProgram{constructor(F){this.variableNames=["A"],this.outTexUsage=K.v2.DOWNLOAD;let $=(0,G.A)();this.outputShape=F,this.userCode=`
      ${H.ye}

      void main() {
        float x = getAAtOutCoords();
        ${$.output} = encode_float(x);
      }
    `}}},14230:function(F,$,V){"use strict";V.d($,{d:function(){return EncodeFloatPackedProgram}});var G=V(29610),H=V(38110),K=V(18378);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let EncodeFloatPackedProgram=class EncodeFloatPackedProgram{constructor(F){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=K.v2.DOWNLOAD;let $=(0,G.A)();this.outputShape=F,this.userCode=`
      ${H.ye}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${$.output} = encode_float(x);
      }
    `}}},1888:function(F,$,V){"use strict";V.d($,{F:function(){return EncodeMatrixProgram}});var G=V(29610),H=V(16697),K=V(38110);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z={R:0,G:1,B:2,A:3};let EncodeMatrixProgram=class EncodeMatrixProgram{constructor(F,$=!1,V="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let ee=(0,G.A)();this.outputShape=F,this.enableShapeUniforms=(0,H.C9)(this.outputShape.length);let et="result";$&&(et="floor(result * 255. + 0.5)");let en="";for(let F=0;F<V.length;F++){let $=V[F];en+=`
          if(offset == ${F}) {
            result = values[${Z[$]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?K.nc():K.ku(F)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${V.length});

        flatIndex = idiv(flatIndex, ${V.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${ee.texture2D}(A, uv);
          ${en}
        }
        ${ee.output} = vec4(${et}, 0., 0., 0.);
      }
    `}}},89105:function(F,$,V){"use strict";V.d($,{Z:function(){return EncodeMatrixPackedProgram}});var G=V(29610),H=V(16697),K=V(38110);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let EncodeMatrixPackedProgram=class EncodeMatrixPackedProgram{constructor(F,$=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let V=(0,G.A)();this.outputShape=F,this.enableShapeUniforms=(0,H.C9)(this.outputShape.length);let Z="",ee="result";$&&(ee="floor(result * 255. + 0.5)");for(let $=0;$<=1;$++)for(let G=0;G<=1;G++){let H=2*$+G;Z+=`
          localCoords = coords;
          if(localCoords[2] + ${G} < ${this.enableShapeUniforms?"outShape[2]":`${F[2]}`}) {
          localCoords[2] += ${G};
          if (localCoords[1] + ${$} < ${this.enableShapeUniforms?"outShape[1]":`${F[1]}`}) {
            localCoords[1] += ${$};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${V.texture2D}(A, uv);

            if (offset == 0) {
              result[${H}] = values[0];
            } else if (offset == 1) {
              result[${H}] = values[1];
            } else if (offset == 2) {
              result[${H}] = values[2];
            } else {
              result[${H}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?K.nc():K.ku(F)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${Z}

          ${V.output} = ${ee};
        }
    `}}},93381:function(F,$,V){"use strict";var G=V(15949),H=V(91906);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let K=(0,G.OBj)();K.registerFlag("HAS_WEBGL",()=>K.getNumber("WEBGL_VERSION")>0),K.registerFlag("WEBGL_VERSION",()=>(0,H.isWebGLVersionEnabled)(2)?2:(0,H.isWebGLVersionEnabled)(1)?1:0),K.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),K.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===K.get("WEBGL_VERSION")),K.registerFlag("WEBGL_CPU_FORWARD",()=>!0),K.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),K.registerFlag("WEBGL_PACK",()=>K.getBool("HAS_WEBGL")),K.registerFlag("WEBGL_PACK_NORMALIZATION",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_PACK_CLIP",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_PACK_REDUCE",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_LAZILY_UNPACK",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_CONV_IM2COL",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>K.getBool("WEBGL_PACK")),K.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>(0,H.getWebGLMaxTextureSize)(K.getNumber("WEBGL_VERSION"))),K.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>(0,H.getMaxTexturesInShader)(K.getNumber("WEBGL_VERSION"))),K.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let F=K.getNumber("WEBGL_VERSION");return 0===F?0:(0,H.getWebGLDisjointQueryTimerVersion)(F)}),K.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>K.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!G.C2$.isMobile()),K.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>(0,H.isCapableOfRenderingToFloatTexture)(K.getNumber("WEBGL_VERSION"))),K.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!K.getBool("WEBGL_FORCE_F16_TEXTURES")&&K.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),K.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>(0,H.isDownloadFloatTextureEnabled)(K.getNumber("WEBGL_VERSION"))),K.registerFlag("WEBGL_FENCE_API_ENABLED",()=>(0,H.isWebGLFenceEnabled)(K.getNumber("WEBGL_VERSION"))),K.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>{let F=K.getBool("WEBGL_RENDER_FLOAT32_ENABLED");return F?4:0}),K.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,F=>{if("number"!=typeof F)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${F}.`);if(F<0&&-1!==F)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${F}.`)}),K.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>G.C2$.isMobile()?1:-1,F=>{if("number"!=typeof F)throw Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${F}.`);if(F<0&&-1!==F)throw Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${F}.`)}),K.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),K.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),K.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),K.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),K.registerFlag("WEBGL_EXP_CONV",()=>!1),K.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>K.getBool("IS_TEST")),K.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),K.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),K.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),K.registerFlag("ENGINE_COMPILE_ONLY",()=>!1)},29610:function(F,$,V){"use strict";V.d($,{A:function(){return getGlslDifferences}});var G=V(15949);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getGlslDifferences(){let F,$,V,H,K,Z,ee,et,en,ea;return 2===(0,G.OBj)().getNumber("WEBGL_VERSION")?(F="#version 300 es",$="in",V="out",H="in",K="texture",Z="outputColor",ee="out vec4 outputColor;",et=(0,G.OBj)().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",en="",ea=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(F="",$="attribute",V="varying",H="varying",K="texture2D",Z="gl_FragColor",ee="",et=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,en=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,ea=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:F,attribute:$,varyingVs:V,varyingFs:H,texture2D:K,output:Z,defineOutput:ee,defineSpecialNaN:et,defineSpecialInf:en,defineRound:ea}}},95489:function(F,$,V){"use strict";V.d($,{A:function(){return GPGPUContext}});var G=V(15949),H=V(90740),K=V(4328),Z=V(18378),ee=V(91906);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GPGPUContext=class GPGPUContext{constructor(F){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let $=(0,G.OBj)().getNumber("WEBGL_VERSION");if(null!=F?(this.gl=F,(0,H.nd)($,F)):this.gl=(0,H.jl)($),F=this.gl,2===(0,G.OBj)().getNumber("WEBGL_VERSION")){let $=F;this.createVertexArray=()=>ee.callAndCheck($,()=>$.createVertexArray()),this.bindVertexArray=F=>ee.callAndCheck($,()=>$.bindVertexArray(F)),this.deleteVertexArray=F=>ee.callAndCheck($,()=>$.deleteVertexArray(F)),this.getVertexArray=()=>ee.callAndCheck($,()=>$.getParameter($.VERTEX_ARRAY_BINDING))}else if(null!=F){let $=F.getExtension("OES_vertex_array_object");if(null==$)throw Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ee.callAndCheck(F,()=>$.createVertexArrayOES()),this.bindVertexArray=V=>ee.callAndCheck(F,()=>$.bindVertexArrayOES(V)),this.deleteVertexArray=V=>ee.callAndCheck(F,()=>$.deleteVertexArrayOES(V)),this.getVertexArray=()=>ee.callAndCheck(F,()=>F.getParameter($.VERTEX_ARRAY_BINDING_OES))}let V="WEBGL_color_buffer_float",et="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,G.OBj)().getNumber("WEBGL_VERSION")){let F="OES_texture_float",$="OES_texture_half_float";if(this.textureFloatExtension=ee.getExtensionOrThrow(this.gl,F),ee.hasExtension(this.gl,$))this.textureHalfFloatExtension=ee.getExtensionOrThrow(this.gl,$);else if((0,G.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(V),ee.hasExtension(this.gl,et))this.colorBufferHalfFloatExtension=ee.getExtensionOrThrow(this.gl,et);else if((0,G.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(V="EXT_color_buffer_float",ee.hasExtension(this.gl,V))this.colorBufferFloatExtension=this.gl.getExtension(V);else if(ee.hasExtension(this.gl,et))this.colorBufferHalfFloatExtension=this.gl.getExtension(et);else throw Error("GL context does not support color renderable floats");this.vertexBuffer=K.createVertexBuffer(this.gl),this.indexBuffer=K.createIndexBuffer(this.gl),this.framebuffer=ee.createFramebuffer(this.gl),this.textureConfig=Z.Sq(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,G.OBj)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let F=this.gl;ee.callAndCheck(F,()=>F.finish()),ee.callAndCheck(F,()=>F.bindFramebuffer(F.FRAMEBUFFER,null)),ee.callAndCheck(F,()=>F.deleteFramebuffer(this.framebuffer)),ee.callAndCheck(F,()=>F.bindBuffer(F.ARRAY_BUFFER,null)),ee.callAndCheck(F,()=>F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,null)),ee.callAndCheck(F,()=>F.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(F,$){return this.throwIfDisposed(),K.createFloat32MatrixTexture(this.gl,F,$,this.textureConfig)}createFloat16MatrixTexture(F,$){return this.throwIfDisposed(),K.createFloat16MatrixTexture(this.gl,F,$,this.textureConfig)}createUnsignedBytesMatrixTexture(F,$){return this.throwIfDisposed(),K.createUnsignedBytesMatrixTexture(this.gl,F,$,this.textureConfig)}uploadPixelDataToTexture(F,$){this.throwIfDisposed(),K.uploadPixelDataToTexture(this.gl,F,$)}uploadDenseMatrixToTexture(F,$,V,G){this.throwIfDisposed(),K.uploadDenseMatrixToTexture(this.gl,F,$,V,G,this.textureConfig)}createFloat16PackedMatrixTexture(F,$){return this.throwIfDisposed(),K.createFloat16PackedMatrixTexture(this.gl,F,$,this.textureConfig)}createPackedMatrixTexture(F,$){return this.throwIfDisposed(),K.createPackedMatrixTexture(this.gl,F,$,this.textureConfig)}deleteMatrixTexture(F){this.throwIfDisposed(),this.outputTexture===F&&(ee.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),ee.callAndCheck(this.gl,()=>this.gl.deleteTexture(F))}downloadByteEncodedFloatMatrixFromOutputTexture(F,$,V){return this.downloadMatrixDriver(F,()=>K.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl,$,V,this.textureConfig))}downloadPackedMatrixFromBuffer(F,$,V,G,H,Z){return K.downloadPackedMatrixFromBuffer(this.gl,F,$,V,G,H,Z,this.textureConfig)}downloadFloat32MatrixFromBuffer(F,$){return K.downloadFloat32MatrixFromBuffer(this.gl,F,$)}createBufferFromTexture(F,$,V){this.bindTextureToFrameBuffer(F);let G=K.createBufferFromOutputTexture(this.gl,$,V,this.textureConfig);return this.unbindTextureToFrameBuffer(),G}createAndWaitForFence(){let F=this.createFence(this.gl);return this.pollFence(F)}createFence(F){let $,V;if((0,G.OBj)().getBool("WEBGL_FENCE_API_ENABLED")){let G=F,H=G.fenceSync(G.SYNC_GPU_COMMANDS_COMPLETE,0);F.flush(),V=()=>{let F=G.clientWaitSync(H,0,0);return F===G.ALREADY_SIGNALED||F===G.CONDITION_SATISFIED},$=H}else(0,G.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?($=this.beginQuery(),this.endQuery(),V=()=>this.isQueryAvailable($,(0,G.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):V=()=>!0;return{query:$,isFencePassed:V}}downloadMatrixFromPackedTexture(F,$,V){return this.downloadMatrixDriver(F,()=>K.downloadMatrixFromPackedOutputTexture(this.gl,$,V))}createProgram(F){this.throwIfDisposed();let $=this.gl;null==this.vertexShader&&(this.vertexShader=K.createVertexShader($));let V=ee.createProgram($);ee.callAndCheck($,()=>$.attachShader(V,this.vertexShader)),ee.callAndCheck($,()=>$.attachShader(V,F)),ee.linkProgram($,V);let G=Object.assign(V,{vao:this.createVertexArray()});return this.debug&&ee.validateProgram($,G),G}buildVao(F){this.setProgram(F),this.bindVertexArray(F.vao);let $=this.gl;ee.callAndCheck($,()=>$.bindBuffer($.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),K.bindVertexProgramAttributeStreams($,F,this.vertexBuffer)}deleteProgram(F){this.throwIfDisposed(),F===this.program&&(this.program=null),null!=F&&(ee.callAndCheck(this.gl,()=>this.gl.deleteProgram(F)),this.deleteVertexArray(F.vao))}setProgram(F){this.throwIfDisposed(),this.program=F,null!=this.program&&this.debug&&ee.validateProgram(this.gl,this.program),ee.callAndCheck(this.gl,()=>this.gl.useProgram(F))}getUniformLocation(F,$,V=!0){return(this.throwIfDisposed(),V)?ee.getProgramUniformLocationOrThrow(this.gl,F,$):ee.getProgramUniformLocation(this.gl,F,$)}getAttributeLocation(F,$){return this.throwIfDisposed(),ee.callAndCheck(this.gl,()=>this.gl.getAttribLocation(F,$))}getUniformLocationNoThrow(F,$){return this.throwIfDisposed(),this.gl.getUniformLocation(F,$)}setInputMatrixTexture(F,$,V){this.throwIfDisposed(),this.throwIfNoProgram(),ee.bindTextureToProgramUniformSampler(this.gl,F,$,V)}setOutputMatrixTexture(F,$,V){this.setOutputMatrixTextureDriver(F,V,$)}setOutputPackedMatrixTexture(F,$,V){this.throwIfDisposed();let[G,H]=Z.qe($,V);this.setOutputMatrixTextureDriver(F,G,H)}setOutputMatrixWriteRegion(F,$,V,G){this.setOutputMatrixWriteRegionDriver(V,F,G,$)}setOutputPackedMatrixWriteRegion(F,$,V,G){throw Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&ee.validateProgram(this.gl,this.program),ee.validateFramebuffer(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let F=this.gl;if(this.debug){let F=this.getVertexArray();console.assert(F===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ee.callAndCheck(F,()=>F.drawElements(F.TRIANGLES,6,F.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ee.callAndCheck(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=ee.getExtensionOrThrow(this.gl,2===(0,G.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,G.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let F=this.gl,$=this.getQueryTimerExtensionWebGL2(),V=F.createQuery();return F.beginQuery($.TIME_ELAPSED_EXT,V),V}let F=this.getQueryTimerExtensionWebGL1(),$=F.createQueryEXT();return F.beginQueryEXT(F.TIME_ELAPSED_EXT,$),$}endQuery(){if(2===(0,G.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let F=this.gl,$=this.getQueryTimerExtensionWebGL2();F.endQuery($.TIME_ELAPSED_EXT);return}let F=this.getQueryTimerExtensionWebGL1();F.endQueryEXT(F.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(F){return await G.D5U.repeatedTry(()=>this.disposed||this.isQueryAvailable(F,(0,G.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(F,(0,G.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(F,$){if(0===$)return null;if(2===$){let $=this.gl,V=$.getQueryParameter(F,$.QUERY_RESULT);return V/1e6}{let $=this.getQueryTimerExtensionWebGL1(),V=$.getQueryObjectEXT(F,$.QUERY_RESULT_EXT);return V/1e6}}isQueryAvailable(F,$){if(0===$)return!0;if(2===$){let $=this.gl,V=this.getQueryTimerExtensionWebGL2(),G=$.getQueryParameter(F,$.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(V.GPU_DISJOINT_EXT)),G&&!this.disjoint}{let $=this.getQueryTimerExtensionWebGL1(),V=$.getQueryObjectEXT(F,$.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter($.GPU_DISJOINT_EXT)),V&&!this.disjoint}}pollFence(F){return new Promise($=>{this.addItemToPoll(()=>F.isFencePassed(),()=>$())})}pollItems(){let F=linearSearchLastTrue(this.itemsToPoll.map(F=>F.isDoneFn));for(let $=0;$<=F;++$){let{resolveFn:F}=this.itemsToPoll[$];F()}this.itemsToPoll=this.itemsToPoll.slice(F+1)}addItemToPoll(F,$){let V;this.itemsToPoll.push({isDoneFn:F,resolveFn:$}),this.itemsToPoll.length>1||("setTimeoutCustom"in(0,G.OBj)().platform&&(V=(0,G.OBj)().platform.setTimeoutCustom.bind((0,G.OBj)().platform)),G.D5U.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,V))}bindTextureToFrameBuffer(F){this.throwIfDisposed(),ee.bindColorTextureToFramebuffer(this.gl,F,this.framebuffer),this.debug&&ee.validateFramebuffer(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(ee.bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.debug&&ee.validateFramebuffer(this.gl)):ee.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}downloadMatrixDriver(F,$){this.bindTextureToFrameBuffer(F);let V=$();return this.unbindTextureToFrameBuffer(),V}setOutputMatrixTextureDriver(F,$,V){this.throwIfDisposed();let G=this.gl;ee.bindColorTextureToFramebuffer(G,F,this.framebuffer),this.debug&&ee.validateFramebuffer(G),this.outputTexture=F,ee.callAndCheck(G,()=>G.viewport(0,0,$,V)),ee.callAndCheck(G,()=>G.scissor(0,0,$,V))}setOutputMatrixWriteRegionDriver(F,$,V,G){this.throwIfDisposed(),ee.callAndCheck(this.gl,()=>this.gl.scissor(F,$,V,G))}throwIfDisposed(){if(this.disposed)throw Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw Error("No GPU program is currently set.")}};function linearSearchLastTrue(F){let $=0;for(;$<F.length;++$){let V=F[$]();if(!V)break}return $-1}},16697:function(F,$,V){"use strict";V.d($,{C9:function(){return useShapeUniforms},IJ:function(){return compileProgram},Yv:function(){return getUniformLocations},_s:function(){return runProgram},mi:function(){return makeShaderKey}});var G=V(15949),H=V(55156),K=V(91906);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function compileProgram(F,$,V,Z){let ee=V.map((F,V)=>{let G={logicalShape:F.shape,texShape:F.isUniform?null:F.texData.texShape,isUniform:F.isUniform,isPacked:!F.isUniform&&F.texData.isPacked,flatOffset:null};return null!=F.texData&&null!=F.texData.slice&&F.texData.slice.flatOffset>0&&(G.flatOffset=F.texData.slice.flatOffset),{name:$.variableNames[V],shapeInfo:G}}),et=ee.map(F=>F.shapeInfo),en={logicalShape:Z.shape,texShape:Z.texData.texShape,isUniform:!1,isPacked:Z.texData.isPacked,flatOffset:null},ea=H.Vm(ee,en,$),ei=(0,K.createFragmentShader)(F.gl,ea),eo=F.createProgram(ei);return(0,G.OBj)().get("ENGINE_COMPILE_ONLY")?{program:$,fragmentShader:ei,source:ea,webGLProgram:eo,inShapeInfos:et,outShapeInfo:en,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(F.buildVao(eo),Object.assign({program:$,fragmentShader:ei,source:ea,webGLProgram:eo,inShapeInfos:et,outShapeInfo:en},getUniformLocations(F,$,eo)))}function getUniformLocations(F,$,V){let H,K,Z;let ee=[],et=[],en=null,ea=null;ea=F.getUniformLocation(V,"NAN",!1),1===(0,G.OBj)().getNumber("WEBGL_VERSION")&&(en=F.getUniformLocation(V,"INFINITY",!1));let ei=!1;for(let G of $.variableNames){let H={name:G,uniform:F.getUniformLocation(V,G,ei),offset:F.getUniformLocation(V,`offset${G}`,ei)};$.enableShapeUniforms&&(H.shape=F.getUniformLocation(V,`${G}Shape`,ei),H.texShape=F.getUniformLocation(V,`${G}TexShape`,ei)),ee.push(H)}if($.enableShapeUniforms&&(H=F.getUniformLocation(V,"outShape",ei),Z=F.getUniformLocation(V,"outShapeStrides",ei),K=F.getUniformLocation(V,"outTexShape",ei)),$.customUniforms)for(let G of $.customUniforms)et.push(F.getUniformLocation(V,G.name,ei));return{variablesLocations:ee,customUniformLocations:et,infLoc:en,nanLoc:ea,outShapeLocation:H,outShapeStridesLocation:Z,outTexShapeLocation:K}}function validateBinaryAndProgram(F,$){if(F.length!==$.length)throw Error(`Binary was compiled with ${F.length} inputs, but was executed with ${$.length} inputs`);F.forEach((F,V)=>{let H=F.logicalShape,K=$[V],Z=K.shape;if(!G.D5U.arraysEqual(H,Z))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${H} and ${Z} must match`);if(F.isUniform&&K.isUniform)return;let ee=F.texShape,et=K.isUniform?null:K.texData.texShape;if(!G.D5U.arraysEqual(ee,et))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${ee} and ${et} must match`)})}function runProgram(F,$,V,K,Z){$.program.enableShapeUniforms||(validateBinaryAndProgram($.inShapeInfos,V),validateBinaryAndProgram([$.outShapeInfo],[K]));let ee=K.texData.texture,et=K.texData.texShape;K.texData.isPacked?F.setOutputPackedMatrixTexture(ee.texture,et[0],et[1]):F.setOutputMatrixTexture(ee.texture,et[0],et[1]),F.setProgram($.webGLProgram),F.bindVertexArray($.webGLProgram.vao),1===(0,G.OBj)().getNumber("WEBGL_VERSION")&&null!==$.infLoc&&F.gl.uniform1f($.infLoc,1/0),null!==$.nanLoc&&F.gl.uniform1f($.nanLoc,NaN);for(let K=0;K<V.length;++K){let Z=V[K],{uniform:ee,offset:et,shape:en,texShape:ea}=$.variablesLocations[K];if(en){let{uniformShape:V}=H.Tt($.program.packedInputs,Z.shape,Z.texData.texShape);switch(V.length){case 1:F.gl.uniform1iv(en,new Int32Array(V));break;case 2:F.gl.uniform2iv(en,new Int32Array(V));break;case 3:F.gl.uniform3iv(en,new Int32Array(V));break;case 4:F.gl.uniform4iv(en,new Int32Array(V))}}if(ea&&F.gl.uniform2i(ea,Z.texData.texShape[0],Z.texData.texShape[1]),null!=ee){if(Z.isUniform){if(2>G.D5U.sizeFromShape(Z.shape))F.gl.uniform1f(ee,Z.uniformValues[0]);else{let $=Z.uniformValues;$ instanceof Float32Array||($=new Float32Array($)),F.gl.uniform1fv(ee,$)}continue}null!=Z.texData.slice&&null!=et&&F.gl.uniform1i(et,Z.texData.slice.flatOffset),F.setInputMatrixTexture(Z.texData.texture.texture,ee,K)}}let en=$.outShapeLocation;if(en)switch(K.shape.length){case 1:F.gl.uniform1iv(en,new Int32Array(K.shape));break;case 2:F.gl.uniform2iv(en,new Int32Array(K.shape));break;case 3:F.gl.uniform3iv(en,new Int32Array(K.shape));break;case 4:F.gl.uniform4iv(en,new Int32Array(K.shape))}if($.outShapeStridesLocation){let V=G.D5U.computeStrides(K.shape);switch(K.shape.length){case 2:F.gl.uniform1iv($.outShapeStridesLocation,new Int32Array(V));break;case 3:F.gl.uniform2iv($.outShapeStridesLocation,new Int32Array(V));break;case 4:F.gl.uniform3iv($.outShapeStridesLocation,new Int32Array(V))}}if($.outTexShapeLocation&&F.gl.uniform2i($.outTexShapeLocation,K.texData.texShape[0],K.texData.texShape[1]),$.program.customUniforms&&Z)for(let V=0;V<$.program.customUniforms.length;++V){let G=$.program.customUniforms[V],H=$.customUniformLocations[V],K=Z[V];if("float"===G.type)F.gl.uniform1fv(H,K);else if("vec2"===G.type)F.gl.uniform2fv(H,K);else if("vec3"===G.type)F.gl.uniform3fv(H,K);else if("vec4"===G.type)F.gl.uniform4fv(H,K);else if("int"===G.type)F.gl.uniform1iv(H,K);else if("ivec2"===G.type)F.gl.uniform2iv(H,K);else if("ivec3"===G.type)F.gl.uniform3iv(H,K);else if("ivec4"===G.type)F.gl.uniform4iv(H,K);else throw Error(`uniform type ${G.type} is not supported yet.`)}F.executeProgram()}function makeShaderKey(F,$,V){let K="";$.concat(V).forEach($=>{let Z=null!=$.texData&&null!=$.texData.slice&&$.texData.slice.flatOffset>0;if(F.enableShapeUniforms&&!$.isUniform){let ee=$.texData.texShape,{useSqueezeShape:et,uniformShape:en,keptDims:ea}=H.Tt(F.packedInputs,$.shape,ee),ei="",eo="",es="";if(1===en.length&&F.packedInputs){let F=[Math.ceil(ee[0]/2),Math.ceil(ee[1]/2)];ei=`${F[0]>1}_${F[1]>1}`}else if(2!==en.length||F.packedInputs){if(en.length>2&&!F.packedInputs){let F=G.D5U.computeStrides(en);es=`${F[0]===ee[1]}_${F[F.length-1]===ee[1]}`}}else eo=`${en[0]>1}_${en[1]>1}`;let eu=$.shape.length,ec=2===en.length&&G.D5U.arraysEqual($.shape,ee),ep=1===G.D5U.sizeFromShape($.shape),eh=G.backend_util.getBroadcastDims($.shape,V.shape),ef=!F.packedInputs&&eu===V.shape.length&&G.D5U.arraysEqual(ee,V.texData.texShape),ed=F.packedInputs||en.length>2?"":`${ee[0]>1}_${ee[1]>1}`;K+=`${eu}_${ef}_${et?ea:""}_${en.length}_${ep}_${eh}_${ec}_${ei}_${eo}_${es}_${ed}_${Z}`}else{let F=$.isUniform?"uniform":$.texData.texShape;K+=`${$.shape}_${F}_${Z}`}});let Z=F.userCode;return F.constructor.name+("_"+K+"_"+Z)+`${(0,G.OBj)().getNumber("WEBGL_VERSION")}`}function useShapeUniforms(F){return(0,G.OBj)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&F<=4}},4328:function(F,$,V){"use strict";V.r($),V.d($,{bindVertexProgramAttributeStreams:function(){return bindVertexProgramAttributeStreams},createBufferFromOutputTexture:function(){return createBufferFromOutputTexture},createFloat16MatrixTexture:function(){return createFloat16MatrixTexture},createFloat16PackedMatrixTexture:function(){return createFloat16PackedMatrixTexture},createFloat32MatrixTexture:function(){return createFloat32MatrixTexture},createIndexBuffer:function(){return createIndexBuffer},createPackedMatrixTexture:function(){return createPackedMatrixTexture},createUnsignedBytesMatrixTexture:function(){return createUnsignedBytesMatrixTexture},createVertexBuffer:function(){return createVertexBuffer},createVertexShader:function(){return createVertexShader},downloadByteEncodedFloatMatrixFromOutputTexture:function(){return downloadByteEncodedFloatMatrixFromOutputTexture},downloadFloat32MatrixFromBuffer:function(){return downloadFloat32MatrixFromBuffer},downloadMatrixFromPackedOutputTexture:function(){return downloadMatrixFromPackedOutputTexture},downloadPackedMatrixFromBuffer:function(){return downloadPackedMatrixFromBuffer},getInternalFormatForFloat16MatrixTexture:function(){return getInternalFormatForFloat16MatrixTexture},getInternalFormatForFloat16PackedMatrixTexture:function(){return getInternalFormatForFloat16PackedMatrixTexture},getInternalFormatForFloat32MatrixTexture:function(){return getInternalFormatForFloat32MatrixTexture},getInternalFormatForPackedMatrixTexture:function(){return getInternalFormatForPackedMatrixTexture},getInternalFormatForUnsignedBytesMatrixTexture:function(){return getInternalFormatForUnsignedBytesMatrixTexture},uploadDenseMatrixToTexture:function(){return uploadDenseMatrixToTexture},uploadPixelDataToTexture:function(){return uploadPixelDataToTexture}});var G=V(15949),H=V(29610),K=V(18378),Z=V(91906);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createVertexShader(F){let $=(0,H.A)(),V=`${$.version}
    precision highp float;
    ${$.attribute} vec3 clipSpacePos;
    ${$.attribute} vec2 uv;
    ${$.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Z.createVertexShader(F,V)}function createVertexBuffer(F){let $=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Z.createStaticVertexBuffer(F,$)}function createIndexBuffer(F){let $=new Uint16Array([0,1,2,2,1,3]);return Z.createStaticIndexBuffer(F,$)}function createAndConfigureTexture(F,$,V,H,K,ee){Z.validateTextureSize($,V);let et=Z.createTexture(F),en=F.TEXTURE_2D;return Z.callAndCheck(F,()=>F.bindTexture(en,et)),Z.callAndCheck(F,()=>F.texParameteri(en,F.TEXTURE_WRAP_S,F.CLAMP_TO_EDGE)),Z.callAndCheck(F,()=>F.texParameteri(en,F.TEXTURE_WRAP_T,F.CLAMP_TO_EDGE)),Z.callAndCheck(F,()=>F.texParameteri(en,F.TEXTURE_MIN_FILTER,F.NEAREST)),Z.callAndCheck(F,()=>F.texParameteri(en,F.TEXTURE_MAG_FILTER,F.NEAREST)),1===(0,G.OBj)().getNumber("WEBGL_VERSION")?Z.callAndCheck(F,()=>F.texImage2D(en,0,H,$,V,0,K,ee,null)):Z.callAndCheck(F,()=>F.texStorage2D(en,1,H,$,V)),Z.callAndCheck(F,()=>F.bindTexture(F.TEXTURE_2D,null)),{texture:et,texShape:[V,$]}}function getInternalFormatForFloat32MatrixTexture(F){return F.internalFormatFloat}function createFloat32MatrixTexture(F,$,V,G){let[H,Z]=K.kk($,V);return createAndConfigureTexture(F,H,Z,getInternalFormatForFloat32MatrixTexture(G),G.textureFormatFloat,F.FLOAT)}function getInternalFormatForFloat16MatrixTexture(F){return F.internalFormatHalfFloat}function createFloat16MatrixTexture(F,$,V,G){let[H,Z]=K.kk($,V);return createAndConfigureTexture(F,H,Z,getInternalFormatForFloat16MatrixTexture(G),G.textureFormatFloat,G.textureTypeHalfFloat)}function getInternalFormatForUnsignedBytesMatrixTexture(F){return F.downloadTextureFormat}function createUnsignedBytesMatrixTexture(F,$,V,G){let[H,Z]=K.kk($,V);return createAndConfigureTexture(F,H,Z,getInternalFormatForUnsignedBytesMatrixTexture(G),F.RGBA,F.UNSIGNED_BYTE)}function getInternalFormatForPackedMatrixTexture(F){return F.internalFormatPackedFloat}function createPackedMatrixTexture(F,$,V,G){let[H,Z]=K.qe($,V);return createAndConfigureTexture(F,H,Z,getInternalFormatForPackedMatrixTexture(G),F.RGBA,F.FLOAT)}function getInternalFormatForFloat16PackedMatrixTexture(F){return F.internalFormatPackedHalfFloat}function createFloat16PackedMatrixTexture(F,$,V,G){let[H,Z]=K.qe($,V);return createAndConfigureTexture(F,H,Z,getInternalFormatForFloat16PackedMatrixTexture(G),F.RGBA,G.textureTypeHalfFloat)}function bindVertexProgramAttributeStreams(F,$,V){let G=0,H=12,K=20;Z.callAndCheck(F,()=>F.bindBuffer(F.ARRAY_BUFFER,V));let ee=Z.bindVertexBufferToProgramAttribute(F,$,"clipSpacePos",V,3,K,G);return ee&&Z.bindVertexBufferToProgramAttribute(F,$,"uv",V,2,K,H)}function uploadDenseMatrixToTexture(F,$,V,H,K,ee){let et,en,ea;Z.callAndCheck(F,()=>F.bindTexture(F.TEXTURE_2D,$)),K instanceof Uint8Array?(et=new Uint8Array(V*H*4),en=F.UNSIGNED_BYTE,ea=F.RGBA):(et=new Float32Array(V*H*4),en=F.FLOAT,ea=ee.internalFormatPackedFloat),et.set(K),2===(0,G.OBj)().getNumber("WEBGL_VERSION")?Z.callAndCheck(F,()=>F.texSubImage2D(F.TEXTURE_2D,0,0,0,V,H,F.RGBA,en,et)):Z.callAndCheck(F,()=>F.texImage2D(F.TEXTURE_2D,0,ea,V,H,0,F.RGBA,en,et)),Z.callAndCheck(F,()=>F.bindTexture(F.TEXTURE_2D,null))}function uploadPixelDataToTexture(F,$,V){Z.callAndCheck(F,()=>F.bindTexture(F.TEXTURE_2D,$)),V.data instanceof Uint8Array?2===(0,G.OBj)().getNumber("WEBGL_VERSION")?Z.callAndCheck(F,()=>F.texSubImage2D(F.TEXTURE_2D,0,0,0,V.width,V.height,F.RGBA,F.UNSIGNED_BYTE,V.data)):Z.callAndCheck(F,()=>F.texImage2D(F.TEXTURE_2D,0,F.RGBA,V.width,V.height,0,F.RGBA,F.UNSIGNED_BYTE,V.data)):2===(0,G.OBj)().getNumber("WEBGL_VERSION")?Z.callAndCheck(F,()=>F.texSubImage2D(F.TEXTURE_2D,0,0,0,F.RGBA,F.UNSIGNED_BYTE,V)):Z.callAndCheck(F,()=>F.texImage2D(F.TEXTURE_2D,0,F.RGBA,F.RGBA,F.UNSIGNED_BYTE,V)),Z.callAndCheck(F,()=>F.bindTexture(F.TEXTURE_2D,null))}function createBufferFromOutputTexture(F,$,V,G){let H=F.createBuffer();Z.callAndCheck(F,()=>F.bindBuffer(F.PIXEL_PACK_BUFFER,H));let K=4,ee=4,et=K*ee*$*V;return Z.callAndCheck(F,()=>F.bufferData(F.PIXEL_PACK_BUFFER,et,F.STREAM_READ)),Z.callAndCheck(F,()=>F.readPixels(0,0,V,$,F.RGBA,F.FLOAT,0)),Z.callAndCheck(F,()=>F.bindBuffer(F.PIXEL_PACK_BUFFER,null)),H}function downloadFloat32MatrixFromBuffer(F,$,V){let G=F,H=new Float32Array(V);return G.bindBuffer(G.PIXEL_PACK_BUFFER,$),G.getBufferSubData(G.PIXEL_PACK_BUFFER,0,H),G.bindBuffer(G.PIXEL_PACK_BUFFER,null),H}function downloadByteEncodedFloatMatrixFromOutputTexture(F,$,V,G){let[H,ee]=K.kk($,V),et=4,en=new Uint8Array(K.yb($*V,et));return Z.callAndCheck(F,()=>F.readPixels(0,0,H,ee,G.downloadTextureFormat,F.UNSIGNED_BYTE,en)),new Float32Array(en.buffer)}function downloadPackedMatrixFromBuffer(F,$,V,G,H,Z,ee,et){let en=F,ea=new Float32Array(K.Se(Z,ee));return en.bindBuffer(en.PIXEL_PACK_BUFFER,$),en.getBufferSubData(en.PIXEL_PACK_BUFFER,0,ea),en.bindBuffer(en.PIXEL_PACK_BUFFER,null),ea}function downloadMatrixFromPackedOutputTexture(F,$,V){let G=new Float32Array($*V*4);return Z.callAndCheck(F,()=>F.readPixels(0,0,V,$,F.RGBA,F.FLOAT,G)),G}},64272:function(F,$,V){"use strict";V.d($,{$O:function(){return eb},$j:function(){return eU},$u:function(){return eV},A0:function(){return eW},AR:function(){return e$},B_:function(){return eh},Bk:function(){return eL},Bo:function(){return eN},CJ:function(){return eF},CV:function(){return eQ},F1:function(){return ez},Fv:function(){return eK},KX:function(){return eH},LS:function(){return eB},M8:function(){return eC},MZ:function(){return eu},PQ:function(){return eg},Qs:function(){return eT},Rn:function(){return em},Sd:function(){return ey},St:function(){return eD},TD:function(){return ec},Tg:function(){return eI},Th:function(){return e_},UN:function(){return eR},X8:function(){return eP},XM:function(){return ee},Y1:function(){return eM},_9:function(){return ej},aX:function(){return eo},cK:function(){return H},cZ:function(){return ek},cm:function(){return et},cx:function(){return Z},fy:function(){return eE},gv:function(){return ei},hO:function(){return eA},ji:function(){return ef},kI:function(){return eG},kY:function(){return ed},m$:function(){return ep},n7:function(){return ea},nL:function(){return ew},nT:function(){return eO},oC:function(){return eX},pk:function(){return en},qO:function(){return K},r:function(){return eS},tx:function(){return es}});var G=V(45226);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let{addImpl:H,bincountImpl:K,bincountReduceImpl:Z,bitwiseAndImpl:ee,castImpl:et,ceilImpl:en,concatImpl:ea,equalImpl:ei,expImpl:eo,expm1Impl:es,floorImpl:eu,gatherNdImpl:ec,gatherV2Impl:ep,greaterImpl:eh,greaterEqualImpl:ef,lessImpl:ed,lessEqualImpl:em,linSpaceImpl:eg,logImpl:ey,maxImpl:eb,maximumImpl:ew,minimumImpl:eS,multiplyImpl:e_,negImpl:eN,notEqualImpl:ek,prodImpl:eI,raggedGatherImpl:eT,raggedRangeImpl:eC,raggedTensorToTensorImpl:eE,rangeImpl:eA,rsqrtImpl:eD,scatterImpl:eM,sigmoidImpl:eR,simpleAbsImpl:eF,sliceImpl:eO,sparseFillEmptyRowsImpl:eP,sparseReshapeImpl:eB,sparseSegmentReductionImpl:e$,sqrtImpl:eL,staticRegexReplaceImpl:ez,stridedSliceImpl:eV,stringNGramsImpl:eU,stringSplitImpl:eW,stringToHashBucketFastImpl:ej,subImpl:eG,tileImpl:eH,topKImpl:eX,transposeImpl:eK,uniqueImpl:eQ}=G},55667:function(F,$,V){"use strict";V.d($,{U:function(){return PackProgram}});var G=V(16697),H=V(21034),K=V(55156);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PackProgram=class PackProgram{constructor(F){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=F,this.rank=F.length,this.enableShapeUniforms=(0,G.C9)(this.outputShape.length),0===this.rank)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let F=(0,H.Ky)("rc",this.rank),$=(0,K.kW)(this.rank),V=this.getOutOfBoundsCondition(F),G=this.getSetup(F),Z=this.getOutput(F);this.userCode=`
        void main() {
          ${$} rc = getOutputCoords();

          if(${V}) {
            setOutput(vec4(0));
          } else {
            ${G}

            setOutput(vec4(${Z}));
          }
        }
      `}}getSourceCoordsArr(F){let $=[];for(let V=0;V<=1;V++)for(let G=0;G<=1;G++){let H=`${0===V?"r":"rp1"}, ${0===G?"c":"cp1"}`;for(let $=2;$<this.rank;$++)H=`${F[F.length-1-$]},`+H;$.push(H)}return $}getOutOfBoundsCondition(F){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let $="";for(let V=this.rank-2;V<this.rank;V++)$+=`${F[V]} >= ${this.enableShapeUniforms?`outShape[${V}]`:this.outputShape[V]}`,V<this.rank-1&&($+="||");return $}getSetup(F){if(1===this.rank)return"";let $=F.slice(-2),V=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],G=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${$[0]};
      int c = ${$[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${V};
      bool rEdge = rp1 >= ${G};
    `}getOutput(F){let $=this.getSourceCoordsArr(F);if(1===this.rank){let F=this.enableShapeUniforms?"outShape":this.outputShape[0];return`getA(rc), (rc + 1 >= ${F} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${$[0]}),
            cEdge ? 0. : getA(${$[1]}),
            rEdge ? 0. : getA(${$[2]}),
            rEdge || cEdge ? 0. : getA(${$[3]})`}}},21034:function(F,$,V){"use strict";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getVecChannels(F,$){return["x","y","z","w","u","v"].slice(0,$).map($=>`${F}.${$}`)}function getChannels(F,$){return 1===$?[F]:getVecChannels(F,$)}function getSourceCoords(F,$){if(1===F)return"rc";let V="";for(let G=0;G<F;G++)V+=$[G],G<F-1&&(V+=",");return V}V.d($,{Ky:function(){return getChannels},Qc:function(){return getSourceCoords},k6:function(){return getVecChannels}})},28831:function(F,$,V){"use strict";V.d($,{v:function(){return ReshapePackedProgram}});var G=V(16697),H=V(38110);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ReshapePackedProgram=class ReshapePackedProgram{constructor(F,$){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=F,this.enableShapeUniforms=(0,G.C9)(this.outputShape.length);let V="";for(let F=0;F<4;F++){let $="thisRC = rc;";F%2==1&&($+="thisRC.z += 1;"),F>1&&($+="thisRC.y += 1;"),V+=`
        ${$}
        ${F>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${F}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${F>0?"}":""}
      `}this.userCode=`
      ${getReshapedInputCoords($,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?H.nc():H.ku(F)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":F[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":F[2]};

        ${V}

        setOutput(result);
      }
    `}};function getReshapedInputCoords(F,$){let V=$?H.al(["r","c","d"],"inputShape"):H.RW(["r","c","d"],F);return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${V}
      return ivec3(r, c, d);
    }
  `}},38110:function(F,$,V){"use strict";V.d($,{Kn:function(){return getOutputLogicalCoordinatesFromFlatIndexByUniform},RW:function(){return getLogicalCoordinatesFromFlatIndex},al:function(){return getLogicalCoordinatesFromFlatIndexByUniform},ku:function(){return getFlatIndexFrom3D},nc:function(){return getFlatIndexFrom3DOutput},ye:function(){return H}});var G=V(15949);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getLogicalCoordinatesFromFlatIndex(F,$,V="index"){let H=G.D5U.computeStrides($);return H.map(($,G)=>{let K=`int ${F[G]} = ${V} / ${$}`,Z=G===H.length-1?`int ${F[G+1]} = ${V} - ${F[G]} * ${$}`:`index -= ${F[G]} * ${$}`;return`${K}; ${Z};`}).join("")}function getOutputLogicalCoordinatesFromFlatIndexByUniform(F,$,V="index"){let H=G.D5U.computeStrides($);return H.map(($,G)=>{let K=`int ${F[G]} = ${V} / outShapeStrides[${G}]`,Z=G===H.length-1?`int ${F[G+1]} = ${V} - ${F[G]} * outShapeStrides[${G}]`:`index -= ${F[G]} * outShapeStrides[${G}]`;return`${K}; ${Z};`}).join("")}function symbolicallyComputeStrides(F,$){let V=F.length,G=F.map(F=>`${$}[${F}]`),H=Array(V-1);H[V-2]=G[V-1];for(let F=V-3;F>=0;--F)H[F]=`(${H[F+1]} * ${G[F+1]})`;return H}function getLogicalCoordinatesFromFlatIndexByUniform(F,$,V="index"){let G=F.map((F,$)=>$),H=symbolicallyComputeStrides(G,$);return H.map(($,G)=>{let K=`int ${F[G]} = ${V} / ${H[G]}`,Z=G===H.length-1?`int ${F[G+1]} = ${V} - ${F[G]} * ${H[G]}`:`index -= ${F[G]} * ${H[G]}`;return`${K}; ${Z};`}).join("")}function getFlatIndexFrom3D(F){let $=G.D5U.computeStrides(F).map(F=>F.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${$[0]} + coords.y * ${$[1]} + coords.z;
  }
`}function getFlatIndexFrom3DOutput(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}let H=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`},18378:function(F,$,V){"use strict";V.d($,{Se:function(){return getPackedRGBAArraySizeFromMatrixShape},Sq:function(){return getTextureConfig},V9:function(){return K},Yz:function(){return getDenseTexShape},kk:function(){return getUnpackedMatrixTextureShapeWidthHeight},m1:function(){return G},qe:function(){return getPackedMatrixTextureShapeWidthHeight},v2:function(){return H},yb:function(){return getUnpackedArraySizeFromMatrixSize}});var G,H,K,Z=V(15949);function getUnpackedMatrixTextureShapeWidthHeight(F,$){return[$,F]}function getUnpackedArraySizeFromMatrixSize(F,$){return F*$}function getDenseTexShape(F){let $=Z.D5U.sizeFromShape(F),V=Math.ceil($/4);return Z.D5U.sizeToSquarishShape(V)}function getPackedMatrixTextureShapeWidthHeight(F,$){return[Math.max(1,Math.ceil($/2)),Math.max(1,Math.ceil(F/2))]}function getPackedRGBAArraySizeFromMatrixShape(F,$){let[V,G]=getPackedMatrixTextureShapeWidthHeight(F,$);return V*G*4}function getTextureConfig(F,$){let V,G,H,K,ee,et,en,ea,ei,eo;let es=F;return 2===(0,Z.OBj)().getNumber("WEBGL_VERSION")?(V=es.R32F,G=es.R16F,H=es.RGBA16F,K=es.RGBA32F,ee=es.RED,en=4,ea=1,ei=es.HALF_FLOAT,eo=es.FLOAT,et=es.RGBA8):(V=F.RGBA,G=F.RGBA,H=F.RGBA,K=es.RGBA,ee=F.RGBA,en=4,ea=4,ei=null!=$?$.HALF_FLOAT_OES:null,eo=F.FLOAT,et=F.RGBA),{internalFormatFloat:V,internalFormatHalfFloat:G,internalFormatPackedHalfFloat:H,internalFormatPackedFloat:K,textureFormatFloat:ee,downloadTextureFormat:et,downloadUnpackNumChannels:en,defaultNumChannels:ea,textureTypeHalfFloat:ei,textureTypeFloat:eo}}!function(F){F[F.DENSE=0]="DENSE",F[F.SHARED_BATCH=1]="SHARED_BATCH"}(G||(G={})),function(F){F[F.RENDER=0]="RENDER",F[F.UPLOAD=1]="UPLOAD",F[F.PIXELS=2]="PIXELS",F[F.DOWNLOAD=3]="DOWNLOAD"}(H||(H={})),function(F){F[F.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",F[F.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",F[F.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",F[F.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",F[F.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(K||(K={}))},42490:function(F,$,V){"use strict";V.d($,{I:function(){return TextureManager}});var G=V(15949),H=V(4328),K=V(18378);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TextureManager=class TextureManager{constructor(F){this.gpgpu=F,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(F,$,V){let G;let H=getPhysicalFromLogicalTextureType($,V),Z=getKeyFromTextureShape(F,H,V);Z in this.freeTextures||(this.freeTextures[Z]=[]),Z in this.usedTextures||(this.usedTextures[Z]=[]);let ee=computeBytes(F,H,this.gpgpu.gl,this.gpgpu.textureConfig,V);if(this.freeTextures[Z].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=ee,this.log();let F=this.freeTextures[Z].pop();return this.usedTextures[Z].push(F),F}return H===K.V9.PACKED_2X2_FLOAT32?G=this.gpgpu.createPackedMatrixTexture(F[0],F[1]):H===K.V9.PACKED_2X2_FLOAT16?G=this.gpgpu.createFloat16PackedMatrixTexture(F[0],F[1]):H===K.V9.UNPACKED_FLOAT32?G=this.gpgpu.createFloat32MatrixTexture(F[0],F[1]):H===K.V9.UNPACKED_FLOAT16?G=this.gpgpu.createFloat16MatrixTexture(F[0],F[1]):H===K.V9.PACKED_4X1_UNSIGNED_BYTE&&(G=this.gpgpu.createUnsignedBytesMatrixTexture(F[0],F[1])),this.usedTextures[Z].push(G),this.numUsedTextures++,this._numBytesAllocated+=ee,this.log(),G}releaseTexture(F,$,V,H){if(null==this.freeTextures)return;let K=getPhysicalFromLogicalTextureType(V,H),Z=getKeyFromTextureShape($,K,H);Z in this.freeTextures||(this.freeTextures[Z]=[]);let ee=computeBytes($,K,this.gpgpu.gl,this.gpgpu.textureConfig,H),et=(0,G.OBj)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==et&&this._numBytesAllocated>et?(this.gpgpu.deleteMatrixTexture(F.texture),this._numBytesAllocated-=ee):(this.freeTextures[Z].push(F),this.numFreeTextures++,this._numBytesFree+=ee),this.numUsedTextures--;let en=this.usedTextures[Z],ea=en&&en.indexOf(F);if(null==ea||ea<0)throw Error("Cannot release a texture that was never provided by this texture manager");en[ea]=en[en.length-1],en.pop(),this.log()}log(){if(!this.logEnabled)return;let F=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${F})`);let $=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*$)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let F in this.freeTextures)this.freeTextures[F].forEach(F=>{this.gpgpu.deleteMatrixTexture(F.texture)});for(let F in this.usedTextures)this.usedTextures[F].forEach(F=>{this.gpgpu.deleteMatrixTexture(F.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function numBytesForInternalFormat(F,$){let V=F;if($===V.R32F)return 4;if($===V.R16F)return 2;if($===V.RGBA32F||$===F.RGBA)return 16;if($===V.RGBA16F)return 8;if($===V.RGBA8)return 4;throw Error(`Unknown internal format ${$}`)}function computeBytes(F,$,V,G,H){let Z;let ee=internalFormatForPhysicalTexType($,G);if(H){let[$,V]=(0,K.qe)(F[0],F[1]);Z=$*V}else{let[$,V]=(0,K.kk)(F[0],F[1]);Z=$*V}let et=numBytesForInternalFormat(V,ee);return Z*et}function internalFormatForPhysicalTexType(F,$){switch(F){case K.V9.PACKED_2X2_FLOAT32:return(0,H.getInternalFormatForPackedMatrixTexture)($);case K.V9.PACKED_2X2_FLOAT16:return(0,H.getInternalFormatForFloat16PackedMatrixTexture)($);case K.V9.UNPACKED_FLOAT32:return(0,H.getInternalFormatForFloat32MatrixTexture)($);case K.V9.UNPACKED_FLOAT16:return(0,H.getInternalFormatForFloat16MatrixTexture)($);case K.V9.PACKED_4X1_UNSIGNED_BYTE:return(0,H.getInternalFormatForUnsignedBytesMatrixTexture)($);default:throw Error(`Unknown physical texture type ${F}`)}}function getPhysicalTextureForRendering(F){return(0,G.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?F?K.V9.PACKED_2X2_FLOAT32:K.V9.UNPACKED_FLOAT32:F?K.V9.PACKED_2X2_FLOAT16:K.V9.UNPACKED_FLOAT16}function getPhysicalFromLogicalTextureType(F,$){if(F===K.v2.UPLOAD)return K.V9.PACKED_2X2_FLOAT32;if(F===K.v2.RENDER||null==F)return getPhysicalTextureForRendering($);if(F===K.v2.DOWNLOAD||F===K.v2.PIXELS)return K.V9.PACKED_4X1_UNSIGNED_BYTE;throw Error(`Unknown logical texture type ${F}`)}function getKeyFromTextureShape(F,$,V){return`${F[0]}_${F[1]}_${$}_${V}`}},84518:function(F,$,V){"use strict";V.d($,{Cv:function(){return ee},D1:function(){return H},Et:function(){return Z},RX:function(){return et},Tq:function(){return ei},bl:function(){return ea},eW:function(){return en},l:function(){return UnaryOpProgram},t$:function(){return K}});var G=V(16697);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let UnaryOpProgram=class UnaryOpProgram{constructor(F,$){this.variableNames=["A"],this.outputShape=F,this.enableShapeUniforms=(0,G.C9)(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${$}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};let H="if (isnan(x)) return x;",K="return x;",Z="return abs(x);",ee="return (x >= 0.0) ? x : (exp(x) - 1.0);",et=H+`
  return (x < 0.0) ? 0.0 : x;
`,en=H+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ea="return x;",ei="return 1.0 / (1.0 + exp(-1.0 * x));"},29365:function(F,$,V){"use strict";V.d($,{Cv:function(){return K},RX:function(){return Z},Tq:function(){return et},cc:function(){return UnaryOpPackedProgram},eW:function(){return ee},t$:function(){return H}});var G=V(16697);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let H="return x;",K=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Z=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ee=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,et="return 1.0 / (1.0 + exp(-1.0 * x));";let UnaryOpPackedProgram=class UnaryOpPackedProgram{constructor(F,$){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=F,this.enableShapeUniforms=(0,G.C9)(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${$}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}},84595:function(F,$,V){"use strict";V.d($,{W:function(){return UnpackProgram}});var G=V(16697),H=V(21034),K=V(55156);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let UnpackProgram=class UnpackProgram{constructor(F){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=F,this.enableShapeUniforms=(0,G.C9)(this.outputShape.length);let $=F.length,V=(0,H.Ky)("rc",$),Z=(0,K.kW)($),ee=(0,H.Qc)($,V),et=V.slice(-2),en=$<=1?"rc":`vec2(${et.join(",")})`;this.userCode=`
      void main() {
        ${Z} rc = getOutputCoords();
        vec4 packedInput = getA(${ee});

        setOutput(getChannel(packedInput, ${en}));
      }
    `}}},91906:function(F,$,V){"use strict";let G,H;V.r($),V.d($,{assertNotComplex:function(){return assertNotComplex},bindCanvasToFramebuffer:function(){return bindCanvasToFramebuffer},bindColorTextureToFramebuffer:function(){return bindColorTextureToFramebuffer},bindTextureToProgramUniformSampler:function(){return bindTextureToProgramUniformSampler},bindTextureUnit:function(){return bindTextureUnit},bindVertexBufferToProgramAttribute:function(){return bindVertexBufferToProgramAttribute},callAndCheck:function(){return callAndCheck},canBeRepresented:function(){return canBeRepresented},createFragmentShader:function(){return createFragmentShader},createFramebuffer:function(){return createFramebuffer},createProgram:function(){return createProgram},createStaticIndexBuffer:function(){return createStaticIndexBuffer},createStaticVertexBuffer:function(){return createStaticVertexBuffer},createTexture:function(){return createTexture},createVertexShader:function(){return createVertexShader},getBatchDim:function(){return getBatchDim},getExtensionOrThrow:function(){return getExtensionOrThrow},getFramebufferErrorMessage:function(){return getFramebufferErrorMessage},getMaxTexturesInShader:function(){return getMaxTexturesInShader},getNumChannels:function(){return getNumChannels},getProgramUniformLocation:function(){return getProgramUniformLocation},getProgramUniformLocationOrThrow:function(){return getProgramUniformLocationOrThrow},getRowsCols:function(){return getRowsCols},getShapeAs3D:function(){return getShapeAs3D},getTextureShapeFromLogicalShape:function(){return getTextureShapeFromLogicalShape},getWebGLDisjointQueryTimerVersion:function(){return getWebGLDisjointQueryTimerVersion},getWebGLErrorMessage:function(){return getWebGLErrorMessage},getWebGLMaxTextureSize:function(){return getWebGLMaxTextureSize},hasExtension:function(){return hasExtension},isCapableOfRenderingToFloatTexture:function(){return isCapableOfRenderingToFloatTexture},isDownloadFloatTextureEnabled:function(){return isDownloadFloatTextureEnabled},isReshapeFree:function(){return isReshapeFree},isWebGLFenceEnabled:function(){return isWebGLFenceEnabled},isWebGLVersionEnabled:function(){return isWebGLVersionEnabled},linkProgram:function(){return linkProgram},logShaderSourceAndInfoLog:function(){return logShaderSourceAndInfoLog},resetMaxTextureSize:function(){return resetMaxTextureSize},resetMaxTexturesInShader:function(){return resetMaxTexturesInShader},unbindColorTextureFromFramebuffer:function(){return unbindColorTextureFromFramebuffer},unbindTextureUnit:function(){return unbindTextureUnit},validateFramebuffer:function(){return validateFramebuffer},validateProgram:function(){return validateProgram},validateTextureSize:function(){return validateTextureSize}});var K=V(15949),Z=V(90740),ee=V(18378);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function callAndCheck(F,$){let V=$();return(0,K.OBj)().getBool("DEBUG")&&checkWebGLError(F),V}function checkWebGLError(F){let $=F.getError();if($!==F.NO_ERROR)throw Error("WebGL Error: "+getWebGLErrorMessage(F,$))}let et=596e-10,en=65504;function canBeRepresented(F){return!!((0,K.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===F||et<Math.abs(F)&&Math.abs(F)<en)}function getWebGLErrorMessage(F,$){switch($){case F.NO_ERROR:return"NO_ERROR";case F.INVALID_ENUM:return"INVALID_ENUM";case F.INVALID_VALUE:return"INVALID_VALUE";case F.INVALID_OPERATION:return"INVALID_OPERATION";case F.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case F.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case F.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${$}`}}function getExtensionOrThrow(F,$){return throwIfNull(F,()=>F.getExtension($),'Extension "'+$+'" not supported on this browser.')}function createVertexShader(F,$){let V=throwIfNull(F,()=>F.createShader(F.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(callAndCheck(F,()=>F.shaderSource(V,$)),callAndCheck(F,()=>F.compileShader(V)),!1===F.getShaderParameter(V,F.COMPILE_STATUS))throw console.log(F.getShaderInfoLog(V)),Error("Failed to compile vertex shader.");return V}function createFragmentShader(F,$){let V=throwIfNull(F,()=>F.createShader(F.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(callAndCheck(F,()=>F.shaderSource(V,$)),callAndCheck(F,()=>F.compileShader(V)),(0,K.OBj)().get("ENGINE_COMPILE_ONLY"))return V;if(!1===F.getShaderParameter(V,F.COMPILE_STATUS))throw logShaderSourceAndInfoLog($,F.getShaderInfoLog(V)),Error("Failed to compile fragment shader.");return V}let ea=/ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(F,$){let V=ea.exec($);if(null==V){console.log(`Couldn't parse line number in error: ${$}`),console.log(F);return}let G=+V[1],H=F.split("\n"),Z=H.length.toString().length+2,ee=H.map((F,$)=>K.D5U.rightPad(($+1).toString(),Z)+F),et=0;for(let F=0;F<ee.length;F++)et=Math.max(ee[F].length,et);let en=ee.slice(0,G-1),ei=ee.slice(G-1,G),eo=ee.slice(G);console.log(en.join("\n")),console.log($.split("\n")[0]),console.log(`%c ${K.D5U.rightPad(ei[0],et)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(eo.join("\n"))}function createProgram(F){return throwIfNull(F,()=>F.createProgram(),"Unable to create WebGLProgram.")}function linkProgram(F,$){if(callAndCheck(F,()=>F.linkProgram($)),!(0,K.OBj)().get("ENGINE_COMPILE_ONLY")&&!1===F.getProgramParameter($,F.LINK_STATUS))throw console.log(F.getProgramInfoLog($)),Error("Failed to link vertex and fragment shaders.")}function validateProgram(F,$){if(callAndCheck(F,()=>F.validateProgram($)),!1===F.getProgramParameter($,F.VALIDATE_STATUS))throw console.log(F.getProgramInfoLog($)),Error("Shader program validation failed.")}function createStaticVertexBuffer(F,$){let V=throwIfNull(F,()=>F.createBuffer(),"Unable to create WebGLBuffer");return callAndCheck(F,()=>F.bindBuffer(F.ARRAY_BUFFER,V)),callAndCheck(F,()=>F.bufferData(F.ARRAY_BUFFER,$,F.STATIC_DRAW)),V}function createStaticIndexBuffer(F,$){let V=throwIfNull(F,()=>F.createBuffer(),"Unable to create WebGLBuffer");return callAndCheck(F,()=>F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,V)),callAndCheck(F,()=>F.bufferData(F.ELEMENT_ARRAY_BUFFER,$,F.STATIC_DRAW)),V}function getNumChannels(){return 2===(0,K.OBj)().getNumber("WEBGL_VERSION")?1:4}function createTexture(F){return throwIfNull(F,()=>F.createTexture(),"Unable to create WebGLTexture.")}function validateTextureSize(F,$){let V=(0,K.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(F<=0||$<=0){let V=`[${F}x${$}]`;throw Error("Requested texture size "+V+" is invalid.")}if(F>V||$>V){let G=`[${F}x${$}]`,H=`[${V}x${V}]`;throw Error("Requested texture size "+G+" greater than WebGL maximum on this browser / GPU "+H+".")}}function createFramebuffer(F){return throwIfNull(F,()=>F.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(F,$,V,G,H,K,Z){let ee=F.getAttribLocation($,V);return -1!==ee&&(callAndCheck(F,()=>F.bindBuffer(F.ARRAY_BUFFER,G)),callAndCheck(F,()=>F.vertexAttribPointer(ee,H,F.FLOAT,!1,K,Z)),callAndCheck(F,()=>F.enableVertexAttribArray(ee)),!0)}function bindTextureUnit(F,$,V){validateTextureUnit(F,V),callAndCheck(F,()=>F.activeTexture(F.TEXTURE0+V)),callAndCheck(F,()=>F.bindTexture(F.TEXTURE_2D,$))}function unbindTextureUnit(F,$){validateTextureUnit(F,$),callAndCheck(F,()=>F.activeTexture(F.TEXTURE0+$)),callAndCheck(F,()=>F.bindTexture(F.TEXTURE_2D,null))}function getProgramUniformLocationOrThrow(F,$,V){return throwIfNull(F,()=>F.getUniformLocation($,V),'uniform "'+V+'" not present in program.')}function getProgramUniformLocation(F,$,V){return F.getUniformLocation($,V)}function bindTextureToProgramUniformSampler(F,$,V,G){callAndCheck(F,()=>bindTextureUnit(F,$,G)),callAndCheck(F,()=>F.uniform1i(V,G))}function bindCanvasToFramebuffer(F){callAndCheck(F,()=>F.bindFramebuffer(F.FRAMEBUFFER,null)),callAndCheck(F,()=>F.viewport(0,0,F.canvas.width,F.canvas.height)),callAndCheck(F,()=>F.scissor(0,0,F.canvas.width,F.canvas.height))}function bindColorTextureToFramebuffer(F,$,V){callAndCheck(F,()=>F.bindFramebuffer(F.FRAMEBUFFER,V)),callAndCheck(F,()=>F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,$,0))}function unbindColorTextureFromFramebuffer(F,$){callAndCheck(F,()=>F.bindFramebuffer(F.FRAMEBUFFER,$)),callAndCheck(F,()=>F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,null,0))}function validateFramebuffer(F){let $=F.checkFramebufferStatus(F.FRAMEBUFFER);if($!==F.FRAMEBUFFER_COMPLETE)throw Error("Error binding framebuffer: "+getFramebufferErrorMessage(F,$))}function getFramebufferErrorMessage(F,$){switch($){case F.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case F.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case F.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case F.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${$}`}}function throwIfNull(F,$,V){let G=callAndCheck(F,()=>$());if(null==G)throw Error(V);return G}function validateTextureUnit(F,$){let V=F.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,G=$+F.TEXTURE0;if(G<F.TEXTURE0||G>V){let F=`[gl.TEXTURE0, gl.TEXTURE${V}]`;throw Error(`textureUnit must be in ${F}.`)}}function getBatchDim(F,$=2){return K.D5U.sizeFromShape(F.slice(0,F.length-$))}function getRowsCols(F){if(0===F.length)throw Error("Cannot get rows and columns of an empty shape array.");return[F.length>1?F[F.length-2]:1,F[F.length-1]]}function getShapeAs3D(F){let $=[1,1,1],V=0===F.length||1===F.length&&1===F[0];return V||($=[getBatchDim(F),...getRowsCols(F)]),$}function getTextureShapeFromLogicalShape(F,$=!1){let V=(0,K.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),G=(0,K.OBj)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(G===1/0&&(0,K.OBj)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(G=V/2),$&&(V*=2,G*=2,1===(F=F.map(($,V)=>V>=F.length-2?K.D5U.nearestLargerEven(F[V]):F[V])).length&&(F=[2,F[0]])),2!==F.length){let $=K.D5U.squeezeShape(F);F=$.newShape}let H=K.D5U.sizeFromShape(F),Z=null;F.length<=1&&H<=V?Z=[1,H]:2===F.length&&F[0]<=V&&F[1]<=V?Z=F:3===F.length&&F[0]*F[1]<=V&&F[2]<=V?Z=[F[0]*F[1],F[2]]:3===F.length&&F[0]<=V&&F[1]*F[2]<=V?Z=[F[0],F[1]*F[2]]:4===F.length&&F[0]*F[1]*F[2]<=V&&F[3]<=V?Z=[F[0]*F[1]*F[2],F[3]]:4===F.length&&F[0]<=V&&F[1]*F[2]*F[3]<=V&&(Z=[F[0],F[1]*F[2]*F[3]]);let ee=null!=Z&&Math.max(...Z)>G&&Math.min(...Z)<=($?2:1)&&Math.min(...Z)>0;if(null==Z||ee){if($){let $=getBatchDim(F),V=2,G=2;F.length&&([V,G]=getRowsCols(F)),H=$*(V/2)*(G/2),Z=K.D5U.sizeToSquarishShape(H).map(F=>2*F)}else Z=K.D5U.sizeToSquarishShape(H)}return Z}function isEven(F){return F%2==0}function isReshapeFree(F,$){if(F=F.slice(-2),$=$.slice(-2),K.D5U.arraysEqual(F,$)||!F.length||!$.length||0===F[0]||0===F[1]||0===$[0]||0===$[1])return!0;if(F.length!==$.length){let V=F[F.length-1],G=$[$.length-1];if(V===G||isEven(V)&&isEven(G)&&(1===F[0]||1===$[0]))return!0}return F[1]===$[1]&&isEven(F[0])&&isEven($[0])}function getWebGLMaxTextureSize(F){if(null==G){let $=(0,Z.jl)(F);G=$.getParameter($.MAX_TEXTURE_SIZE)}return G}function resetMaxTextureSize(){G=null}function resetMaxTexturesInShader(){H=null}function getMaxTexturesInShader(F){if(null==H){let $=(0,Z.jl)(F);H=$.getParameter($.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,H)}function getWebGLDisjointQueryTimerVersion(F){if(0===F)return 0;let $=(0,Z.jl)(F);return hasExtension($,"EXT_disjoint_timer_query_webgl2")&&2===F?2:hasExtension($,"EXT_disjoint_timer_query")?1:0}function hasExtension(F,$){let V=F.getExtension($);return null!=V}function isWebGLVersionEnabled(F){try{let $=(0,Z.jl)(F);if(null!=$)return!0}catch(F){console.log("Error when getting WebGL context: ",F)}return!1}function isCapableOfRenderingToFloatTexture(F){if(0===F)return!1;let $=(0,Z.jl)(F);if(1===F){if(!hasExtension($,"OES_texture_float"))return!1}else if(!hasExtension($,"EXT_color_buffer_float"))return!1;let V=createFloatTextureAndBindToFramebuffer($);return V}function isDownloadFloatTextureEnabled(F){if(0===F)return!1;let $=(0,Z.jl)(F);if(1===F){if(!hasExtension($,"OES_texture_float")||!hasExtension($,"WEBGL_color_buffer_float"))return!1}else{if(hasExtension($,"EXT_color_buffer_float"))return createFloatTextureAndBindToFramebuffer($);let F="EXT_color_buffer_half_float";if(hasExtension($,F)){let V=$.getExtension(F);return createHalfFloatTextureAndBindToFramebuffer($,V)}return!1}let V=createFloatTextureAndBindToFramebuffer($);return V}function createFloatTextureAndBindToFramebuffer(F){let $=(0,ee.Sq)(F),V=F.createTexture();F.bindTexture(F.TEXTURE_2D,V);let G=1,H=1;F.texImage2D(F.TEXTURE_2D,0,$.internalFormatFloat,G,H,0,$.textureFormatFloat,$.textureTypeFloat,null);let K=F.createFramebuffer();F.bindFramebuffer(F.FRAMEBUFFER,K),F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,V,0);let Z=F.checkFramebufferStatus(F.FRAMEBUFFER)===F.FRAMEBUFFER_COMPLETE;return F.bindTexture(F.TEXTURE_2D,null),F.bindFramebuffer(F.FRAMEBUFFER,null),F.deleteTexture(V),F.deleteFramebuffer(K),Z}function createHalfFloatTextureAndBindToFramebuffer(F,$){let V=(0,ee.Sq)(F,$),G=F.createTexture();F.bindTexture(F.TEXTURE_2D,G);let H=1,K=1;F.texImage2D(F.TEXTURE_2D,0,V.internalFormatHalfFloat,H,K,0,V.textureFormatFloat,V.textureTypeHalfFloat,null);let Z=F.createFramebuffer();F.bindFramebuffer(F.FRAMEBUFFER,Z),F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,G,0);let et=F.checkFramebufferStatus(F.FRAMEBUFFER)===F.FRAMEBUFFER_COMPLETE;return F.bindTexture(F.TEXTURE_2D,null),F.bindFramebuffer(F.FRAMEBUFFER,null),F.deleteTexture(G),F.deleteFramebuffer(Z),et}function isWebGLFenceEnabled(F){if(2!==F)return!1;let $=(0,Z.jl)(F),V=null!=$.fenceSync;return V}function assertNotComplex(F,$){Array.isArray(F)||(F=[F]),F.forEach(F=>{null!=F&&K.D5U.assert("complex64"!==F.dtype,()=>`${$} does not support complex64 tensors in the WebGL backend.`)})}},68713:function(F,$,V){"use strict";V.d($,{JL:function(){return DataStorage},Zu:function(){return KernelBackend}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let G=1e-7,H=1e-4;let DataStorage=class DataStorage{constructor(F,$){this.backend=F,this.dataMover=$,this.data=new WeakMap,this.dataIdsCount=0}get(F){return this.data.has(F)||this.dataMover.moveData(this.backend,F),this.data.get(F)}set(F,$){this.dataIdsCount++,this.data.set(F,$)}has(F){return this.data.has(F)}delete(F){return this.dataIdsCount--,this.data.delete(F)}numDataIds(){return this.dataIdsCount}};let KernelBackend=class KernelBackend{refCount(F){return notYetImplemented("refCount")}incRef(F){return notYetImplemented("incRef")}timerAvailable(){return!0}time(F){return notYetImplemented("time")}read(F){return notYetImplemented("read")}readSync(F){return notYetImplemented("readSync")}readToGPU(F,$){return notYetImplemented("readToGPU")}numDataIds(){return notYetImplemented("numDataIds")}disposeData(F,$){return notYetImplemented("disposeData")}write(F,$,V){return notYetImplemented("write")}move(F,$,V,G,H){return notYetImplemented("move")}createTensorFromGPUData(F,$,V){return notYetImplemented("createTensorFromGPUData")}memory(){return notYetImplemented("memory")}floatPrecision(){return notYetImplemented("floatPrecision")}epsilon(){return 32===this.floatPrecision()?G:H}dispose(){return notYetImplemented("dispose")}};function notYetImplemented(F){throw Error(`'${F}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},68329:function(F,$,V){"use strict";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function binaryInsert(F,$,V){let G=binarySearch(F,$,V),H=G<0?-(G+1):G;F.splice(H,0,$)}function binarySearch(F,$,V){return binarySearch_(F,$,V||defaultComparator)}function defaultComparator(F,$){return F>$?1:F<$?-1:0}function binarySearch_(F,$,V){let G=0,H=F.length,K=0,Z=!1;for(;G<H;){K=G+(H-G>>>1);let ee=V($,F[K]);ee>0?G=K+1:(H=K,Z=!ee)}return Z?G:-G-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppressionV3Impl(F,$,V,G,H){return nonMaxSuppressionImpl_(F,$,V,G,H,0)}function nonMaxSuppressionV4Impl(F,$,V,G,H,K){return nonMaxSuppressionImpl_(F,$,V,G,H,0,!1,K,!0)}function nonMaxSuppressionV5Impl(F,$,V,G,H,K){return nonMaxSuppressionImpl_(F,$,V,G,H,K,!0)}function nonMaxSuppressionImpl_(F,$,V,G,H,K,Z=!1,ee=!1,et=!1){let en=[];for(let F=0;F<$.length;F++)$[F]>H&&en.push({score:$[F],boxIndex:F,suppressBeginIndex:0});en.sort(ascendingComparator);let ea=K>0?-.5/K:0,ei=[],eo=[];for(;ei.length<V&&en.length>0;){let $=en.pop(),{score:V,boxIndex:K,suppressBeginIndex:Z}=$;if(V<H)break;let ee=!1;for(let V=ei.length-1;V>=Z;--V){let Z=intersectionOverUnion(F,K,ei[V]);if(Z>=G){ee=!0;break}if($.score=$.score*suppressWeight(G,ea,Z),$.score<=H)break}$.suppressBeginIndex=ei.length,!ee&&($.score===V?(ei.push(K),eo.push($.score)):$.score>H&&binaryInsert(en,$,ascendingComparator))}let es=ei.length,eu=V-es;ee&&eu>0&&(ei.push(...Array(eu).fill(0)),eo.push(...Array(eu).fill(0)));let ec={selectedIndices:ei};return Z&&(ec.selectedScores=eo),et&&(ec.validOutputs=es),ec}function intersectionOverUnion(F,$,V){let G=F.subarray(4*$,4*$+4),H=F.subarray(4*V,4*V+4),K=Math.min(G[0],G[2]),Z=Math.min(G[1],G[3]),ee=Math.max(G[0],G[2]),et=Math.max(G[1],G[3]),en=Math.min(H[0],H[2]),ea=Math.min(H[1],H[3]),ei=Math.max(H[0],H[2]),eo=Math.max(H[1],H[3]),es=(ee-K)*(et-Z),eu=(ei-en)*(eo-ea);if(es<=0||eu<=0)return 0;let ec=Math.max(K,en),ep=Math.max(Z,ea),eh=Math.min(ee,ei),ef=Math.min(et,eo),ed=Math.max(eh-ec,0)*Math.max(ef-ep,0);return ed/(es+eu-ed)}function suppressWeight(F,$,V){let G=Math.exp($*V*V);return V<=F?G:0}function ascendingComparator(F,$){return F.score-$.score||F.score===$.score&&$.boxIndex-F.boxIndex}V.d($,{GP:function(){return nonMaxSuppressionV3Impl},qP:function(){return nonMaxSuppressionV4Impl},pA:function(){return nonMaxSuppressionV5Impl}})},48333:function(F,$,V){"use strict";V.d($,{Z:function(){return whereImpl}});var G=V(72657);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function whereImpl(F,$){let V=[];for(let F=0;F<$.length;F++)$[F]&&V.push(F);let H=(0,G.f)(F,"int32"),K=(0,G.f)([V.length,F.length],"int32");for(let $=0;$<V.length;$++){let G=H.indexToLoc(V[$]),Z=$*F.length;K.values.set(G,Z)}return K.toTensor()}},50196:function(F,$,V){"use strict";V.d($,{BV:function(){return es},wv:function(){return getOrMakeEngine}});var G=V(68713),H=V(22885),K=V(55938),Z=V(29121),ee=V(26151),et=V(64706),en=V(23418),ea=V(20569);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Profiler=class Profiler{constructor(F,$){this.backendTimer=F,this.logger=$,null==$&&(this.logger=new Logger)}profileKernel(F,$,V){let G,K;let holdResultWrapperFn=()=>{G=V()},Z=en.now();if(this.backendTimer.timerAvailable())K=this.backendTimer.time(holdResultWrapperFn);else{for(let F of(holdResultWrapperFn(),G))F.dataSync();K=Promise.resolve({kernelMs:en.now()-Z})}if((0,H.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let $=0;$<G.length;$++){let V=G[$];V.data().then($=>{checkComputationForErrors($,V.dtype,F)})}let ee={kernelName:F,outputs:G,inputs:$,timeMs:K.then(F=>F.kernelMs),extraInfo:K.then(F=>null!=F.getExtraProfileInfo?F.getExtraProfileInfo():"")};return ee}logKernelProfile(F){let{kernelName:$,outputs:V,timeMs:G,inputs:H,extraInfo:K}=F;V.forEach(F=>{Promise.all([F.data(),G,K]).then(V=>{this.logger.logKernelProfile($,F,V[0],V[1],H,V[2])})})}};function checkComputationForErrors(F,$,V){if("float32"!==$)return!1;for(let $=0;$<F.length;$++){let G=F[$];if(isNaN(G)||!isFinite(G))return console.warn(`Found ${G} in the result of '${V}'`),!0}return!1}let Logger=class Logger{logKernelProfile(F,$,V,G,H,K){let Z="number"==typeof G?ea.oj(`${G}ms`,9):G.error,ee=ea.oj(F,25),et=$.rank,en=$.size,ei=ea.oj($.shape.toString(),14),eo="";for(let F in H){let V=H[F];if(null!=V){let G=V.shape||$.shape,H=G.length;eo+=`${F}: ${H}D ${H>0?G:""} `}}console.log(`%c${ee}	%c${Z}	%c${et}D ${ei}	%c${en}	%c${eo}	%c${K}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getFilteredNodesXToY(F,$,V){let G={},H={};for(let F=0;F<$.length;F++)G[$[F].id]=!0;for(let V=0;V<F.length;V++){let K=F[V],Z=K.inputs;for(let F in Z){let V=Z[F],ee=!1;for(let F=0;F<$.length;F++)if(G[V.id]){K.outputs.forEach(F=>G[F.id]=!0),ee=!0,H[K.id]=!0;break}if(ee)break}}let K={};K[V.id]=!0;let Z={};for(let $=F.length-1;$>=0;$--){let V=F[$],G=V.inputs;for(let F=0;F<V.outputs.length;F++)if(K[V.outputs[F].id]){for(let F in G)K[G[F].id]=!0,Z[V.id]=!0;break}}let ee=[];for(let $=0;$<F.length;$++){let V=F[$];if(H[V.id]&&Z[V.id]){let F={};for(let $ in V.inputs){let H=V.inputs[$];G[H.id]&&(F[$]=H)}let $=Object.assign({},V);$.inputs=F,$.outputs=V.outputs,ee.push($)}}return ee}function backpropagateGradients(F,$,V,G){for(let H=$.length-1;H>=0;H--){let K=$[H],Z=[];if(K.outputs.forEach($=>{let V=F[$.id];null!=V?Z.push(V):Z.push(null)}),null==K.gradient)throw Error(`Cannot compute gradient: gradient function not found for ${K.kernelName}.`);let ee=K.gradient(Z);for(let $ in K.inputs){if(!($ in ee))throw Error(`Cannot backprop through input ${$}. Available gradients found: ${Object.keys(ee)}.`);let H=V(()=>ee[$]());if("float32"!==H.dtype)throw Error(`Error in gradient for op ${K.kernelName}. The gradient of input ${$} must have 'float32' dtype, but has '${H.dtype}'`);let Z=K.inputs[$];if(!ea.cO(H.shape,Z.shape))throw Error(`Error in gradient for op ${K.kernelName}. The gradient of input '${$}' has shape '${H.shape}', which does not match the shape of the input '${Z.shape}'`);if(null==F[Z.id])F[Z.id]=H;else{let $=F[Z.id];F[Z.id]=G($,H),$.dispose()}}}}var ei=V(40974),eo=V(80747);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isRegisteredKernelInvocation(F){return null!=F.kernelName}let EngineState=class EngineState{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(F=>F.name)))}}}dispose(){for(let F in this.registeredVariables)this.registeredVariables[F].dispose()}};let Engine=class Engine{constructor(F){this.ENV=F,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new EngineState}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;let F=this.getSortedBackends();for(let $=0;$<F.length;$++){let V=F[$],G=await this.initializeBackend(V).success;if(G){await this.setBackend(V);return}}throw Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:F,asyncInit:$}=this.initializeBackendsAndReturnBest();if($)throw Error(`The highest priority backend '${F}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(F)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(F){if(!(F in this.registry)){if(!(F in this.registryFactory))return null;{let{asyncInit:$}=this.initializeBackend(F);if($)return null}}return this.registry[F]}findBackendFactory(F){return F in this.registryFactory?this.registryFactory[F].factory:null}registerBackend(F,$,V=1){return F in this.registryFactory?(et.Z(`${F} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[F]={factory:$,priority:V},!0)}async setBackend(F){if(null==this.registryFactory[F])throw Error(`Backend name '${F}' not found in registry`);if(this.backendName=F,null==this.registry[F]){this.backendInstance=null;let{success:$,asyncInit:V}=this.initializeBackend(F),G=V?await $:$;if(!G)return!1}return this.backendInstance=this.registry[F],this.setupRegisteredKernels(),this.profiler=new Profiler(this.backendInstance),!0}setupRegisteredKernels(){let F=(0,ee.tr)(this.backendName);F.forEach(F=>{null!=F.setupFunc&&F.setupFunc(this.backendInstance)})}disposeRegisteredKernels(F){let $=(0,ee.tr)(F);$.forEach($=>{null!=$.disposeFunc&&$.disposeFunc(this.registry[F])})}initializeBackend(F){let $=this.registryFactory[F];if(null==$)throw Error(`Cannot initialize backend ${F}, no registration found.`);try{let V=$.factory();if(!V||V instanceof G.Zu||"function"!=typeof V.then)return this.registry[F]=V,{success:!0,asyncInit:!1};{let $=++this.pendingBackendInitId,G=V.then(V=>!($<this.pendingBackendInitId)&&(this.registry[F]=V,this.pendingBackendInit=null,!0)).catch(V=>!($<this.pendingBackendInitId)&&(this.pendingBackendInit=null,et.Z(`Initialization of backend ${F} failed`),et.Z(V.stack||V.message),!1));return this.pendingBackendInit=G,{success:G,asyncInit:!0}}}catch($){return et.Z(`Initialization of backend ${F} failed`),et.Z($.stack||$.message),{success:!1,asyncInit:!1}}}removeBackend(F){if(!(F in this.registryFactory))throw Error(`${F} backend not found in registry`);this.backendName===F&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,F in this.registry&&(this.disposeRegisteredKernels(F),this.registry[F].dispose(),delete this.registry[F]),delete this.registryFactory[F],this.backendName===F&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((F,$)=>this.registryFactory[$].priority-this.registryFactory[F].priority)}initializeBackendsAndReturnBest(){let F=this.getSortedBackends();for(let $=0;$<F.length;$++){let V=F[$],{success:G,asyncInit:H}=this.initializeBackend(V);if(H||G)return{name:V,asyncInit:H}}throw Error("Could not initialize any backends, all backend initializations failed.")}moveData(F,$){let V=this.state.tensorInfo.get($),G=V.backend,H=this.readSync($),K=G.refCount($);G.disposeData($,!0),V.backend=F,F.move($,H,V.shape,V.dtype,K),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(F,$){let V,G=null;if(null==$){if("function"!=typeof F)throw Error("Please provide a function to tidy()");$=F}else{if("string"!=typeof F&&!(F instanceof String))throw Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof $)throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");G=F}return this.scopedRun(()=>this.startScope(G),()=>this.endScope(V),()=>((V=$())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),V))}scopedRun(F,$,V){F();try{let F=V();return $(),F}catch(F){throw $(),F}}nextTensorId(){return Engine.nextTensorId++}nextVariableId(){return Engine.nextVariableId++}clone(F){let $=es.runKernel(Z.iJz,{x:F}),V={x:F},grad=F=>({x:()=>{let $="float32",V={x:F},G={dtype:$};return es.runKernel(Z.RFZ,V,G)}}),G=[];return this.addTapeNode(this.state.activeScope.name,V,[$],grad,G,{}),$}runKernel(F,$,V){null==this.backendName&&this.backend;let G=null!=(0,ee.pI)(F,this.backendName);if(!G)throw Error(`Kernel '${F}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:F,inputs:$,attrs:V})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(F,$,V){let G=this.backend.numDataIds(),H=0;V.forEach(F=>{H+="complex64"===F.dtype?3:1});let K=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],Z=G-$-H-K;if(Z>0)throw Error(`Backend '${this.backendName}' has an internal memory leak (${Z} data ids) after running '${F}'`)}runKernelFunc(F){let $,V,G,H;let K=[],Z=this.isTapeOn(),et=this.state.numBytes,en=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let ei=isRegisteredKernelInvocation(F)?F.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(isRegisteredKernelInvocation(F)){let{kernelName:$,inputs:H,attrs:et}=F;null==this.backendName&&this.backend;let en=(0,ee.pI)($,this.backendName);ea.hu(null!=en,()=>`Cannot find registered kernel '${$}' for backend '${this.backendName}'`),V=()=>{let F=this.backend.numDataIds();G=en.kernelFunc({inputs:H,attrs:et,backend:this.backend});let V=Array.isArray(G)?G:[G];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak($,F,V);let ee=V.map(F=>null!=F.rank?F:this.makeTensorFromTensorInfo(F));if(Z){let F=this.getTensorsForGradient($,H,ee);K=this.saveTensorsForBackwardMode(F)}return ee}}else{let{forwardFunc:$}=F,saveFunc=F=>{Z&&(K=F.map(F=>this.keep(this.clone(F))))};V=()=>{let F=this.backend.numDataIds();G=this.tidy(()=>$(this.backend,saveFunc));let V=Array.isArray(G)?G:[G];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(ei,F,V),V}}let{inputs:eo,attrs:es}=F,eu=isRegisteredKernelInvocation(F)?null:F.backwardsFunc;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(H=this.profiler.profileKernel(ei,eo,()=>V()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(H),$=H.outputs):$=V()}),Z&&this.addTapeNode(ei,eo,$,eu,K,es),this.state.profiling&&this.state.activeProfile.kernels.push({name:ei,bytesAdded:this.state.numBytes-et,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-en,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(eo).map(F=>null!=eo[F]?eo[F].shape:null),outputShapes:$.map(F=>F.shape),kernelTimeMs:H.timeMs,extraInfo:H.extraInfo}),Array.isArray(G)?$:$[0]}saveTensorsForBackwardMode(F){let $=F.map(F=>this.keep(this.clone(F)));return $}getTensorsForGradient(F,$,V){let G=(0,ee.uk)(F);if(null!=G){let F;let H=G.inputsToSave||[],K=G.outputsToSave||[];G.saveAllInputs?(ea.hu(Array.isArray($),()=>"saveAllInputs is true, expected inputs to be an array."),F=Object.keys($).map(F=>$[F])):F=H.map(F=>$[F]);let Z=V.filter((F,$)=>K[$]);return F.concat(Z)}return[]}makeTensor(F,$,V,G){if(null==F)throw Error("Values passed to engine.makeTensor() are null");V=V||"float32",G=G||this.backend;let H=F;"string"===V&&ea.HD(F[0])&&(H=F.map(F=>en.encodeString(F)));let K=G.write(H,$,V),Z=new ei.es($,V,K,this.nextTensorId());if(this.trackTensor(Z,G),"string"===V){let F=this.state.tensorInfo.get(K),$=(0,ea.Ub)(H);this.state.numBytes+=$-F.bytes,F.bytes=$}return Z}makeTensorFromDataId(F,$,V,G){V=V||"float32";let H={dataId:F,shape:$,dtype:V};return this.makeTensorFromTensorInfo(H,G)}makeTensorFromTensorInfo(F,$){let{dataId:V,shape:G,dtype:H}=F,K=new ei.es(G,H,V,this.nextTensorId());return this.trackTensor(K,$),K}makeVariable(F,$=!0,V,G){V=V||this.nextVariableId().toString(),null!=G&&G!==F.dtype&&(F=F.cast(G));let H=new ei._w(F,$,V,this.nextTensorId());if(null!=this.state.registeredVariables[H.name])throw Error(`Variable with name ${H.name} was already registered`);return this.state.registeredVariables[H.name]=H,this.incRef(H,this.backend),H}trackTensor(F,$){this.state.numTensors++,"string"===F.dtype&&this.state.numStringTensors++;let V=0;"complex64"!==F.dtype&&"string"!==F.dtype&&(V=F.size*ea.bT(F.dtype)),this.state.numBytes+=V,this.state.tensorInfo.has(F.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(F.dataId,{backend:$||this.backend,dtype:F.dtype,shape:F.shape,bytes:V})),F instanceof ei._w||this.track(F)}incRef(F,$){this.trackTensor(F,$),this.backend.incRef(F.dataId)}removeDataId(F,$){this.state.tensorInfo.has(F)&&this.state.tensorInfo.get(F).backend===$&&(this.state.tensorInfo.delete(F),this.state.numDataBuffers--)}disposeTensor(F){if(!this.state.tensorInfo.has(F.dataId))return;let $=this.state.tensorInfo.get(F.dataId);if(this.state.numTensors--,"string"===F.dtype&&(this.state.numStringTensors--,this.state.numBytes-=$.bytes),"complex64"!==F.dtype&&"string"!==F.dtype){let $=F.size*ea.bT(F.dtype);this.state.numBytes-=$}$.backend.disposeData(F.dataId)&&this.removeDataId(F.dataId,$.backend)}disposeVariables(){for(let F in this.state.registeredVariables){let $=this.state.registeredVariables[F];this.disposeVariable($)}}disposeVariable(F){this.disposeTensor(F),null!=this.state.registeredVariables[F.name]&&delete this.state.registeredVariables[F.name]}memory(){let F=this.backend.memory();return F.numTensors=this.state.numTensors,F.numDataBuffers=this.state.numDataBuffers,F.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(F.unreliable=!0,null==F.reasons&&(F.reasons=[]),F.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),F}async profile(F){this.state.profiling=!0;let $=this.state.numBytes,V=this.state.numTensors;for(let G of(this.state.activeProfile.kernels=[],this.state.activeProfile.result=await F(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(F=>F.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-$,this.state.activeProfile.newTensors=this.state.numTensors-V,this.state.activeProfile.kernels))G.kernelTimeMs=await G.kernelTimeMs,G.extraInfo=await G.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(F,$,V,G,H,K){let Z={id:this.state.nextTapeNodeId++,kernelName:F,inputs:$,outputs:V,saved:H},et=(0,ee.uk)(F);null!=et&&(G=et.gradFunc),null!=G&&(Z.gradient=F=>G((F=F.map((F,$)=>{if(null==F){let F=V[$],G=ea.wT(F.size,F.dtype);return this.makeTensor(G,F.shape,F.dtype)}return F})).length>1?F:F[0],H,K)),this.state.activeTape.push(Z)}keep(F){return F.kept=!0,F}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(F){let $={track:[],name:"unnamed scope",id:this.state.nextScopeId++};F&&($.name=F),this.state.scopeStack.push($),this.state.activeScope=$}endScope(F){let $=(0,eo.getTensorsInContainer)(F),V=new Set($.map(F=>F.id));for(let F=0;F<this.state.activeScope.track.length;F++){let $=this.state.activeScope.track[F];$.kept||V.has($.id)||$.dispose()}let G=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],$.forEach(F=>{F.kept||F.scopeId!==G.id||this.track(F)})}gradients(F,$,V,G=!1){if(ea.hu($.length>0,()=>"gradients() received an empty list of xs."),null!=V&&"float32"!==V.dtype)throw Error(`dy must have 'float32' dtype, but has '${V.dtype}'`);let H=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",F));ea.hu(H instanceof ei.es,()=>"The result y returned by f() must be a tensor.");let K=getFilteredNodesXToY(this.state.activeTape,$,H);if(!G&&0===K.length&&$.length>0)throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let F={};F[H.id]=null==V?ones(H.shape):V,backpropagateGradients(F,K,F=>this.tidy(F),add);let G=$.map($=>F[$.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(F=>{for(let $ of F.saved)$.dispose()}),this.state.activeTape=null),{value:H,grads:G}})}customGrad(F){return ea.hu(ea.mf(F),()=>"The f passed in customGrad(f) must be a function."),(...$)=>{let V;ea.hu($.every(F=>F instanceof ei.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let G={};$.forEach((F,$)=>{G[$]=F});let forwardFunc=(G,H)=>(V=F(...[...$,H]),ea.hu(V.value instanceof ei.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ea.hu(ea.mf(V.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),V.value),backwardsFunc=(F,G)=>{let H=V.gradFunc(F,G),K=Array.isArray(H)?H:[H];ea.hu(K.length===$.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ea.hu(K.every(F=>F instanceof ei.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let Z={};return K.forEach((F,$)=>{Z[$]=()=>F}),Z};return this.runKernelFunc({forwardFunc,backwardsFunc,inputs:G})}}readSync(F){let $=this.state.tensorInfo.get(F);return $.backend.readSync(F)}read(F){let $=this.state.tensorInfo.get(F);return $.backend.read(F)}readToGPU(F,$){let V=this.state.tensorInfo.get(F);return V.backend.readToGPU(F,$)}async time(F){let $=(0,en.now)(),V=await this.backend.time(F);return V.wallMs=(0,en.now)()-$,V}track(F){return null!=this.state.activeScope&&(F.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(F)),F}get registeredVariables(){return this.state.registeredVariables}reset(){for(let F in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new EngineState,this.registry)this.disposeRegisteredKernels(F),this.registry[F].dispose(),delete this.registry[F];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function ones(F){let $=(0,ea.p8)((0,ea.NA)(F),"float32");return es.makeTensor($,F,"float32")}function getOrMakeEngine(){let F=(0,K.D)();if(null==F._tfengine){let $=new H.qA(F);F._tfengine=new Engine($)}return(0,H.iG)(F._tfengine.ENV),(0,ei.Vi)(()=>F._tfengine),F._tfengine}Engine.nextTensorId=0,Engine.nextVariableId=0;let es=getOrMakeEngine();function add(F,$){let V={a:F,b:$};return es.runKernel(Z.mm_,V)}},22885:function(F,$,V){"use strict";V.d($,{OB:function(){return env},Vi:function(){return K},iG:function(){return setEnvironmentGlobal},qA:function(){return Environment}});var G=V(20569);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let H="tfjsflags";let Environment=class Environment{constructor(F){this.global=F,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=getQueryParams,this.populateURLFlags()}setPlatform(F,$){null==this.platform||env().getBool("IS_TEST")||env().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${F}.`),this.platformName=F,this.platform=$}registerFlag(F,$,V){if(this.flagRegistry[F]={evaluationFn:$,setHook:V},null!=this.urlFlags[F]){let $=this.urlFlags[F];env().getBool("IS_TEST")||env().getBool("PROD")||console.warn(`Setting feature override from URL ${F}: ${$}.`),this.set(F,$)}}async getAsync(F){return F in this.flags||(this.flags[F]=await this.evaluateFlag(F)),this.flags[F]}get(F){if(F in this.flags)return this.flags[F];let $=this.evaluateFlag(F);if((0,G.tI)($))throw Error(`Flag ${F} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[F]=$,this.flags[F]}getNumber(F){return this.get(F)}getBool(F){return this.get(F)}getString(F){return this.get(F)}getFlags(){return this.flags}get features(){return this.flags}set(F,$){if(null==this.flagRegistry[F])throw Error(`Cannot set flag ${F} as it has not been registered.`);this.flags[F]=$,null!=this.flagRegistry[F].setHook&&this.flagRegistry[F].setHook($)}evaluateFlag(F){if(null==this.flagRegistry[F])throw Error(`Cannot evaluate flag '${F}': no evaluation function found.`);return this.flagRegistry[F].evaluationFn()}setFlags(F){this.flags=Object.assign({},F)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;let F=this.getQueryParams(this.global.location.search);if(H in F){let $=F[H].split(",");$.forEach(F=>{let[$,V]=F.split(":");this.urlFlags[$]=parseValue($,V)})}}};function getQueryParams(F){let $={};return F.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(F,...V)=>(decodeParam($,V[0],V[1]),V.join("="))),$}function decodeParam(F,$,V){F[decodeURIComponent($)]=decodeURIComponent(V||"")}function parseValue(F,$){let V=$.toLowerCase();return"true"===V||"false"===V?"true"===V:`${+V}`===V?+V:$}function env(){return K}let K=null;function setEnvironmentGlobal(F){K=F}},55938:function(F,$,V){"use strict";let G;V.d($,{D:function(){return getGlobalNamespace},R:function(){return getGlobal}});var H=V(83454);function getGlobalNamespace(){if(null==G){let F;if("undefined"!=typeof window)F=window;else if(void 0!==V.g)F=V.g;else if(void 0!==H)F=H;else if("undefined"!=typeof self)F=self;else throw Error("Could not find a global object");G=F}return G}function getGlobalMap(){let F=getGlobalNamespace();return null==F._tfGlobals&&(F._tfGlobals=new Map),F._tfGlobals}function getGlobal(F,$){let V=getGlobalMap();if(V.has(F))return V.get(F);{let G=$();return V.set(F,G),V.get(F)}}},4368:function(F,$,V){"use strict";V.d($,{B9:function(){return dispose},CQ:function(){return setBackend},Cd:function(){return ready},Cn:function(){return keep},G4:function(){return enableProdMode},MX:function(){return deprecationWarn},N5:function(){return profile},N8:function(){return disposeVariables},N_:function(){return getBackend},R:function(){return enableDebugMode},SR:function(){return engine},VY:function(){return setPlatform},XV:function(){return time},cF:function(){return disableDeprecationWarnings},cj:function(){return removeBackend},jq:function(){return registerBackend},lu:function(){return tidy},sq:function(){return memory},x3:function(){return findBackend},y3:function(){return backend},ze:function(){return findBackendFactory}});var G=V(50196),H=V(22885),K=V(40974),Z=V(80747);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function enableProdMode(){(0,H.OB)().set("PROD",!0)}function enableDebugMode(){(0,H.OB)().set("DEBUG",!0)}function disableDeprecationWarnings(){(0,H.OB)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function deprecationWarn(F){(0,H.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(F+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function disposeVariables(){G.BV.disposeVariables()}function engine(){return G.BV}function memory(){return G.BV.memory()}function profile(F){return G.BV.profile(F)}function tidy(F,$){return G.BV.tidy(F,$)}function dispose(F){let $=(0,Z.getTensorsInContainer)(F);$.forEach(F=>F.dispose())}function keep(F){return G.BV.keep(F)}function time(F){return G.BV.time(F)}function setBackend(F){return G.BV.setBackend(F)}function ready(){return G.BV.ready()}function getBackend(){return G.BV.backendName}function removeBackend(F){G.BV.removeBackend(F)}function findBackend(F){return G.BV.findBackend(F)}function findBackendFactory(F){return G.BV.findBackendFactory(F)}function registerBackend(F,$,V=1){return G.BV.registerBackend(F,$,V)}function backend(){return G.BV.backend}function setPlatform(F,$){(0,H.OB)().setPlatform(F,$)}(0,K.FZ)(deprecationWarn)},30633:function(F,$,V){"use strict";V.d($,{UQ:function(){return grad},cb:function(){return customGrad},fN:function(){return valueAndGrads},h7:function(){return valueAndGrad},pn:function(){return variableGrads},ti:function(){return grads}});var G=V(50196),H=V(40974),K=V(43740),Z=V(20569);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function grad(F){return Z.hu(Z.mf(F),()=>"The f passed in grad(f) must be a function"),($,V)=>{let H=(0,K._1)($,"x","tf.grad","string_or_numeric"),ee=null!=V?(0,K._1)(V,"dy","tf.grad"):null;return G.BV.tidy(()=>{let{value:$,grads:V}=G.BV.gradients(()=>F(H),[H],ee);return null!=ee&&Z.k5($.shape,ee.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),checkGrads(V),V[0]})}}function grads(F){return Z.hu(Z.mf(F),()=>"The f passed in grads(f) must be a function"),($,V)=>{Z.hu(Array.isArray($),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let H=(0,K.sI)($,"args","tf.grads","string_or_numeric"),ee=null!=V?(0,K._1)(V,"dy","tf.grads"):null;return G.BV.tidy(()=>{let{value:$,grads:V}=G.BV.gradients(()=>F(...H),H,ee);return null!=ee&&Z.k5($.shape,ee.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(V),V})}}function valueAndGrad(F){return Z.hu(Z.mf(F),()=>"The f passed in valueAndGrad(f) must be a function"),($,V)=>{Z.hu($ instanceof H.es,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),Z.hu(null==V||V instanceof H.es,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:K,value:ee}=G.BV.gradients(()=>F($),[$],V);return checkGrads(K),{grad:K[0],value:ee}}}function valueAndGrads(F){return Z.hu(Z.mf(F),()=>"The f passed in valueAndGrads(f) must be a function"),($,V)=>{Z.hu(Array.isArray($)&&$.every(F=>F instanceof H.es),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),Z.hu(null==V||V instanceof H.es,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let K=G.BV.gradients(()=>F(...$),$,V);return null!=V&&Z.k5(K.value.shape,V.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(K.grads),K}}function variableGrads(F,$){Z.hu(Z.mf(F),()=>"The f passed in variableGrads(f) must be a function"),Z.hu(null==$||Array.isArray($)&&$.every(F=>F instanceof H._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let V=null!=$;if(!V)for(let F in $=[],G.BV.registeredVariables)$.push(G.BV.registeredVariables[F]);let K=V?$.filter(F=>!F.trainable):null,ee=$.length;$=$.filter(F=>F.trainable),Z.hu($.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${ee} variables is trainable.`);let et=!0,{value:en,grads:ea}=G.BV.gradients(F,$,null,et);Z.hu(ea.some(F=>null!=F),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Z.hu(0===en.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${en.rank} tensor`);let ei={};return $.forEach((F,$)=>{null!=ea[$]&&(ei[F.name]=ea[$])}),null!=K&&K.forEach(F=>ei[F.name]=null),{value:en,grads:ei}}function customGrad(F){return G.BV.customGrad(F)}function checkGrads(F){let $=F.filter(F=>null==F).length;if($>0)throw Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}},15949:function(F,$,V){"use strict";let G,H,K;V.d($,{SYM:function(){return th.SYM},VGw:function(){return th.VGw},SpW:function(){return th.SpW},zJI:function(){return AdadeltaOptimizer},HeW:function(){return AdagradOptimizer},a4z:function(){return AdamOptimizer},DBS:function(){return AdamaxOptimizer},mm_:function(){return th.mm_},Xze:function(){return th.Xze},oT6:function(){return th.oT6},IKK:function(){return th.IKK},sJF:function(){return th.sJF},aJk:function(){return th.aJk},M2y:function(){return th.M2y},qw7:function(){return th.qw7},jMg:function(){return th.jMg},QCc:function(){return th.QCc},Oyi:function(){return th.Oyi},JhU:function(){return th.JhU},_k9:function(){return th._k9},IMb:function(){return th.IMb},ROF:function(){return th.ROF},XLW:function(){return th.XLW},zws:function(){return th.zws},zvY:function(){return th.zvY},hCO:function(){return th.hCO},eEB:function(){return th.eEB},Ly9:function(){return th.Ly9},RFZ:function(){return th.RFZ},gJX:function(){return th.gJX},xnO:function(){return th.xnO},Zz9:function(){return th.Zz9},yj2:function(){return th.yj2},Eh3:function(){return th.Eh3},mhS:function(){return th.mhS},wUP:function(){return th.wUP},wm:function(){return th.wm},x12:function(){return th.x12},o2y:function(){return th.o2y},ik2:function(){return th.ik2},mc4:function(){return th.mc4},TR1:function(){return th.TR1},VcC:function(){return th.VcC},Byc:function(){return th.Byc},iHb:function(){return th.iHb},JLz:function(){return tK.JL},QRR:function(){return th.QRR},T0n:function(){return th.T0n},cie:function(){return th.cie},sL$:function(){return th.sL$},y7R:function(){return th.y7R},$w:function(){return th.$w},p4S:function(){return th.p4S},Vn9:function(){return th.Vn9},ekb:function(){return th.ekb},hGc:function(){return th.hGc},ViN:function(){return ef.Vi},$g6:function(){return th.$g6},SX0:function(){return th.SX0},HEU:function(){return th.HEU},qAh:function(){return ef.qA},hdR:function(){return th.hdR},Omj:function(){return th.Omj},NEP:function(){return th.NEP},YFo:function(){return th.YFo},Y0y:function(){return th.Y0y},vwp:function(){return th.vwp},deh:function(){return th.deh},Uyb:function(){return th.Uyb},OR:function(){return th.OR},jeX:function(){return th.jeX},eBW:function(){return th.eBW},sHE:function(){return th.sHE},_V0:function(){return th._V0},luS:function(){return th.luS},q1x:function(){return th.q1x},qi_:function(){return th.qi_},iZT:function(){return th.iZT},Acj:function(){return th.Acj},Qg5:function(){return th.Qg5},iJz:function(){return th.iJz},J_u:function(){return th.J_u},avt:function(){return th.avt},iWB:function(){return th.iWB},r7n:function(){return th.r7n},Zuw:function(){return tK.Zu},eZ0:function(){return th.eZ0},Hhh:function(){return th.Hhh},J$2:function(){return th.J$2},vtC:function(){return th.vtC},CAk:function(){return th.CAk},e7N:function(){return th.e7N},ZbH:function(){return th.ZbH},kU:function(){return th.kU},qCd:function(){return th.qCd},PYm:function(){return th.PYm},VfG:function(){return th.VfG},MZg:function(){return th.MZg},w6g:function(){return th.w6g},qIC:function(){return th.qIC},J7O:function(){return th.J7O},YoZ:function(){return th.YoZ},mTV:function(){return th.mTV},OAf:function(){return th.OAf},OU7:function(){return th.OU7},OV7:function(){return th.OV7},vFR:function(){return th.vFR},BMI:function(){return th.BMI},q2K:function(){return th.q2K},c17:function(){return th.c17},q8u:function(){return th.q8u},jQs:function(){return th.jQs},Vbg:function(){return th.Vbg},rIn:function(){return MomentumOptimizer},NZg:function(){return th.NZg},wYn:function(){return th.wYn},kuV:function(){return th.kuV},uv1:function(){return th.uv1},cye:function(){return th.cye},W0H:function(){return th.W0H},yQU:function(){return th.yQU},zvA:function(){return tT.zvA},we_:function(){return th.we_},qWM:function(){return th.qWM},gaJ:function(){return Optimizer},eEe:function(){return OptimizerConstructors},QiL:function(){return th.QiL},lyA:function(){return th.lyA},Kgp:function(){return th.Kgp},pe_:function(){return th.pe_},o0g:function(){return th.o0g},DlI:function(){return th.DlI},gVI:function(){return RMSPropOptimizer},dDz:function(){return th.dDz},CQl:function(){return th.CQl},BiW:function(){return th.BiW},e6w:function(){return th.e6w},yw1:function(){return tI.yw},xJR:function(){return th.xJR},oHH:function(){return th.oHH},$HU:function(){return th.$HU},IH3:function(){return tC.I},qkr:function(){return th.qkr},SbG:function(){return th.SbG},HZH:function(){return th.HZH},_Yw:function(){return th._Yw},zbQ:function(){return th.zbQ},dpD:function(){return th.dpD},Hmb:function(){return th.Hmb},mKl:function(){return th.mKl},b9H:function(){return th.b9H},e07:function(){return th.e07},bV0:function(){return th.bV0},DYp:function(){return SGDOptimizer},xQA:function(){return th.xQA},nr8:function(){return th.nr8},PhF:function(){return th.PhF},oFR:function(){return th.oFR},a5O:function(){return th.a5O},i5y:function(){return th.i5y},RQH:function(){return th.RQH},wYB:function(){return th.wYB},p2w:function(){return th.p2w},Gcp:function(){return th.Gcp},MRv:function(){return th.MRv},TQc:function(){return th.TQc},O3z:function(){return th.O3z},nhH:function(){return th.nhH},w3H:function(){return th.w3H},ZjV:function(){return th.ZjV},D2d:function(){return th.D2d},L8s:function(){return th.L8s},FKq:function(){return th.FKq},bK0:function(){return th.bK0},_tC:function(){return th._tC},e0R:function(){return th.e0R},h8e:function(){return th.h8e},jQk:function(){return th.jQk},_JP:function(){return th._JP},s1s:function(){return th.s1s},XkS:function(){return th.XkS},Tr8:function(){return th.Tr8},GBy:function(){return th.GBy},sEM:function(){return th.sEM},MIZ:function(){return th.MIZ},esB:function(){return ez.es},YDk:function(){return ez.YD},SIB:function(){return th.SIB},n9L:function(){return th.n9L},cWu:function(){return th.cWu},wx7:function(){return th.wx7},G3Y:function(){return th.G3Y},kpP:function(){return th.kpP},ToN:function(){return th.ToN},Qvg:function(){return th.Qvg},XDQ:function(){return th.XDQ},_wD:function(){return ez._w},RuY:function(){return th.RuY},usg:function(){return th.usg},WnP:function(){return tT.WnP},Khb:function(){return tT.Khb},__u:function(){return tT.__u},IHx:function(){return tT.IHx},QBD:function(){return tT.QBD},$6P:function(){return tT.$6P},YjB:function(){return tT.YjB},NqF:function(){return tT.NqF},vHJ:function(){return tT.vHJ},ZRM:function(){return tT.ZRM},VfV:function(){return tT.VfV},z4N:function(){return tT.z4N},fvJ:function(){return tT.fvJ},C80:function(){return tT.C80},wS1:function(){return tT.wS1},uR5:function(){return tT.uR5},y3$:function(){return eU.y3},backend_util:function(){return ec},zEQ:function(){return tT.zEQ},tgs:function(){return tT.tgs},Dxk:function(){return tT.Dxk},JY5:function(){return tT.JY5},p3b:function(){return tT.p3b},E4h:function(){return tT.E4h},yE8:function(){return tT.yE8},ycw:function(){return tT.ycw},anm:function(){return tT.anm},XsQ:function(){return tT.XsQ},UFq:function(){return tT.UFq},Jyw:function(){return tc},Xhn:function(){return ei},f3b:function(){return tT.f3b},pju:function(){return tT.pju},mDi:function(){return tT.mDi},iUl:function(){return tT.iUl},d9v:function(){return tT.d9v},PYB:function(){return tT.PYB},zoF:function(){return tT.zoF},gME:function(){return tT.gME},Izb:function(){return tT.Izb},MNy:function(){return tT.MNy},ZaL:function(){return tT.ZaL},PAt:function(){return tT.PAt},Tek:function(){return tT.Tek},bc:function(){return tT.bc},pdZ:function(){return tT.pdZ},$QV:function(){return tT.$QV},T3b:function(){return td.T3},mCk:function(){return tT.mCk},f9Y:function(){return tT.f9Y},mew:function(){return tT.mew},$Gn:function(){return tT.$Gn},zbp:function(){return tT.zbp},cbc:function(){return eQ.cb},ppE:function(){return tT.ppE},MXe:function(){return eU.MX},nTT:function(){return tT.nTT},B10:function(){return tT.B10},C2$:function(){return ee},Ka3:function(){return tT.Ka3},WmZ:function(){return tT.WmZ},cFr:function(){return eU.cF},B90:function(){return eU.B9},N8o:function(){return eU.N8},hiC:function(){return tT.hiC},NTj:function(){return tT.NTj},AKD:function(){return tT.AKD},rvX:function(){return tT.rvX},WYO:function(){return tT.WYO},pyx:function(){return tT.pyx},Ra$:function(){return eU.R},G48:function(){return eU.G4},GRh:function(){return tT.GRh},SRH:function(){return eU.SR},EDe:function(){return tT.EDe},OBj:function(){return ef.OB},DgJ:function(){return tT.DgJ},qNN:function(){return tT.qNN},d2q:function(){return tT.d2q},Qqt:function(){return tT.Qqt},dt4:function(){return tT.dt4},t$B:function(){return tT.t$B},iyy:function(){return tT.iyy},kp_:function(){return tT.kp_},hlL:function(){return tT.hlL},x3e:function(){return eU.x3},zel:function(){return eU.ze},GWj:function(){return tT.GWj},qPi:function(){return tT.qPi},imm:function(){return tT.imm},Iqj:function(){return tT.Iqj},dbB:function(){return tT.dbB},DaI:function(){return eo},N_N:function(){return eU.N_},ukX:function(){return td.uk},pIF:function(){return td.pI},trD:function(){return td.tr},UQy:function(){return eQ.UQ},tiA:function(){return eQ.ti},pjt:function(){return tT.pjt},brS:function(){return tT.brS},Sxn:function(){return tT.Sxn},asL:function(){return tT.asL},image:function(){return tT.BHj},V3u:function(){return tT.V3u},io:function(){return en},wx0:function(){return tT.wx0},xVT:function(){return tT.xVT},UWc:function(){return tT.UWc},i2d:function(){return tT.i2d},CnY:function(){return eU.Cn},GDt:function(){return ep},hi7:function(){return tT.hi7},d9m:function(){return tT.d9m},zN1:function(){return tT.zN1},$r2:function(){return tT.$r2},SX3:function(){return tT.SX3},G9k:function(){return tT.G9k},cM7:function(){return tT.cM7},Krr:function(){return tT.Krr},e_t:function(){return tT.e_t},CmS:function(){return tT.CmS},l_t:function(){return tT.l_t},HvI:function(){return tT.HvI},hJK:function(){return tT.hJK},K5V:function(){return tT.K5V},egP:function(){return tT.egP},MB5:function(){return tT.MB5},eab:function(){return tT.eab},OI3:function(){return tT.OI3},mAU:function(){return ea},Fp7:function(){return tT.Fp7},_sB:function(){return tT._sB},YQQ:function(){return tT.YQQ},Ip$:function(){return tT.Ip$},gWQ:function(){return tT.gWQ},J69:function(){return tT.J69},sq6:function(){return eU.sq},ry_:function(){return tT.ry_},VV$:function(){return tT.VV$},LTh:function(){return tT.LTh},VdP:function(){return tT.VdP},wQq:function(){return tT.wQq},Gi7:function(){return tT.Gi7},p_:function(){return tT.p_},dC7:function(){return tT.dC7},rq4:function(){return tT.rq4},SJ_:function(){return tT.SJ_},W76:function(){return tT.W76},glt:function(){return nextFrame},KOy:function(){return tT.KOy},Quu:function(){return tT.Quu},lfX:function(){return tT.lfX},iUs:function(){return tT.iUs},JpU:function(){return tT.JpU},op:function(){return tT.op},N2O:function(){return tT.N2O},vku:function(){return tT.vku},pNR:function(){return tT.pNR},koy:function(){return tT.koy},t1L:function(){return tT.t1L},lGY:function(){return tT.lGY},d_R:function(){return tT.d_R},sQ3:function(){return tT.sQ3},AL3:function(){return tT.AL3},S0v:function(){return tT.S0v},WVs:function(){return tT.WVs},N5s:function(){return eU.N5},$gW:function(){return tT.$gW},VT$:function(){return tT.VT$},N89:function(){return tT.N89},TN_:function(){return tT.TN_},wzB:function(){return tT.wzB},nGf:function(){return tT.nGf},ruB:function(){return tT.ruB},LGj:function(){return tT.LGj},pe5:function(){return tT.pe5},w6H:function(){return tT.w6H},Cd_:function(){return eU.Cd},kwC:function(){return tT.kwC},M25:function(){return tT.M25},jqO:function(){return eU.jq},LiG:function(){return td.Li},wCN:function(){return td.wC},UYe:function(){return tT.UYe},btT:function(){return tT.btT},cjG:function(){return eU.cj},XLQ:function(){return tT.XLQ},GYS:function(){return tT.GYS},SDf:function(){return tT.SDf},diP:function(){return tT.diP},sx7:function(){return tT.sx7},mG2:function(){return tT.mG2},QEs:function(){return tT.QEs},NMM:function(){return tT.NMM},bp0:function(){return tT.bp0},iD$:function(){return tT.iD$},snQ:function(){return tT.snQ},yV1:function(){return tb},zcT:function(){return tT.zcT},U8D:function(){return tT.U8D},U_I:function(){return tT.U_I},m7h:function(){return et},CQI:function(){return eU.CQ},VYu:function(){return eU.VY},ODp:function(){return tT.ODp},XD2:function(){return tT.XD2},Xxe:function(){return tT.Xxe},tdS:function(){return tT.tdS},O$l:function(){return tT.O$l},R_K:function(){return tT.R_K},tPi:function(){return tT.tPi},jZU:function(){return tT.jZU},SmN:function(){return tT.SmN},CnO:function(){return tT.CnO},p0P:function(){return tT.p0P},kuN:function(){return tv},XAC:function(){return tT.XAC},Wvh:function(){return tT.Wvh},fBT:function(){return tT.fBT},rVs:function(){return tT.rVs},ers:function(){return tT.ers},uN7:function(){return tT.uN7},Vl2:function(){return tT.Vl2},_b3:function(){return tT._b3},h62:function(){return tT.h62},$i:function(){return tT.$i},L9e:function(){return tT.L9e},knu:function(){return tT.knu},Nbs:function(){return tT.Nbs},NXj:function(){return tT.NXj},Z_8:function(){return tT.Z_8},luU:function(){return tT.luU},Smz:function(){return tT.Smz},z4k:function(){return tI.z4},ORZ:function(){return tT.ORZ},AEp:function(){return tT.AEp},XeE:function(){return tT.XeE},RRF:function(){return tT.RRF},odF:function(){return tT.odF},wOQ:function(){return tT.wOQ},yXz:function(){return tT.yXz},Bfx:function(){return tT.Bfx},xZs:function(){return tT.xZs},Pg0:function(){return tT.Pg0},piX:function(){return tw},p3L:function(){return es},lub:function(){return eU.lu},Gg6:function(){return tT.Gg6},XVJ:function(){return eU.XV},hg7:function(){return tT.hg7},p_j:function(){return tE},p4s:function(){return tT.p4s},Xu6:function(){return tT.Xu6},Two:function(){return tT.Two},bt3:function(){return td.bt},nEe:function(){return td.nE},pUJ:function(){return tT.pUJ},HHK:function(){return tT.HHK},x8V:function(){return tI.x8},GaM:function(){return tT.GaM},D5U:function(){return tS},h76:function(){return eQ.h7},fNQ:function(){return eQ.fN},VD$:function(){return tT.VD$},pnJ:function(){return eQ.pn},jTM:function(){return tk},arb:function(){return tT.arb},itS:function(){return tT.itS},lls:function(){return tT.lls},P84:function(){return tT.P84}});var Z,ee={};V.r(ee),V.d(ee,{isBrowser:function(){return isBrowser},isMobile:function(){return isMobile},mockIsMobile:function(){return mockIsMobile}});var et={};V.r(et),V.d(et,{Serializable:function(){return Serializable},SerializationMap:function(){return SerializationMap},getRegisteredName:function(){return getRegisteredName},registerClass:function(){return registerClass}});var en={};V.r(en),V.d(en,{CompositeArrayBuffer:function(){return ey.w},browserFiles:function(){return browserFiles},browserHTTPRequest:function(){return browserHTTPRequest},concatenateArrayBuffers:function(){return eg.JY},copyModel:function(){return copyModel},decodeWeights:function(){return eg.dI},decodeWeightsStream:function(){return eg.r},encodeWeights:function(){return eg.yz},fromMemory:function(){return fromMemory},fromMemorySync:function(){return fromMemorySync},getLoadHandlers:function(){return getLoadHandlers},getModelArtifactsForJSON:function(){return eg.jN},getModelArtifactsForJSONSync:function(){return eg.ji},getModelArtifactsInfoForJSON:function(){return eg.Q},getSaveHandlers:function(){return getSaveHandlers},getWeightSpecs:function(){return eg.hu},http:function(){return http},isHTTPScheme:function(){return isHTTPScheme},listModels:function(){return listModels},loadWeights:function(){return loadWeights},moveModel:function(){return moveModel},registerLoadRouter:function(){return registerLoadRouter},registerSaveRouter:function(){return registerSaveRouter},removeModel:function(){return removeModel},weightsLoaderFactory:function(){return weightsLoaderFactory},withSaveHandler:function(){return withSaveHandler},withSaveHandlerSync:function(){return withSaveHandlerSync}});var ea={};V.r(ea),V.d(ea,{confusionMatrix:function(){return tl}});var ei={};V.r(ei),V.d(ei,{draw:function(){return draw},fromPixels:function(){return ty},fromPixelsAsync:function(){return fromPixelsAsync},toPixels:function(){return toPixels}});var eo={};V.r(eo),V.d(eo,{prepareAndValidate:function(){return prepareAndValidate}});var es={};V.r(es),V.d(es,{TEST_EPSILON_FLOAT16:function(){return tN},createVideoElement:function(){return createVideoElement},encodeStrings:function(){return encodeStrings},expectArrayBuffersEqual:function(){return expectArrayBuffersEqual},expectArraysClose:function(){return expectArraysClose},expectArraysEqual:function(){return expectArraysEqual},expectNumbersClose:function(){return expectNumbersClose},expectPromiseToFail:function(){return expectPromiseToFail},expectValuesInRange:function(){return expectValuesInRange},play:function(){return play},testEpsilon:function(){return testEpsilon}});var eu={};V.r(eu),V.d(eu,{collectGatherOpShapeInfo:function(){return collectGatherOpShapeInfo},computeOutShape:function(){return segment_util_computeOutShape},segOpComputeOptimalWindowSize:function(){return segOpComputeOptimalWindowSize}});var ec={};V.r(ec),V.d(ec,{ERF_A1:function(){return tB},ERF_A2:function(){return t$},ERF_A3:function(){return tL},ERF_A4:function(){return tz},ERF_A5:function(){return tV},ERF_P:function(){return tP},PARALLELIZE_THRESHOLD:function(){return tF},RowPartitionType:function(){return Z},SELU_SCALE:function(){return tO.$},SELU_SCALEALPHA:function(){return tO.y},applyActivation:function(){return tR.QH},assertAndGetBroadcastShape:function(){return tc.assertAndGetBroadcastShape},assertAxesAreInnerMostDims:function(){return tD.lB},assertParamsConsistent:function(){return assertParamsConsistent},assignToTypedArray:function(){return assignToTypedArray},axesAreInnerMostDims:function(){return tD.YB},calculateShapes:function(){return tb.calculateShapes},checkEinsumDimSizes:function(){return checkEinsumDimSizes},checkPadOnDimRoundingMode:function(){return tM.m},combineLocations:function(){return tD.Vh},combineRaggedTensorToTensorShapes:function(){return combineRaggedTensorToTensorShapes},complexWithEvenIndex:function(){return complexWithEvenIndex},complexWithOddIndex:function(){return complexWithOddIndex},computeConv2DInfo:function(){return tM.Ix},computeConv3DInfo:function(){return tM.jw},computeDefaultPad:function(){return tM.aO},computeDilation2DInfo:function(){return tM.Rf},computeOptimalWindowSize:function(){return computeOptimalWindowSize},computeOutAndReduceShapes:function(){return tD.kz},computeOutShape:function(){return computeOutShape},computePool2DInfo:function(){return tM.Xw},computePool3DInfo:function(){return tM.pl},convertConv2DDataFormat:function(){return tM.sl},decodeEinsumEquation:function(){return decodeEinsumEquation},eitherStridesOrDilationsAreOne:function(){return tM.jT},expandShapeToKeepDim:function(){return tD.rv},exponent:function(){return exponent},exponents:function(){return exponents},fromStringArrayToUint8:function(){return fromStringArrayToUint8},fromUint8ToStringArray:function(){return fromUint8ToStringArray},getAxesPermutation:function(){return tD.Q3},getBroadcastDims:function(){return tc.getBroadcastDims},getComplexWithIndex:function(){return getComplexWithIndex},getEinsumComputePath:function(){return getEinsumComputePath},getEinsumPermutation:function(){return getEinsumPermutation},getFusedBiasGradient:function(){return tR.pf},getFusedDyActivation:function(){return tR.Fr},getImageCenter:function(){return getImageCenter},getInnerMostAxes:function(){return tD.sY},getPermuted:function(){return getPermuted},getRaggedRank:function(){return getRaggedRank},getReductionAxes:function(){return tc.getReductionAxes},getReshaped:function(){return getReshaped},getReshapedPermuted:function(){return getReshapedPermuted},getRowPartitionTypesHelper:function(){return getRowPartitionTypesHelper},getSliceBeginCoords:function(){return getSliceBeginCoords},getSliceSize:function(){return getSliceSize},getSparseFillEmptyRowsIndicesDenseShapeMismatch:function(){return getSparseFillEmptyRowsIndicesDenseShapeMismatch},getSparseFillEmptyRowsNegativeIndexErrorMessage:function(){return getSparseFillEmptyRowsNegativeIndexErrorMessage},getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:function(){return getSparseFillEmptyRowsOutOfRangeIndexErrorMessage},getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:function(){return getSparseReshapeEmptyTensorZeroOutputDimErrorMessage},getSparseReshapeInputOutputMismatchErrorMessage:function(){return getSparseReshapeInputOutputMismatchErrorMessage},getSparseReshapeInputOutputMultipleErrorMessage:function(){return getSparseReshapeInputOutputMultipleErrorMessage},getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:function(){return getSparseReshapeMultipleNegativeOneOutputDimErrorMessage},getSparseReshapeNegativeOutputDimErrorMessage:function(){return getSparseReshapeNegativeOutputDimErrorMessage},getSparseSegmentReductionIndicesOutOfRangeErrorMessage:function(){return getSparseSegmentReductionIndicesOutOfRangeErrorMessage},getSparseSegmentReductionNegativeSegmentIdsErrorMessage:function(){return getSparseSegmentReductionNegativeSegmentIdsErrorMessage},getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:function(){return getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage},getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:function(){return getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage},getUndoAxesPermutation:function(){return tD.LJ},isIdentityPermutation:function(){return isIdentityPermutation},log:function(){return tU.c},mergeRealAndImagArrays:function(){return mergeRealAndImagArrays},prepareAndValidate:function(){return prepareAndValidate},prepareSplitSize:function(){return prepareSplitSize},segment_util:function(){return eu},shouldFuse:function(){return tR.uy},slice_util:function(){return tv},splitRealAndImagArrays:function(){return splitRealAndImagArrays},stridesOrDilationsArePositive:function(){return tM.U3},tupleValuesAreOne:function(){return tM.I0},upcastType:function(){return tI.x8},validateDefaultValueShape:function(){return validateDefaultValueShape},validateInput:function(){return tb.validateInput},validateUpdateShape:function(){return tb.validateUpdateShape},warn:function(){return tU.Z}});var ep={};V.r(ep),V.d(ep,{nonMaxSuppressionV3Impl:function(){return tH.GP},nonMaxSuppressionV4Impl:function(){return tH.qP},nonMaxSuppressionV5Impl:function(){return tH.pA},whereImpl:function(){return tX.Z}});var eh=V(50196);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _isNavigatorDefined(){return"undefined"!=typeof navigator&&null!=navigator}function mockIsMobile(F){G=F}function isMobile(F){if(void 0!==G)return G;if(F||_isNavigatorDefined()){if(F||(F=navigator),"ReactNative"===F.product)return!0;let $=F.userAgent||F.vendor||("undefined"!=typeof window?window.opera:"");if(!$){let $=F;return $.userAgentData&&$.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test($)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test($.substr(0,4))}return!1}function isBrowser(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var ef=V(22885),ed=V(83454);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let em=(0,ef.OB)();em.registerFlag("DEBUG",()=>!1,F=>{F&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),em.registerFlag("IS_BROWSER",()=>isBrowser()),em.registerFlag("IS_NODE",()=>void 0!==ed&&void 0!==ed.versions&&void 0!==ed.versions.node),em.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),em.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),em.registerFlag("PROD",()=>!1),em.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>em.getBool("DEBUG")),em.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),em.registerFlag("IS_TEST",()=>!1),em.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>em.getBool("DEBUG")),em.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),em.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),em.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var eg=V(91989);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let IORouterRegistry=class IORouterRegistry{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==IORouterRegistry.instance&&(IORouterRegistry.instance=new IORouterRegistry),IORouterRegistry.instance}static registerSaveRouter(F){IORouterRegistry.getInstance().saveRouters.push(F)}static registerLoadRouter(F){IORouterRegistry.getInstance().loadRouters.push(F)}static getSaveHandlers(F){return IORouterRegistry.getHandlers(F,"save")}static getLoadHandlers(F,$){return IORouterRegistry.getHandlers(F,"load",$)}static getHandlers(F,$,V){let G=[],H="load"===$?IORouterRegistry.getInstance().loadRouters:IORouterRegistry.getInstance().saveRouters;return H.forEach($=>{let H=$(F,V);null!==H&&G.push(H)}),G}};let registerSaveRouter=F=>IORouterRegistry.registerSaveRouter(F),registerLoadRouter=F=>IORouterRegistry.registerLoadRouter(F),getSaveHandlers=F=>IORouterRegistry.getSaveHandlers(F),getLoadHandlers=(F,$)=>IORouterRegistry.getLoadHandlers(F,$);var ey=V(10574);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eb="tensorflowjs",ew=1,eS="models_store",e_="model_info_store";function getIndexedDBFactory(){if(!(0,ef.OB)().getBool("IS_BROWSER"))throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let F="undefined"==typeof window?self:window,$=F.indexedDB||F.mozIndexedDB||F.webkitIndexedDB||F.msIndexedDB||F.shimIndexedDB;if(null==$)throw Error("The current browser does not appear to support IndexedDB.");return $}function setUpDatabase(F){let $=F.result;$.createObjectStore(eS,{keyPath:"modelPath"}),$.createObjectStore(e_,{keyPath:"modelPath"})}let BrowserIndexedDB=class BrowserIndexedDB{constructor(F){if(this.indexedDB=getIndexedDBFactory(),null==F||!F)throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=F}async save(F){if(F.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,F)}async load(){return this.databaseAction(this.modelPath)}databaseAction(F,$){return new Promise((F,V)=>{let G=this.indexedDB.open(eb,ew);G.onupgradeneeded=()=>setUpDatabase(G),G.onsuccess=()=>{let H=G.result;if(null==$){let $=H.transaction(eS,"readonly"),G=$.objectStore(eS),K=G.get(this.modelPath);K.onsuccess=()=>{if(null==K.result)return H.close(),V(Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));F(K.result.modelArtifacts)},K.onerror=F=>(H.close(),V(K.error)),$.oncomplete=()=>H.close()}else{let G,K;$.weightData=ey.w.join($.weightData);let Z=(0,eg.Q)($),ee=H.transaction(e_,"readwrite"),et=ee.objectStore(e_);try{G=et.put({modelPath:this.modelPath,modelArtifactsInfo:Z})}catch(F){return V(F)}G.onsuccess=()=>{let G;K=H.transaction(eS,"readwrite");let en=K.objectStore(eS);try{G=en.put({modelPath:this.modelPath,modelArtifacts:$,modelArtifactsInfo:Z})}catch(F){return V(F)}G.onsuccess=()=>F({modelArtifactsInfo:Z}),G.onerror=F=>{et=ee.objectStore(e_);let $=et.delete(this.modelPath);$.onsuccess=()=>(H.close(),V(G.error)),$.onerror=F=>(H.close(),V(G.error))}},G.onerror=F=>(H.close(),V(G.error)),ee.oncomplete=()=>{null==K?H.close():K.oncomplete=()=>H.close()}}},G.onerror=F=>V(G.error)})}};BrowserIndexedDB.URL_SCHEME="indexeddb://";let indexedDBRouter=F=>(0,ef.OB)().getBool("IS_BROWSER")&&!Array.isArray(F)&&F.startsWith(BrowserIndexedDB.URL_SCHEME)?browserIndexedDB(F.slice(BrowserIndexedDB.URL_SCHEME.length)):null;function browserIndexedDB(F){return new BrowserIndexedDB(F)}function maybeStripScheme(F){return F.startsWith(BrowserIndexedDB.URL_SCHEME)?F.slice(BrowserIndexedDB.URL_SCHEME.length):F}IORouterRegistry.registerSaveRouter(indexedDBRouter),IORouterRegistry.registerLoadRouter(indexedDBRouter);let BrowserIndexedDBManager=class BrowserIndexedDBManager{constructor(){this.indexedDB=getIndexedDBFactory()}async listModels(){return new Promise((F,$)=>{let V=this.indexedDB.open(eb,ew);V.onupgradeneeded=()=>setUpDatabase(V),V.onsuccess=()=>{let G=V.result,H=G.transaction(e_,"readonly"),K=H.objectStore(e_),Z=K.getAll();Z.onsuccess=()=>{let $={};for(let F of Z.result)$[F.modelPath]=F.modelArtifactsInfo;F($)},Z.onerror=F=>(G.close(),$(Z.error)),H.oncomplete=()=>G.close()},V.onerror=F=>$(V.error)})}async removeModel(F){return F=maybeStripScheme(F),new Promise(($,V)=>{let G=this.indexedDB.open(eb,ew);G.onupgradeneeded=()=>setUpDatabase(G),G.onsuccess=()=>{let H;let K=G.result,Z=K.transaction(e_,"readwrite"),ee=Z.objectStore(e_),et=ee.get(F);et.onsuccess=()=>{if(null==et.result)return K.close(),V(Error(`Cannot find model with path '${F}' in IndexedDB.`));{let G=ee.delete(F),deleteModelData=()=>{H=K.transaction(eS,"readwrite");let G=H.objectStore(eS),Z=G.delete(F);Z.onsuccess=()=>$(et.result.modelArtifactsInfo),Z.onerror=F=>V(et.error)};G.onsuccess=deleteModelData,G.onerror=F=>(deleteModelData(),K.close(),V(et.error))}},et.onerror=F=>(K.close(),V(et.error)),Z.oncomplete=()=>{null==H?K.close():H.oncomplete=()=>K.close()}},G.onerror=F=>V(G.error)})}};var eN=V(20569);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ek="/",eI="tensorflowjs_models",eT="info",eC="model_topology",eE="weight_specs",eA="weight_data",eD="model_metadata";function getModelKeys(F){return{info:[eI,F,eT].join(ek),topology:[eI,F,eC].join(ek),weightSpecs:[eI,F,eE].join(ek),weightData:[eI,F,eA].join(ek),modelMetadata:[eI,F,eD].join(ek)}}function removeItems(F){for(let $ of Object.values(F))window.localStorage.removeItem($)}function getModelPathFromKey(F){let $=F.split(ek);if($.length<3)throw Error(`Invalid key format: ${F}`);return $.slice(1,$.length-1).join(ek)}function local_storage_maybeStripScheme(F){return F.startsWith(BrowserLocalStorage.URL_SCHEME)?F.slice(BrowserLocalStorage.URL_SCHEME.length):F}let BrowserLocalStorage=class BrowserLocalStorage{constructor(F){if(!(0,ef.OB)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==F||!F)throw Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=F,this.keys=getModelKeys(this.modelPath)}async save(F){if(F.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let $=JSON.stringify(F.modelTopology),V=JSON.stringify(F.weightSpecs),G=(0,eg.Q)(F),H=ey.w.join(F.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(G)),this.LS.setItem(this.keys.topology,$),this.LS.setItem(this.keys.weightSpecs,V),this.LS.setItem(this.keys.weightData,(0,eg._n)(H));let K={format:F.format,generatedBy:F.generatedBy,convertedBy:F.convertedBy,signature:null!=F.signature?F.signature:void 0,userDefinedMetadata:null!=F.userDefinedMetadata?F.userDefinedMetadata:void 0,modelInitializer:null!=F.modelInitializer?F.modelInitializer:void 0,initializerSignature:null!=F.initializerSignature?F.initializerSignature:void 0,trainingConfig:null!=F.trainingConfig?F.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(K)),{modelArtifactsInfo:G}}catch(F){throw removeItems(this.keys),Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${G.modelTopologyBytes}, weightSpecsBytes=${G.weightSpecsBytes}, weightDataBytes=${G.weightDataBytes}.`)}}}async load(){let F=JSON.parse(this.LS.getItem(this.keys.info));if(null==F)throw Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==F.modelTopologyType)throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let $={},V=JSON.parse(this.LS.getItem(this.keys.topology));if(null==V)throw Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);$.modelTopology=V;let G=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==G)throw Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);$.weightSpecs=G;let H=this.LS.getItem(this.keys.modelMetadata);if(null!=H){let F=JSON.parse(H);$.format=F.format,$.generatedBy=F.generatedBy,$.convertedBy=F.convertedBy,null!=F.signature&&($.signature=F.signature),null!=F.userDefinedMetadata&&($.userDefinedMetadata=F.userDefinedMetadata),null!=F.modelInitializer&&($.modelInitializer=F.modelInitializer),null!=F.initializerSignature&&($.initializerSignature=F.initializerSignature),null!=F.trainingConfig&&($.trainingConfig=F.trainingConfig)}let K=this.LS.getItem(this.keys.weightData);if(null==K)throw Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return $.weightData=(0,eg.n7)(K),$}};BrowserLocalStorage.URL_SCHEME="localstorage://";let localStorageRouter=F=>(0,ef.OB)().getBool("IS_BROWSER")&&!Array.isArray(F)&&F.startsWith(BrowserLocalStorage.URL_SCHEME)?browserLocalStorage(F.slice(BrowserLocalStorage.URL_SCHEME.length)):null;function browserLocalStorage(F){return new BrowserLocalStorage(F)}IORouterRegistry.registerSaveRouter(localStorageRouter),IORouterRegistry.registerLoadRouter(localStorageRouter);let BrowserLocalStorageManager=class BrowserLocalStorageManager{constructor(){(0,eN.hu)((0,ef.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,eN.hu)("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let F={},$=eI+ek,V=ek+eT;for(let G=0;G<this.LS.length;++G){let H=this.LS.key(G);if(H.startsWith($)&&H.endsWith(V)){let $=getModelPathFromKey(H);F[$]=JSON.parse(this.LS.getItem(H))}}return F}async removeModel(F){F=local_storage_maybeStripScheme(F);let $=getModelKeys(F);if(null==this.LS.getItem($.info))throw Error(`Cannot find model at path '${F}'`);let V=JSON.parse(this.LS.getItem($.info));return removeItems($),V}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eM="://";let ModelStoreManagerRegistry=class ModelStoreManagerRegistry{constructor(){this.managers={}}static getInstance(){return null==ModelStoreManagerRegistry.instance&&(ModelStoreManagerRegistry.instance=new ModelStoreManagerRegistry),ModelStoreManagerRegistry.instance}static registerManager(F,$){(0,eN.hu)(null!=F,()=>"scheme must not be undefined or null."),F.endsWith(eM)&&(F=F.slice(0,F.indexOf(eM))),(0,eN.hu)(F.length>0,()=>"scheme must not be an empty string.");let V=ModelStoreManagerRegistry.getInstance();(0,eN.hu)(null==V.managers[F],()=>`A model store manager is already registered for scheme '${F}'.`),V.managers[F]=$}static getManager(F){let $=ModelStoreManagerRegistry.getInstance().managers[F];if(null==$)throw Error(`Cannot find model manager for scheme '${F}'`);return $}static getSchemes(){return Object.keys(ModelStoreManagerRegistry.getInstance().managers)}};function parseURL(F){if(-1===F.indexOf(eM))throw Error(`The url string provided does not contain a scheme. Supported schemes are: ${ModelStoreManagerRegistry.getSchemes().join(",")}`);return{scheme:F.split(eM)[0],path:F.split(eM)[1]}}async function cloneModelInternal(F,$,V=!1){(0,eN.hu)(F!==$,()=>`Old path and new path are the same: '${F}'`);let G=IORouterRegistry.getLoadHandlers(F);(0,eN.hu)(G.length>0,()=>`Copying failed because no load handler is found for source URL ${F}.`),(0,eN.hu)(G.length<2,()=>`Copying failed because more than one (${G.length}) load handlers for source URL ${F}.`);let H=G[0],K=IORouterRegistry.getSaveHandlers($);(0,eN.hu)(K.length>0,()=>`Copying failed because no save handler is found for destination URL ${$}.`),(0,eN.hu)(K.length<2,()=>`Copying failed because more than one (${G.length}) save handlers for destination URL ${$}.`);let Z=K[0],ee=parseURL(F).scheme,et=parseURL(F).path,en=ee===parseURL(F).scheme,ea=await H.load();V&&en&&await ModelStoreManagerRegistry.getManager(ee).removeModel(et);let ei=await Z.save(ea);return V&&!en&&await ModelStoreManagerRegistry.getManager(ee).removeModel(et),ei.modelArtifactsInfo}async function listModels(){let F=ModelStoreManagerRegistry.getSchemes(),$={};for(let V of F){let F=await ModelStoreManagerRegistry.getManager(V).listModels();for(let G in F){let H=V+eM+G;$[H]=F[G]}}return $}async function removeModel(F){let $=parseURL(F),V=ModelStoreManagerRegistry.getManager($.scheme);return V.removeModel($.path)}async function copyModel(F,$){let V=!1;return cloneModelInternal(F,$,V)}async function moveModel(F,$){let V=!0;return cloneModelInternal(F,$,V)}var eR=V(59742);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PlatformBrowser=class PlatformBrowser{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(F,$){return fetch(F,$)}now(){return performance.now()}encode(F,$){if("utf-8"!==$&&"utf8"!==$)throw Error(`Browser's encoder only supports utf-8, but got ${$}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(F)}decode(F,$){return new TextDecoder($).decode(F)}setTimeoutCustom(F,$){if("undefined"==typeof window||!(0,ef.OB)().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(F,$);return}this.functionRefs.push(F),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},$),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",F=>{if(F.source===window&&F.data.name===this.messageName){F.stopPropagation();let $=this.functionRefs[F.data.index];$(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(F){return(0,eR.j)(F)}};if((0,ef.OB)().get("IS_BROWSER")){(0,ef.OB)().setPlatform("browser",new PlatformBrowser);try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager)}catch(F){}try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager)}catch(F){}}var eF=V(83454);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eO={importFetch:()=>V(75410)};let PlatformNode=class PlatformNode{constructor(){this.util=V(48628),this.textEncoder=new this.util.TextEncoder}fetch(F,$){return null!=(0,ef.OB)().global.fetch?(0,ef.OB)().global.fetch(F,$):(null==H&&(H=eO.importFetch()),H(F,$))}now(){let F=eF.hrtime();return 1e3*F[0]+F[1]/1e6}encode(F,$){if("utf-8"!==$&&"utf8"!==$)throw Error(`Node built-in encoder only supports utf-8, but got ${$}`);return this.textEncoder.encode(F)}decode(F,$){return 0===F.length?"":new this.util.TextDecoder($).decode(F)}isTypedArray(F){return this.util.types.isFloat32Array(F)||this.util.types.isInt32Array(F)||this.util.types.isUint8Array(F)||this.util.types.isUint8ClampedArray(F)}};(0,ef.OB)().get("IS_NODE")&&!(0,ef.OB)().get("IS_BROWSER")&&(0,ef.OB)().setPlatform("node",new PlatformNode);var eP=V(72657),eB=V(62271),e$=V(8723),eL=V(29798),ez=V(40974);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,eh.wv)();let eV={buffer:eP.f,cast:eB.p,clone:e$.d,print:eL.S};(0,ez.Vp)(eV);var eU=V(4368),eW=V(56407),ej=V(41274),eG=V(24841),eH=V(13261),eX=V(50248),eK=V(6577),eQ=V(30633),eZ=V(99494);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eY=new Map,eJ=new Map;let Serializable=class Serializable{getClassName(){return this.constructor.className}static fromConfig(F,$){return new F($)}};let SerializationMap=class SerializationMap{constructor(){this.classNameMap={}}static getMap(){return null==SerializationMap.instance&&(SerializationMap.instance=new SerializationMap),SerializationMap.instance}static register(F){SerializationMap.getMap().classNameMap[F.className]=[F,F.fromConfig]}};function registerClass(F,$,V){(0,eN.hu)(null!=F.className,()=>"Class being registered does not have the static className property defined."),(0,eN.hu)("string"==typeof F.className,()=>"className is required to be a string, but got type "+typeof F.className),(0,eN.hu)(F.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===$&&($="Custom"),void 0===V&&(V=F.className);let G=V,H=$+">"+G;return SerializationMap.register(F),eY.set(H,F),eJ.set(F,H),F}function getRegisteredName(F){return eJ.has(F)?eJ.get(F):F.className}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Optimizer=class Optimizer extends Serializable{minimize(F,$=!1,V){let{value:G,grads:H}=this.computeGradients(F,V);if(null!=V){let F=V.map(F=>({name:F.name,tensor:H[F.name]}));this.applyGradients(F)}else this.applyGradients(H);return((0,eU.B9)(H),$)?G:(G.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(F,$){return(0,eQ.pn)(F,$)}dispose(){null!=this.iterations_&&(0,eU.B9)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,eZ.i)(this.iterations_,"int32")}}async getWeights(){throw Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(F){throw Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(F){return this.iterations_=(await F[0].tensor.data())[0],F.slice(1)}};Object.defineProperty(Optimizer,Symbol.hasInstance,{value:F=>null!=F.minimize&&null!=F.computeGradients&&null!=F.applyGradients});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AdadeltaOptimizer=class AdadeltaOptimizer extends Optimizer{static get className(){return"Adadelta"}constructor(F,$,V=null){super(),this.learningRate=F,this.rho=$,this.epsilon=V,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==V&&(this.epsilon=eh.BV.backend.epsilon())}applyGradients(F){let $=Array.isArray(F)?F.map(F=>F.name):Object.keys(F);$.forEach(($,V)=>{let G=eh.BV.registeredVariables[$],H=!1;null==this.accumulatedGrads[V]&&(this.accumulatedGrads[V]={originalName:`${$}/accum_grad`,variable:(0,eU.lu)(()=>(0,eK.P)(G).variable(H))}),null==this.accumulatedUpdates[V]&&(this.accumulatedUpdates[V]={originalName:`${$}/accum_var`,variable:(0,eU.lu)(()=>(0,eK.P)(G).variable(H))});let K=Array.isArray(F)?F[V].tensor:F[$];if(null==K)return;let Z=this.accumulatedGrads[V].variable,ee=this.accumulatedUpdates[V].variable;(0,eU.lu)(()=>{let F=(0,eW.I)((0,eG.d)(Z,this.rho),(0,eG.d)((0,eX.h)(K),1-this.rho)),$=(0,eG.d)((0,ej.h)((0,eH._)((0,eW.I)(ee,this.epsilon)),(0,eH._)((0,eW.I)(Z,this.epsilon))),K),V=(0,eW.I)((0,eG.d)(ee,this.rho),(0,eG.d)((0,eX.h)($),1-this.rho));Z.assign(F),ee.assign(V);let H=(0,eW.I)((0,eG.d)($,-this.learningRate),G);G.assign(H)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,eU.B9)(this.accumulatedGrads.map(F=>F.variable)),(0,eU.B9)(this.accumulatedUpdates.map(F=>F.variable)))}async getWeights(){let F=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(F.map(F=>({name:F.originalName,tensor:F.variable})))}async setWeights(F){F=await this.extractIterations(F);let $=F.length/2,V=!1;this.accumulatedGrads=F.slice(0,$).map(F=>({originalName:F.name,variable:F.tensor.variable(V)})),this.accumulatedUpdates=F.slice($,2*$).map(F=>({originalName:F.name,variable:F.tensor.variable(V)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(F,$){return new F($.learningRate,$.rho,$.epsilon)}};var e1=V(14006);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AdagradOptimizer=class AdagradOptimizer extends Optimizer{static get className(){return"Adagrad"}constructor(F,$=.1){super(),this.learningRate=F,this.initialAccumulatorValue=$,this.accumulatedGrads=[]}applyGradients(F){let $=Array.isArray(F)?F.map(F=>F.name):Object.keys(F);$.forEach(($,V)=>{let G=eh.BV.registeredVariables[$];if(null==this.accumulatedGrads[V]){let F=!1;this.accumulatedGrads[V]={originalName:`${$}/accumulator`,variable:(0,eU.lu)(()=>(0,e1.h)(G.shape,this.initialAccumulatorValue).variable(F))}}let H=Array.isArray(F)?F[V].tensor:F[$];if(null==H)return;let K=this.accumulatedGrads[V].variable;(0,eU.lu)(()=>{let F=(0,eW.I)(K,(0,eX.h)(H));K.assign(F);let $=(0,eW.I)((0,eG.d)((0,ej.h)(H,(0,eH._)((0,eW.I)(F,eh.BV.backend.epsilon()))),-this.learningRate),G);G.assign($)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,eU.B9)(this.accumulatedGrads.map(F=>F.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(F=>({name:F.originalName,tensor:F.variable})))}async setWeights(F){F=await this.extractIterations(F);let $=!1;this.accumulatedGrads=F.map(F=>({originalName:F.name,variable:F.tensor.variable($)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(F,$){return new F($.learningRate,$.initialAccumulatorValue)}};var e2=V(33453),e3=V(70827);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AdamOptimizer=class AdamOptimizer extends Optimizer{static get className(){return"Adam"}constructor(F,$,V,G=null){super(),this.learningRate=F,this.beta1=$,this.beta2=V,this.epsilon=G,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,eU.lu)(()=>{this.accBeta1=(0,eZ.i)($).variable(),this.accBeta2=(0,eZ.i)(V).variable()}),null==G&&(this.epsilon=eh.BV.backend.epsilon())}applyGradients(F){let $=Array.isArray(F)?F.map(F=>F.name):Object.keys(F);(0,eU.lu)(()=>{let V=(0,e3.l)(1,this.accBeta1),G=(0,e3.l)(1,this.accBeta2);$.forEach(($,H)=>{let K=eh.BV.registeredVariables[$],Z=!1;null==this.accumulatedFirstMoment[H]&&(this.accumulatedFirstMoment[H]={originalName:`${$}/m`,variable:(0,eU.lu)(()=>(0,eK.P)(K).variable(Z))}),null==this.accumulatedSecondMoment[H]&&(this.accumulatedSecondMoment[H]={originalName:`${$}/v`,variable:(0,eU.lu)(()=>(0,eK.P)(K).variable(Z))});let ee=Array.isArray(F)?F[H].tensor:F[$];if(null==ee)return;let et=this.accumulatedFirstMoment[H].variable,en=this.accumulatedSecondMoment[H].variable,ea=(0,eW.I)((0,eG.d)(et,this.beta1),(0,eG.d)(ee,1-this.beta1)),ei=(0,eW.I)((0,eG.d)(en,this.beta2),(0,eG.d)((0,eX.h)(ee),1-this.beta2)),eo=(0,ej.h)(ea,V),es=(0,ej.h)(ei,G);et.assign(ea),en.assign(ei);let eu=(0,eW.I)((0,eG.d)((0,ej.h)(eo,(0,eW.I)((0,eH._)(es),this.epsilon)),-this.learningRate),K);K.assign(eu)}),this.accBeta1.assign((0,eG.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,eG.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,eU.B9)(this.accumulatedFirstMoment.map(F=>F.variable)),null!=this.accumulatedSecondMoment&&(0,eU.B9)(this.accumulatedSecondMoment.map(F=>F.variable))}async getWeights(){let F=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(F.map(F=>({name:F.originalName,tensor:F.variable})))}async setWeights(F){F=await this.extractIterations(F),(0,eU.lu)(()=>{this.accBeta1.assign((0,e2.s)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,e2.s)(this.beta2,this.iterations_+1))});let $=F.length/2,V=!1;this.accumulatedFirstMoment=F.slice(0,$).map(F=>({originalName:F.name,variable:F.tensor.variable(V)})),this.accumulatedSecondMoment=F.slice($,2*$).map(F=>({originalName:F.name,variable:F.tensor.variable(V)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(F,$){return new F($.learningRate,$.beta1,$.beta2,$.epsilon)}};var e4=V(96235),e6=V(80632);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AdamaxOptimizer=class AdamaxOptimizer extends Optimizer{static get className(){return"Adamax"}constructor(F,$,V,G=null,H=0){super(),this.learningRate=F,this.beta1=$,this.beta2=V,this.epsilon=G,this.decay=H,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,eU.lu)(()=>{this.iteration=(0,eZ.i)(0).variable(),this.accBeta1=(0,eZ.i)($).variable()}),null==G&&(this.epsilon=eh.BV.backend.epsilon())}applyGradients(F){let $=Array.isArray(F)?F.map(F=>F.name):Object.keys(F);(0,eU.lu)(()=>{let V=(0,e3.l)(1,this.accBeta1),G=(0,ej.h)(-this.learningRate,(0,eW.I)((0,eG.d)(this.iteration,this.decay),1));$.forEach(($,H)=>{let K=eh.BV.registeredVariables[$],Z=!1;null==this.accumulatedFirstMoment[H]&&(this.accumulatedFirstMoment[H]={originalName:`${$}/m`,variable:(0,eK.P)(K).variable(Z)}),null==this.accumulatedWeightedInfNorm[H]&&(this.accumulatedWeightedInfNorm[H]={originalName:`${$}/v`,variable:(0,eK.P)(K).variable(Z)});let ee=Array.isArray(F)?F[H].tensor:F[$];if(null==ee)return;let et=this.accumulatedFirstMoment[H].variable,en=this.accumulatedWeightedInfNorm[H].variable,ea=(0,eW.I)((0,eG.d)(et,this.beta1),(0,eG.d)(ee,1-this.beta1)),ei=(0,eG.d)(en,this.beta2),eo=(0,e4.W)(ee),es=(0,e6.g)(ei,eo);et.assign(ea),en.assign(es);let eu=(0,eW.I)((0,eG.d)((0,ej.h)(G,V),(0,ej.h)(ea,(0,eW.I)(es,this.epsilon))),K);K.assign(eu)}),this.iteration.assign((0,eW.I)(this.iteration,1)),this.accBeta1.assign((0,eG.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,eU.B9)(this.accumulatedFirstMoment.map(F=>F.variable)),null!=this.accumulatedWeightedInfNorm&&(0,eU.B9)(this.accumulatedWeightedInfNorm.map(F=>F.variable))}async getWeights(){throw Error("getWeights() is not implemented for Adamax yet.")}async setWeights(F){throw Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(F,$){return new F($.learningRate,$.beta1,$.beta2,$.epsilon,$.decay)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SGDOptimizer=class SGDOptimizer extends Optimizer{static get className(){return"SGD"}constructor(F){super(),this.learningRate=F,this.setLearningRate(F)}applyGradients(F){let $=Array.isArray(F)?F.map(F=>F.name):Object.keys(F);$.forEach(($,V)=>{let G=Array.isArray(F)?F[V].tensor:F[$];if(null==G)return;let H=eh.BV.registeredVariables[$];(0,eU.lu)(()=>{let F=(0,eW.I)((0,eG.d)(this.c,G),H);H.assign(F)})}),this.incrementIterations()}setLearningRate(F){this.learningRate=F,null!=this.c&&this.c.dispose(),this.c=(0,eU.Cn)((0,eZ.i)(-F))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(F){if(0!==(F=await this.extractIterations(F)).length)throw Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(F,$){return new F($.learningRate)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MomentumOptimizer=class MomentumOptimizer extends SGDOptimizer{static get className(){return"Momentum"}constructor(F,$,V=!1){super(F),this.learningRate=F,this.momentum=$,this.useNesterov=V,this.accumulations=[],this.m=(0,eZ.i)(this.momentum)}applyGradients(F){let $=Array.isArray(F)?F.map(F=>F.name):Object.keys(F);$.forEach(($,V)=>{let G=eh.BV.registeredVariables[$];if(null==this.accumulations[V]){let F=!1;this.accumulations[V]={originalName:`${$}/momentum`,variable:(0,eU.lu)(()=>(0,eK.P)(G).variable(F))}}let H=this.accumulations[V].variable,K=Array.isArray(F)?F[V].tensor:F[$];null!=K&&(0,eU.lu)(()=>{let F;let $=(0,eW.I)((0,eG.d)(this.m,H),K);F=this.useNesterov?(0,eW.I)((0,eG.d)(this.c,(0,eW.I)(K,(0,eG.d)($,this.m))),G):(0,eW.I)((0,eG.d)(this.c,$),G),H.assign($),G.assign(F)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,eU.B9)(this.accumulations.map(F=>F.variable))}setMomentum(F){this.momentum=F}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(F=>({name:F.originalName,tensor:F.variable})))}async setWeights(F){F=await this.extractIterations(F);let $=!1;this.accumulations=F.map(F=>({originalName:F.name,variable:F.tensor.variable($)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(F,$){return new F($.learningRate,$.momentum,$.useNesterov)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let RMSPropOptimizer=class RMSPropOptimizer extends Optimizer{static get className(){return"RMSProp"}constructor(F,$=.9,V=0,G=null,H=!1){if(super(),this.learningRate=F,this.decay=$,this.momentum=V,this.epsilon=G,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=H,null==G&&(this.epsilon=eh.BV.backend.epsilon()),null==F)throw Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(F){let $=Array.isArray(F)?F.map(F=>F.name):Object.keys(F);$.forEach(($,V)=>{let G=eh.BV.registeredVariables[$],H=!1;null==this.accumulatedMeanSquares[V]&&(this.accumulatedMeanSquares[V]={originalName:`${$}/rms`,variable:(0,eU.lu)(()=>(0,eK.P)(G).variable(H))}),null==this.accumulatedMoments[V]&&(this.accumulatedMoments[V]={originalName:`${$}/momentum`,variable:(0,eU.lu)(()=>(0,eK.P)(G).variable(H))}),null==this.accumulatedMeanGrads[V]&&this.centered&&(this.accumulatedMeanGrads[V]={originalName:`${$}/mg`,variable:(0,eU.lu)(()=>(0,eK.P)(G).variable(H))});let K=Array.isArray(F)?F[V].tensor:F[$];if(null==K)return;let Z=this.accumulatedMeanSquares[V].variable,ee=this.accumulatedMoments[V].variable;(0,eU.lu)(()=>{let F=(0,eW.I)((0,eG.d)(Z,this.decay),(0,eG.d)((0,eX.h)(K),1-this.decay));if(this.centered){let $=this.accumulatedMeanGrads[V].variable,H=(0,eW.I)((0,eG.d)($,this.decay),(0,eG.d)(K,1-this.decay)),et=(0,ej.h)((0,eG.d)(K,this.learningRate),(0,eH._)((0,e3.l)(F,(0,eW.I)((0,eX.h)(H),this.epsilon)))),en=(0,eW.I)((0,eG.d)(ee,this.momentum),et);Z.assign(F),$.assign(H),ee.assign(en);let ea=(0,e3.l)(G,en);G.assign(ea)}else{let F=(0,eW.I)((0,eG.d)(Z,this.decay),(0,eG.d)((0,eX.h)(K),1-this.decay)),$=(0,eW.I)((0,eG.d)(ee,this.momentum),(0,ej.h)((0,eG.d)(K,this.learningRate),(0,eH._)((0,eW.I)(F,this.epsilon))));Z.assign(F),ee.assign($);let V=(0,e3.l)(G,$);G.assign(V)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,eU.B9)(this.accumulatedMeanSquares.map(F=>F.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,eU.B9)(this.accumulatedMeanGrads.map(F=>F.variable)),null!=this.accumulatedMoments&&(0,eU.B9)(this.accumulatedMoments.map(F=>F.variable))}async getWeights(){let F=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&F.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(F.map(F=>({name:F.originalName,tensor:F.variable})))}async setWeights(F){F=await this.extractIterations(F);let $=this.centered?F.length/3:F.length/2,V=!1;this.accumulatedMeanSquares=F.slice(0,$).map(F=>({originalName:F.name,variable:F.tensor.variable(V)})),this.accumulatedMoments=F.slice($,2*$).map(F=>({originalName:F.name,variable:F.tensor.variable(V)})),this.centered&&(this.accumulatedMeanGrads=F.slice(2*$,3*$).map(F=>({originalName:F.name,variable:F.tensor.variable(V)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(F,$){return new F($.learningRate,$.decay,$.momentum,$.epsilon,$.centered)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let e5=[AdadeltaOptimizer,AdagradOptimizer,AdamOptimizer,AdamaxOptimizer,MomentumOptimizer,RMSPropOptimizer,SGDOptimizer];function registerOptimizers(){for(let F of e5)registerClass(F)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let e9="model",e8=".json",e7=".weights.bin";function defer(F){return new Promise(F=>setTimeout(F)).then(F)}let BrowserDownloads=class BrowserDownloads{constructor(F){if(!(0,ef.OB)().getBool("IS_BROWSER"))throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");F.startsWith(BrowserDownloads.URL_SCHEME)&&(F=F.slice(BrowserDownloads.URL_SCHEME.length)),(null==F||0===F.length)&&(F=e9),this.modelJsonFileName=F+e8,this.weightDataFileName=F+e7}async save(F){if("undefined"==typeof document)throw Error("Browser downloads are not supported in this environment since `document` is not present");let $=ey.w.join(F.weightData),V=window.URL.createObjectURL(new Blob([$],{type:"application/octet-stream"}));if(F.modelTopology instanceof ArrayBuffer)throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let $=[{paths:["./"+this.weightDataFileName],weights:F.weightSpecs}],G=(0,eg.Yd)(F,$),H=window.URL.createObjectURL(new Blob([JSON.stringify(G)],{type:"application/json"})),K=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(K.download=this.modelJsonFileName,K.href=H,await defer(()=>K.dispatchEvent(new MouseEvent("click"))),null!=F.weightData){let F=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;F.download=this.weightDataFileName,F.href=V,await defer(()=>F.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:(0,eg.Q)(F)}}}};BrowserDownloads.URL_SCHEME="downloads://";let BrowserFiles=class BrowserFiles{constructor(F){if(null==F||F.length<1)throw Error(`When calling browserFiles, at least 1 file is required, but received ${F}`);this.jsonFile=F[0],this.weightsFiles=F.slice(1)}async load(){return new Promise((F,$)=>{let V=new FileReader;V.onload=V=>{let G=JSON.parse(V.target.result),H=G.modelTopology;if(null==H){$(Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}let K=G.weightsManifest;if(null==K){$(Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(0===this.weightsFiles.length){F({modelTopology:H});return}let Z=(0,eg.jN)(G,F=>this.loadWeights(F));F(Z)},V.onerror=F=>$(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),V.readAsText(this.jsonFile)})}loadWeights(F){let $=[],V=[];for(let G of F)$.push(...G.weights),V.push(...G.paths);let G=this.checkManifestAndWeightFiles(F),H=V.map(F=>this.loadWeightsFile(F,G[F]));return Promise.all(H).then(F=>[$,F])}loadWeightsFile(F,$){return new Promise((V,G)=>{let H=new FileReader;H.onload=F=>{let $=F.target.result;V($)},H.onerror=$=>G(`Failed to weights data from file of path '${F}'.`),H.readAsArrayBuffer($)})}checkManifestAndWeightFiles(F){let $=[],V=this.weightsFiles.map(F=>(0,eg.EZ)(F.name)),G={};for(let H of F)H.paths.forEach(F=>{let H=(0,eg.EZ)(F);if(-1!==$.indexOf(H))throw Error(`Duplicate file basename found in weights manifest: '${H}'`);if($.push(H),-1===V.indexOf(H))throw Error(`Weight file with basename '${H}' is not provided.`);G[F]=this.weightsFiles[V.indexOf(H)]});if($.length!==this.weightsFiles.length)throw Error(`Mismatch in the number of files in weights manifest (${$.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return G}};let browserDownloadsRouter=F=>(0,ef.OB)().getBool("IS_BROWSER")&&!Array.isArray(F)&&F.startsWith(BrowserDownloads.URL_SCHEME)?browserDownloads(F.slice(BrowserDownloads.URL_SCHEME.length)):null;function browserDownloads(F="model"){return new BrowserDownloads(F)}function browserFiles(F){return new BrowserFiles(F)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function monitorPromisesProgress(F,$,V,G){checkPromises(F),checkFraction(V=null==V?0:V,G=null==G?1:G);let H=0,registerMonitor=K=>(K.then(K=>{let Z=V+ ++H/F.length*(G-V);return $(Z),K}),K);function checkPromises(F){(0,eN.hu)(null!=F&&Array.isArray(F)&&F.length>0,()=>"promises must be a none empty array")}function checkFraction(F,$){(0,eN.hu)(F>=0&&F<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${F}`),(0,eN.hu)($>=0&&$<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${$}`),(0,eN.hu)($>=F,()=>`startFraction must be no more than endFraction, but got startFraction ${F} and endFraction ${$}`)}return Promise.all(F.map(registerMonitor))}IORouterRegistry.registerSaveRouter(browserDownloadsRouter);var te=V(75771);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function loadWeightsAsArrayBuffer(F,$){null==$&&($={});let V=null==$.fetchFunc?(0,ef.OB)().platform.fetch:$.fetchFunc,G=F.map(F=>V(F,$.requestInit,{isBinary:!0})),H=0,K=.5,Z=null==$.onProgress?await Promise.all(G):await monitorPromisesProgress(G,$.onProgress,H,K),ee=Z.map(F=>F.arrayBuffer()),et=.5,en=1,ea=null==$.onProgress?await Promise.all(ee):await monitorPromisesProgress(ee,$.onProgress,et,en);return ea}function streamWeights(F,$){var V;let G;let H=null==$.fetchFunc?(0,ef.OB)().platform.fetch:$.fetchFunc,K=0;return null===(V=$.onProgress)||void 0===V||V.call($,0),new ReadableStream({pull:async V=>{for(var Z;K<F.length;){if(!G){let V=(await H(F[K],$.requestInit,{isBinary:!0})).body;G=V.getReader()}let{done:ee,value:et}=await G.read();if(ee){K++,G=void 0,null===(Z=$.onProgress)||void 0===Z||Z.call($,K/F.length);continue}V.enqueue(et);return}V.close()}})}async function loadWeights(F,$="",V,G){let fetchWeights=F=>loadWeightsAsArrayBuffer(F,{requestInit:G}),H=weightsLoaderFactory(fetchWeights);return H(F,$,V)}function weightsLoaderFactory(F){return async($,V="",G)=>{let H=$.map(()=>!1),K={},Z=null!=G?G.map(()=>!1):[],ee=[];if($.forEach((F,$)=>{let V=0;F.weights.forEach(F=>{let et="quantization"in F?F.quantization.dtype:F.dtype,en=te.J[et]*eN.NA(F.shape),enqueueWeightsForFetchingFn=()=>{H[$]=!0,null==K[$]&&(K[$]=[]),K[$].push({manifestEntry:F,groupOffset:V,sizeBytes:en})};null!=G?G.forEach(($,V)=>{$===F.name&&(enqueueWeightsForFetchingFn(),Z[V]=!0)}):enqueueWeightsForFetchingFn(),ee.push(F.name),V+=en})}),!Z.every(F=>F)){let F=G.filter((F,$)=>!Z[$]);throw Error(`Could not find weights in manifest with names: ${F.join(", ")}. 
Manifest JSON has weights with names: ${ee.join(", ")}.`)}let et=H.reduce((F,$,V)=>($&&F.push(V),F),[]),en=[];et.forEach(F=>{$[F].paths.forEach(F=>{let $=V+(V.endsWith("/")?"":"/")+F;en.push($)})});let ea=await F(en),ei={},eo=0;return et.forEach(F=>{let V=$[F].paths.length,G=new ey.w(ea.slice(eo,eo+V)),H=K[F];H.forEach(F=>{let $=G.slice(F.groupOffset,F.groupOffset+F.sizeBytes),V=(0,eg.dI)($,[F.manifestEntry]);for(let F in V)ei[F]=V[F]}),eo+=V}),ei}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tt="application/octet-stream",tr="application/json";let HTTPRequest=class HTTPRequest{constructor(F,$){if(this.DEFAULT_METHOD="POST",null==$&&($={}),this.weightPathPrefix=$.weightPathPrefix,this.weightUrlConverter=$.weightUrlConverter,null!=$.fetchFunc?((0,eN.hu)("function"==typeof $.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=$.fetchFunc):this.fetch=(0,ef.OB)().platform.fetch,(0,eN.hu)(null!=F&&F.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(F)&&(0,eN.hu)(2===F.length,()=>`URL paths for http must have a length of 2, (actual length is ${F.length}).`),this.path=F,null!=$.requestInit&&null!=$.requestInit.body)throw Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=$.requestInit||{},this.loadOptions=$}async save(F){if(F.modelTopology instanceof ArrayBuffer)throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let $=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);$.body=new FormData;let V=[{paths:["./model.weights.bin"],weights:F.weightSpecs}],G=(0,eg.Yd)(F,V);if($.body.append("model.json",new Blob([JSON.stringify(G)],{type:tr}),"model.json"),null!=F.weightData){let V=ey.w.join(F.weightData);$.body.append("model.weights.bin",new Blob([V],{type:tt}),"model.weights.bin")}let H=await this.fetch(this.path,$);if(H.ok)return{modelArtifactsInfo:(0,eg.Q)(F),responses:[H]};throw Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${H.status}.`)}async loadModelJSON(){let F;let $=await this.fetch(this.path,this.requestInit);if(!$.ok)throw Error(`Request to ${this.path} failed with status code ${$.status}. Please verify this URL points to the model JSON of the model to load.`);try{F=await $.json()}catch($){let F=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?F+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":F+=" Please make sure the server is serving valid JSON for this request.",Error(F)}let V=F.modelTopology,G=F.weightsManifest;if(null==V&&null==G)throw Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return F}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let F=await this.loadModelJSON();return(0,eg.jN)(F,F=>this.loadWeights(F))}async loadStream(){let F=await this.loadModelJSON(),$=await this.getWeightUrls(F.weightsManifest),V=(0,eg.hu)(F.weightsManifest),stream=()=>streamWeights($,this.loadOptions);return Object.assign(Object.assign({},F),{weightSpecs:V,getWeightStream:stream})}async getWeightUrls(F){let $=Array.isArray(this.path)?this.path[1]:this.path,[V,G]=parseUrl($),H=this.weightPathPrefix||V,K=[],Z=[];for(let $ of F)for(let F of $.paths)null!=this.weightUrlConverter?Z.push(this.weightUrlConverter(F)):K.push(H+F+G);return this.weightUrlConverter&&K.push(...await Promise.all(Z)),K}async loadWeights(F){let $=await this.getWeightUrls(F),V=(0,eg.hu)(F),G=await loadWeightsAsArrayBuffer($,this.loadOptions);return[V,G]}};function parseUrl(F){let $=F.lastIndexOf("/"),V=F.lastIndexOf("?"),G=F.substring(0,$),H=V>$?F.substring(V):"";return[G+"/",H]}function isHTTPScheme(F){return null!=F.match(HTTPRequest.URL_SCHEME_REGEX)}HTTPRequest.URL_SCHEME_REGEX=/^https?:\/\//;let httpRouter=(F,$)=>{if("undefined"==typeof fetch&&(null==$||null==$.fetchFunc));else{let V=!0;if(V=Array.isArray(F)?F.every(F=>isHTTPScheme(F)):isHTTPScheme(F))return http(F,$)}return null};function http(F,$){return new HTTPRequest(F,$)}function browserHTTPRequest(F,$){return http(F,$)}IORouterRegistry.registerSaveRouter(httpRouter),IORouterRegistry.registerLoadRouter(httpRouter);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PassthroughLoader=class PassthroughLoader{constructor(F){this.modelArtifacts=F}load(){return this.modelArtifacts}};let PassthroughSaver=class PassthroughSaver{constructor(F){this.saveHandler=F}save(F){return this.saveHandler(F)}};let PassthroughAsync=class PassthroughAsync{constructor(F){F.load&&(this.load=()=>Promise.resolve(F.load())),F.save&&(this.save=$=>Promise.resolve(F.save($)))}};function fromMemory(F,$,V,G){let H=arguments;return new PassthroughAsync(fromMemorySync(...H))}function fromMemorySync(F,$,V,G){if(1!=arguments.length)return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PassthroughLoader({modelTopology:F,weightSpecs:$,weightData:V,trainingConfig:G});{let $=null!=F.modelTopology||null!=F.weightSpecs;return $?new PassthroughLoader(F):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PassthroughLoader({modelTopology:F}))}}function withSaveHandler(F){return new PassthroughSaver(F)}function withSaveHandlerSync(F){return new PassthroughSaver(F)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var tn=V(43740),ta=V(28687),ti=V(76708),ts=V(2668),tu=V(89065);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function confusionMatrix_(F,$,V){let G=(0,tn._1)(F,"labels","confusionMatrix"),H=(0,tn._1)($,"predictions","confusionMatrix");eN.hu(null==V||V>0&&Number.isInteger(V),()=>`If provided, numClasses must be a positive integer, but got ${V}`),eN.hu(1===G.rank,()=>`Expected the rank of labels to be 1, but got ${G.rank}`),eN.hu(1===H.rank,()=>`Expected the rank of predictions to be 1, but got ${H.rank}`),eN.hu(G.shape[0]===H.shape[0],()=>`Mismatch in the number of examples: ${G.shape[0]} vs. ${H.shape[0]}. Labels and predictions should have the same number of elements.`),eN.hu(V>0&&Number.isInteger(V),()=>`numClasses is required to be a positive integer, but got ${V}`);let K=(0,ti.l)((0,eB.p)(G,"int32"),V),Z=(0,ti.l)((0,eB.p)(H,"int32"),V),ee=(0,tu.p)(K),et=(0,ta.O)(ee,Z);return(0,eB.p)(et,"int32")}let tl=(0,ts.op)({confusionMatrix_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var tc=V(72200),th=V(29121),td=V(26151),tm=V(99906);let tg=!1;function fromPixels_(F,$=3){let V,G;if($>4)throw Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==F)throw Error("pixels passed to tf.browser.fromPixels() can not be null");let H=!1,Z=!1,ee=!1,et=!1,en=!1,ea=!1;if(F.data instanceof Uint8Array)H=!0;else if("undefined"!=typeof ImageData&&F instanceof ImageData)Z=!0;else if("undefined"!=typeof HTMLVideoElement&&F instanceof HTMLVideoElement)ee=!0;else if("undefined"!=typeof HTMLImageElement&&F instanceof HTMLImageElement)et=!0;else if(null!=F.getContext)en=!0;else if("undefined"!=typeof ImageBitmap&&F instanceof ImageBitmap)ea=!0;else throw Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${F.constructor.name}`);let ei=(0,td.pI)(th.eBW,eh.BV.backendName);if(null!=ei){let V={pixels:F},G={numChannels:$};return eh.BV.runKernel(th.eBW,V,G)}let[eo,es]=ee?[F.videoWidth,F.videoHeight]:[F.width,F.height];if(en)V=F.getContext("2d").getImageData(0,0,eo,es).data;else if(Z||H)V=F.data;else if(et||ee||ea){if(null==K){if("undefined"==typeof document){if("undefined"!=typeof OffscreenCanvas&&"undefined"!=typeof OffscreenCanvasRenderingContext2D)K=new OffscreenCanvas(1,1).getContext("2d");else throw Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.")}else K=document.createElement("canvas").getContext("2d",{willReadFrequently:!0})}K.canvas.width=eo,K.canvas.height=es,K.drawImage(F,0,0,eo,es),V=K.getImageData(0,0,eo,es).data}if(4===$)G=new Int32Array(V);else{let F=eo*es;G=new Int32Array(F*$);for(let H=0;H<F;H++)for(let F=0;F<$;++F)G[H*$+F]=V[4*H+F]}let eu=[es,eo,$];return(0,tm.w)(G,eu,"int32")}function isPixelData(F){return null!=F&&F.data instanceof Uint8Array}function isImageBitmapFullySupported(){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")}function isNonEmptyPixels(F){return null!=F&&0!==F.width&&0!==F.height}function canWrapPixelsToImageBitmap(F){return isImageBitmapFullySupported()&&!(F instanceof ImageBitmap)&&isNonEmptyPixels(F)&&!isPixelData(F)}async function fromPixelsAsync(F,$=3){let V=null;if((0,ef.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&canWrapPixelsToImageBitmap(F)){let $;try{$=await createImageBitmap(F,{premultiplyAlpha:"none"})}catch(F){$=null}V=null!=$&&$.width===F.width&&$.height===F.height?$:F}else V=F;return fromPixels_(V,$)}function validateImgTensor(F){if(2!==F.rank&&3!==F.rank)throw Error(`toPixels only supports rank 2 or 3 tensors, got rank ${F.rank}.`);let $=2===F.rank?1:F.shape[2];if($>4||2===$)throw Error(`toPixels only supports depth of size 1, 3 or 4 but got ${$}`);if("float32"!==F.dtype&&"int32"!==F.dtype)throw Error(`Unsupported type for toPixels: ${F.dtype}. Please use float32 or int32 tensors.`)}function validateImageOptions(F){let $=(null==F?void 0:F.alpha)||1;if($>1||$<0)throw Error(`Alpha value ${$} is suppoed to be in range [0 - 1].`)}async function toPixels(F,$){let V=(0,tn._1)(F,"img","toPixels");if(!(F instanceof ez.es)){let F=V;V=(0,eB.p)(F,"int32"),F.dispose()}validateImgTensor(V);let[G,H]=V.shape.slice(0,2),K=2===V.rank?1:V.shape[2],Z=await V.data(),ee="float32"===V.dtype?255:1,et=new Uint8ClampedArray(H*G*4);for(let F=0;F<G*H;++F){let $=[0,0,0,255];for(let G=0;G<K;G++){let H=Z[F*K+G];if("float32"===V.dtype){if(H<0||H>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${H}.`)}else if("int32"===V.dtype&&(H<0||H>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${H}.`);1===K?($[0]=H*ee,$[1]=H*ee,$[2]=H*ee):$[G]=H*ee}let G=4*F;et[G+0]=Math.round($[0]),et[G+1]=Math.round($[1]),et[G+2]=Math.round($[2]),et[G+3]=Math.round($[3])}if(null!=$){if(!tg){let F=(0,td.pI)(th.hGc,eh.BV.backendName);null!=F&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),tg=!0)}$.width=H,$.height=G;let F=$.getContext("2d"),V=new ImageData(et,H,G);F.putImageData(V,0,0)}return V!==F&&V.dispose(),et}function draw(F,$,V){let G=(0,tn._1)(F,"img","draw");if(!(F instanceof ez.es)){let F=G;G=(0,eB.p)(F,"int32"),F.dispose()}validateImgTensor(G),validateImageOptions(null==V?void 0:V.imageOptions);let H={image:G},K={canvas:$,options:V};eh.BV.runKernel(th.hGc,H,K)}let ty=(0,ts.op)({fromPixels_});function prepareAndValidate(F,$){let V=F.shape.length,G=$.shape.length;if(V<1)throw Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${V}.`);if(G<1)throw Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${G}.`);if("int32"!==$.dtype)throw Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${$.dtype}.`);if($.shape[G-1]>V)throw Error(`index innermost dimension length must be <= tensor rank; saw: ${$.shape[G-1]} vs. ${V}`);if(0===(0,eN.NA)(F.shape))throw Error(`Requested more than 0 entries, but input is empty. Input shape: ${F.shape}.`);let H=$.shape,K=H[H.length-1],Z=1;for(let F=0;F<H.length-1;++F)Z*=H[F];let ee=F.shape,et=H.slice();et.pop();let en=1;for(let F=K;F<V;++F)en*=ee[F],et.push(ee[F]);let ea=[...(0,eN.e3)(F.shape).map(F=>F/en),1].slice(0,K);return[et,Z,en,ea]}var tb=V(33028),tv=V(37650),tw=V(80747),tS=V(23418);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let t_=.001,tN=.1;function expectArraysClose(F,$,V){return null==V&&(V=testEpsilon()),expectArraysPredicate(F,$,(F,$)=>areClose(F,$,V))}function testEpsilon(){return 32===eh.BV.backend.floatPrecision()?t_:tN}function expectArraysPredicate(F,$,V){let G=!0;if(((0,tS.isTypedArray)(F)||(0,tS.isTypedArray)($))&&(G=!1),(0,tS.isTypedArray)(F)&&(0,tS.isTypedArray)($)&&(G=!0),G){let V=F.constructor.name,G=$.constructor.name;if(V!==G)throw Error(`Arrays are of different type. Actual: ${V}. Expected: ${G}`)}if(Array.isArray(F)&&Array.isArray($)){let V=(0,tn.C)(F),G=(0,tn.C)($);if(!(0,eN.cO)(V,G))throw Error(`Arrays have different shapes. Actual: [${V}]. Expected: [${G}]`)}let H=(0,tS.isTypedArray)(F)?F:(0,tS.flatten)(F),K=(0,tS.isTypedArray)($)?$:(0,tS.flatten)($);if(H.length!==K.length)throw Error(`Arrays have different lengths actual: ${H.length} vs expected: ${K.length}.
Actual:   ${H}.
Expected: ${K}.`);for(let F=0;F<K.length;++F){let $=H[F],G=K[F];if(!V($,G))throw Error(`Arrays differ: actual[${F}] = ${$}, expected[${F}] = ${G}.
Actual:   ${H}.
Expected: ${K}.`)}"undefined"!=typeof expect&&expect().nothing()}function expectPromiseToFail(F,$){F().then(()=>$.fail(),()=>$()),"undefined"!=typeof expect&&expect().nothing()}function expectArraysEqual(F,$){let V="string"==typeof $||"number"==typeof $||"boolean"==typeof $?[$]:$;return(0,eN.HD)(F)||(0,eN.HD)(F[0])||(0,eN.HD)($)||(0,eN.HD)($[0])?expectArraysPredicate(F,V,(F,$)=>F==$):expectArraysPredicate(F,$,(F,$)=>areClose(F,$,0))}function expectNumbersClose(F,$,V){if(null==V&&(V=testEpsilon()),!areClose(F,$,V))throw Error(`Numbers differ: actual === ${F}, expected === ${$}`);"undefined"!=typeof expect&&expect().nothing()}function areClose(F,$,V){return!(isFinite(F)||isFinite($))||!(isNaN(F)||isNaN($)||Math.abs(F-$)>V)}function expectValuesInRange(F,$,V){for(let G=0;G<F.length;G++)if(F[G]<$||F[G]>V)throw Error(`Value out of range:${F[G]} low: ${$}, high: ${V}`)}function expectArrayBuffersEqual(F,$){let V=new Float32Array(F),G=new Float32Array($);if(V.length!==G.length)throw Error(`Expected ArrayBuffer to be of length ${G.length}, but it was ${V.length}`);for(let F=0;F<G.length;F++)if(V[F]!==G[F])throw Error(`Expected ArrayBuffer value at ${F} to be ${G[F]} but got ${V[F]} instead`)}function encodeStrings(F){for(let $=0;$<F.length;$++){let V=F[$];Array.isArray(V)?encodeStrings(V):F[$]=(0,tS.encodeString)(V)}return F}function createVideoElement(F){let $=document.createElement("video");return"playsInline"in $&&($.playsInline=!0),$.muted=!0,$.loop=!0,$.style.position="fixed",$.style.left="0px",$.style.top="0px",$.preload="auto",$.appendChild(F),new Promise(F=>{$.addEventListener("loadeddata",V=>F($)),$.load()})}async function play(F){await F.play(),"requestVideoFrameCallback"in F&&await new Promise($=>{F.requestVideoFrameCallback($)})}/** @license See the LICENSE file. */let tk="4.15.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OptimizerConstructors=class OptimizerConstructors{static sgd(F){return new SGDOptimizer(F)}static momentum(F,$,V=!1){return new MomentumOptimizer(F,$,V)}static rmsprop(F,$=.9,V=0,G=null,H=!1){return new RMSPropOptimizer(F,$,V,G,H)}static adam(F=.001,$=.9,V=.999,G=null){return new AdamOptimizer(F,$,V,G)}static adadelta(F=.001,$=.95,V=null){return new AdadeltaOptimizer(F,$,V)}static adamax(F=.002,$=.9,V=.999,G=null,H=0){return new AdamaxOptimizer(F,$,V,G,H)}static adagrad(F,$=.1){return new AdagradOptimizer(F,$)}};var tI=V(71221),tT=V(72816),tC=V(49876);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tE=OptimizerConstructors,tA="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:F=>F();function nextFrame(){return new Promise(F=>tA(()=>F()))}var tD=V(83591);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertParamsConsistent(F,$){let V=F[0].length;F.forEach((F,$)=>{eN.hu(F.length===V,()=>`Error in concat${V}D: rank of tensors[${$}] must be the same as the rank of the rest (${V})`)}),eN.hu($>=0&&$<V,()=>`Error in concat${V}D: axis must be between 0 and ${V-1}.`);let G=F[0];F.forEach((F,H)=>{for(let K=0;K<V;K++)eN.hu(K===$||F[K]===G[K],()=>`Error in concat${V}D: Shape of tensors[${H}] (${F}) does not match the shape of the rest (${G}) along the non-concatenated axis ${H}.`)})}function computeOutShape(F,$){let V=F[0].slice();for(let G=1;G<F.length;G++)V[$]+=F[G][$];return V}var tM=V(2582),tR=V(19323);function combineRaggedTensorToTensorShapes(F,$,V){let G=[];if(null==V&&null==$)return G;if(null==$)for(;G.length<F+V.length;)G.push(-1);else G=$.slice();if(null==V)return G;if(F+V.length!==G.length)throw Error(`rt input.shape and shape=${$} are incompatible: rt input.rank = ${F+V.length}, but shape.rank = ${G.length}`);for(let H=1;H<V.length;++H){let K=V[H],Z=G[G.length-V.length+H],ee=G[Z];if(K>=0){if(ee>=0){if(ee!==K)throw Error(`rt input.shape and shape=${$} are incompatible: rt input.shape[${H+F}] = ${K} but shape[${H+F}] = ${ee}`)}else G[Z]=K}}return G}function getRowPartitionTypesHelper(F){let $={FIRST_DIM_SIZE:Z.FIRST_DIM_SIZE,VALUE_ROWIDS:Z.VALUE_ROWIDS,ROW_LENGTHS:Z.ROW_LENGTHS,ROW_SPLITS:Z.ROW_SPLITS,ROW_LIMITS:Z.ROW_LIMITS,ROW_STARTS:Z.ROW_STARTS},V=[];for(let G of F)if(G in $)V.push($[G]);else break;return V}function getRaggedRank(F){return 0===F.length?0:F[0]===Z.FIRST_DIM_SIZE?F.length-1:F.length}function validateDefaultValueShape(F,$){if(null==F||null==$)return;let V=F.length,G=$.length;if(V>=G)throw Error(`defaultValue.shape=${F} and ragged tensor flatValues.shape=${$}, are incompatible: defaultValue.rank = ${V} must be less than ragged tensor input flatValues.rank = ${G})`);for(let H=0;H<Math.min(V,G-1);++H){let V=F[H],G=$[H+1];if(V>=0&&G>=0&&1!==V&&V!==G)throw Error(`defaultValue.shape=${F}, and ragged tensor input flatValues.shape=${$} are incompatible: defaultValue.shape[${H-F.length}] = ${V} but ragged tensor input.flatValues.shape[${H-F.length}] = ${G}`)}}!function(F){F[F.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",F[F.VALUE_ROWIDS=1]="VALUE_ROWIDS",F[F.ROW_LENGTHS=2]="ROW_LENGTHS",F[F.ROW_SPLITS=3]="ROW_SPLITS",F[F.ROW_LIMITS=4]="ROW_LIMITS",F[F.ROW_STARTS=5]="ROW_STARTS"}(Z||(Z={}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tF=30;function computeOptimalWindowSize(F){return F<=tF?F:(0,eN.jP)(F,Math.floor(Math.sqrt(F)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getImageCenter(F,$,V){let G=V*("number"==typeof F?F:F[0]),H=$*("number"==typeof F?F:F[1]);return[G,H]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getReshaped(F,$,V,G=!0){let H=[];if(G)(H=H.concat($.slice(0))).push(F[0]/V),H=H.concat(F.slice(1));else{H=H.concat(F[0]);let V=$.length;for(let G=0;G<V;++G)H=H.concat([F[G+1]/$[G],$[G]]);H=H.concat(F.slice(V+1))}return H}function getPermuted(F,$,V=!0){let G=[];if(V){G.push($);for(let V=$+1;V<F;++V)V<=2*$?(G.push(V),G.push(V-($+1))):G.push(V)}else{let V=[],H=[];for(let G=1;G<F;++G)G>=2*$+1||G%2==1?H.push(G):V.push(G);G.push(...V),G.push(0),G.push(...H)}return G}function getReshapedPermuted(F,$,V,G=!0){let H=[];G?H.push(F[0]/V):H.push(F[0]*V);for(let V=1;V<F.length;++V)V<=$.length?G?H.push($[V-1]*F[V]):H.push(F[V]/$[V-1]):H.push(F[V]);return H}function getSliceBeginCoords(F,$){let V=[0];for(let G=0;G<$;++G)V.push(F[G][0]);return V}function getSliceSize(F,$,V){let G=F.slice(0,1);for(let H=0;H<V;++H)G.push(F[H+1]-$[H][0]-$[H][1]);return G}var tO=V(43179);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tP=.3275911,tB=.254829592,t$=-.284496736,tL=1.421413741,tz=-1.453152027,tV=1.061405429;var tU=V(64706);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mergeRealAndImagArrays(F,$){if(F.length!==$.length)throw Error(`Cannot merge real and imag arrays of different lengths. real:${F.length}, imag: ${$.length}.`);let V=new Float32Array(2*F.length);for(let G=0;G<V.length;G+=2)V[G]=F[G/2],V[G+1]=$[G/2];return V}function splitRealAndImagArrays(F){let $=new Float32Array(F.length/2),V=new Float32Array(F.length/2);for(let G=0;G<F.length;G+=2)$[G/2]=F[G],V[G/2]=F[G+1];return{real:$,imag:V}}function complexWithEvenIndex(F){let $=Math.ceil(F.length/4),V=new Float32Array($),G=new Float32Array($);for(let $=0;$<F.length;$+=4)V[Math.floor($/4)]=F[$],G[Math.floor($/4)]=F[$+1];return{real:V,imag:G}}function complexWithOddIndex(F){let $=Math.floor(F.length/4),V=new Float32Array($),G=new Float32Array($);for(let $=2;$<F.length;$+=4)V[Math.floor($/4)]=F[$],G[Math.floor($/4)]=F[$+1];return{real:V,imag:G}}function getComplexWithIndex(F,$){let V=F[2*$],G=F[2*$+1];return{real:V,imag:G}}function assignToTypedArray(F,$,V,G){F[2*G]=$,F[2*G+1]=V}function exponents(F,$){let V=new Float32Array(F/2),G=new Float32Array(F/2);for(let H=0;H<Math.ceil(F/2);H++){let K=($?2:-2)*Math.PI*(H/F);V[H]=Math.cos(K),G[H]=Math.sin(K)}return{real:V,imag:G}}function exponent(F,$,V){let G=(V?2:-2)*Math.PI*(F/$),H=Math.cos(G),K=Math.sin(G);return{real:H,imag:K}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tW="->",tj=/->/g,tG=",",tq="...";function decodeEinsumEquation(F,$){F=F.replace(/\s/g,"");let V=(F.length-F.replace(tj,"").length)/tW.length;if(V<1)throw Error("Equations without an arrow are not supported.");if(V>1)throw Error(`Equation must contain exactly one arrow ("${tW}").`);let[G,H]=F.split(tW);(0,eN.hu)(-1===G.indexOf(tq),()=>`The ellipsis notation ("${tq}") is not supported yet.`);let K=G.split(tG),Z=K.length;if($!==Z)throw Error(`Expected ${Z} input tensors, received ${$}`);if(Z>2)throw Error("Support for more than 2 input tensors is not implemented yet.");let ee=[];for(let F=0;F<H.length;++F){let $=H[F];if(!K.some(F=>-1!==F.indexOf($)))throw Error(`Output subscripts contain the label ${$} not present in the input subscripts.`);-1===ee.indexOf($)&&ee.push($)}for(let F=0;F<G.length;++F){let $=G[F];-1===ee.indexOf($)&&$!==tG&&ee.push($)}let et=Array(K.length);for(let F=0;F<Z;++F){if(new Set(K[F].split("")).size!==K[F].length)throw Error(`Found duplicate axes in input component ${K[F]}. Support for duplicate axes in input is not implemented yet.`);et[F]=[];for(let $=0;$<K[F].length;++$)et[F].push(ee.indexOf(K[F][$]))}let en=ee.length,ea=H.length,ei=[];for(let F=ea;F<en;++F)ei.push(F);return{allDims:ee,summedDims:ei,idDims:et}}function getEinsumPermutation(F,$){let V=Array(F);V.fill(-1);for(let F=0;F<$.length;++F)V[$[F]]=F;let G=[];for(let $=0;$<F;++$)-1===V[$]&&G.push($);return{permutationIndices:V=V.filter(F=>-1!==F),expandDims:G}}function checkEinsumDimSizes(F,$,V){let G=Array(F);for(let F=0;F<V.length;++F){let H=V[F].shape;for(let V=0;V<$[F].length;++V)void 0===G[$[F][V]]?G[$[F][V]]=H[V]:(0,eN.hu)(G[$[F][V]]===H[V],()=>`Expected dimension ${G[$[F][V]]} at axis ${V} of input shaped ${JSON.stringify(H)}, but got dimension ${H[V]}`)}}function getEinsumComputePath(F,$){let V=F,G=[],H=0;0===F.length&&V.push(-1),H=F.length+1;for(let F=0;F<H;++F)G.push([]);let K=[];for(let F=0;F<V.length;++F){let H=V[F],Z=findTermsWithDim($,H);for(let $ of Z)-1===K.indexOf($)&&(G[F].push($),K.push($))}return{path:V,steps:G}}function isIdentityPermutation(F){return F.every((F,$)=>F===$)}function findTermsWithDim(F,$){let V=[];for(let G=0;G<F.length;++G)(0===F[G].length||-1!==F[G].indexOf($)||-1===$)&&V.push(G);return V}function prepareSplitSize(F,$,V=0){let G=[];if("number"==typeof $)(0,eN.hu)(F.shape[V]%$==0,()=>"Number of splits must evenly divide the axis."),G=Array($).fill(F.shape[V]/$);else{let H=$.reduce((F,$)=>(-1===$&&(F+=1),F),0);(0,eN.hu)(H<=1,()=>"There should be only one negative value in split array.");let K=$.indexOf(-1);if(-1!==K){let G=$.reduce((F,$)=>$>0?F+$:F);$[K]=F.shape[V]-G}(0,eN.hu)(F.shape[V]===$.reduce((F,$)=>F+$),()=>"The sum of sizes must match the size of the axis dimension."),G=$}return G}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getSparseFillEmptyRowsIndicesDenseShapeMismatch(F){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${F}`}function getSparseFillEmptyRowsNegativeIndexErrorMessage(F,$){return`indices(${F}, 0) is invalid: ${$} < 0`}function getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(F,$,V){return`indices(${F}, 0) is invalid: ${$} >= ${V}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(F,$){return`only one output dimension may be -1, not both ${F} and ${$}`}function getSparseReshapeNegativeOutputDimErrorMessage(F,$){return`size ${F} must be non-negative, not ${$}`}function getSparseReshapeEmptyTensorZeroOutputDimErrorMessage(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function getSparseReshapeInputOutputMultipleErrorMessage(F,$){let V=(0,eN.NA)(F),G=(0,eN.NA)($);return`Input to reshape is a SparseTensor with ${V}
  dense values, but the requested shape requires a multiple of ${G}. inputShape=${F} outputShape= ${$}`}function getSparseReshapeInputOutputMismatchErrorMessage(F,$){let V=(0,eN.NA)(F),G=(0,eN.NA)($);return`Input to reshape is a tensor with ${V} dense values, but the requested shape has ${G}. inputShape=${F} outputShape=${$}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getSparseSegmentReductionNegativeSegmentIdsErrorMessage(){return"segment ids must be >= 0"}function getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage(){return"segment ids are not increasing"}function getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(F,$){return`Segment id ${F} out of range [0, ${$}), possibly because segmentIds input is not sorted.`}function getSparseSegmentReductionIndicesOutOfRangeErrorMessage(F,$,V){return`Bad: indices[${F}] == ${$} out of range [0, ${V})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function segOpComputeOptimalWindowSize(F,$){let V,G=!1;for(F<=tF?(V=F,G=!0):V=(0,eN.jP)(F,Math.floor(Math.sqrt(F)));!G;)V>$||V===F?G=!0:V=(0,eN.jP)(F,V+1);return V}function segment_util_computeOutShape(F,$,V){let G=[],H=F.length;for(let K=0;K<H;K++)K!==$?G.push(F[K]):G.push(V);return G}function collectGatherOpShapeInfo(F,$,V,G){let H=$.shape.length,K=F.shape.length;if(0!==G&&(G<-H||G>H))throw Error(`Expect batchDims in the range of [-${H}, ${H}], but got ${G}`);if(G<0&&(G+=H),G>K)throw Error(`batchDims (${G}) must be less than rank(x) (
    ${K}).`);if(V<G)throw Error(`batchDims (${G}) must be less than or equal to axis (${V}).`);for(let V=0;V<G;++V)if(F.shape[V]!==$.shape[V])throw Error(`x.shape[${V}]: ${F.shape[V]} should be equal to indices.shape[${V}]: ${$.shape[V]}.`);let Z=F.shape[V],ee=[],et=1,en=1,ea=1;for(let $=0;$<G;++$)ee.push(F.shape[$]),et*=F.shape[$];for(let $=G;$<V;$++)ee.push(F.shape[$]),en*=F.shape[$];for(let F=G;F<H;F++)ee.push($.shape[F]);for(let $=V+1;$<K;$++)ee.push(F.shape[$]),ea*=F.shape[$];return{batchSize:et,sliceSize:ea,outerSize:en,dimSize:Z,outputShape:ee}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fromUint8ToStringArray(F){try{return F.map(F=>(0,tS.decodeString)(F))}catch(F){throw Error(`Failed to decode encoded string bytes into utf-8, error: ${F}`)}}function fromStringArrayToUint8(F){return F.map(F=>(0,tS.encodeString)(F))}var tH=V(68329),tX=V(48333),tK=V(68713);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */registerOptimizers()},10574:function(F,$,V){"use strict";V.d($,{w:function(){return CompositeArrayBuffer}});var G=V(23418);let CompositeArrayBuffer=class CompositeArrayBuffer{static join(F){return new CompositeArrayBuffer(F).slice()}constructor(F){if(this.shards=[],this.previousShardIndex=0,null==F||(F instanceof Array||(F=[F]),0===(F=F.map(F=>G.isTypedArray(F)?F.buffer:F)).length))return;this.bufferUniformSize=F[0].byteLength;let $=0;for(let V=0;V<F.length;V++){let G=F[V];V!==F.length-1&&G.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let H=$+G.byteLength;this.shards.push({buffer:G,start:$,end:H}),$=H}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(F=0,$=this.byteLength){if(0===this.shards.length||(F=isNaN(Number(F))?0:F,$=isNaN(Number($))?0:$,F=Math.max(0,F),($=Math.min(this.byteLength,$))<=F))return new ArrayBuffer(0);let V=this.findShardForByte(F);if(-1===V)throw Error(`Could not find start shard for byte ${F}`);let G=$-F,H=new ArrayBuffer(G),K=new Uint8Array(H),Z=0;for(let G=V;G<this.shards.length;G++){let V=this.shards[G],H=F+Z,ee=H-V.start,et=Z,en=Math.min($,V.end),ea=en-V.start,ei=new Uint8Array(V.buffer,ee,ea-ee);if(K.set(ei,et),Z+=ei.length,$<V.end)break}return H}findShardForByte(F){if(0===this.shards.length||F<0||F>=this.byteLength)return -1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(F/this.bufferUniformSize),this.previousShardIndex;function check($){return F<$.start?-1:F>=$.end?1:0}if(0===check(this.shards[this.previousShardIndex]))return this.previousShardIndex;let $=search(this.shards,check);return -1===$?-1:(this.previousShardIndex=$,this.previousShardIndex)}};function search(F,$){let V=0,G=F.length;for(;V<=G;){let H=Math.floor((G-V)/2)+V,K=$(F[H]);if(0===K)return H;K<0?G=H:V=H+1}return -1}},91989:function(F,$,V){"use strict";V.d($,{EZ:function(){return basename},JY:function(){return concatenateArrayBuffers},Q:function(){return getModelArtifactsInfoForJSON},Yd:function(){return getModelJSONForModelArtifacts},_n:function(){return arrayBufferToBase64String},dI:function(){return decodeWeights},hu:function(){return getWeightSpecs},jN:function(){return getModelArtifactsForJSON},ji:function(){return getModelArtifactsForJSONSync},n7:function(){return base64StringToArrayBuffer},r:function(){return decodeWeightsStream},yz:function(){return encodeWeights}});var G=V(61661),H=V(10701),K=V(20569),Z=V(75771),ee=V(10574),et=V(4368),en=V(22885),ea=V(21876).Buffer;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ei=4;async function encodeWeights(F,$){let V=[],G=[],H=Array.isArray(F)?F.map(F=>F.name):Object.keys(F);for(let K=0;K<H.length;++K){let Z=H[K],ee=Array.isArray(F)?F[K].tensor:F[Z];if("float32"!==ee.dtype&&"int32"!==ee.dtype&&"bool"!==ee.dtype&&"string"!==ee.dtype&&"complex64"!==ee.dtype)throw Error(`Unsupported dtype in weight '${Z}': ${ee.dtype}`);let et={name:Z,shape:ee.shape,dtype:ee.dtype};if("string"===ee.dtype){let F=new Promise(async F=>{let $=await ee.bytes(),V=$.reduce((F,$)=>F+$.length,0)+ei*$.length,G=new Uint8Array(V),H=0;for(let F=0;F<$.length;F++){let V=$[F],K=new Uint8Array(new Uint32Array([V.length]).buffer);G.set(K,H),H+=ei,G.set(V,H),H+=V.length}F(G)});G.push(F)}else G.push(ee.data());null!=$&&(et.group=$),V.push(et)}let K=await Promise.all(G);return{data:concatenateTypedArrays(K),specs:V}}function decodeWeights(F,$){let V=new ee.w(F),G={},H=0;for(let F of $){let $=getWeightBytelength(F,(F,$)=>V.slice(H+F,H+$));G[F.name]=decodeWeight(F,V.slice(H,H+$)),H+=$}return G}function getWeightBytelength(F,$){let V;let G=(0,K.NA)(F.shape);if("quantization"in F){let $=F.quantization;V=Z.J[$.dtype]}else if("string"===F.dtype){let F=0;for(let V=0;V<G;V++)F+=ei+new Uint32Array($(F,F+ei))[0];return F}else V=Z.J[F.dtype];return G*V}async function getWeightBytelengthAsync(F,$){let V;let G=(0,K.NA)(F.shape);if("quantization"in F){let $=F.quantization;V=Z.J[$.dtype]}else if("string"===F.dtype){let F=0;for(let V=0;V<G;V++)F+=ei+new Uint32Array(await $(F,F+ei))[0];return F}else V=Z.J[F.dtype];return G*V}function decodeWeight(F,$){let V;let ee=F.name,et=F.dtype,en=F.shape,ea=(0,K.NA)(en),eo=0;if("quantization"in F){let G=F.quantization;if("uint8"===G.dtype||"uint16"===G.dtype){if(!("min"in G&&"scale"in G))throw Error(`Weight ${F.name} with quantization ${G.dtype} doesn't have corresponding metadata min and scale.`)}else if("float16"===G.dtype){if("float32"!==et)throw Error(`Weight ${F.name} is quantized with ${G.dtype} which only supports weights of type float32 not ${et}.`)}else throw Error(`Weight ${F.name} has unknown quantization dtype ${G.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let H=Z.J[G.dtype],K="uint8"===G.dtype?new Uint8Array($):new Uint16Array($);if("float32"===et){if("uint8"===G.dtype||"uint16"===G.dtype){V=new Float32Array(K.length);for(let F=0;F<K.length;F++){let $=K[F];V[F]=$*G.scale+G.min}}else if("float16"===G.dtype){let F=getFloat16Decoder();V=F(K)}else throw Error(`Unsupported quantization type ${G.dtype} for weight type float32.`)}else if("int32"===et){if("uint8"!==G.dtype&&"uint16"!==G.dtype)throw Error(`Unsupported quantization type ${G.dtype} for weight type int32.`);V=new Int32Array(K.length);for(let F=0;F<K.length;F++){let $=K[F];V[F]=Math.round($*G.scale+G.min)}}else throw Error(`Unsupported dtype in weight '${ee}': ${et}`);eo+=ea*H}else if("string"===et){let G=(0,K.NA)(F.shape);V=[];for(let F=0;F<G;F++){let F=new Uint32Array($.slice(eo,eo+ei))[0];eo+=ei;let G=new Uint8Array($.slice(eo,eo+F));V.push(G),eo+=F}}else{let F=Z.J[et];if("float32"===et)V=new Float32Array($);else if("int32"===et)V=new Int32Array($);else if("bool"===et)V=new Uint8Array($);else if("complex64"===et){V=new Float32Array($);let F=new Float32Array(V.length/2),K=new Float32Array(V.length/2);for(let $=0;$<F.length;$++)F[$]=V[2*$],K[$]=V[2*$+1];let Z=(0,H.X)(F,en,"float32"),ee=(0,H.X)(K,en,"float32"),et=(0,G.P)(Z,ee);return Z.dispose(),ee.dispose(),et}else throw Error(`Unsupported dtype in weight '${ee}': ${et}`);eo+=ea*F}return(0,H.X)(V,en,et)}async function readToLength(F,$,V){let G=new Uint8Array($);for(;G.byteLength<V;){let{done:$,value:H}=await F.read();if($&&null==H){let F=V-G.byteLength;throw Error(`Reader is done but ${F} bytes are still expected`)}let K=new Uint8Array(G.length+H.byteLength);K.set(G,0),K.set(new Uint8Array(H),G.length),G=K}return G.buffer}async function decodeWeightsStream(F,$){let V={},G=F.getReader(),H=new ArrayBuffer(0);for(let F of $){let $=await getWeightBytelengthAsync(F,async(F,$)=>(H=await readToLength(G,H,$)).slice(F,$));H=await readToLength(G,H,$);let Z=H.slice(0,$);H=H.slice($);let ee=decodeWeight(F,Z);if(V[F.name]=ee,"webgpu"===(0,et.N_)()){let F=(0,et.y3)();"uploadToGPU"in F&&(0,K.NA)(ee.shape)>=(0,en.OB)().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&F.uploadToGPU(ee.dataId)}}return V}function concatenateTypedArrays(F){if(null===F)throw Error(`Invalid input value: ${JSON.stringify(F)}`);let $=0,V=[];F.forEach(F=>{if($+=F.byteLength,V.push(F.byteLength===F.buffer.byteLength?F:new F.constructor(F)),!(F instanceof Float32Array||F instanceof Int32Array||F instanceof Uint8Array))throw Error(`Unsupported TypedArray subtype: ${F.constructor.name}`)});let G=new Uint8Array($),H=0;return V.forEach(F=>{G.set(new Uint8Array(F.buffer),H),H+=F.byteLength}),G.buffer}let eo=void 0!==ea&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function stringByteLength(F){return eo?ea.byteLength(F,"utf8"):new Blob([F]).size}function arrayBufferToBase64String(F){if(eo)return ea.from(F).toString("base64");let $=new Uint8Array(F),V="";for(let F=0,G=$.length;F<G;F++)V+=String.fromCharCode($[F]);return btoa(V)}function base64StringToArrayBuffer(F){if(eo){let $=ea.from(F,"base64");return $.buffer.slice($.byteOffset,$.byteOffset+$.byteLength)}let $=atob(F),V=new Uint8Array($.length);for(let F=0;F<$.length;++F)V.set([$.charCodeAt(F)],F);return V.buffer}function concatenateArrayBuffers(F){return ee.w.join(F)}function basename(F){let $="/";for(F=F.trim();F.endsWith($);)F=F.slice(0,F.length-1);let V=F.split($);return V[V.length-1]}function getModelJSONForModelArtifacts(F,$){let V={modelTopology:F.modelTopology,format:F.format,generatedBy:F.generatedBy,convertedBy:F.convertedBy,weightsManifest:$};return null!=F.signature&&(V.signature=F.signature),null!=F.userDefinedMetadata&&(V.userDefinedMetadata=F.userDefinedMetadata),null!=F.modelInitializer&&(V.modelInitializer=F.modelInitializer),null!=F.initializerSignature&&(V.initializerSignature=F.initializerSignature),null!=F.trainingConfig&&(V.trainingConfig=F.trainingConfig),V}function getModelArtifactsForJSONSync(F,$,V){let G={modelTopology:F.modelTopology,format:F.format,generatedBy:F.generatedBy,convertedBy:F.convertedBy};if(null!=F.trainingConfig&&(G.trainingConfig=F.trainingConfig),null!=F.weightsManifest){if(!$)throw Error("modelJSON has weightsManifest but weightSpecs is null");if(!V)throw Error("modelJSON has weightsManifest but weightData is null");G.weightSpecs=$,G.weightData=V}return null!=F.signature&&(G.signature=F.signature),null!=F.userDefinedMetadata&&(G.userDefinedMetadata=F.userDefinedMetadata),null!=F.modelInitializer&&(G.modelInitializer=F.modelInitializer),null!=F.initializerSignature&&(G.initializerSignature=F.initializerSignature),G}async function getModelArtifactsForJSON(F,$){let V,G;return null!=F.weightsManifest&&([V,G]=await $(F.weightsManifest)),getModelArtifactsForJSONSync(F,V,G)}function getModelArtifactsInfoForJSON(F){if(F.modelTopology instanceof ArrayBuffer)throw Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==F.modelTopology?0:stringByteLength(JSON.stringify(F.modelTopology)),weightSpecsBytes:null==F.weightSpecs?0:stringByteLength(JSON.stringify(F.weightSpecs)),weightDataBytes:null==F.weightData?0:new ee.w(F.weightData).byteLength}}function getWeightSpecs(F){let $=[];for(let V of F)$.push(...V.weights);return $}function computeFloat16MantisaTable(){let convertMantissa=F=>{let $=F<<13,V=0;for(;(8388608&$)==0;)V-=8388608,$<<=1;return($&=-8388609)|(V+=947912704)},F=new Uint32Array(2048);F[0]=0;for(let $=1;$<1024;$++)F[$]=convertMantissa($);for(let $=1024;$<2048;$++)F[$]=939524096+($-1024<<13);return F}function computeFloat16ExponentTable(){let F=new Uint32Array(64);F[0]=0,F[31]=1199570944,F[32]=2147483648,F[63]=3347054592;for(let $=1;$<31;$++)F[$]=$<<23;for(let $=33;$<63;$++)F[$]=2147483648+($-32<<23);return F}function computeFloat16OffsetTable(){let F=new Uint32Array(64);for(let $=0;$<64;$++)F[$]=1024;return F[0]=F[32]=0,F}function getFloat16Decoder(){let F=computeFloat16MantisaTable(),$=computeFloat16ExponentTable(),V=computeFloat16OffsetTable();return G=>{let H=new ArrayBuffer(4*G.length),K=new Uint32Array(H);for(let H=0;H<G.length;H++){let Z=G[H],ee=F[V[Z>>10]+(1023&Z)]+$[Z>>10];K[H]=ee}return new Float32Array(H)}}},75771:function(F,$,V){"use strict";V.d($,{J:function(){return G}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let G={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},29121:function(F,$,V){"use strict";V.d($,{$HU:function(){return rs},$g6:function(){return eJ},$w:function(){return eH},Acj:function(){return tu},BMI:function(){return tF},BiW:function(){return rn},Byc:function(){return e$},CAk:function(){return tv},CQl:function(){return rr},D2d:function(){return rV},DlI:function(){return t7},Eh3:function(){return eE},FKq:function(){return rD},G3Y:function(){return r2},GBy:function(){return rM},Gcp:function(){return rO},HEU:function(){return e2},HZH:function(){return rl},Hhh:function(){return tD},Hmb:function(){return rp},IKK:function(){return en},IMb:function(){return em},J$2:function(){return ty},J7O:function(){return tM},J_u:function(){return th},JhU:function(){return eh},Kgp:function(){return t5},L8s:function(){return rF},Ly9:function(){return eS},M2y:function(){return eo},MIZ:function(){return rZ},MRv:function(){return rA},MZg:function(){return tI},NEP:function(){return e6},NZg:function(){return tG},O3z:function(){return rP},OAf:function(){return tB},OR:function(){return tt},OU7:function(){return t$},OV7:function(){return tP},Omj:function(){return e3},Oyi:function(){return ec},PYm:function(){return tN},PhF:function(){return r_},QCc:function(){return ep},QRR:function(){return eV},Qg5:function(){return tc},QiL:function(){return t4},Qvg:function(){return r6},RFZ:function(){return eN},ROF:function(){return ef},RQH:function(){return rI},RuY:function(){return r9},SIB:function(){return rw},SX0:function(){return e1},SYM:function(){return G},SbG:function(){return rg},SpW:function(){return K},T0n:function(){return eU},TQc:function(){return rR},TR1:function(){return eB},ToN:function(){return r4},Tr8:function(){return rK},Uyb:function(){return te},VGw:function(){return H},Vbg:function(){return tj},VcC:function(){return ez},VfG:function(){return tk},Vn9:function(){return eQ},W0H:function(){return tZ},XDQ:function(){return r5},XLW:function(){return eg},XkS:function(){return rX},Xze:function(){return ee},Y0y:function(){return e9},YFo:function(){return e5},YoZ:function(){return tR},ZbH:function(){return tS},ZjV:function(){return rz},Zz9:function(){return eT},_JP:function(){return rq},_V0:function(){return nr},_Yw:function(){return rh},_k9:function(){return ed},_tC:function(){return rU},a5O:function(){return rE},aJk:function(){return ei},avt:function(){return td},b9H:function(){return ne},bK0:function(){return rW},bV0:function(){return rx},c17:function(){return tV},cWu:function(){return rJ},cie:function(){return eW},cye:function(){return tQ},dDz:function(){return rt},deh:function(){return e7},dpD:function(){return rc},e07:function(){return rb},e0R:function(){return rj},e6w:function(){return ra},e7N:function(){return tw},eBW:function(){return r7},eEB:function(){return e_},eZ0:function(){return tA},ekb:function(){return eK},gJX:function(){return ek},h8e:function(){return r8},hCO:function(){return ew},hGc:function(){return eZ},hdR:function(){return e4},i5y:function(){return rC},iHb:function(){return eL},iJz:function(){return tl},iWB:function(){return tm},iZT:function(){return ts},ik2:function(){return eO},jMg:function(){return eu},jQk:function(){return rG},jQs:function(){return tW},jeX:function(){return tr},kU:function(){return t_},kpP:function(){return r3},kuV:function(){return tH},luS:function(){return nn},lyA:function(){return t6},mKl:function(){return ry},mTV:function(){return tO},mc4:function(){return eP},mhS:function(){return eA},mm_:function(){return Z},n9L:function(){return rY},nhH:function(){return rB},nr8:function(){return rS},o0g:function(){return t8},o2y:function(){return eF},oFR:function(){return rN},oHH:function(){return eY},oT6:function(){return et},p2w:function(){return rk},p4S:function(){return eX},pe_:function(){return t9},q1x:function(){return ti},q2K:function(){return tz},q8u:function(){return tU},qCd:function(){return tC},qIC:function(){return tE},qWM:function(){return tY},qi_:function(){return ta},qkr:function(){return ru},qw7:function(){return es},r7n:function(){return tg},s1s:function(){return rH},sEM:function(){return rQ},sHE:function(){return tn},sJF:function(){return ea},sL$:function(){return ej},usg:function(){return nt},uv1:function(){return tK},vFR:function(){return tL},vtC:function(){return tb},vwp:function(){return e8},w3H:function(){return r$},w6g:function(){return tT},wUP:function(){return eD},wYB:function(){return rT},wYn:function(){return tq},we_:function(){return tJ},wm:function(){return eM},wx7:function(){return r0},x12:function(){return eR},xJR:function(){return ro},xQA:function(){return rv},xnO:function(){return eI},y7R:function(){return eG},yQU:function(){return tX},yj2:function(){return eC},zbQ:function(){return rf},zvY:function(){return eb},zws:function(){return ey}});let G="Abs",H="Acos",K="Acosh",Z="Add",ee="AddN",et="All",en="Any",ea="ArgMax",ei="ArgMin",eo="Asin",es="Asinh",eu="Atan",ec="Atanh",ep="Atan2",eh="AvgPool",ef="AvgPoolGrad",ed="AvgPool3D",em="AvgPool3DGrad",eg="BatchMatMul",ey="BatchToSpaceND",eb="Bincount",ew="BitwiseAnd",eS="BroadcastTo",e_="BroadcastArgs",eN="Cast",ek="Ceil",eI="ClipByValue",eT="Complex",eC="ComplexAbs",eE="Concat",eA="Conv2D",eD="Conv2DBackpropFilter",eM="Conv2DBackpropInput",eR="Conv3D",eF="Conv3DBackpropFilterV2",eO="Conv3DBackpropInputV2",eP="Cos",eB="Cosh",e$="Cumprod",eL="Cumsum",ez="CropAndResize",eV="DenseBincount",eU="DepthToSpace",eW="DepthwiseConv2dNative",ej="DepthwiseConv2dNativeBackpropFilter",eG="DepthwiseConv2dNativeBackpropInput",eH="Diag",eX="Dilation2D",eK="Dilation2DBackpropInput",eQ="Dilation2DBackpropFilter",eZ="Draw",eY="RealDiv",eJ="Einsum",e1="Elu",e2="EluGrad",e3="Erf",e4="Equal",e6="Exp",e5="ExpandDims",e9="Expm1",e8="FFT",e7="Fill",te="FlipLeftRight",tt="Floor",tr="FloorDiv",tn="FusedBatchNorm",ta="GatherV2",ti="GatherNd",ts="Greater",tu="GreaterEqual",tl="Identity",tc="IFFT",th="Imag",td="IsFinite",tm="IsInf",tg="IsNan",ty="LeakyRelu",tb="Less",tv="LessEqual",tw="LinSpace",tS="Log",t_="Log1p",tN="LogicalAnd",tk="LogicalNot",tI="LogicalOr",tT="LogicalXor",tC="LogSoftmax",tE="LowerBound",tA="LRN",tD="LRNGrad",tM="MatrixBandPart",tR="Max",tF="Maximum",tO="MaxPool",tP="MaxPoolGrad",tB="MaxPool3D",t$="MaxPool3DGrad",tL="MaxPoolWithArgmax",tz="Mean",tV="Min",tU="Minimum",tW="MirrorPad",tj="Mod",tG="Multinomial",tq="Multiply",tH="Neg",tX="NotEqual",tK="NonMaxSuppressionV3",tQ="NonMaxSuppressionV4",tZ="NonMaxSuppressionV5",tY="OnesLike",tJ="OneHot",t4="Pack",t6="PadV2",t5="Pool",t9="Pow",t8="Prelu",t7="Prod",rt="RaggedGather",rr="RaggedRange",rn="RaggedTensorToTensor",ra="Range",ro="Real",rs="Reciprocal",ru="Relu",rl="Reshape",rc="ResizeNearestNeighbor",rp="ResizeNearestNeighborGrad",rh="ResizeBilinear",rf="ResizeBilinearGrad",rg="Relu6",ry="Reverse",rb="Round",rx="Rsqrt",rv="ScatterNd",rw="TensorScatterUpdate",rS="SearchSorted",r_="Select",rN="Selu",rk="Slice",rI="Sin",rT="Sinh",rC="Sign",rE="Sigmoid",rA="Softplus",rD="Sqrt",rM="Sum",rR="SpaceToBatchND",rF="SplitV",rO="Softmax",rP="SparseFillEmptyRows",rB="SparseReshape",r$="SparseSegmentMean",rz="SparseSegmentSum",rV="SparseToDense",rU="SquaredDifference",rW="Square",rj="StaticRegexReplace",rG="StridedSlice",rq="StringNGrams",rH="StringSplit",rX="StringToHashBucketFast",rK="Sub",rQ="Tan",rZ="Tanh",rY="Tile",rJ="TopK",r0="Transform",r2="Transpose",r3="Unique",r4="Unpack",r6="UnsortedSegmentSum",r5="UpperBound",r9="ZerosLike",r8="Step",r7="FromPixels",ne="RotateWithOffset",nt="_FusedMatMul",nr="FusedConv2D",nn="FusedDepthwiseConv2D"},26151:function(F,$,V){"use strict";V.d($,{Li:function(){return registerGradient},T3:function(){return copyRegisteredKernels},bt:function(){return unregisterGradient},nE:function(){return unregisterKernel},pI:function(){return getKernel},tr:function(){return getKernelsForBackend},uk:function(){return getGradient},wC:function(){return registerKernel}});var G=V(22885),H=V(55938),K=V(64706);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z=(0,H.R)("kernelRegistry",()=>new Map),ee=(0,H.R)("gradRegistry",()=>new Map);function getKernel(F,$){let V=makeKey(F,$);return Z.get(V)}function getGradient(F){return ee.get(F)}function getKernelsForBackend(F){let $=Z.entries(),V=[];for(;;){let{done:G,value:H}=$.next();if(G)break;let[K,Z]=H,[ee]=K.split("_");ee===F&&V.push(Z)}return V}function registerKernel(F){let{kernelName:$,backendName:V}=F,G=makeKey($,V);Z.has(G)&&K.Z(`The kernel '${$}' for backend '${V}' is already registered`),Z.set(G,F)}function registerGradient(F){let{kernelName:$}=F;ee.has($)&&(0,G.OB)().getBool("DEBUG")&&K.Z(`Overriding the gradient for '${$}'`),ee.set($,F)}function unregisterKernel(F,$){let V=makeKey(F,$);if(!Z.has(V))throw Error(`The kernel '${F}' for backend '${$}' is not registered`);Z.delete(V)}function unregisterGradient(F){if(!ee.has(F))throw Error(`The gradient '${F}' for backend is not registered`);ee.delete(F)}function copyRegisteredKernels(F,$){let V=getKernelsForBackend(F);V.forEach(F=>{let V=Object.assign({},F,{backendName:$});registerKernel(V)})}function makeKey(F,$){return`${$}_${F}`}},64706:function(F,$,V){"use strict";V.d($,{Z:function(){return warn},c:function(){return log}});var G=V(22885);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function warn(...F){(0,G.OB)().getBool("IS_TEST")||(0,G.OB)().getBool("PROD")||console.warn(...F)}function log(...F){(0,G.OB)().getBool("IS_TEST")||(0,G.OB)().getBool("PROD")||console.log(...F)}},96235:function(F,$,V){"use strict";V.d($,{W:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function abs_(F){let $=(0,K._1)(F,"x","abs");if("complex64"===$.dtype){let F={x:$};return G.BV.runKernel(H.yj2,F)}{let F={x:$};return G.BV.runKernel(H.SYM,F)}}let ee=(0,Z.op)({abs_})},17839:function(F,$,V){"use strict";V.d($,{K:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function acos_(F){let $=(0,K._1)(F,"x","acos"),V={x:$};return G.BV.runKernel(H.VGw,V)}let ee=(0,Z.op)({acos_})},91470:function(F,$,V){"use strict";V.d($,{_:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function acosh_(F){let $=(0,K._1)(F,"x","acosh"),V={x:$};return G.BV.runKernel(H.SpW,V)}let ee=(0,Z.op)({acosh_})},56407:function(F,$,V){"use strict";V.d($,{I:function(){return et}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function add_(F,$){let V=(0,Z._1)(F,"a","add"),ee=(0,Z._1)($,"b","add");[V,ee]=(0,K.makeTypesMatch)(V,ee);let et={a:V,b:ee};return G.BV.runKernel(H.mm_,et)}let et=(0,ee.op)({add_})},90781:function(F,$,V){"use strict";V.d($,{$:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function all_(F,$=null,V=!1){let Z=(0,K._1)(F,"x","all","bool"),ee={x:Z},et={axis:$,keepDims:V};return G.BV.runKernel(H.oT6,ee,et)}let ee=(0,Z.op)({all_})},92998:function(F,$,V){"use strict";V.d($,{Y:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function any_(F,$=null,V=!1){let Z=(0,K._1)(F,"x","any","bool"),ee={x:Z},et={axis:$,keepDims:V};return G.BV.runKernel(H.IKK,ee,et)}let ee=(0,Z.op)({any_})},40047:function(F,$,V){"use strict";V.d($,{N:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMax_(F,$=0){let V=(0,K._1)(F,"x","argMax"),Z={x:V},ee={axis:$};return G.BV.runKernel(H.sJF,Z,ee)}let ee=(0,Z.op)({argMax_})},27394:function(F,$,V){"use strict";V.d($,{v:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMin_(F,$=0){let V=(0,K._1)(F,"x","argMin"),Z={x:V},ee={axis:$};return G.BV.runKernel(H.aJk,Z,ee)}let ee=(0,Z.op)({argMin_})},72421:function(F,$,V){"use strict";V.d($,{Z:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function asin_(F){let $=(0,K._1)(F,"x","asin"),V={x:$};return G.BV.runKernel(H.M2y,V)}let ee=(0,Z.op)({asin_})},21891:function(F,$,V){"use strict";V.d($,{V:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function asinh_(F){let $=(0,K._1)(F,"x","asinh"),V={x:$};return G.BV.runKernel(H.qw7,V)}let ee=(0,Z.op)({asinh_})},77037:function(F,$,V){"use strict";V.d($,{z:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function atan_(F){let $=(0,K._1)(F,"x","atan"),V={x:$};return G.BV.runKernel(H.jMg,V)}let ee=(0,Z.op)({atan_})},29812:function(F,$,V){"use strict";V.d($,{f:function(){return et}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function atan2_(F,$){let V=(0,Z._1)(F,"a","atan2"),ee=(0,Z._1)($,"b","atan2");[V,ee]=(0,K.makeTypesMatch)(V,ee);let et={a:V,b:ee};return G.BV.runKernel(H.QCc,et)}let et=(0,ee.op)({atan2_})},80369:function(F,$,V){"use strict";V.d($,{C:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function atanh_(F){let $=(0,K._1)(F,"x","atanh"),V={x:$};return G.BV.runKernel(H.Oyi,V)}let ee=(0,Z.op)({atanh_})},15176:function(F,$,V){"use strict";V.d($,{w:function(){return ei}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(62271),et=V(2582),en=V(2668),ea=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool_(F,$,V,en,ei){let eo=(0,K._1)(F,"x","avgPool","float32"),es=1;Z.hu(et.jT(V,es),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${V} and dilations '${es}'`);let eu=eo,ec=!1;3===eo.rank&&(ec=!0,eu=(0,ea.X)(eo,[1,eo.shape[0],eo.shape[1],eo.shape[2]])),Z.hu(4===eu.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${eu.rank}.`),et.m("avgPool",en,ei);let ep={x:eu},eh={filterSize:$,strides:V,pad:en,dimRoundingMode:ei},ef=G.BV.runKernel(H.JhU,ep,eh);return(ef=(0,ee.p)(ef,eo.dtype),ec)?(0,ea.X)(ef,[ef.shape[1],ef.shape[2],ef.shape[3]]):ef}let ei=(0,en.op)({avgPool_})},83591:function(F,$,V){"use strict";V.d($,{LJ:function(){return getUndoAxesPermutation},Q3:function(){return getAxesPermutation},Vh:function(){return combineLocations},YB:function(){return axesAreInnerMostDims},kz:function(){return computeOutAndReduceShapes},lB:function(){return assertAxesAreInnerMostDims},rv:function(){return expandShapeToKeepDim},sY:function(){return getInnerMostAxes}});var G=V(20569);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function axesAreInnerMostDims(F,$){for(let V=0;V<F.length;++V)if(F[F.length-V-1]!==$-1-V)return!1;return!0}function combineLocations(F,$,V){let G=F.length+$.length,H=[],K=0,Z=0;for(let ee=0;ee<G;ee++)-1===V.indexOf(ee)?H.push(F[K++]):H.push($[Z++]);return H}function computeOutAndReduceShapes(F,$){let V=[],G=F.length;for(let H=0;H<G;H++)-1===$.indexOf(H)&&V.push(F[H]);let H=$.map($=>F[$]);return[V,H]}function expandShapeToKeepDim(F,$){let V=$.map(F=>1);return combineLocations(F,V,$)}function assertAxesAreInnerMostDims(F,$,V){G.hu(axesAreInnerMostDims($,V),()=>`${F} supports only inner-most axes for now. Got axes ${$} and rank-${V} input.`)}function getAxesPermutation(F,$){if(axesAreInnerMostDims(F,$))return null;let V=[];for(let G=0;G<$;++G)-1===F.indexOf(G)&&V.push(G);return F.forEach(F=>V.push(F)),V}function getUndoAxesPermutation(F){return F.map((F,$)=>[$,F]).sort((F,$)=>F[1]-$[1]).map(F=>F[0])}function getInnerMostAxes(F,$){let V=[];for(let G=$-F;G<$;++G)V.push(G);return V}},28441:function(F,$,V){"use strict";V.d($,{E:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchToSpaceND_(F,$,V){let ee=(0,K._1)(F,"x","batchToSpaceND"),et=$.reduce((F,$)=>F*$);Z.hu(ee.rank>=1+$.length,()=>`input rank is ${ee.rank} but should be > than blockShape.length ${$.length}`),Z.hu(V.length===$.length,()=>`crops.length is ${V.length} but should be equal to blockShape.length  ${$.length}`),Z.hu(ee.shape[0]%et==0,()=>`input tensor batch is ${ee.shape[0]} but is not divisible by the product of the elements of blockShape ${$.join(" * ")} === ${et}`);let en={x:ee},ea={blockShape:$,crops:V};return G.BV.runKernel(H.zws,en,ea)}let et=(0,ee.op)({batchToSpaceND_})},40094:function(F,$,V){"use strict";V.d($,{t:function(){return en}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(4968);function xAs4D(F){return 0===F.rank||1===F.rank?(0,ee.X)(F,[1,1,1,F.size]):2===F.rank?(0,ee.X)(F,[1,1,F.shape[0],F.shape[1]]):3===F.rank?(0,ee.X)(F,[1,F.shape[0],F.shape[1],F.shape[2]]):F}var et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchNorm_(F,$,V,et,en,ea){let ei,eo;null==ea&&(ea=.001);let es=(0,K._1)(F,"x","batchNorm"),eu=(0,K._1)($,"mean","batchNorm"),ec=(0,K._1)(V,"variance","batchNorm");null!=en&&(ei=(0,K._1)(en,"scale","batchNorm")),null!=et&&(eo=(0,K._1)(et,"offset","batchNorm")),Z.hu(eu.rank===ec.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Z.hu(null==eo||eu.rank===eo.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Z.hu(null==ei||eu.rank===ei.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let ep=xAs4D(es),eh={x:ep,scale:ei,offset:eo,mean:eu,variance:ec},ef={varianceEpsilon:ea},ed=G.BV.runKernel(H.sHE,eh,ef);return(0,ee.X)(ed,es.shape)}let en=(0,et.op)({batchNorm_})},68247:function(F,$,V){"use strict";V.d($,{U:function(){return ea}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(8723),et=V(2668),en=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function broadcastTo_(F,$){let V=(0,K._1)(F,"broadcastTo","x"),et=V.shape;if((0,Z.Mu)($),$.length<V.rank)throw Error(`broadcastTo(): shape.length=${$.length} < input.rank=${V.rank}.`);if($.length>V.rank){let F=V.shape.slice();for(;F.length<$.length;)F.unshift(1);V=(0,en.X)(V,F)}let ea=V.shape,ei=Array.from($);for(let F=$.length-1;F>=0;F--)if(ea[F]===$[F])ei[F]=1;else if(1!==V.shape[F])throw Error(`broadcastTo(): [${et}] cannot be broadcast to [${$}].`);let eo=ei.map((F,$)=>F>1?$:-1).filter(F=>F>=0);if(0===eo.length)return(0,ee.d)(V);let es={x:V},eu={reps:ei};return G.BV.runKernel(H.n9L,es,eu)}let ea=(0,et.op)({broadcastTo_})},72200:function(F,$,V){"use strict";/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getBroadcastDims(F,$){let V=F.length,G=[];for(let H=0;H<V;H++){let K=V-1-H,Z=F[K]||1,ee=$[$.length-1-H]||1;ee>1&&1===Z&&G.unshift(K)}return G}function getReductionAxes(F,$){let V=[];for(let G=0;G<$.length;G++){let H=F[F.length-G-1],K=$.length-G-1,Z=$[K];(null==H||1===H&&Z>1)&&V.unshift(K)}return V}function assertAndGetBroadcastShape(F,$){let V=Math.max(F.length,$.length),G=Array(V);for(let H=0;H<V;H++){let K=F[F.length-H-1];null==K&&(K=1);let Z=$[$.length-H-1];if(null==Z&&(Z=1),1===K)G[V-H-1]=Z;else if(1===Z)G[V-H-1]=K;else if(K!==Z){let V=`Operands could not be broadcast together with shapes ${F} and ${$}.`;throw Error(V)}else G[V-H-1]=K}return G}V.r($),V.d($,{assertAndGetBroadcastShape:function(){return assertAndGetBroadcastShape},getBroadcastDims:function(){return getBroadcastDims},getReductionAxes:function(){return getReductionAxes}})},72657:function(F,$,V){"use strict";V.d($,{f:function(){return buffer}});var G=V(40974),H=V(20569);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function buffer(F,$="float32",V){return $=$||"float32",H.Mu(F),new G.YD(F,$,V)}},62271:function(F,$,V){"use strict";V.d($,{p:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cast_(F,$){let V=(0,K._1)(F,"x","cast");if(!Z.LP($))throw Error(`Failed to cast to unknown dtype ${$}`);if("string"===$&&"string"!==V.dtype||"string"!==$&&"string"===V.dtype)throw Error("Only strings can be casted to strings");let ee={x:V},et={dtype:$};return G.BV.runKernel(H.RFZ,ee,et)}let et=(0,ee.op)({cast_})},6825:function(F,$,V){"use strict";V.d($,{m:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ceil_(F){let $=(0,K._1)(F,"x","ceil","float32"),V={x:$};return G.BV.runKernel(H.gJX,V)}let ee=(0,Z.op)({ceil_})},42279:function(F,$,V){"use strict";V.d($,{i:function(){return en}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(14006),et=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function clipByValue_(F,$,V){let et=(0,K._1)(F,"x","clipByValue");if(Z.hu($<=V,()=>`Error in clip: min (${$}) must be less than or equal to max (${V}).`),$===V)return(0,ee.h)(et.shape,$,et.dtype);let en={x:et},ea={clipValueMin:$,clipValueMax:V};return G.BV.runKernel(H.xnO,en,ea)}let en=(0,et.op)({clipByValue_})},8723:function(F,$,V){"use strict";V.d($,{d:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function clone_(F){let $=(0,K._1)(F,"x","clone","string_or_numeric"),V={x:$};return G.BV.runKernel(H.iJz,V)}let ee=(0,Z.op)({clone_})},61661:function(F,$,V){"use strict";V.d($,{P:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex_(F,$){let V=(0,K._1)(F,"real","complex"),ee=(0,K._1)($,"imag","complex");Z.k5(V.shape,ee.shape,`real and imag shapes, ${V.shape} and ${ee.shape}, must match in call to tf.complex().`);let et={real:V,imag:ee};return G.BV.runKernel(H.Zz9,et)}let et=(0,ee.op)({complex_})},46884:function(F,$,V){"use strict";V.d($,{z:function(){return en}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(8723),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concat_(F,$=0){(0,Z.hu)(F.length>=1,()=>"Pass at least one tensor to concat");let V=(0,K.sI)(F,"tensors","concat","string_or_numeric");if("complex64"===V[0].dtype&&V.forEach(F=>{if("complex64"!==F.dtype)throw Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${F.dtype}. `)}),1===V.length)return(0,ee.d)(V[0]);let et=V,en={axis:$};return G.BV.runKernel(H.Eh3,et,en)}let en=(0,et.op)({concat_})},11355:function(F,$,V){"use strict";V.d($,{P:function(){return en}});var G=V(43740),H=V(20569),K=V(64794),Z=V(2582),ee=V(2668),et=V(4968);function conv1d_(F,$,V,ee,en="NWC",ea=1,ei){let eo=(0,G._1)(F,"x","conv1d"),es=(0,G._1)($,"filter","conv1d"),eu=eo,ec=!1;2===eo.rank&&(ec=!0,eu=(0,et.X)(eo,[1,eo.shape[0],eo.shape[1]])),H.hu(3===eu.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${eu.rank}.`),H.hu(3===es.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${es.rank}.`),Z.m("conv1d",ee,ei),H.hu(eu.shape[2]===es.shape[1],()=>`Error in conv1d: depth of input (${eu.shape[2]}) must match input depth for filter ${es.shape[1]}.`),H.hu(Z.jT(V,ea),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${V} and dilation '${ea}'`),H.hu(Z.U3(ea),()=>"Error in conv1D: Dilated rates should be larger than 0."),H.hu(Z.U3(V),()=>"Error in conv1D: Stride should be larger than 0."),H.hu("NWC"===en,()=>`Error in conv1d: got dataFormat of ${en} but only NWC is currently supported.`);let ep=(0,et.X)(es,[1,es.shape[0],es.shape[1],es.shape[2]]),eh=(0,et.X)(eu,[eu.shape[0],1,eu.shape[1],eu.shape[2]]),ef=[1,V],ed=[1,ea],em="NHWC",eg=(0,K.T)(eh,ep,ef,ee,em,ed,ei);return ec?(0,et.X)(eg,[eg.shape[2],eg.shape[3]]):(0,et.X)(eg,[eg.shape[0],eg.shape[2],eg.shape[3]])}let en=(0,ee.op)({conv1d_})},64794:function(F,$,V){"use strict";V.d($,{T:function(){return ea}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2582),et=V(2668),en=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2d_(F,$,V,et,ea="NHWC",ei=[1,1],eo){let es=(0,K._1)(F,"x","conv2d","float32"),eu=(0,K._1)($,"filter","conv2d","float32"),ec=es,ep=!1;3===es.rank&&(ep=!0,ec=(0,en.X)(es,[1,es.shape[0],es.shape[1],es.shape[2]])),Z.hu(4===ec.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${ec.rank}.`),Z.hu(4===eu.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${eu.rank}.`),ee.m("conv2d",et,eo);let eh="NHWC"===ea?ec.shape[3]:ec.shape[1];Z.hu(eh===eu.shape[2],()=>`Error in conv2d: depth of input (${eh}) must match input depth for filter ${eu.shape[2]}.`),Z.hu(ee.jT(V,ei),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${V} and dilations '${ei}'`),Z.hu(ee.U3(ei),()=>"Error in conv2D: Dilated rates should be larger than 0."),Z.hu(ee.U3(V),()=>"Error in conv2D: Strides should be larger than 0.");let ef={x:ec,filter:eu},ed={strides:V,pad:et,dataFormat:ea,dilations:ei,dimRoundingMode:eo},em=G.BV.runKernel(H.mhS,ef,ed);return ep?(0,en.X)(em,[em.shape[1],em.shape[2],em.shape[3]]):em}let ea=(0,et.op)({conv2d_})},36013:function(F,$,V){"use strict";V.d($,{p:function(){return en}});var G=V(50196),H=V(29121),K=V(20569),Z=V(2582),ee=V(2668),et=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropFilter_(F,$,V,ee,en,ea="NHWC",ei){let eo=F;3===F.rank&&(eo=(0,et.X)(F,[1,F.shape[0],F.shape[1],F.shape[2]]));let es=$;3===es.rank&&(es=(0,et.X)($,[1,$.shape[0],$.shape[1],$.shape[2]])),K.hu(4===eo.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${eo.shape}.`),K.hu(4===es.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${es.shape}.`),K.hu(4===V.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${V}.`);let eu="NHWC"===ea?eo.shape[3]:eo.shape[1],ec="NHWC"===ea?es.shape[3]:es.shape[1];K.hu(eu===V[2],()=>`Error in conv2dDerFilter: depth of input ${eu}) must match input depth in filter (${V[2]}.`),K.hu(ec===V[3],()=>`Error in conv2dDerFilter: depth of dy (${ec}) must match output depth for filter (${V[3]}).`),Z.m("conv2dDerFilter",en,ei);let ep={x:eo,dy:es},eh={strides:ee,pad:en,dataFormat:ea,dimRoundingMode:ei,filterShape:V};return G.BV.runKernel(H.wUP,ep,eh)}let en=(0,ee.op)({conv2DBackpropFilter_})},39832:function(F,$,V){"use strict";V.d($,{_:function(){return en}});var G=V(50196),H=V(29121),K=V(20569),Z=V(2582),ee=V(2668),et=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropInput_(F,$,V,ee,en,ea="NHWC",ei){K.hu(F.length===$.rank,()=>`Length of inShape (${F.length}) and rank of dy (${$.rank}) must match`);let eo=F,es=$,eu=!1;3===$.rank&&(eu=!0,es=(0,et.X)($,[1,$.shape[0],$.shape[1],$.shape[2]]),eo=[1,F[0],F[1],F[2]]),K.hu(4===eo.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${eo.length}.`),K.hu(4===es.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${es.rank}`),K.hu(4===V.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${V.rank}`);let ec="NHWC"===ea?eo[3]:eo[1],ep="NHWC"===ea?es.shape[3]:es.shape[1];K.hu(ec===V.shape[2],()=>`Error in conv2dDerInput: depth of input (${ec}) must match input depth for filter ${V.shape[2]}.`),K.hu(ep===V.shape[3],()=>`Error in conv2dDerInput: depth of output (${ep}) must match output depth for filter ${V.shape[3]}.`),Z.m("conv2dDerInput",en,ei);let eh={dy:es,filter:V},ef={strides:ee,pad:en,dataFormat:ea,dimRoundingMode:ei,inputShape:eo},ed=G.BV.runKernel(H.wm,eh,ef);return eu?(0,et.X)(ed,[ed.shape[1],ed.shape[2],ed.shape[3]]):ed}let en=(0,ee.op)({conv2DBackpropInput_})},71405:function(F,$,V){"use strict";V.d($,{b:function(){return Z}});var G=V(43740),H=V(39832),K=V(2668);function conv2dTranspose_(F,$,V,K,Z,ee){let et=(0,G._1)(F,"x","conv2dTranspose"),en=(0,G._1)($,"filter","conv2dTranspose");return(0,H._)(V,et,en,K,Z,"NHWC",ee)}let Z=(0,K.op)({conv2dTranspose_})},97594:function(F,$,V){"use strict";V.d($,{_:function(){return et}});var G=V(50196),H=V(29121),K=V(20569),Z=V(2668),ee=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropInput_(F,$,V,Z,et){K.hu(F.length===$.rank,()=>`Length of inShape (${F.length}) and rank of dy (${$.rank}) must match`);let en=F,ea=$,ei=!1;4===$.rank&&(ei=!0,ea=(0,ee.X)($,[1,$.shape[0],$.shape[1],$.shape[2],$.shape[3]]),en=[1,F[0],F[1],F[2],F[3]]);let eo=en[4],es=ea.shape[4];K.hu(5===en.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${en.length}.`),K.hu(5===ea.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${ea.rank}`),K.hu(5===V.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${V.rank}`),K.hu(eo===V.shape[3],()=>`Error in conv3dDerInput: depth of input (${eo}) must match input depth for filter ${V.shape[3]}.`),K.hu(es===V.shape[4],()=>`Error in conv3dDerInput: depth of output (${es}) must match output depth for filter ${V.shape[4]}.`);let eu={dy:ea,filter:V},ec={pad:et,strides:Z,inputShape:en},ep=G.BV.runKernel(H.ik2,eu,ec);return ei?(0,ee.X)(ep,[ep.shape[1],ep.shape[2],ep.shape[3],ep.shape[4]]):ep}let et=(0,Z.op)({conv3DBackpropInput_})},2582:function(F,$,V){"use strict";V.d($,{I0:function(){return tupleValuesAreOne},Ix:function(){return computeConv2DInfo},Rf:function(){return computeDilation2DInfo},U3:function(){return stridesOrDilationsArePositive},Xw:function(){return computePool2DInfo},aO:function(){return computeDefaultPad},jT:function(){return eitherStridesOrDilationsAreOne},jw:function(){return computeConv3DInfo},m:function(){return checkPadOnDimRoundingMode},pl:function(){return computePool3DInfo},sl:function(){return convertConv2DDataFormat}});var G=V(20569);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function computeDilation2DInfo(F,$,V,G,H="NHWC",K){let Z=F[3],ee=[...$,Z],et=convertConv2DDataFormat(H);return computeConv2DInfo(F,ee,V,K,G,null,null,et)}function computePool2DInfo(F,$,V,G,H,K,Z="channelsLast"){let ee;let[et,en]=parseTupleParam($);if("channelsLast"===Z)ee=[et,en,F[3],F[3]];else if("channelsFirst"===Z)ee=[et,en,F[1],F[1]];else throw Error(`Unknown dataFormat ${Z}`);return computeConv2DInfo(F,ee,V,G,H,K,!1,Z)}function computePool3DInfo(F,$,V,G,H,K,Z="NDHWC"){let ee,et;let[en,ea,ei]=parse3TupleParam($);if("NDHWC"===Z)et="channelsLast",ee=[en,ea,ei,F[4],F[4]];else if("NCDHW"===Z)et="channelsFirst",ee=[en,ea,ei,F[1],F[1]];else throw Error(`Unknown dataFormat ${Z}`);return computeConv3DInfo(F,ee,V,G,H,!1,et,K)}function computeConv2DInfo(F,$,V,G,H,K,Z=!1,ee="channelsLast"){let et,[en,ea,ei,eo]=[-1,-1,-1,-1];if("channelsLast"===ee)[en,ea,ei,eo]=F;else if("channelsFirst"===ee)[en,eo,ea,ei]=F;else throw Error(`Unknown dataFormat ${ee}`);let[es,eu,,ec]=$,[ep,eh]=parseTupleParam(V),[ef,ed]=parseTupleParam(G),em=getEffectiveFilterSize(es,ef),eg=getEffectiveFilterSize(eu,ed),{padInfo:ey,outHeight:eb,outWidth:ew}=getPadAndOutInfo(H,ea,ei,ep,eh,em,eg,K,ee),eS=Z?ec*eo:ec;return"channelsFirst"===ee?et=[en,eS,eb,ew]:"channelsLast"===ee&&(et=[en,eb,ew,eS]),{batchSize:en,dataFormat:ee,inHeight:ea,inWidth:ei,inChannels:eo,outHeight:eb,outWidth:ew,outChannels:eS,padInfo:ey,strideHeight:ep,strideWidth:eh,filterHeight:es,filterWidth:eu,effectiveFilterHeight:em,effectiveFilterWidth:eg,dilationHeight:ef,dilationWidth:ed,inShape:F,outShape:et,filterShape:$}}function computeConv3DInfo(F,$,V,G,H,K=!1,Z="channelsLast",ee){let et,[en,ea,ei,eo,es]=[-1,-1,-1,-1,-1];if("channelsLast"===Z)[en,ea,ei,eo,es]=F;else if("channelsFirst"===Z)[en,es,ea,ei,eo]=F;else throw Error(`Unknown dataFormat ${Z}`);let[eu,ec,ep,,eh]=$,[ef,ed,em]=parse3TupleParam(V),[eg,ey,eb]=parse3TupleParam(G),ew=getEffectiveFilterSize(eu,eg),eS=getEffectiveFilterSize(ec,ey),e_=getEffectiveFilterSize(ep,eb),{padInfo:eN,outDepth:ek,outHeight:eI,outWidth:eT}=get3DPadAndOutInfo(H,ea,ei,eo,ef,ed,em,ew,eS,e_,ee),eC=K?eh*es:eh;return"channelsFirst"===Z?et=[en,eC,ek,eI,eT]:"channelsLast"===Z&&(et=[en,ek,eI,eT,eC]),{batchSize:en,dataFormat:Z,inDepth:ea,inHeight:ei,inWidth:eo,inChannels:es,outDepth:ek,outHeight:eI,outWidth:eT,outChannels:eC,padInfo:eN,strideDepth:ef,strideHeight:ed,strideWidth:em,filterDepth:eu,filterHeight:ec,filterWidth:ep,effectiveFilterDepth:ew,effectiveFilterHeight:eS,effectiveFilterWidth:e_,dilationDepth:eg,dilationHeight:ey,dilationWidth:eb,inShape:F,outShape:et,filterShape:$}}function computeOutputShape2D(F,$,V,G,H){null==G&&(G=computeDefaultPad(F,$,V));let K=F[0],Z=F[1],ee=round((K-$+2*G)/V+1,H),et=round((Z-$+2*G)/V+1,H);return[ee,et]}function computeOutputShape4D(F,$,V,G,H,K){null==H&&(H=computeDefaultPad(F,$[0],G[0]));let Z=[0,0,0,V];for(let V=0;V<3;V++)F[V]+2*H>=$[V]&&(Z[V]=round((F[V]-$[V]+2*H)/G[V]+1,K));return Z}function computeDefaultPad(F,$,V,G=1){let H=getEffectiveFilterSize($,G);return Math.floor((F[0]*(V-1)-V+H)/2)}function parseTupleParam(F){return"number"==typeof F?[F,F,F]:2===F.length?[F[0],F[1],1]:F}function parse3TupleParam(F){return"number"==typeof F?[F,F,F]:F}function getEffectiveFilterSize(F,$){return $<=1?F:F+(F-1)*($-1)}function getPadAndOutInfo(F,$,V,G,H,K,Z,ee,et){let en,ea,ei;if("number"==typeof F){let H=0===F?"VALID":"NUMBER";en={top:F,bottom:F,left:F,right:F,type:H};let Z=computeOutputShape2D([$,V],K,G,F,ee);ea=Z[0],ei=Z[1]}else if("same"===F){ea=Math.ceil($/G),ei=Math.ceil(V/H);let F=Math.max(0,(ea-1)*G+K-$),ee=Math.max(0,(ei-1)*H+Z-V),et=Math.floor(F/2),eo=F-et,es=Math.floor(ee/2),eu=ee-es;en={top:et,bottom:eo,left:es,right:eu,type:"SAME"}}else if("valid"===F)en={top:0,bottom:0,left:0,right:0,type:"VALID"},ea=Math.ceil(($-K+1)/G),ei=Math.ceil((V-Z+1)/H);else if("object"==typeof F){let eo="channelsLast"===et?F[1][0]:F[2][0],es="channelsLast"===et?F[1][1]:F[2][1],eu="channelsLast"===et?F[2][0]:F[3][0],ec="channelsLast"===et?F[2][1]:F[3][1],ep=0===eo&&0===es&&0===eu&&0===ec?"VALID":"EXPLICIT";en={top:eo,bottom:es,left:eu,right:ec,type:ep},ea=round(($-K+eo+es)/G+1,ee),ei=round((V-Z+eu+ec)/H+1,ee)}else throw Error(`Unknown padding parameter: ${F}`);return{padInfo:en,outHeight:ea,outWidth:ei}}function get3DPadAndOutInfo(F,$,V,G,H,K,Z,ee,et,en,ea){let ei,eo,es,eu;if("valid"===F&&(F=0),"number"==typeof F){let ec=0===F?"VALID":"NUMBER";ei={top:F,bottom:F,left:F,right:F,front:F,back:F,type:ec};let ep=computeOutputShape4D([$,V,G,1],[ee,et,en],1,[H,K,Z],F,ea);eo=ep[0],es=ep[1],eu=ep[2]}else if("same"===F){eo=Math.ceil($/H),es=Math.ceil(V/K),eu=Math.ceil(G/Z);let F=(eo-1)*H+ee-$,ea=(es-1)*K+et-V,ec=(eu-1)*Z+en-G,ep=Math.floor(F/2),eh=F-ep,ef=Math.floor(ea/2),ed=ea-ef,em=Math.floor(ec/2),eg=ec-em;ei={top:ef,bottom:ed,left:em,right:eg,front:ep,back:eh,type:"SAME"}}else throw Error(`Unknown padding parameter: ${F}`);return{padInfo:ei,outDepth:eo,outHeight:es,outWidth:eu}}function round(F,$){if(!$)return Math.trunc(F);switch($){case"round":return Math.round(F);case"ceil":return Math.ceil(F);case"floor":return Math.floor(F);default:throw Error(`Unknown roundingMode ${$}`)}}function tupleValuesAreOne(F){let[$,V,G]=parseTupleParam(F);return 1===$&&1===V&&1===G}function eitherStridesOrDilationsAreOne(F,$){return tupleValuesAreOne(F)||tupleValuesAreOne($)}function stridesOrDilationsArePositive(F){return parseTupleParam(F).every(F=>F>0)}function convertConv2DDataFormat(F){if("NHWC"===F)return"channelsLast";if("NCHW"===F)return"channelsFirst";throw Error(`Unknown dataFormat ${F}`)}function checkPadOnDimRoundingMode(F,$,V){if(null!=V){if("string"==typeof $)throw Error(`Error in ${F}: pad must be an integer when using dimRoundingMode ${V} but got pad ${$}.`);if("number"==typeof $)G.hu(G.GN($),()=>`Error in ${F}: pad must be an integer when using dimRoundingMode ${V} but got pad ${$}.`);else if("object"==typeof $)$.forEach($=>{$.forEach($=>{G.hu(G.GN($),()=>`Error in ${F}: pad must be an integer when using dimRoundingMode ${V} but got pad ${$}.`)})});else throw Error(`Error in ${F}: Unknown padding parameter: ${$}`)}}},70173:function(F,$,V){"use strict";V.d($,{m:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cos_(F){let $=(0,K._1)(F,"x","cos","float32"),V={x:$};return G.BV.runKernel(H.mc4,V)}let ee=(0,Z.op)({cos_})},2699:function(F,$,V){"use strict";V.d($,{f:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cosh_(F){let $=(0,K._1)(F,"x","cosh","float32"),V={x:$};return G.BV.runKernel(H.TR1,V)}let ee=(0,Z.op)({cosh_})},9640:function(F,$,V){"use strict";V.d($,{$:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumprod_(F,$=0,V=!1,Z=!1){let ee=(0,K._1)(F,"x","cumprod"),et={x:ee},en={axis:$,exclusive:V,reverse:Z};return G.BV.runKernel(H.Byc,et,en)}let ee=(0,Z.op)({cumprod_})},37405:function(F,$,V){"use strict";V.d($,{z:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumsum_(F,$=0,V=!1,Z=!1){let ee=(0,K._1)(F,"x","cumsum"),et={x:ee},en={axis:$,exclusive:V,reverse:Z};return G.BV.runKernel(H.iHb,et,en)}let ee=(0,Z.op)({cumsum_})},89112:function(F,$,V){"use strict";V.d($,{n:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthToSpace_(F,$,V="NHWC"){let ee=(0,K._1)(F,"x","depthToSpace","float32"),et="NHWC"===V?ee.shape[1]:ee.shape[2],en="NHWC"===V?ee.shape[2]:ee.shape[3],ea="NHWC"===V?ee.shape[3]:ee.shape[1];Z.hu($>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${$}`),Z.hu(et*$>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${et} and ${$}  for depthToSpace with input shape
    ${ee.shape}`),Z.hu(en*$>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${en} and ${$} for depthToSpace with input shape
        ${ee.shape}`),Z.hu(ea%($*$)==0,()=>`Dimension size must be evenly divisible by ${$*$} but is ${ea} for depthToSpace with input shape ${ee.shape}`);let ei={x:ee},eo={blockSize:$,dataFormat:V};return G.BV.runKernel(H.T0n,ei,eo)}let et=(0,ee.op)({depthToSpace_})},64718:function(F,$,V){"use strict";V.d($,{B:function(){return ea}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2582),et=V(2668),en=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2d_(F,$,V,et,ea="NHWC",ei=[1,1],eo){let es=(0,K._1)(F,"x","depthwiseConv2d","float32"),eu=(0,K._1)($,"filter","depthwiseConv2d","float32"),ec=es,ep=!1;3===es.rank&&(ep=!0,ec=(0,en.X)(es,[1,es.shape[0],es.shape[1],es.shape[2]])),Z.hu(4===ec.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${ec.rank}.`),Z.hu(4===eu.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${eu.rank}.`);let eh="NHWC"===ea?ec.shape[3]:ec.shape[1];Z.hu(eh===eu.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${eh}) must match the inChannels dimension in filter ${eu.shape[2]}.`),ee.m("depthwiseConv2d",et,eo);let ef={x:ec,filter:eu},ed={strides:V,pad:et,dataFormat:ea,dilations:ei,dimRoundingMode:eo},em=G.BV.runKernel(H.cie,ef,ed);return ep?(0,en.X)(em,[em.shape[1],em.shape[2],em.shape[3]]):em}let ea=(0,et.op)({depthwiseConv2d_})},88098:function(F,$,V){"use strict";V.d($,{z:function(){return ee}});var G=V(50196),H=V(29121),K=V(2668),Z=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropFilter_(F,$,V,K,ee,et=[1,1],en){let ea=F;3===F.rank&&(ea=(0,Z.X)(F,[1,F.shape[0],F.shape[1],F.shape[2]]));let ei=$;3===ei.rank&&(ei=(0,Z.X)($,[1,$.shape[0],$.shape[1],$.shape[2]]));let eo={x:ea,dy:ei},es={strides:K,pad:ee,dimRoundingMode:en,dilations:et,filterShape:V};return G.BV.runKernel(H.sL$,eo,es)}let ee=(0,K.op)({depthwiseConv2dNativeBackpropFilter_})},54375:function(F,$,V){"use strict";V.d($,{v:function(){return ee}});var G=V(50196),H=V(29121),K=V(2668),Z=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropInput_(F,$,V,K,ee,et=[1,1],en){let ea=$,ei=!1;3===$.rank&&(ei=!0,ea=(0,Z.X)($,[1,$.shape[0],$.shape[1],$.shape[2]]));let eo={dy:ea,filter:V},es={strides:K,pad:ee,dimRoundingMode:en,dilations:et,inputShape:F},eu=G.BV.runKernel(H.y7R,eo,es);return ei?(0,Z.X)(eu,[eu.shape[1],eu.shape[2],eu.shape[3]]):eu}let ee=(0,K.op)({depthwiseConv2dNativeBackpropInput_})},70557:function(F,$,V){"use strict";V.d($,{W:function(){return en}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668),et=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dilation2d_(F,$,V,ee,en=[1,1],ea="NHWC"){let ei=(0,K._1)(F,"x","dilation2d"),eo=(0,K._1)($,"filter","dilation2d");Z.hu(3===ei.rank||4===ei.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${ei.rank}.`),Z.hu(3===eo.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${eo.rank}.`),Z.hu("NHWC"===ea,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${ea}`);let es=ei,eu=!1;3===ei.rank&&(es=(0,et.X)(ei,[1,ei.shape[0],ei.shape[1],ei.shape[2]]),eu=!0),Z.hu(es.shape[3]===eo.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${es.shape[3]} vs ${eo.shape[2]}`);let ec={x:es,filter:eo},ep={strides:V,pad:ee,dilations:en},eh=G.BV.runKernel(H.p4S,ec,ep);return eu?(0,et.X)(eh,[eh.shape[1],eh.shape[2],eh.shape[3]]):eh}let en=(0,ee.op)({dilation2d_})},41274:function(F,$,V){"use strict";V.d($,{h:function(){return en}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(9165),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function div_(F,$){let V=(0,Z._1)(F,"a","div"),et=(0,Z._1)($,"b","div");if([V,et]=(0,K.makeTypesMatch)(V,et),"int32"===V.dtype&&"int32"===et.dtype)return(0,ee.q)(V,et);let en={a:V,b:et},ea={};return G.BV.runKernel(H.oHH,en,ea)}let en=(0,et.op)({div_})},49322:function(F,$,V){"use strict";V.d($,{N:function(){return ea}});var G=V(80747),H=V(43740),K=V(41274),Z=V(26477),ee=V(2668),et=V(95912),en=V(6577);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function divNoNan_(F,$){let V=(0,H._1)(F,"a","div"),ee=(0,H._1)($,"b","div");[V,ee]=(0,G.makeTypesMatch)(V,ee);let ea=(0,K.h)(V,ee),ei=(0,en.P)(ea),eo=(0,Z.D)(ee,ei);return(0,et.a)(eo,ei,ea)}let ea=(0,ee.op)({divNoNan_})},30548:function(F,$,V){"use strict";V.d($,{A:function(){return et}});var G=V(43740),H=V(20569),K=V(28687),Z=V(2668),ee=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dot_(F,$){let V=(0,G._1)(F,"t1","dot"),Z=(0,G._1)($,"t2","dot");H.hu((1===V.rank||2===V.rank)&&(1===Z.rank||2===Z.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${V.rank} and ${Z.rank}.`);let et=1===V.rank?V.size:V.shape[1],en=1===Z.rank?Z.size:Z.shape[0];if(H.hu(et===en,()=>`Error in dot: inner dimensions of inputs must match, but got ${et} and ${en}.`),1===V.rank&&1===Z.rank){let F=(0,ee.X)(V,[1,-1]),$=(0,ee.X)(Z,[-1,1]),G=(0,K.O)(F,$);return(0,ee.X)(G,[])}if(1===V.rank&&2===Z.rank){let F=(0,ee.X)(V,[1,-1]),$=(0,ee.X)(Z,[Z.shape[0],Z.shape[1]]),G=(0,K.O)(F,$);return(0,ee.X)(G,[G.size])}if(2===V.rank&&1===Z.rank){let F=(0,ee.X)(Z,[-1,1]),$=(0,K.O)(V,F);return(0,ee.X)($,[$.size])}{let F=(0,ee.X)(Z,[Z.shape[0],Z.shape[1]]),$=(0,K.O)(V,F);return $}}let et=(0,Z.op)({dot_})},83233:function(F,$,V){"use strict";V.d($,{p:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function elu_(F){let $=(0,K._1)(F,"x","elu","float32"),V={x:$};return G.BV.runKernel(H.SX0,V)}let ee=(0,Z.op)({elu_})},26477:function(F,$,V){"use strict";V.d($,{D:function(){return en}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(72200),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function equal_(F,$){let V=(0,Z._1)(F,"a","equal","string_or_numeric"),et=(0,Z._1)($,"b","equal","string_or_numeric");[V,et]=(0,K.makeTypesMatch)(V,et),(0,ee.assertAndGetBroadcastShape)(V.shape,et.shape);let en={a:V,b:et};return G.BV.runKernel(H.hdR,en)}let en=(0,et.op)({equal_})},34650:function(F,$,V){"use strict";V.d($,{q:function(){return en}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(62271),et=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function erf_(F){let $=(0,K._1)(F,"x","erf");Z.hu("int32"===$.dtype||"float32"===$.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===$.dtype&&($=(0,ee.p)($,"float32"));let V={x:$};return G.BV.runKernel(H.Omj,V)}let en=(0,et.op)({erf_})},31954:function(F,$,V){"use strict";V.d($,{d:function(){return K}});var G=V(3561),H=V(2668);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function euclideanNorm_(F,$=null,V=!1){return(0,G.K)(F,"euclidean",$,V)}let K=(0,H.op)({euclideanNorm_})},44842:function(F,$,V){"use strict";V.d($,{Q:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function exp_(F){let $=(0,K._1)(F,"x","exp"),V={x:$};return G.BV.runKernel(H.NEP,V)}let ee=(0,Z.op)({exp_})},81300:function(F,$,V){"use strict";V.d($,{d:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expandDims_(F,$=0){let V=(0,K._1)(F,"x","expandDims","string_or_numeric");Z.hu($<=V.rank,()=>"Axis must be <= rank of the tensor");let ee={input:V},et={dim:$};return G.BV.runKernel(H.YFo,ee,et)}let et=(0,ee.op)({expandDims_})},53426:function(F,$,V){"use strict";V.d($,{t:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expm1_(F){let $=(0,K._1)(F,"x","expm1"),V={x:$};return G.BV.runKernel(H.Y0y,V)}let ee=(0,Z.op)({expm1_})},14006:function(F,$,V){"use strict";V.d($,{h:function(){return fill}});var G=V(50196),H=V(29121),K=V(20569);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill(F,$,V){(0,K.Mu)(F),V=V||(0,K.D2)($);let Z={shape:F,value:$,dtype:V};return G.BV.runKernel(H.deh,{},Z)}},26943:function(F,$,V){"use strict";V.d($,{G:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function floor_(F){let $=(0,K._1)(F,"x","floor","float32"),V={x:$};return G.BV.runKernel(H.OR,V)}let ee=(0,Z.op)({floor_})},9165:function(F,$,V){"use strict";V.d($,{q:function(){return et}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function floorDiv_(F,$){let V=(0,Z._1)(F,"a","floorDiv"),ee=(0,Z._1)($,"b","floorDiv");[V,ee]=(0,K.makeTypesMatch)(V,ee);let et={a:V,b:ee};return G.BV.runKernel(H.jeX,et)}let et=(0,ee.op)({floorDiv_})},19323:function(F,$,V){"use strict";V.d($,{Fr:function(){return getFusedDyActivation},QH:function(){return applyActivation},pf:function(){return getFusedBiasGradient},uy:function(){return shouldFuse}});var G=V(72200),H=V(83233),K=V(99133),Z=V(24841),ee=V(98151),et=V(7409),en=V(83582),ea=V(4968),ei=V(30625),eo=V(71901),es=V(15475);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getFusedDyActivation(F,$,V){if(null==V||"linear"===V)return F;if("relu"===V)return(0,Z.d)(F,(0,eo.N)($));throw Error(`Cannot compute gradient for fused activation ${V}.`)}function getFusedBiasGradient(F,$){let V=$,H=G.getReductionAxes(F.shape,$.shape);return H.length>0&&(V=(0,es.S)(V,H)),(0,ea.X)(V,F.shape)}function applyActivation(F,$,V,G){if("linear"===$)return F;if("relu"===$)return(0,et.U)(F);if("elu"===$)return(0,H.p)(F);if("relu6"===$)return(0,en.b)(F);if("prelu"===$)return(0,ee.A)(F,V);if("leakyrelu"===$)return(0,K.h)(F,G);if("sigmoid"===$)return(0,ei.X)(F);throw Error(`Unknown fused activation ${$}.`)}let shouldFuse=(F,$)=>{let V=F>0;return!V||"linear"===$}},24926:function(F,$,V){"use strict";V.d($,{I:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gather_(F,$,V=0,Z=0){let ee=(0,K._1)(F,"x","gather"),et=(0,K._1)($,"indices","gather","int32"),en={x:ee,indices:et},ea={axis:V,batchDims:Z};return G.BV.runKernel(H.qi_,en,ea)}let ee=(0,Z.op)({gather_})},20636:function(F,$,V){"use strict";V.d($,{p:function(){return en}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(72200),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function greater_(F,$){let V=(0,Z._1)(F,"a","greater","string_or_numeric"),et=(0,Z._1)($,"b","greater","string_or_numeric");[V,et]=(0,K.makeTypesMatch)(V,et),(0,ee.assertAndGetBroadcastShape)(V.shape,et.shape);let en={a:V,b:et};return G.BV.runKernel(H.iZT,en)}let en=(0,et.op)({greater_})},17630:function(F,$,V){"use strict";V.d($,{b:function(){return en}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(72200),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function greaterEqual_(F,$){let V=(0,Z._1)(F,"a","greaterEqual","string_or_numeric"),et=(0,Z._1)($,"b","greaterEqual","string_or_numeric");[V,et]=(0,K.makeTypesMatch)(V,et),(0,ee.assertAndGetBroadcastShape)(V.shape,et.shape);let en={a:V,b:et};return G.BV.runKernel(H.Acj,en)}let en=(0,et.op)({greaterEqual_})},64386:function(F,$,V){"use strict";V.d($,{a:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag_(F){let $=(0,K._1)(F,"input","imag"),V={input:$};return G.BV.runKernel(H.J_u,V)}let ee=(0,Z.op)({imag_})},13305:function(F,$,V){"use strict";V.d($,{I:function(){return en}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668),et=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeBilinear_(F,$,V=!1,ee=!1){let en=(0,K._1)(F,"images","resizeBilinear");Z.hu(3===en.rank||4===en.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${en.rank}.`),Z.hu(2===$.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${$}.`),Z.hu(!1===ee||!1===V,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let ea=en,ei=!1;3===en.rank&&(ei=!0,ea=(0,et.X)(en,[1,en.shape[0],en.shape[1],en.shape[2]]));let[]=$,eo={images:ea},es={alignCorners:V,halfPixelCenters:ee,size:$},eu=G.BV.runKernel(H._Yw,eo,es);return ei?(0,et.X)(eu,[eu.shape[1],eu.shape[2],eu.shape[3]]):eu}let en=(0,ee.op)({resizeBilinear_})},95098:function(F,$,V){"use strict";V.d($,{j:function(){return en}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668),et=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeNearestNeighbor_(F,$,V=!1,ee=!1){let en=(0,K._1)(F,"images","resizeNearestNeighbor");Z.hu(3===en.rank||4===en.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${en.rank}.`),Z.hu(2===$.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${$}.`),Z.hu("float32"===en.dtype||"int32"===en.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Z.hu(!1===ee||!1===V,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let ea=en,ei=!1;3===en.rank&&(ei=!0,ea=(0,et.X)(en,[1,en.shape[0],en.shape[1],en.shape[2]]));let[]=$,eo={images:ea},es={alignCorners:V,halfPixelCenters:ee,size:$},eu=G.BV.runKernel(H.dpD,eo,es);return ei?(0,et.X)(eu,[eu.shape[1],eu.shape[2],eu.shape[3]]):eu}let en=(0,ee.op)({resizeNearestNeighbor_})},13963:function(F,$,V){"use strict";V.d($,{x:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isFinite_(F){let $=(0,K._1)(F,"x","isFinite"),V={x:$};return G.BV.runKernel(H.avt,V)}let ee=(0,Z.op)({isFinite_})},4365:function(F,$,V){"use strict";V.d($,{U:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isInf_(F){let $=(0,K._1)(F,"x","isInf"),V={x:$};return G.BV.runKernel(H.iWB,V)}let ee=(0,Z.op)({isInf_})},96230:function(F,$,V){"use strict";V.d($,{i:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isNaN_(F){let $=(0,K._1)(F,"x","isNaN"),V={x:$};return G.BV.runKernel(H.r7n,V)}let ee=(0,Z.op)({isNaN_})},99133:function(F,$,V){"use strict";V.d($,{h:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function leakyRelu_(F,$=.2){let V=(0,K._1)(F,"x","leakyRelu"),Z={x:V},ee={alpha:$};return G.BV.runKernel(H.J$2,Z,ee)}let ee=(0,Z.op)({leakyRelu_})},86573:function(F,$,V){"use strict";V.d($,{d:function(){return en}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(72200),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function less_(F,$){let V=(0,Z._1)(F,"a","less","string_or_numeric"),et=(0,Z._1)($,"b","less","string_or_numeric");[V,et]=(0,K.makeTypesMatch)(V,et),(0,ee.assertAndGetBroadcastShape)(V.shape,et.shape);let en={a:V,b:et};return G.BV.runKernel(H.vtC,en)}let en=(0,et.op)({less_})},50624:function(F,$,V){"use strict";V.d($,{z:function(){return en}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(72200),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lessEqual_(F,$){let V=(0,Z._1)(F,"a","lessEqual","string_or_numeric"),et=(0,Z._1)($,"b","lessEqual","string_or_numeric");[V,et]=(0,K.makeTypesMatch)(V,et),(0,ee.assertAndGetBroadcastShape)(V.shape,et.shape);let en={a:V,b:et};return G.BV.runKernel(H.CAk,en)}let en=(0,et.op)({lessEqual_})},79648:function(F,$,V){"use strict";V.d($,{G:function(){return en}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668),et=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function localResponseNormalization_(F,$=5,V=1,ee=1,en=.5){let ea=(0,K._1)(F,"x","localResponseNormalization");Z.hu(4===ea.rank||3===ea.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${ea.rank}.`),Z.hu(Z.GN($),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${$}.`);let ei=ea,eo=!1;3===ea.rank&&(eo=!0,ei=(0,et.X)(ea,[1,ea.shape[0],ea.shape[1],ea.shape[2]]));let es={x:ei},eu={depthRadius:$,bias:V,alpha:ee,beta:en},ec=G.BV.runKernel(H.eZ0,es,eu);return eo?(0,et.X)(ec,[ec.shape[1],ec.shape[2],ec.shape[3]]):ec}let en=(0,ee.op)({localResponseNormalization_})},82597:function(F,$,V){"use strict";V.d($,{c:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function log_(F){let $=(0,K._1)(F,"x","log","float32"),V={x:$};return G.BV.runKernel(H.ZbH,V)}let ee=(0,Z.op)({log_})},17474:function(F,$,V){"use strict";V.d($,{K:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function log1p_(F){let $=(0,K._1)(F,"x","log1p"),V={x:$};return G.BV.runKernel(H.kU,V)}let ee=(0,Z.op)({log1p_})},13888:function(F,$,V){"use strict";V.d($,{e:function(){return ea}});var G=V(30633),H=V(43740),K=V(24841),Z=V(17370),ee=V(2668),et=V(30625),en=V(3694);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logSigmoid_(F){let $=(0,H._1)(F,"x","logSigmoid"),V=(0,G.cb)(F=>{let $=(0,Z.W)((0,en.W)((0,Z.W)(F))),gradFunc=$=>{let V=(0,K.d)($,(0,et.X)((0,Z.W)(F)));return V};return{value:$,gradFunc}});return V($)}let ea=(0,ee.op)({logSigmoid_})},31510:function(F,$,V){"use strict";V.d($,{C:function(){return es}});var G=V(30633),H=V(43740),K=V(62271),Z=V(44842),ee=V(82597),et=V(83307),en=V(24841),ea=V(2668),ei=V(70827),eo=V(15475);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logSoftmax_(F,$=-1){let V=(0,H._1)(F,"logits","logSoftmax");if(-1===$&&($=V.rank-1),$!==V.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${V.rank} and axis was ${$}`);let ea=(0,G.cb)((F,V)=>{let G=!0,H=(0,et.F)(F,$,!0),ea=(0,ei.l)(F,H),es=(0,ei.l)((0,K.p)(ea,"float32"),(0,ee.c)((0,eo.S)((0,Z.Q)(ea),$,G)));V([es]);let gradFunc=(F,V)=>{let[G]=V,H=!0,K=(0,Z.Q)(G);return(0,ei.l)(F,(0,en.d)((0,eo.S)(F,$,H),K))};return{value:es,gradFunc}});return ea(V)}let es=(0,ea.op)({logSoftmax_})},11391:function(F,$,V){"use strict";V.d($,{l:function(){return eu}});var G=V(43740),H=V(20569),K=V(56407),Z=V(83591),ee=V(44842),et=V(82597),en=V(83307),ea=V(2668),ei=V(4968),eo=V(70827),es=V(15475);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logSumExp_(F,$=null,V=!1){let ea=(0,G._1)(F,"x","logSumExp"),eu=(0,H.EC)($,ea.shape),ec=(0,en.F)(ea,eu,!0),ep=(0,eo.l)(ea,ec),eh=(0,ee.Q)(ep),ef=(0,es.S)(eh,eu),ed=(0,et.c)(ef),em=(0,K.I)((0,ei.X)(ec,ed.shape),ed);if(V){let F=(0,Z.rv)(em.shape,eu);return(0,ei.X)(em,F)}return em}let eu=(0,ea.op)({logSumExp_})},2856:function(F,$,V){"use strict";V.d($,{H:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(72200),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logicalAnd_(F,$){let V=(0,K._1)(F,"a","logicalAnd","bool"),ee=(0,K._1)($,"b","logicalAnd","bool");(0,Z.assertAndGetBroadcastShape)(V.shape,ee.shape);let et={a:V,b:ee};return G.BV.runKernel(H.PYm,et)}let et=(0,ee.op)({logicalAnd_})},38651:function(F,$,V){"use strict";V.d($,{h:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logicalNot_(F){let $=(0,K._1)(F,"x","logicalNot","bool"),V={x:$};return G.BV.runKernel(H.VfG,V)}let ee=(0,Z.op)({logicalNot_})},15750:function(F,$,V){"use strict";V.d($,{K:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(72200),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logicalOr_(F,$){let V=(0,K._1)(F,"a","logicalOr","bool"),ee=(0,K._1)($,"b","logicalOr","bool");(0,Z.assertAndGetBroadcastShape)(V.shape,ee.shape);let et={a:V,b:ee};return G.BV.runKernel(H.MZg,et)}let et=(0,ee.op)({logicalOr_})},10596:function(F,$,V){"use strict";V.d($,{e:function(){return en}});var G=V(43740),H=V(72200),K=V(2856),Z=V(38651),ee=V(15750),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logicalXor_(F,$){let V=(0,G._1)(F,"a","logicalXor","bool"),et=(0,G._1)($,"b","logicalXor","bool");return(0,H.assertAndGetBroadcastShape)(V.shape,et.shape),(0,K.H)((0,ee.K)(F,$),(0,Z.h)((0,K.H)(F,$)))}let en=(0,et.op)({logicalXor_})},49876:function(F,$,V){"use strict";var G;V.d($,{I:function(){return G}}),function(F){F[F.NONE=0]="NONE",F[F.MEAN=1]="MEAN",F[F.SUM=2]="SUM",F[F.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(G||(G={}))},28687:function(F,$,V){"use strict";V.d($,{O:function(){return et}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function matMul_(F,$,V=!1,ee=!1){let et=(0,Z._1)(F,"a","matMul"),en=(0,Z._1)($,"b","matMul");[et,en]=(0,K.makeTypesMatch)(et,en);let ea={a:et,b:en},ei={transposeA:V,transposeB:ee};return G.BV.runKernel(H.XLW,ea,ei)}let et=(0,ee.op)({matMul_})},83307:function(F,$,V){"use strict";V.d($,{F:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function max_(F,$=null,V=!1){let Z=(0,K._1)(F,"x","max"),ee={x:Z},et={reductionIndices:$,keepDims:V};return G.BV.runKernel(H.YoZ,ee,et)}let ee=(0,Z.op)({max_})},21174:function(F,$,V){"use strict";V.d($,{_:function(){return ea}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2582),et=V(2668),en=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool_(F,$,V,et,ea){let ei=(0,K._1)(F,"x","maxPool"),eo=1,es=ei,eu=!1;3===ei.rank&&(eu=!0,es=(0,en.X)(ei,[1,ei.shape[0],ei.shape[1],ei.shape[2]])),Z.hu(4===es.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${es.rank}.`),Z.hu(ee.jT(V,eo),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${V} and dilations '${eo}'`),ee.m("maxPool",et,ea);let ec={x:es},ep={filterSize:$,strides:V,pad:et,dimRoundingMode:ea},eh=G.BV.runKernel(H.mTV,ec,ep);return eu?(0,en.X)(eh,[eh.shape[1],eh.shape[2],eh.shape[3]]):eh}let ea=(0,et.op)({maxPool_})},80632:function(F,$,V){"use strict";V.d($,{g:function(){return ea}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(72200),et=V(62271),en=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maximum_(F,$){let V=(0,Z._1)(F,"a","maximum"),en=(0,Z._1)($,"b","maximum");[V,en]=(0,K.makeTypesMatch)(V,en),"bool"===V.dtype&&(V=(0,et.p)(V,"int32"),en=(0,et.p)(en,"int32")),(0,ee.assertAndGetBroadcastShape)(V.shape,en.shape);let ea={a:V,b:en};return G.BV.runKernel(H.BMI,ea)}let ea=(0,en.op)({maximum_})},75130:function(F,$,V){"use strict";V.d($,{J:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mean_(F,$=null,V=!1){let Z=(0,K._1)(F,"x","mean"),ee={x:Z},et={axis:$,keepDims:V};return G.BV.runKernel(H.q2K,ee,et)}let ee=(0,Z.op)({mean_})},25735:function(F,$,V){"use strict";V.d($,{V:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function min_(F,$=null,V=!1){let Z=(0,K._1)(F,"x","min"),ee={x:Z},et={axis:$,keepDims:V};return G.BV.runKernel(H.c17,ee,et)}let ee=(0,Z.op)({min_})},24513:function(F,$,V){"use strict";V.d($,{L:function(){return ea}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(72200),et=V(62271),en=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function minimum_(F,$){let V=(0,Z._1)(F,"a","minimum"),en=(0,Z._1)($,"b","minimum");[V,en]=(0,K.makeTypesMatch)(V,en),"bool"===V.dtype&&(V=(0,et.p)(V,"int32"),en=(0,et.p)(en,"int32")),(0,ee.assertAndGetBroadcastShape)(V.shape,en.shape);let ea={a:V,b:en};return G.BV.runKernel(H.q8u,ea)}let ea=(0,en.op)({minimum_})},71483:function(F,$,V){"use strict";V.d($,{V:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mirrorPad_(F,$,V){Z.hu("reflect"===V||"symmetric"===V,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${V}.`);let ee=(0,K._1)(F,"x","mirrorPad");if(0===ee.rank)throw Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Z.hu($.length===ee.rank,()=>`Padding doesn't match input. Must be ${ee.rank}. Got ${$.length}.`);let et="reflect"===V?1:0;for(let F=0;F<ee.rank;F++)Z.hu(2===$[F].length,()=>"Invalid number of paddings. Must be length of 2 each."),Z.hu($[F][0]>=0&&$[F][0]<=ee.shape[F]-et&&$[F][1]>=0&&$[F][1]<=ee.shape[F]-et,()=>`Padding in dimension ${F} cannot be greater than or equal to ${ee.shape[F]-et} or less than 0 for input of shape ${ee.shape}`);let en={paddings:$,mode:V},ea={x:ee};return G.BV.runKernel(H.jQs,ea,en)}let et=(0,ee.op)({mirrorPad_})},85228:function(F,$,V){"use strict";V.d($,{w:function(){return et}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mod_(F,$){let V=(0,Z._1)(F,"a","mod"),ee=(0,Z._1)($,"b","mod");[V,ee]=(0,K.makeTypesMatch)(V,ee);let et={a:V,b:ee};return G.BV.runKernel(H.Vbg,et)}let et=(0,ee.op)({mod_})},24841:function(F,$,V){"use strict";V.d($,{d:function(){return et}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mul_(F,$){let V=(0,Z._1)(F,"a","mul"),ee=(0,Z._1)($,"b","mul");[V,ee]=(0,K.makeTypesMatch)(V,ee);let et={a:V,b:ee};return G.BV.runKernel(H.wYn,et)}let et=(0,ee.op)({mul_})},17370:function(F,$,V){"use strict";V.d($,{W:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function neg_(F){let $=(0,K._1)(F,"x","neg"),V={x:$};return G.BV.runKernel(H.kuV,V)}let ee=(0,Z.op)({neg_})},3561:function(F,$,V){"use strict";V.d($,{K:function(){return ep}});var G=V(43740),H=V(20569),K=V(96235),Z=V(83591),ee=V(83307),et=V(25735),en=V(2668),ea=V(33453),ei=V(4968),eo=V(99494),es=V(13261),eu=V(50248),ec=V(15475);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function norm_(F,$="euclidean",V=null,K=!1){F=(0,G._1)(F,"x","norm");let ee=normImpl(F,$,V),et=ee.shape;if(K){let $=(0,H.EC)(V,F.shape);et=Z.rv(ee.shape,$)}return(0,ei.X)(ee,et)}function normImpl(F,$,V=null){if(0===F.rank)return(0,K.W)(F);if(1!==F.rank&&null===V)return normImpl((0,ei.X)(F,[-1]),$,V);if(1===F.rank||"number"==typeof V||Array.isArray(V)&&1===V.length){if(1===$)return(0,ec.S)((0,K.W)(F),V);if($===1/0)return(0,ee.F)((0,K.W)(F),V);if($===-1/0)return(0,et.V)((0,K.W)(F),V);if("euclidean"===$||2===$)return(0,es._)((0,ec.S)((0,ea.s)((0,K.W)(F),(0,eo.i)(2,"int32")),V));throw Error(`Error in norm: invalid ord value: ${$}`)}if(Array.isArray(V)&&2===V.length){if(1===$)return(0,ee.F)((0,ec.S)((0,K.W)(F),V[0]),V[1]-1);if($===1/0)return(0,ee.F)((0,ec.S)((0,K.W)(F),V[1]),V[0]);if($===-1/0)return(0,et.V)((0,ec.S)((0,K.W)(F),V[1]),V[0]);if("fro"===$||"euclidean"===$)return(0,es._)((0,ec.S)((0,eu.h)(F),V));throw Error(`Error in norm: invalid ord value: ${$}`)}throw Error(`Error in norm: invalid axis: ${V}`)}let ep=(0,en.op)({norm_})},16500:function(F,$,V){"use strict";V.d($,{Q:function(){return en}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(72200),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function notEqual_(F,$){let V=(0,Z._1)(F,"a","notEqual","string_or_numeric"),et=(0,Z._1)($,"b","notEqual","string_or_numeric");[V,et]=(0,K.makeTypesMatch)(V,et),(0,ee.assertAndGetBroadcastShape)(V.shape,et.shape);let en={a:V,b:et};return G.BV.runKernel(H.yQU,en)}let en=(0,et.op)({notEqual_})},76708:function(F,$,V){"use strict";V.d($,{l:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oneHot_(F,$,V=1,Z=0,ee="int32"){if($<2)throw Error(`Error in oneHot: depth must be >=2, but it is ${$}`);let et=(0,K._1)(F,"indices","oneHot","int32"),en={indices:et},ea={dtype:ee,depth:$,onValue:V,offValue:Z};return G.BV.runKernel(H.we_,en,ea)}let ee=(0,Z.op)({oneHot_})},44917:function(F,$,V){"use strict";V.d($,{i:function(){return ones}});var G=V(50196),H=V(20569),K=V(61661),Z=V(59640);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ones(F,$="float32"){if((0,H.Mu)(F),"complex64"===$){let $=ones(F,"float32"),V=(0,Z.l)(F,"float32");return(0,K.P)($,V)}let V=(0,H.p8)((0,H.NA)(F),$);return G.BV.makeTensor(V,F,$)}},7846:function(F,$,V){"use strict";V.d($,{J:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function onesLike_(F){let $=(0,K._1)(F,"x","onesLike"),V={x:$};return G.BV.runKernel(H.qWM,V)}let ee=(0,Z.op)({onesLike_})},2668:function(F,$,V){"use strict";V.d($,{op:function(){return op},z:function(){return K}});var G=V(50196),H=V(20569);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let K="__op";function op(F){let $=Object.keys(F);if(1!==$.length)throw Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${$.length} keys.`);let V=$[0],Z=F[V];V.endsWith("_")&&(V=V.substring(0,V.length-1)),V+=K;let f2=(...F)=>{G.BV.startScope(V);try{let $=Z(...F);return(0,H.tI)($)&&console.error("Cannot return a Promise inside of tidy."),G.BV.endScope($),$}catch(F){throw G.BV.endScope(null),F}};return Object.defineProperty(f2,"name",{value:V,configurable:!0}),f2}},72816:function(F,$,V){"use strict";V.d($,{zvA:function(){return eo.z},WnP:function(){return H.W},Khb:function(){return K.K},__u:function(){return Z._},IHx:function(){return ee.I},QBD:function(){return es},$6P:function(){return eu.$},YjB:function(){return ec.Y},NqF:function(){return ep.N},vHJ:function(){return eh.v},ZRM:function(){return ef.Z},VfV:function(){return ed.V},z4N:function(){return em.z},fvJ:function(){return eg.f},C80:function(){return ey.C},wS1:function(){return eb.w},uR5:function(){return eN},zEQ:function(){return eD},tgs:function(){return eR.t},Dxk:function(){return eF},JY5:function(){return eO},p3b:function(){return eP},E4h:function(){return eM.E},yE8:function(){return eB},ycw:function(){return e$},anm:function(){return nA},XsQ:function(){return eL},UFq:function(){return ez.U},f3b:function(){return eV.f},pju:function(){return ew.p},mDi:function(){return eU.m},iUl:function(){return eW.i},d9v:function(){return ej.d},PYB:function(){return eG.P},zoF:function(){return ek.z},gME:function(){return eH},Izb:function(){return eX},MNy:function(){return eK},ZaL:function(){return eQ},PAt:function(){return eZ.P},Tek:function(){return eY.T},bc:function(){return eJ.b},pdZ:function(){return e1},$QV:function(){return e3},mCk:function(){return e4.m},f9Y:function(){return e6.f},mew:function(){return cosineWindow},$Gn:function(){return e5.$},zbp:function(){return e9.z},ppE:function(){return e8},nTT:function(){return e7.n},B10:function(){return te.B},Ka3:function(){return tt},WmZ:function(){return tr.W},hiC:function(){return tn.h},NTj:function(){return ta.N},AKD:function(){return ti.A},rvX:function(){return n$},WYO:function(){return ts},pyx:function(){return tu.p},GRh:function(){return enclosingPowerOfTwo},EDe:function(){return tl},DgJ:function(){return tc.D},qNN:function(){return th.q},d2q:function(){return td.d},Qqt:function(){return tm.Q},dt4:function(){return tg.d},t$B:function(){return ty.t},iyy:function(){return tv},kp_:function(){return r5.k},hlL:function(){return tw.h},GWj:function(){return tS.G},qPi:function(){return t_.q},imm:function(){return G},Iqj:function(){return tN.I},dbB:function(){return nB},pjt:function(){return tk.p},brS:function(){return tI.b},Sxn:function(){return r9.S},asL:function(){return tT.a},BHj:function(){return aV},V3u:function(){return nL},wx0:function(){return r8.w},xVT:function(){return tC.x},UWc:function(){return tE.U},i2d:function(){return tA.i},hi7:function(){return tD.h},d9m:function(){return tM.d},zN1:function(){return tR.z},$r2:function(){return aU},SX3:function(){return linspace},G9k:function(){return tF.G},cM7:function(){return tO.c},Krr:function(){return tP.K},e_t:function(){return tB.e},CmS:function(){return t$.C},l_t:function(){return tL.l},HvI:function(){return tz.H},hJK:function(){return tV.h},K5V:function(){return tU.K},egP:function(){return tW.e},MB5:function(){return aW},eab:function(){return lowerBound},OI3:function(){return eI.O},Fp7:function(){return tq.F},_sB:function(){return tH._},YQQ:function(){return tX},Ip$:function(){return tK},gWQ:function(){return tQ.g},J69:function(){return tZ.J},ry_:function(){return meshgrid},VV$:function(){return t4.V},LTh:function(){return t6.L},VdP:function(){return t5.V},wQq:function(){return t9.w},Gi7:function(){return rr},p_:function(){return nF},dC7:function(){return eT.d},rq4:function(){return rn},SJ_:function(){return ra},W76:function(){return ro.W},KOy:function(){return nM.K},Quu:function(){return rs.Q},lfX:function(){return ru.l},iUs:function(){return tY.i},JpU:function(){return rl.J},op:function(){return eo.op},N2O:function(){return rc},vku:function(){return rp.v},pNR:function(){return rh},koy:function(){return rf},t1L:function(){return rg},lGY:function(){return ry},d_R:function(){return rb.d},sQ3:function(){return rx.s},AL3:function(){return rv.A},S0v:function(){return rw.S},WVs:function(){return rS.W},$gW:function(){return r_},VT$:function(){return rN},N89:function(){return rk},TN_:function(){return rI},wzB:function(){return rC},nGf:function(){return rE},ruB:function(){return rA},LGj:function(){return rD},pe5:function(){return rM},w6H:function(){return range},kwC:function(){return rR.k},M25:function(){return rF.M},UYe:function(){return rO.U},btT:function(){return rP.b},XLQ:function(){return e_.X},GYS:function(){return rB.G},SDf:function(){return r$},diP:function(){return rz},sx7:function(){return rV},mG2:function(){return rU},QEs:function(){return r7.Q},NMM:function(){return rW.N},bp0:function(){return rj.b},iD$:function(){return rG.i},snQ:function(){return nO},zcT:function(){return tG},U8D:function(){return rq.U},U_I:function(){return rH.U},ODp:function(){return rX},XD2:function(){return eC.X},Xxe:function(){return rK.X},tdS:function(){return az},O$l:function(){return rQ.O},R_K:function(){return rZ.R},tPi:function(){return eE.t},jZU:function(){return rY},SmN:function(){return rJ},CnO:function(){return r0},p0P:function(){return r2},XAC:function(){return r3.X},Wvh:function(){return r4.W},fBT:function(){return r6.f},rVs:function(){return aj},ers:function(){return nP},uN7:function(){return a$},Vl2:function(){return ne.V},_b3:function(){return nt._},h62:function(){return t7.h},$i:function(){return nr.$},L9e:function(){return nn.L},knu:function(){return ni.k},Nbs:function(){return no.N},NXj:function(){return nu.N},Z_8:function(){return aG},luU:function(){return rt.l},Smz:function(){return nl.S},ORZ:function(){return np.O},AEp:function(){return eA.A},XeE:function(){return nh.X},RRF:function(){return tensor1d},odF:function(){return tensor2d},wOQ:function(){return nm.w},yXz:function(){return tensor4d},Bfx:function(){return tensor5d},xZs:function(){return tensor6d},Pg0:function(){return ny},Gg6:function(){return tb.G},hg7:function(){return nx.h},p4s:function(){return nD.p},Xu6:function(){return nw},Two:function(){return nS.T},pUJ:function(){return n_.p},HHK:function(){return nN.H},GaM:function(){return upperBound},VD$:function(){return variable},arb:function(){return nk.a},itS:function(){return nT},lls:function(){return nC.l},P84:function(){return nE.P}});var G={};V.r(G),V.d(G,{conv2d:function(){return nq},depthwiseConv2d:function(){return nK},matMul:function(){return nQ}});var H=V(96235),K=V(17839),Z=V(91470),ee=V(56407),et=V(50196),en=V(29121),ea=V(43740),ei=V(20569),eo=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function addN_(F){ei.hu(Array.isArray(F),()=>"The argument passed to tf.addN() must be a list of tensors"),ei.hu(F.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${F.length}`);let $=F.map((F,$)=>(0,ea._1)(F,`tensors${$}`,"addN")),V=$[0];$.forEach(F=>{if(F.dtype!==V.dtype)throw Error("All tensors passed to tf.addN() must have the same dtype")}),$.forEach(F=>{if(!ei.cO(F.shape,V.shape))throw Error("All tensors passed to tf.addN() must have the same shape")});let G=$;return et.BV.runKernel(en.Xze,G)}let es=(0,eo.op)({addN_});var eu=V(90781),ec=V(92998),ep=V(40047),eh=V(27394),ef=V(72421),ed=V(21891),em=V(77037),eg=V(29812),ey=V(80369),eb=V(15176),ew=V(62271),eS=V(2582),e_=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3d_(F,$,V,G,H,K="NDHWC"){let Z=(0,ea._1)(F,"x","avgPool3d","float32"),ee=Z,eo=!1;4===Z.rank&&(eo=!0,ee=(0,e_.X)(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2],Z.shape[3]])),ei.hu(5===ee.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${ee.rank}.`),ei.hu("NDHWC"===K,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${K}`),ei.hu("number"==typeof V&&V>0||Array.isArray(V)&&V[0]>0&&V[1]>0&&V[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${V}'`),(0,eS.m)("avgPool3d",G,H);let es={x:ee},eu={filterSize:$,strides:V,pad:G,dimRoundingMode:H,dataFormat:K},ec=et.BV.runKernel(en._k9,es,eu);return(ec=(0,ew.p)(ec,ee.dtype),eo)?(0,e_.X)(ec,[ec.shape[1],ec.shape[2],ec.shape[3],ec.shape[4]]):ec}let eN=(0,eo.op)({avgPool3d_});var ek=V(46884),eI=V(28687),eT=V(24841),eC=V(30625),eE=V(22676),eA=V(21869);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function basicLSTMCell_(F,$,V,G,H,K){let Z=(0,ea._1)(F,"forgetBias","basicLSTMCell"),et=(0,ea._1)($,"lstmKernel","basicLSTMCell"),en=(0,ea._1)(V,"lstmBias","basicLSTMCell"),ei=(0,ea._1)(G,"data","basicLSTMCell"),eo=(0,ea._1)(H,"c","basicLSTMCell"),es=(0,ea._1)(K,"h","basicLSTMCell"),eu=(0,ek.z)([ei,es],1),ec=(0,eI.O)(eu,et),ep=(0,ee.I)(ec,en),eh=ep.shape[0],ef=ep.shape[1]/4,ed=[eh,ef],em=(0,eE.t)(ep,[0,0],ed),eg=(0,eE.t)(ep,[0,ef],ed),ey=(0,eE.t)(ep,[0,2*ef],ed),eb=(0,eE.t)(ep,[0,3*ef],ed),ew=(0,ee.I)((0,eT.d)((0,eC.X)(em),(0,eA.A)(eg)),(0,eT.d)(eo,(0,eC.X)((0,ee.I)(Z,ey)))),eS=(0,eT.d)((0,eA.A)(ew),(0,eC.X)(eb));return[ew,eS]}let eD=(0,eo.op)({basicLSTMCell_});var eM=V(28441),eR=V(40094);function batchNorm2d_(F,$,V,G,H,K){let Z,ee;let et=(0,ea._1)(F,"x","batchNorm"),en=(0,ea._1)($,"mean","batchNorm"),eo=(0,ea._1)(V,"variance","batchNorm");return null!=H&&(Z=(0,ea._1)(H,"scale","batchNorm")),null!=G&&(ee=(0,ea._1)(G,"offset","batchNorm")),ei.hu(2===et.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${et.rank}.`),ei.hu(2===en.rank||1===en.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${en.rank}.`),ei.hu(2===eo.rank||1===eo.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${eo.rank}.`),null!=Z&&ei.hu(2===Z.rank||1===Z.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${Z.rank}.`),null!=ee&&ei.hu(2===ee.rank||1===ee.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${ee.rank}.`),(0,eR.t)(et,en,eo,ee,Z,K)}let eF=(0,eo.op)({batchNorm2d_});function batchNorm3d_(F,$,V,G,H,K){let Z,ee;let et=(0,ea._1)(F,"x","batchNorm"),en=(0,ea._1)($,"mean","batchNorm"),eo=(0,ea._1)(V,"variance","batchNorm");return null!=H&&(Z=(0,ea._1)(H,"scale","batchNorm")),null!=G&&(ee=(0,ea._1)(G,"offset","batchNorm")),ei.hu(3===et.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${et.rank}.`),ei.hu(3===en.rank||1===en.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${en.rank}.`),ei.hu(3===eo.rank||1===eo.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${eo.rank}.`),null!=Z&&ei.hu(3===Z.rank||1===Z.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${Z.rank}.`),null!=ee&&ei.hu(3===ee.rank||1===ee.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${ee.rank}.`),(0,eR.t)(et,en,eo,ee,Z,K)}let eO=(0,eo.op)({batchNorm3d_});function batchNorm4d_(F,$,V,G,H,K){let Z,ee;let et=(0,ea._1)(F,"x","batchNorm"),en=(0,ea._1)($,"mean","batchNorm"),eo=(0,ea._1)(V,"variance","batchNorm");return null!=H&&(Z=(0,ea._1)(H,"scale","batchNorm")),null!=G&&(ee=(0,ea._1)(G,"offset","batchNorm")),ei.hu(4===et.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${et.rank}.`),ei.hu(4===en.rank||1===en.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${en.rank}.`),ei.hu(4===eo.rank||1===eo.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${eo.rank}.`),null!=Z&&ei.hu(4===Z.rank||1===Z.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${Z.rank}.`),null!=ee&&ei.hu(4===ee.rank||1===ee.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${ee.rank}.`),(0,eR.t)(et,en,eo,ee,Z,K)}let eP=(0,eo.op)({batchNorm4d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bincount_(F,$,V){let G=(0,ea._1)(F,"x","bincount"),H=(0,ea._1)($,"weights","bincount");ei.hu("int32"===G.dtype,()=>`Error in bincount: input dtype must be int32, but got ${G.dtype}`),ei.hu(V>=0,()=>`size must be non-negative, but got ${V}.`),ei.hu(H.size===G.size||0===H.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${G.shape}, weights shape: ${H.shape}.`);let K={x:G,weights:H},Z={size:V};return et.BV.runKernel(en.zvY,K,Z)}let eB=(0,eo.op)({bincount_});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bitwiseAnd_(F,$){let V=(0,ea._1)(F,"x","bitwiseAnd"),G=(0,ea._1)($,"y","bitwiseAnd");if(!(0,ei.cO)(V.shape,G.shape))throw Error(`BitwiseAnd: Tensors must have the same shape. x: ${V.shape}, y: ${G.shape}`);if("int32"!==V.dtype||"int32"!==G.dtype)throw Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${V.dtype} and type of y: ${G.dtype}`);let H={a:V,b:G};return et.BV.runKernel(en.hCO,H)}let e$=(0,eo.op)({bitwiseAnd_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function broadcastArgs_(F,$){let V=(0,ea._1)(F,"s0","broadcastArgs","int32"),G=(0,ea._1)($,"s1","broadcastArgs","int32");if(1!==V.rank)throw Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${V.rank}`);if(1!==G.rank)throw Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${G.rank}`);let H={s0:V,s1:G};return et.BV.runKernel(en.eEB,H)}let eL=(0,eo.op)({broadcastArgs_});var ez=V(68247),eV=V(72657),eU=V(6825),eW=V(42279),ej=V(8723),eG=V(61661);function concat1d_(F){return(0,ek.z)(F,0)}let eH=(0,eo.op)({concat1d_});function concat2d_(F,$){return(0,ek.z)(F,$)}let eX=(0,eo.op)({concat2d_});function concat3d_(F,$){return(0,ek.z)(F,$)}let eK=(0,eo.op)({concat3d_});function concat4d_(F,$){return(0,ek.z)(F,$)}let eQ=(0,eo.op)({concat4d_});var eZ=V(11355),eY=V(64794),eJ=V(71405);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3d_(F,$,V,G,H="NDHWC",K=[1,1,1]){let Z=(0,ea._1)(F,"x","conv3d"),ee=(0,ea._1)($,"filter","conv3d"),eo=Z,es=!1;4===Z.rank&&(es=!0,eo=(0,e_.X)(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2],Z.shape[3]])),ei.hu(5===eo.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${eo.rank}.`),ei.hu(5===ee.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${ee.rank}.`),ei.hu(eo.shape[4]===ee.shape[3],()=>`Error in conv3d: depth of input (${eo.shape[4]}) must match input depth for filter ${ee.shape[3]}.`),ei.hu((0,eS.jT)(V,K),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${V} and dilations '${K}'`),ei.hu("NDHWC"===H,()=>`Error in conv3d: got dataFormat of ${H} but only NDHWC is currently supported.`),ei.hu((0,eS.U3)(K),()=>"Error in conv3D: Dilated rates should be larger than 0."),ei.hu((0,eS.U3)(V),()=>"Error in conv3D: Strides should be larger than 0.");let eu={x:eo,filter:ee},ec={strides:V,pad:G,dataFormat:H,dilations:K},ep=et.BV.runKernel(en.x12,eu,ec);return es?(0,e_.X)(ep,[ep.shape[1],ep.shape[2],ep.shape[3],ep.shape[4]]):ep}let e1=(0,eo.op)({conv3d_});var e2=V(97594);function conv3dTranspose_(F,$,V,G,H){let K=(0,ea._1)(F,"x","conv3dTranspose"),Z=(0,ea._1)($,"filter","conv3dTranspose");return(0,e2._)(V,K,Z,G,H)}let e3=(0,eo.op)({conv3dTranspose_});var e4=V(70173),e6=V(2699),e5=V(9640),e9=V(37405);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function denseBincount_(F,$,V,G=!1){let H=(0,ea._1)(F,"x","denseBincount"),K=(0,ea._1)($,"weights","denseBincount");ei.hu("int32"===H.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${H.dtype}`),ei.hu(H.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${H.rank}.`),ei.hu(V>=0,()=>`size must be non-negative, but got ${V}.`),ei.hu(K.size===H.size||0===K.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${H.shape}, weights shape: ${K.shape}.`);let Z={x:H,weights:K},ee={size:V,binaryOutput:G};return et.BV.runKernel(en.QRR,Z,ee)}let e8=(0,eo.op)({denseBincount_});var e7=V(89112),te=V(64718);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function diag_(F){let $=(0,ea._1)(F,"x","diag"),V={x:$};return et.BV.runKernel(en.$w,V)}let tt=(0,eo.op)({diag_});var tr=V(70557),tn=V(41274),ta=V(49322),ti=V(30548);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function einsum_(F,...$){let V=$.map((F,$)=>(0,ea._1)(F,`tensors${$}`,"einsum")),G={equation:F};return et.BV.runKernel(en.$g6,V,G)}let ts=(0,eo.op)({einsum_});var tu=V(83233);/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ensureShape_(F,$){let V=(0,ea._1)(F,"x","ensureShape","string_or_numeric");if(!(0,ei.DK)(V.shape,$))throw Error(`EnsureShape: Shape of tensor ${V.shape} is not compatible with expected shape ${$}`);return F}let tl=(0,eo.op)({ensureShape_});var tc=V(26477),th=V(34650),td=V(31954),tm=V(44842),tg=V(81300),ty=V(53426),tb=V(47501);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eye_(F,$,V,G="float32"){null==$&&($=F);let H=(0,eV.f)([F,$],G),K=F<=$?F:$;for(let F=0;F<K;++F)H.set(1,F,F);let Z=(0,e_.X)(H.toTensor(),[F,$]);if(null==V)return Z;if(1===V.length)return(0,tb.G)((0,tg.d)(Z,0),[V[0],1,1]);if(2===V.length)return(0,tb.G)((0,tg.d)((0,tg.d)(Z,0),0),[V[0],V[1],1,1]);if(3===V.length)return(0,tb.G)((0,tg.d)((0,tg.d)((0,tg.d)(Z,0),0),0),[V[0],V[1],V[2],1,1]);throw Error(`eye() currently supports only 1D and 2D batchShapes, but received ${V.length}D.`)}let tv=(0,eo.op)({eye_});var tw=V(14006),tS=V(26943),t_=V(9165),tN=V(24926),tk=V(20636),tI=V(17630),tT=V(64386),tC=V(13963),tE=V(4365),tA=V(96230),tD=V(99133),tM=V(86573),tR=V(50624);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function linspace(F,$,V){if(V<=0)throw Error("The number of values should be positive.");let G={start:F,stop:$,num:V};return et.BV.runKernel(en.e7N,{},G)}var tF=V(79648),tO=V(82597),tP=V(17474),tB=V(13888),t$=V(31510),tL=V(11391),tz=V(2856),tV=V(38651),tU=V(15750),tW=V(10596);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tj=2147483648;function searchSorted_(F,$,V="left"){let G=(0,ea._1)(F,"sortedSequence","searchSorted"),H=(0,ea._1)($,"values","searchSorted"),K=G.shape[G.shape.length-1],Z=H.shape[H.shape.length-1],ee=(0,e_.X)(G,[-1,K]),eo=(0,e_.X)(H,[-1,Z]);if(ee.rank<2)throw Error("Sorted input argument must be at least 2-dimensional");if(ee.shape[0]!==eo.shape[0])throw Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,ei.NA)(eo.shape)>=tj)throw Error(`values tensor size must less than ${tj}`);if(ee.shape[1]>=tj)throw Error(`trailing dim_size must less than ${tj} for int32 output type, was ${ee.shape[1]}`);let es={sortedSequence:ee,values:eo},eu={side:V};return et.BV.runKernel(en.nr8,es,eu)}let tG=(0,eo.op)({searchSorted_});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lowerBound(F,$){return tG(F,$,"left")}var tq=V(83307),tH=V(21174);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3d_(F,$=[1,1,1],V,G,H,K="NDHWC"){let Z=(0,ea._1)(F,"x","maxPool3d"),ee=Z,eo=!1;4===Z.rank&&(eo=!0,ee=(0,e_.X)(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2],Z.shape[3]])),ei.hu(5===ee.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${ee.rank}.`),ei.hu("NDHWC"===K,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${K}`),(0,eS.m)("maxPool3d",G,H);let es={x:ee},eu={filterSize:$,strides:V,pad:G,dimRoundingMode:H,dataFormat:K},ec=et.BV.runKernel(en.OAf,es,eu);return eo?(0,e_.X)(ec,[ec.shape[1],ec.shape[2],ec.shape[3],ec.shape[4]]):ec}let tX=(0,eo.op)({maxPool3d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolWithArgmax_(F,$,V,G,H=!1){let K=(0,ea._1)(F,"x","maxPoolWithArgmax"),Z={x:K},ee={filterSize:$,strides:V,pad:G,includeBatchInIndex:H},ei=et.BV.runKernel(en.vFR,Z,ee);return{result:ei[0],indexes:ei[1]}}let tK=(0,eo.op)({maxPoolWithArgmax_});var tQ=V(80632),tZ=V(75130),tY=V(44917),tJ=V(40974);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function meshgrid(F,$,{indexing:V="xy"}={}){if("xy"!==V&&"ij"!==V)throw TypeError(`${V} is not a valid third argument to meshgrid`);if(void 0===F)return[];let G=(0,ea._1)(F,"x","meshgrid",F instanceof tJ.es?F.dtype:"float32");if(void 0===$)return[G];let H=(0,ea._1)($,"y","meshgrid",$ instanceof tJ.es?$.dtype:"float32"),K=(0,ei.NA)(G.shape),Z=(0,ei.NA)(H.shape);return"xy"===V?(G=(0,e_.X)(G,[1,-1]),H=(0,e_.X)(H,[-1,1]),[(0,eI.O)((0,tY.i)([Z,1],G.dtype),G),(0,eI.O)(H,(0,tY.i)([1,K],H.dtype))]):(G=(0,e_.X)(G,[-1,1]),H=(0,e_.X)(H,[1,-1]),[(0,eI.O)(G,(0,tY.i)([1,Z],G.dtype)),(0,eI.O)((0,tY.i)([K,1],H.dtype),H)])}var t4=V(25735),t6=V(24513),t5=V(71483),t9=V(85228),t8=V(83591),t7=V(50248),rt=V(70827);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function moments_(F,$=null,V=!1){F=(0,ea._1)(F,"x","moments");let G=(0,ei.EC)($,F.shape),H=(0,tZ.J)(F,G,V),K=H.shape;V||(K=(0,t8.rv)(H.shape,G));let Z=(0,t7.h)((0,rt.l)((0,ew.p)(F,"float32"),(0,e_.X)(H,K))),ee=(0,tZ.J)(Z,G,V);return{mean:H,variance:ee}}let rr=(0,eo.op)({moments_});function multiRNNCell_(F,$,V,G){let H=(0,ea._1)($,"data","multiRNNCell"),K=(0,ea.sI)(V,"c","multiRNNCell"),Z=(0,ea.sI)(G,"h","multiRNNCell"),ee=H,et=[];for(let $=0;$<F.length;$++){let V=F[$](ee,K[$],Z[$]);et.push(V[0]),et.push(V[1]),ee=V[1]}let en=[],ei=[];for(let F=0;F<et.length;F+=2)en.push(et[F]),ei.push(et[F+1]);return[en,ei]}let rn=(0,eo.op)({multiRNNCell_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function multinomial_(F,$,V,G=!1){let H=(0,ea._1)(F,"logits","multinomial"),K=H.size,Z=H.rank;if(K<2)throw Error(`Error in multinomial: you need at least 2 outcomes, but got ${K}.`);if(Z>2)throw Error(`Rank of probabilities must be 1 or 2, but is ${Z}`);V=V||Math.random();let ee=1===Z?(0,e_.X)(H,[1,-1]):H,ei={logits:ee},eo={numSamples:$,seed:V,normalized:G},es=et.BV.runKernel(en.NZg,ei,eo);return 1===Z?(0,e_.X)(es,[es.size]):es}let ra=(0,eo.op)({multinomial_});var ro=V(17370),rs=V(16500),ru=V(76708),rl=V(7846);function outerProduct_(F,$){let V=(0,ea._1)(F,"v1","outerProduct"),G=(0,ea._1)($,"v2","outerProduct");ei.hu(1===V.rank&&1===G.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${V.rank} and ${G.rank}.`);let H=(0,e_.X)(V,[-1,1]),K=(0,e_.X)(G,[1,-1]);return(0,eI.O)(H,K)}let rc=(0,eo.op)({outerProduct_});var rp=V(39682);function pad1d_(F,$,V=0){return(0,ei.hu)(2===$.length,()=>"Invalid number of paddings. Must be length of 2."),(0,rp.v)(F,[$],V)}let rh=(0,eo.op)({pad1d_});function pad2d_(F,$,V=0){return(0,ei.hu)(2===$.length&&2===$[0].length&&2===$[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,rp.v)(F,$,V)}let rf=(0,eo.op)({pad2d_});function pad3d_(F,$,V=0){return(0,ei.hu)(3===$.length&&2===$[0].length&&2===$[1].length&&2===$[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,rp.v)(F,$,V)}let rg=(0,eo.op)({pad3d_});function pad4d_(F,$,V=0){return(0,ei.hu)(4===$.length&&2===$[0].length&&2===$[1].length&&2===$[2].length&&2===$[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,rp.v)(F,$,V)}let ry=(0,eo.op)({pad4d_});var rb=V(85860),rx=V(33453),rv=V(98151),rw=V(29798),rS=V(49451);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function raggedGather_(F,$,V,G){let H=F.map((F,$)=>(0,ea._1)(F,`tensors${$}`,"raggedGather","int32")),K=(0,ea._1)($,"paramsDenseValues","raggedGather"),Z=(0,ea._1)(V,"indices","raggedGather","int32"),ee={paramsNestedSplits:H,paramsDenseValues:K,indices:Z},ei={outputRaggedRank:G},eo=et.BV.runKernel(en.dDz,ee,ei);return{outputNestedSplits:eo.slice(0,eo.length-1),outputDenseValues:eo[eo.length-1]}}let r_=(0,eo.op)({raggedGather_});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function raggedRange_(F,$,V){let G=(0,ea._1)(F,"starts","raggedRange"),H=(0,ea._1)($,"limits","raggedRange",G.dtype),K=(0,ea._1)(V,"deltas","raggedRange",G.dtype),Z={starts:G,limits:H,deltas:K},ee=et.BV.runKernel(en.CQl,Z);return{rtNestedSplits:ee[0],rtDenseValues:ee[1]}}let rN=(0,eo.op)({raggedRange_});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function raggedTensorToTensor_(F,$,V,G,H){let K=(0,ea._1)(F,"shape","raggedTensorToTensor","int32"),Z=(0,ea._1)($,"values","raggedTensorToTensor"),ee=(0,ea._1)(V,"defaultValue","raggedTensorToTensor",Z.dtype),ei=G.map((F,$)=>(0,ea._1)(F,`tensors${$}`,"raggedTensorToTensor","int32")),eo={shape:K,values:Z,defaultValue:ee,rowPartitionTensors:ei},es={rowPartitionTypes:H};return et.BV.runKernel(en.BiW,eo,es)}let rk=(0,eo.op)({raggedTensorToTensor_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rand_(F,$,V){(0,ei.Mu)(F);let G=(0,ei.NA)(F),H=null;if(null==V||"float32"===V)H=new Float32Array(G);else if("int32"===V)H=new Int32Array(G);else if("bool"===V)H=new Uint8Array(G);else throw Error(`Unknown data type ${V}`);for(let F=0;F<G;F++)H[F]=$();return et.BV.makeTensor(H,F,V)}let rI=(0,eo.op)({rand_});var rT=V(36377);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MPRandGauss=class MPRandGauss{constructor(F,$,V,G,H){this.mean=F,this.stdDev=$,this.dtype=V,this.nextVal=NaN,this.truncated=G,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let K=H||Math.random();this.random=rT.alea(K.toString())}nextValue(){let F,$;if(!isNaN(this.nextVal)){let F=this.nextVal;return this.nextVal=NaN,F}let V=!1;for(;!V;){let G,H,K;do K=(G=2*this.random()-1)*G+(H=2*this.random()-1)*H;while(K>=1||0===K);let Z=Math.sqrt(-2*Math.log(K)/K);F=this.mean+this.stdDev*G*Z,$=this.mean+this.stdDev*H*Z,(!this.truncated||this.isValidTruncated(F))&&(V=!0)}return(!this.truncated||this.isValidTruncated($))&&(this.nextVal=this.convertValue($)),this.convertValue(F)}convertValue(F){return null==this.dtype||"float32"===this.dtype?F:Math.round(F)}isValidTruncated(F){return F<=this.upper&&F>=this.lower}};let RandGamma=class RandGamma{constructor(F,$,V,G){this.alpha=F,this.beta=1/$,this.dtype=V;let H=G||Math.random();this.randu=rT.alea(H.toString()),this.randn=new MPRandGauss(0,1,V,!1,this.randu()),F<1?this.d=F+2/3:this.d=F-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let F,$,V,G,H,K;for(;;){do G=this.randn.nextValue(),K=1+this.c*G;while(K<=0);if(K*=K*K,$=1-.331*(F=G*G)*F,V=.5*F+this.d*(1-K+Math.log(K)),(H=this.randu())<$||Math.log(H)<V)break}return K=1/this.beta*this.d*K,this.alpha<1&&(K*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(K)}convertValue(F){return"float32"===this.dtype?F:Math.round(F)}};let UniformRandom=class UniformRandom{constructor(F=0,$=1,V,G){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=F,this.range=$-F,this.dtype=V,null==G&&(G=Math.random()),"number"==typeof G&&(G=G.toString()),!this.canReturnFloat()&&this.range<=1)throw Error(`The difference between ${F} - ${$} <= 1 and dtype is not float`);this.random=rT.alea(G)}convertValue(F){return this.canReturnFloat()?F:Math.round(F)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function randomGamma_(F,$,V=1,G="float32",H){if((0,ei.Mu)(F),null==V&&(V=1),null==G&&(G="float32"),"float32"!==G&&"int32"!==G)throw Error(`Unsupported data type ${G}`);let K=new RandGamma($,V,G,H),Z=(0,eV.f)(F,G);for(let F=0;F<Z.values.length;F++)Z.values[F]=K.nextValue();return Z.toTensor()}let rC=(0,eo.op)({randomGamma_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function randomNormal_(F,$=0,V=1,G,H){if((0,ei.Mu)(F),null!=G&&"bool"===G)throw Error(`Unsupported data type ${G}`);let K=new MPRandGauss($,V,G,!1,H),Z=(0,eV.f)(F,G);for(let F=0;F<Z.values.length;F++)Z.values[F]=K.nextValue();return Z.toTensor()}let rE=(0,eo.op)({randomNormal_});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function randomStandardNormal_(F,$,V){if(null!=$&&"bool"===$)throw Error(`Unsupported data type ${$}`);return rE(F,0,1,$,V)}let rA=(0,eo.op)({randomStandardNormal_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function randomUniform_(F,$=0,V=1,G="float32",H){(0,ei.Mu)(F);let K=(0,eV.f)(F,G),Z=new UniformRandom($,V,null,H);for(let F=0;F<K.values.length;F++)K.values[F]=Z.nextValue();return K.toTensor()}let rD=(0,eo.op)({randomUniform_});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function randomUniformInt_(F,$,V,G){return rD(F,$,V,"int32",G)}let rM=(0,eo.op)({randomUniformInt_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function range(F,$,V=1,G="float32"){if(0===V)throw Error("Cannot have a step of zero");let H={start:F,stop:$,step:V,dtype:G};return et.BV.runKernel(en.e6w,{},H)}var rR=V(60766),rF=V(19036),rO=V(7409),rP=V(83582),rB=V(57486);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse1d_(F){let $=(0,ea._1)(F,"x","reverse");return ei.hu(1===$.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${$.rank}.`),(0,rB.G)($,0)}let r$=(0,eo.op)({reverse1d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse2d_(F,$){let V=(0,ea._1)(F,"x","reverse");return ei.hu(2===V.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${V.rank}.`),(0,rB.G)(V,$)}let rz=(0,eo.op)({reverse2d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse3d_(F,$){let V=(0,ea._1)(F,"x","reverse");return ei.hu(3===V.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${V.rank}.`),(0,rB.G)(V,$)}let rV=(0,eo.op)({reverse3d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse4d_(F,$){let V=(0,ea._1)(F,"x","reverse");return ei.hu(4===V.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${V.rank}.`),(0,rB.G)(V,$)}let rU=(0,eo.op)({reverse4d_});var rW=V(97809),rj=V(32634),rG=V(99494),rq=V(55503),rH=V(68678);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function setdiff1dAsync_(F,$){let V=(0,ea._1)(F,"x","setdiff1d"),G=(0,ea._1)($,"y","setdiff1d");ei.hu(V.dtype===G.dtype,()=>`x and y should have the same dtype, but got x (${V.dtype}) and y (${G.dtype}).`),ei.hu(1===V.rank,()=>`x should be 1D tensor, but got x (${V.shape}).`),ei.hu(1===G.rank,()=>`y should be 1D tensor, but got y (${G.shape}).`);let H=await V.data(),K=await G.data(),Z=new Set(K),ee=0;for(let F=0;F<H.length;F++)!Z.has(H[F])&&ee++;let et=new tJ.YD([ee],V.dtype),en=new tJ.YD([ee],"int32");for(let F=0,$=0;F<H.length;F++)!Z.has(H[F])&&(et.values[$]=H[F],en.values[$]=F,$++);return[et.toTensor(),en.toTensor()]}let rX=setdiff1dAsync_;var rK=V(34434),rQ=V(99331),rZ=V(83254);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice1d_(F,$,V){let G=(0,ea._1)(F,"x","slice1d");return ei.hu(1===G.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${G.rank} tensor`),(0,eE.t)(G,[$],[V])}let rY=(0,eo.op)({slice1d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice2d_(F,$,V){let G=(0,ea._1)(F,"x","slice2d");return ei.hu(2===G.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${G.rank} tensor`),(0,eE.t)(G,$,V)}let rJ=(0,eo.op)({slice2d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice3d_(F,$,V){let G=(0,ea._1)(F,"x","slice3d");return ei.hu(3===G.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${G.rank} tensor`),(0,eE.t)(G,$,V)}let r0=(0,eo.op)({slice3d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice4d_(F,$,V){let G=(0,ea._1)(F,"x","slice4d");return ei.hu(4===G.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${G.rank} tensor`),(0,eE.t)(G,$,V)}let r2=(0,eo.op)({slice4d_});var r3=V(80682),r4=V(3694),r6=V(27918),r5=V(7020),r9=V(88447),r8=V(84415),r7=V(13710),ne=V(28644),nt=V(13261),nr=V(15265),nn=V(79590),ni=V(82991),no=V(71901),nu=V(55158),nl=V(15475),np=V(61173),nh=V(10701),nf=V(57852);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor1d(F,$){(0,ei.Cq)(F);let V=(0,ea.C)(F,$);if(1!==V.length)throw Error("tensor1d() requires values to be a flat/TypedArray");let G=null;return(0,nf.H)(F,G,V,$)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor2d(F,$,V){if((0,ei.Cq)(F),null!=$&&2!==$.length)throw Error("tensor2d() requires shape to have two numbers");let G=(0,ea.C)(F,V);if(2!==G.length&&1!==G.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===G.length&&null==$)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,nf.H)(F,$,G,V)}var nm=V(99906);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor4d(F,$,V){if((0,ei.Cq)(F),null!=$&&4!==$.length)throw Error("tensor4d() requires shape to have four numbers");let G=(0,ea.C)(F,V);if(4!==G.length&&1!==G.length)throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===G.length&&null==$)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,nf.H)(F,$,G,V)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor5d(F,$,V){if((0,ei.Cq)(F),null!=$&&5!==$.length)throw Error("tensor5d() requires shape to have five numbers");let G=(0,ea.C)(F,V);if(5!==G.length&&1!==G.length)throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===G.length&&null==$)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,nf.H)(F,$,G,V)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor6d(F,$,V){if((0,ei.Cq)(F),null!=$&&6!==$.length)throw Error("tensor6d() requires shape to have six numbers");let G=(0,ea.C)(F,V);if(6!==G.length&&1!==G.length)throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===G.length&&null==$)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return $=$||G,(0,nf.H)(F,$,G,V)}var ng=V(33028);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensorScatterUpdate_(F,$,V){let G=(0,ea._1)(F,"tensor","tensorScatterupdate"),H=(0,ea._1)($,"indices","tensorScatterupdate","int32"),K=(0,ea._1)(V,"updates","tensorScatterupdate");if(ng.validateInput(K,H,G.shape),G.dtype!==K.dtype)throw Error(`tensor and updates must have the same dtype, instead they are ${G.dtype} and ${K.dtype}.`);let Z={tensor:G,indices:H,updates:K},ee={};return et.BV.runKernel(en.SIB,Z,ee)}let ny=(0,eo.op)({tensorScatterUpdate_});var nx=V(43243);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function truncatedNormal_(F,$=0,V=1,G,H){if((0,ei.Mu)(F),null!=G&&"bool"===G)throw Error("Unsupported data type $ { dtype }");let K=new MPRandGauss($,V,G,!0,H),Z=(0,eV.f)(F,G);for(let F=0;F<Z.values.length;F++)Z.values[F]=K.nextValue();return Z.toTensor()}let nw=(0,eo.op)({truncatedNormal_});var nS=V(49608),n_=V(98749),nN=V(24136);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function upperBound(F,$){return tG(F,$,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function variable(F,$=!0,V,G){return et.BV.makeVariable(F,$,V,G)}var nk=V(95912),nI=V(48333);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function whereAsync_(F){let $=(0,ea._1)(F,"condition","whereAsync","bool"),V=await $.data(),G=(0,nI.Z)($.shape,V);return F!==$&&$.dispose(),G}let nT=whereAsync_;var nC=V(59640),nE=V(6577);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function booleanMaskAsync_(F,$,V){let G=(0,ea._1)(F,"tensor","boolMask"),H=(0,ea._1)($,"mask","boolMask","bool"),K=null==V?0:V,Z=H.rank,ee=G.shape;ei.hu(Z>0,()=>"mask cannot be scalar"),ei.k5(ee.slice(K,K+Z),H.shape,"mask's shape must match the first K dimensions of tensor's shape,");let et=1;for(let F=K;F<K+Z;F++)et*=ee[F];let en=ee.slice(0,K).concat([et],ee.slice(K+Z)),eo=(0,e_.X)(G,en),es=(0,e_.X)(H,[-1]),eu=await nT(es),ec=(0,nn.L)(eu,[1]),ep=(0,tN.I)(eo,ec,K);return F!==G&&G.dispose(),$!==H&&H.dispose(),ec.dispose(),eo.dispose(),es.dispose(),eu.dispose(),ep}let nA=booleanMaskAsync_;var nD=V(89065),nM=V(3561),nR=V(80747);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function movingAverage_(F,$,V,G,H=!0){let K=(0,ea._1)(F,"v","movingAverage"),Z=(0,ea._1)($,"x","movingAverage"),et=(0,ea._1)(V,"decay","movingAverage");(0,nR.assertTypesMatch)(K,Z),ei.hu(ei.cO(K.shape,Z.shape),()=>"Shape mismatch in v and x");let en=(0,rG.i)(1),eo=(0,rt.l)(en,et),es=(0,eT.d)((0,rt.l)(Z,K),eo);if(H){ei.hu(null!=G,()=>"When using zeroDebias: true, step is required.");let F=(0,ea._1)(G,"step","movingAverage");es=(0,tn.h)(es,(0,rt.l)(en,(0,rx.s)(et,F)))}return(0,ee.I)(K,es)}let nF=(0,eo.op)({movingAverage_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scatterND_(F,$,V){(0,ei.Mu)(V);let G=(0,ea._1)(F,"indices","scatterND","int32"),H=(0,ea._1)($,"updates","scatterND");ng.validateInput(H,G,V);let K={indices:G,updates:H},Z={shape:V};return et.BV.runKernel(en.xQA,K,Z)}let nO=(0,eo.op)({scatterND_});function validateInput(F,$,V,G){if("int32"!==F.dtype)throw Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${F.dtype}.`);if(F.rank>2)throw Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${F.shape}.`);let H=F.rank>0?F.shape[0]:1,K=F.rank>1?F.shape[1]:1;if(V.length!==K)throw Error(`outputShape has incorrect number of elements:, ${V.length}, should be: ${K}.`);let Z=$.size;if(!(0===$.rank||1===$.rank&&Z===H))throw Error(`sparseValues has incorrect shape ${$.shape}, should be [] or [${H}]`);if($.dtype!==G.dtype)throw Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseToDense_(F,$,V,G=0){(0,ei.Mu)(V);let H=(0,ea._1)(F,"sparseIndices","sparseToDense","int32"),K=(0,ea._1)($,"sparseValues","sparseToDense","string_or_numeric"),Z=(0,ea._1)(G,"defaultValue","sparseToDense",K.dtype);validateInput(H,K,V,Z);let ee={sparseIndices:H,sparseValues:K,defaultValue:Z},eo={outputShape:V};return et.BV.runKernel(en.D2d,ee,eo)}let nP=(0,eo.op)({sparseToDense_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherND_(F,$){let V=(0,ea._1)($,"indices","gatherND","int32"),G=(0,ea._1)(F,"x","gatherND","string_or_numeric"),H={params:G,indices:V};return et.BV.runKernel(en.q1x,H)}let nB=(0,eo.op)({gatherND_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getNoiseShape(F,$){if(null==$)return F.shape.slice();if(ei.cO(F.shape,$))return $;if(F.shape.length===$.length){let V=[];for(let G=0;G<F.shape.length;G++)null==$[G]&&null!=F.shape[G]?V.push(F.shape[G]):V.push($[G]);return V}return $}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dropout_(F,$,V,G){let H=(0,ea._1)(F,"x","dropout");if(ei.hu("float32"===H.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${H.dtype} tensor instead.`),ei.hu($>=0&&$<1,()=>`rate must be a float in the range [0, 1), but got ${$}.`),0===$)return F instanceof tJ.es?H.clone():H;let K=getNoiseShape(H,V),Z=1-$,et=(0,tn.h)((0,tS.G)((0,ee.I)(rD(K,0,1,"float32",G),Z)),Z);return(0,eT.d)(H,et)}let n$=(0,eo.op)({dropout_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function enclosingPowerOfTwo(F){return Math.floor(Math.pow(2,Math.ceil(Math.log(F)/Math.log(2))))}function cosineWindow(F,$,V){let G=1-F%2,H=new Float32Array(F);for(let K=0;K<F;++K){let Z=2*Math.PI*K/(F+G-1);H[K]=$-V*Math.cos(Z)}return tensor1d(H,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function inTopKAsync_(F,$,V=1){let G=(0,ea._1)(F,"predictions","inTopK"),H=(0,ea._1)($,"targets","inTopK");(0,ei.hu)(G.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${G.rank}`),(0,ei.hu)(G.rank-1===H.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${G.rank} and targets rank ${H.rank}`),(0,ei.k5)(G.shape.slice(0,G.shape.length-1),H.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let K=G.shape[G.shape.length-1];(0,ei.hu)(V>0&&V<=K,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${K}), but got ${V}`);let Z=await G.data(),ee=await H.data(),[et,en]=[Z.length/K,K],eo=(0,ei.WP)("bool",et);for(let F=0;F<et;F++){let $=F*en,G=Z.subarray($,$+en),H=[];for(let F=0;F<G.length;F++)H.push({value:G[F],index:F});H.sort((F,$)=>$.value-F.value),eo[F]=0;for(let $=0;$<V;$++)if(H[$].index===ee[F]){eo[F]=1;break}}return F!==G&&G.dispose(),$!==H&&H.dispose(),(0,nh.X)(eo,H.shape,"bool")}let nL=inTopKAsync_;var nV=V(30633),nU=V(72200),nW=V(36013),nj=V(39832),nG=V(19323);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedConv2d_({x:F,filter:$,strides:V,pad:G,dataFormat:H="NHWC",dilations:K=[1,1],dimRoundingMode:Z,bias:eo,activation:es="linear",preluActivationWeights:eu,leakyreluAlpha:ec}){let ep,eh;if(es=es||"linear",!1===(0,nG.uy)(et.BV.state.gradientDepth,es)){ei.hu("NHWC"===H,()=>`Error in fused conv2d: got dataFormat of ${H} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let et=(0,eY.T)(F,$,V,G,H,K,Z);return null!=eo&&(et=(0,ee.I)(et,eo)),(0,nG.QH)(et,es,eu,ec)}let ef=(0,ea._1)(F,"x","conv2d","float32"),ed=(0,ea._1)($,"filter","conv2d","float32"),em=ef,eg=!1;3===ef.rank&&(eg=!0,em=(0,e_.X)(ef,[1,ef.shape[0],ef.shape[1],ef.shape[2]])),ei.hu(4===em.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${em.rank}.`),ei.hu(4===ed.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${ed.rank}.`),eS.m("fused conv2d",G,Z);let ey="NHWC"===H?em.shape[3]:em.shape[1];ei.hu(ed.shape[2]===ey,()=>`Error in conv2d: depth of input (${ey}) must match input depth for filter ${ed.shape[2]}.`),ei.hu(eS.jT(V,K),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${V} and dilations '${K}'`);let eb=eS.Ix(em.shape,ed.shape,V,K,G,Z);if(null!=eo&&(ep=(0,ea._1)(eo,"bias","fused conv2d"),[ep]=(0,nR.makeTypesMatch)(ep,ef),"NHWC"===H?nU.assertAndGetBroadcastShape(eb.outShape,ep.shape):(ei.hu(ep.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${ep.shape.length}.`),ei.hu(0===ep.shape.length||ep.shape[0]===eb.outChannels||1===ep.shape[0],()=>`Error in fused conv2d: bias shape (${ep.shape}) is not compatible with the number of output channels (${eb.outChannels})`))),null!=eu){let F=eu.shape;if(ei.hu(F.length<=1||3===F.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${F.length}.`),1===F.length)ei.hu(1===F[0]||F[0]===eb.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${F}) is not compatible with the number of output channels (${eb.outChannels}).`);else if(3===F.length)try{nU.assertAndGetBroadcastShape(F,eb.outShape)}catch(V){let $=`Error in fused conv2d: PReLU activation weights (${F}) is not compatible with the output shape of the conv2d (${eb.outShape}).`;throw Error($)}eh=(0,ea._1)(eu,"prelu weights","fused conv2d")}let grad=(F,$)=>{ei.hu("NHWC"===H,()=>`Error in gradient of fused conv2D: got dataFormat of ${H} but only NHWC is currently supported.`);let[Z,ee,et,en]=$,ea=(0,nG.Fr)(F,et,es);ei.hu(eS.I0(K),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${K}'`);let eo=(0,nj._)(ee.shape,ea,Z,V,G),eu=(0,nW.p)(ee,ea,Z.shape,V,G),ec=[eo,eu];if(null!=en){let F=(0,nG.pf)(en,ea);ec.push(F)}return ec},ew={x:em,filter:ed,bias:ep,preluActivationWeights:eh},eN={strides:V,pad:G,dataFormat:H,dilations:K,dimRoundingMode:Z,activation:es,leakyreluAlpha:ec};if(null==eo){let F=(0,nV.cb)((F,$,V)=>{let G=et.BV.runKernel(en._V0,ew,eN);return V([$,F,G]),eg&&(G=(0,e_.X)(G,[G.shape[1],G.shape[2],G.shape[3]])),{value:G,gradFunc:grad}});return F(em,ed)}{let F=(0,nV.cb)((F,$,V,G)=>{let H=et.BV.runKernel(en._V0,ew,eN);return G([$,F,H,V]),eg&&(H=(0,e_.X)(H,[H.shape[1],H.shape[2],H.shape[3]])),{value:H,gradFunc:grad}});return F(em,ed,ep)}}let nq=(0,eo.op)({fusedConv2d_});var nH=V(88098),nX=V(54375);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedDepthwiseConv2d_({x:F,filter:$,strides:V,pad:G,dataFormat:H="NHWC",dilations:K=[1,1],dimRoundingMode:Z,bias:eo,activation:es="linear",preluActivationWeights:eu,leakyreluAlpha:ec}){let ep,eh;if(!1===(0,nG.uy)(et.BV.state.gradientDepth,es)){let et=(0,te.B)(F,$,V,G,H,K,Z);return null!=eo&&(et=(0,ee.I)(et,eo)),(0,nG.QH)(et,es,eu,ec)}let ef=(0,ea._1)(F,"x","depthwiseConv2d","float32"),ed=(0,ea._1)($,"filter","depthwiseConv2d","float32"),em=ef,eg=!1;3===ef.rank&&(eg=!0,em=(0,e_.X)(ef,[1,ef.shape[0],ef.shape[1],ef.shape[2]])),ei.hu(4===em.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${em.rank}.`),ei.hu(4===ed.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${ed.rank}.`),ei.hu(em.shape[3]===ed.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${em.shape[3]}) must match the inChannels dimension in filter ${ed.shape[2]}.`),null==K&&(K=[1,1]),ei.hu(eS.jT(V,K),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${V} and dilations '${K}'`),eS.m("fused depthwiseConv2d",G,Z);let ey=eS.Ix(em.shape,ed.shape,V,K,G,Z,!0);null!=eo&&(ep=(0,ea._1)(eo,"bias","fused conv2d"),[ep]=(0,nR.makeTypesMatch)(ep,ef),nU.assertAndGetBroadcastShape(ey.outShape,ep.shape)),null!=eu&&(eh=(0,ea._1)(eu,"prelu weights","fused depthwiseConv2d"));let grad=(F,$)=>{ei.hu(eS.I0(K),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${K}'`);let[H,ee,et,en]=$,ea=(0,nG.Fr)(F,et,es),eo=(0,nX.v)(ee.shape,ea,H,V,G,K,Z),eu=(0,nH.z)(ee,ea,H.shape,V,G,K,Z);if(null!=en){let F=(0,nG.pf)(ep,ea);return[eo,eu,F]}return[eo,eu]},eb={x:em,filter:ed,bias:ep,preluActivationWeights:eh},ew={strides:V,pad:G,dataFormat:H,dilations:K,dimRoundingMode:Z,activation:es,leakyreluAlpha:ec};if(null==eo){let F=(0,nV.cb)((F,$,V)=>{let G=et.BV.runKernel(en.luS,eb,ew);return V([$,F,G]),eg&&(G=(0,e_.X)(G,[G.shape[1],G.shape[2],G.shape[3]])),{value:G,gradFunc:grad}});return F(em,ed)}{let F=(0,nV.cb)((F,$,V,G)=>{let H=et.BV.runKernel(en.luS,eb,ew);return G([$,F,H,V]),eg&&(H=(0,e_.X)(H,[H.shape[1],H.shape[2],H.shape[3]])),{value:H,gradFunc:grad}});return F(em,ed,ep)}}let nK=(0,eo.op)({fusedDepthwiseConv2d_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedMatMul_({a:F,b:$,transposeA:V=!1,transposeB:G=!1,bias:H,activation:K="linear",preluActivationWeights:Z,leakyreluAlpha:eo=.2}){let es,eu;if(!1===(0,nG.uy)(et.BV.state.gradientDepth,K)){let et=(0,eI.O)(F,$,V,G);return null!=H&&(et=(0,ee.I)(et,H)),(0,nG.QH)(et,K,Z,eo)}let ec=(0,ea._1)(F,"a","fused matMul"),ep=(0,ea._1)($,"b","fused matMul");[ec,ep]=(0,nR.makeTypesMatch)(ec,ep);let eh=V?ec.shape[ec.rank-2]:ec.shape[ec.rank-1],ef=G?ep.shape[ep.rank-1]:ep.shape[ep.rank-2],ed=V?ec.shape[ec.rank-1]:ec.shape[ec.rank-2],em=G?ep.shape[ep.rank-2]:ep.shape[ep.rank-1],eg=ec.shape.slice(0,-2),ey=ep.shape.slice(0,-2),eb=ei.NA(eg),ew=ei.NA(ey);ei.hu(eh===ef,()=>`Error in fused matMul: inner shapes (${eh}) and (${ef}) of Tensors with shapes ${ec.shape} and ${ep.shape} and transposeA=${V} and transposeB=${G} must match.`);let eS=nU.assertAndGetBroadcastShape(ec.shape.slice(0,-2),ep.shape.slice(0,-2)),eN=eS.concat([ed,em]),ek=V?(0,e_.X)(ec,[eb,eh,ed]):(0,e_.X)(ec,[eb,ed,eh]),eT=G?(0,e_.X)(ep,[ew,em,ef]):(0,e_.X)(ep,[ew,ef,em]);null!=H&&(es=(0,ea._1)(H,"bias","fused matMul"),[es]=(0,nR.makeTypesMatch)(es,ec),nU.assertAndGetBroadcastShape(eN,es.shape)),null!=Z&&(eu=(0,ea._1)(Z,"prelu weights","fused matMul"));let grad=(F,$)=>{let Z,ee;let[et,en,ea,ei]=$,eo=(0,nG.Fr)((0,e_.X)(F,ea.shape),ea,K);if(V||G?!V&&G?(Z=(0,eI.O)(eo,en,!1,!1),ee=(0,eI.O)(eo,et,!0,!1)):V&&!G?(Z=(0,eI.O)(en,eo,!1,!0),ee=(0,eI.O)(et,eo,!1,!1)):(Z=(0,eI.O)(en,eo,!0,!0),ee=(0,eI.O)(eo,et,!0,!0)):(Z=(0,eI.O)(eo,en,!1,!0),ee=(0,eI.O)(et,eo,!0,!1)),null==H)return[Z,ee];{let F=(0,nG.pf)(ei,eo);return[Z,ee,F]}},eC={a:ek,b:eT,bias:es,preluActivationWeights:eu},eE={transposeA:V,transposeB:G,activation:K,leakyreluAlpha:eo};if(null==H){let F=(0,nV.cb)((F,$,V)=>{let G=et.BV.runKernel(en.usg,eC,eE);return V([F,$,G]),{value:(0,e_.X)(G,eN),gradFunc:grad}});return F(ek,eT)}{let F=(0,nV.cb)((F,$,V,G)=>{let H=et.BV.runKernel(en.usg,eC,eE);return G([F,$,H,V]),{value:(0,e_.X)(H,eN),gradFunc:grad}});return F(ek,eT,es)}}let nQ=(0,eo.op)({fusedMatMul_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hammingWindow_(F){return cosineWindow(F,.54,.46)}let nZ=(0,eo.op)({hammingWindow_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hannWindow_(F){return cosineWindow(F,.5,.5)}let nY=(0,eo.op)({hannWindow_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function frame_(F,$,V,G=!1,H=0){let K=0,Z=[];for(;K+$<=F.size;)Z.push((0,eE.t)(F,K,$)),K+=V;if(G)for(;K<F.size;){let G=K+$-F.size,ee=(0,ek.z)([(0,eE.t)(F,K,$-G),(0,tw.h)([G],H)]);Z.push(ee),K+=V}return 0===Z.length?tensor2d([],[0,$]):(0,e_.X)((0,ek.z)(Z),[Z.length,$])}let nJ=(0,eo.op)({frame_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stft_(F,$,V,G,H=nY){null==G&&(G=enclosingPowerOfTwo($));let K=nJ(F,$,V),Z=(0,eT.d)(K,H($));return(0,r7.Q)(Z,G)}let n3=(0,eo.op)({stft_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cropAndResize_(F,$,V,G,H="bilinear",K=0){let Z=(0,ea._1)(F,"image","cropAndResize"),ee=(0,ea._1)($,"boxes","cropAndResize","float32"),eo=(0,ea._1)(V,"boxInd","cropAndResize","int32"),es=ee.shape[0];ei.hu(4===Z.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${Z.rank}.`),ei.hu(2===ee.rank&&4===ee.shape[1],()=>`Error in cropAndResize: boxes must be have size [${es},4] but had shape ${ee.shape}.`),ei.hu(1===eo.rank&&eo.shape[0]===es,()=>`Error in cropAndResize: boxInd must be have size [${es}] but had shape ${ee.shape}.`),ei.hu(2===G.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${G.length}.`),ei.hu(G[0]>=1&&G[1]>=1,()=>`cropSize must be atleast [1,1], but was ${G}`),ei.hu("bilinear"===H||"nearest"===H,()=>`method must be bilinear or nearest, but was ${H}`);let eu={image:Z,boxes:ee,boxInd:eo},ec={method:H,extrapolationValue:K,cropSize:G},ep=et.BV.runKernel(en.VcC,eu,ec);return ep}let n4=(0,eo.op)({cropAndResize_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function flipLeftRight_(F){let $=(0,ea._1)(F,"image","flipLeftRight","float32");ei.hu(4===$.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${$.rank}.`);let V={image:$},G=et.BV.runKernel(en.Uyb,V,{});return G}let n6=(0,eo.op)({flipLeftRight_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function grayscaleToRGB_(F){let $=(0,ea._1)(F,"image","grayscaleToRGB"),V=$.rank-1,G=$.shape[V];ei.hu($.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${$.rank}.`),ei.hu(1===G,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${G}.`);let H=Array($.rank);return H.fill(1,0,V),H[V]=3,(0,tb.G)($,H)}let n5=(0,eo.op)({grayscaleToRGB_});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rgbToGrayscale_(F){let $;let V=(0,ea._1)(F,"image","RGBToGrayscale"),G=V.rank-1,H=V.shape[G];ei.hu(V.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${V.rank}.`),ei.hu(3===H,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${H}.`);let K=V.dtype,Z=(0,ew.p)(V,"float32"),ee=tensor1d([.2989,.587,.114]);switch(V.rank){case 2:$=ts("ij,j->i",Z,ee);break;case 3:$=ts("ijk,k->ij",Z,ee);break;case 4:$=ts("ijkl,l->ijk",Z,ee);break;case 5:$=ts("ijklm,m->ijkl",Z,ee);break;case 6:$=ts("ijklmn,n->ijklm",Z,ee);break;default:throw Error("Not a valid tensor rank.")}return $=(0,tg.d)($,-1),(0,ew.p)($,K)}let n9=(0,eo.op)({rgbToGrayscale_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rotateWithOffset_(F,$,V=0,G=.5){let H=(0,ea._1)(F,"image","rotateWithOffset","float32");ei.hu(4===H.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${H.rank}.`);let K={image:H},Z={radians:$,fillValue:V,center:G},ee=et.BV.runKernel(en.b9H,K,Z);return ee}let n8=(0,eo.op)({rotateWithOffset_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppSanityCheck(F,$,V,G,H,K){null==G&&(G=.5),null==H&&(H=Number.NEGATIVE_INFINITY),null==K&&(K=0);let Z=F.shape[0];return V=Math.min(V,Z),ei.hu(0<=G&&G<=1,()=>`iouThreshold must be in [0, 1], but was '${G}'`),ei.hu(2===F.rank,()=>`boxes must be a 2D tensor, but was of rank '${F.rank}'`),ei.hu(4===F.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${F.shape[1]}`),ei.hu(1===$.rank,()=>"scores must be a 1D tensor"),ei.hu($.shape[0]===Z,()=>`scores has incompatible shape with boxes. Expected ${Z}, but was ${$.shape[0]}`),ei.hu(0<=K&&K<=1,()=>`softNmsSigma must be in [0, 1], but was '${K}'`),{maxOutputSize:V,iouThreshold:G,scoreThreshold:H,softNmsSigma:K}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppression_(F,$,V,G=.5,H=Number.NEGATIVE_INFINITY){let K=(0,ea._1)(F,"boxes","nonMaxSuppression","float32"),Z=(0,ea._1)($,"scores","nonMaxSuppression","float32"),ee=nonMaxSuppSanityCheck(K,Z,V,G,H);V=ee.maxOutputSize,G=ee.iouThreshold,H=ee.scoreThreshold;let ei={maxOutputSize:V,iouThreshold:G,scoreThreshold:H};return et.BV.runKernel(en.uv1,{boxes:K,scores:Z},ei)}let n7=(0,eo.op)({nonMaxSuppression_});var ae=V(68329);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nonMaxSuppressionAsync_(F,$,V,G=.5,H=Number.NEGATIVE_INFINITY){let K=(0,ea._1)(F,"boxes","nonMaxSuppressionAsync"),Z=(0,ea._1)($,"scores","nonMaxSuppressionAsync"),ee=nonMaxSuppSanityCheck(K,Z,V,G,H);V=ee.maxOutputSize,G=ee.iouThreshold,H=ee.scoreThreshold;let et=await Promise.all([K.data(),Z.data()]),en=et[0],ei=et[1],{selectedIndices:eo}=(0,ae.GP)(en,ei,V,G,H);return K!==F&&K.dispose(),Z!==$&&Z.dispose(),tensor1d(eo,"int32")}let ar=nonMaxSuppressionAsync_;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppressionWithScore_(F,$,V,G=.5,H=Number.NEGATIVE_INFINITY,K=0){let Z=(0,ea._1)(F,"boxes","nonMaxSuppression"),ee=(0,ea._1)($,"scores","nonMaxSuppression"),ei=nonMaxSuppSanityCheck(Z,ee,V,G,H,K);V=ei.maxOutputSize,G=ei.iouThreshold,H=ei.scoreThreshold,K=ei.softNmsSigma;let eo={boxes:Z,scores:ee},es={maxOutputSize:V,iouThreshold:G,scoreThreshold:H,softNmsSigma:K},eu=et.BV.runKernel(en.W0H,eo,es);return{selectedIndices:eu[0],selectedScores:eu[1]}}let an=(0,eo.op)({nonMaxSuppressionWithScore_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nonMaxSuppressionWithScoreAsync_(F,$,V,G=.5,H=Number.NEGATIVE_INFINITY,K=0){let Z=(0,ea._1)(F,"boxes","nonMaxSuppressionAsync"),ee=(0,ea._1)($,"scores","nonMaxSuppressionAsync"),et=nonMaxSuppSanityCheck(Z,ee,V,G,H,K);V=et.maxOutputSize,G=et.iouThreshold,H=et.scoreThreshold,K=et.softNmsSigma;let en=await Promise.all([Z.data(),ee.data()]),ei=en[0],eo=en[1],{selectedIndices:es,selectedScores:eu}=(0,ae.pA)(ei,eo,V,G,H,K);return Z!==F&&Z.dispose(),ee!==$&&ee.dispose(),{selectedIndices:tensor1d(es,"int32"),selectedScores:tensor1d(eu)}}let aa=nonMaxSuppressionWithScoreAsync_;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppressionPadded_(F,$,V,G=.5,H=Number.NEGATIVE_INFINITY,K=!1){let Z=(0,ea._1)(F,"boxes","nonMaxSuppression"),ee=(0,ea._1)($,"scores","nonMaxSuppression"),ei=nonMaxSuppSanityCheck(Z,ee,V,G,H,null),eo=ei.maxOutputSize,es=ei.iouThreshold,eu=ei.scoreThreshold,ec={boxes:Z,scores:ee},ep={maxOutputSize:eo,iouThreshold:es,scoreThreshold:eu,padToMaxOutputSize:K},eh=et.BV.runKernel(en.cye,ec,ep);return{selectedIndices:eh[0],validOutputs:eh[1]}}let ai=(0,eo.op)({nonMaxSuppressionPadded_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nonMaxSuppressionPaddedAsync_(F,$,V,G=.5,H=Number.NEGATIVE_INFINITY,K=!1){let Z=(0,ea._1)(F,"boxes","nonMaxSuppressionAsync"),ee=(0,ea._1)($,"scores","nonMaxSuppressionAsync"),et=nonMaxSuppSanityCheck(Z,ee,V,G,H,null),en=et.maxOutputSize,ei=et.iouThreshold,eo=et.scoreThreshold,[es,eu]=await Promise.all([Z.data(),ee.data()]),{selectedIndices:ec,validOutputs:ep}=(0,ae.qP)(es,eu,en,ei,eo,K);return Z!==F&&Z.dispose(),ee!==$&&ee.dispose(),{selectedIndices:tensor1d(ec,"int32"),validOutputs:(0,rG.i)(ep,"int32")}}let ao=nonMaxSuppressionPaddedAsync_;var as=V(13305),au=V(95098);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function threshold_(F,$="binary",V=!1,G=.5){let H,K,Z,et;let en=(0,ea._1)(F,"image","threshold"),eo=.2989,es=.587,eu=.114,ec=en.shape[0]*en.shape[1],ep=(0,eT.d)(tensor1d([G]),255);if(ei.hu(3===en.rank,()=>`Error in threshold: image must be rank 3,but got rank ${en.rank}.`),ei.hu(3===en.shape[2]||1===en.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${en.shape[2]}.`),ei.hu("int32"===en.dtype||"float32"===en.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${en.dtype}.`),ei.hu("otsu"===$||"binary"===$,()=>`Method must be binary or otsu, but was ${$}`),3===en.shape[2]){[H,K,Z]=(0,ne.V)(en,[1,1,1],-1);let F=(0,eT.d)(H,eo),$=(0,eT.d)(K,es),V=(0,eT.d)(Z,eu);et=(0,ee.I)((0,ee.I)(F,$),V)}else et=F;if("otsu"===$){let F=eB((0,ew.p)((0,rW.N)(et),"int32"),(0,nh.X)([]),256);ep=otsu(F,ec)}let eh=V?(0,tR.z)(et,ep):(0,tk.p)(et,ep),ef=(0,ew.p)((0,eT.d)(eh,255),"int32");return ef}function otsu(F,$){let V,G,H,K,Z,et,en=tensor1d([-1]),ea=tensor1d([0]),ei=tensor1d([0]);for(let eo=0;eo<F.size-1;eo++){V=(0,eE.t)(F,0,eo+1),G=(0,eE.t)(F,eo+1),Z=(0,tn.h)((0,nl.S)(V),$),et=(0,tn.h)((0,nl.S)(G),$);let es=(0,nl.S)((0,eT.d)(V,range(0,V.size)));H=(0,tn.h)(es,(0,nl.S)(V));let eu=(0,tw.h)(G.shape,V.size),ec=(0,ee.I)(range(0,G.size),eu),ep=(0,eT.d)(G,ec);K=(0,tn.h)((0,nl.S)(ep),(0,nl.S)(G));let eh=(0,rt.l)(H,K),ef=(0,rt.l)(H,K),ed=(0,eT.d)(Z,et);ei=(0,eT.d)((0,eT.d)(ed,eh),ef);let em=(0,tk.p)(ei,ea);ea=(0,nk.a)(em,ei,ea),en=(0,nk.a)(em,tensor1d([eo]),en)}return en}let ac=(0,eo.op)({threshold_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transform_(F,$,V="nearest",G="constant",H=0,K){let Z=(0,ea._1)(F,"image","transform","float32"),ee=(0,ea._1)($,"transforms","transform","float32");ei.hu(4===Z.rank,()=>`Error in transform: image must be rank 4,but got rank ${Z.rank}.`),ei.hu(2===ee.rank&&(ee.shape[0]===Z.shape[0]||1===ee.shape[0])&&8===ee.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),ei.hu(null==K||2===K.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${K}.`);let eo={image:Z,transforms:ee},es={interpolation:V,fillMode:G,fillValue:H,outputShape:K};return et.BV.runKernel(en.wx7,eo,es)}let ap=(0,eo.op)({transform_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bandPart_(F,$,V){let G,H;let K=(0,ea._1)(F,"a","bandPart");(0,ei.hu)(K.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${K.rank}.`);let Z=K.shape,[ee,et]=K.shape.slice(-2);"number"==typeof $?((0,ei.hu)($%1==0,()=>`bandPart(): numLower must be an integer, got ${$}.`),(0,ei.hu)($<=ee,()=>`bandPart(): numLower (${$}) must not be greater than the number of rows (${ee}).`),G=(0,ea._1)($<0?ee:$,"numLower","bandPart")):((0,ei.hu)("int32"===$.dtype,()=>"bandPart(): numLower's dtype must be an int32."),G=(0,nk.a)((0,tM.d)($,0),ee,(0,t6.L)($,ee))),"number"==typeof V?((0,ei.hu)(V%1==0,()=>`bandPart(): numUpper must be an integer, got ${V}.`),(0,ei.hu)(V<=et,()=>`bandPart(): numUpper (${V}) must not be greater than the number of columns (${et}).`),H=(0,ea._1)(V<0?et:V,"numUpper","bandPart")):((0,ei.hu)("int32"===V.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),H=(0,nk.a)((0,tM.d)(V,0),et,(0,t6.L)(V,et)));let en=(0,e_.X)(range(0,ee,1,"int32"),[-1,1]),eo=range(0,et,1,"int32"),es=(0,rt.l)(en,eo),eu=(0,tz.H)((0,tR.z)(es,G),(0,tI.b)(es,(0,ro.W)(H))),ec=(0,nC.l)([ee,et],K.dtype);return(0,e_.X)((0,ni.k)((0,nN.H)((0,e_.X)(K,[-1,ee,et])).map(F=>(0,nk.a)(eu,F,ec))),Z)}let ad=(0,eo.op)({bandPart_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gramSchmidt_(F){let $;if(Array.isArray(F)){$=!1,(0,ei.hu)(null!=F&&F.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let V=F[0].shape[0];for(let $=1;$<F.length;++$)(0,ei.hu)(F[$].shape[0]===V,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${F[$].shape[0]} vs. ${V})`)}else $=!0,F=(0,ne.V)(F,F.shape[0],0).map(F=>(0,nn.L)(F,[0]));(0,ei.hu)(F.length<=F[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${F.length}) exceeds number of dimensions (${F[0].shape[0]}).`);let V=[],G=F;for(let $=0;$<F.length;++$)V.push(et.BV.tidy(()=>{let F=G[$];if($>0)for(let G=0;G<$;++G){let $=(0,eT.d)((0,nl.S)((0,eT.d)(V[G],F)),V[G]);F=(0,rt.l)(F,$)}return(0,tn.h)(F,(0,nM.K)(F,"euclidean"))}));return $?(0,ni.k)(V,0):V}let am=(0,eo.op)({gramSchmidt_});var ag=V(4368);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qr_(F,$=!1){if((0,ei.hu)(F.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${F.rank}`),2===F.rank)return qr2d(F,$);{let V=F.shape.slice(0,F.shape.length-2).reduce((F,$)=>F*$),G=(0,nN.H)((0,e_.X)(F,[V,F.shape[F.shape.length-2],F.shape[F.shape.length-1]]),0),H=[],K=[];G.forEach(F=>{let[V,G]=qr2d(F,$);H.push(V),K.push(G)});let Z=(0,e_.X)((0,ni.k)(H,0),F.shape),ee=(0,e_.X)((0,ni.k)(K,0),F.shape);return[Z,ee]}}function qr2d(F,$=!1){return et.BV.tidy(()=>{(0,ei.hu)(2===F.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${F.shape.length}D Tensor.`);let V=F.shape[0],G=F.shape[1],H=tv(V),K=(0,ej.d)(F),Z=tensor2d([[1]],[1,1]),ee=(0,ej.d)(Z),en=V>=G?G:V;for(let F=0;F<en;++F){let $=K,en=ee,ea=H;[ee,K,H]=et.BV.tidy(()=>{let $=(0,eE.t)(K,[F,F],[V-F,1]),et=(0,nM.K)($),en=(0,eE.t)(K,[F,F],[1,1]),ea=(0,nk.a)((0,tk.p)(en,0),tensor2d([[-1]]),tensor2d([[1]])),ei=(0,rt.l)(en,(0,eT.d)(ea,et)),eo=(0,tn.h)($,ei);ee=1===eo.shape[0]?(0,ej.d)(Z):(0,ek.z)([Z,(0,eE.t)(eo,[1,0],[eo.shape[0]-1,eo.shape[1]])],0);let es=(0,ro.W)((0,tn.h)((0,eI.O)(ea,ei),et)),eu=(0,eE.t)(K,[F,0],[V-F,G]),ec=(0,eT.d)(es,ee),ep=(0,nD.p)(ee);if(0===F)K=(0,rt.l)(eu,(0,eI.O)(ec,(0,eI.O)(ep,eu)));else{let $=(0,rt.l)(eu,(0,eI.O)(ec,(0,eI.O)(ep,eu)));K=(0,ek.z)([(0,eE.t)(K,[0,0],[F,G]),$],0)}let eh=(0,nD.p)(ec),ef=(0,eE.t)(H,[0,F],[V,H.shape[1]-F]);if(0===F)H=(0,rt.l)(ef,(0,eI.O)((0,eI.O)(ef,ee),eh));else{let $=(0,rt.l)(ef,(0,eI.O)((0,eI.O)(ef,ee),eh));H=(0,ek.z)([(0,eE.t)(H,[0,0],[V,F]),$],1)}return[ee,K,H]}),(0,ag.B9)([$,en,ea])}return!$&&V>G&&(H=(0,eE.t)(H,[0,0],[V,G]),K=(0,eE.t)(K,[0,0],[G,G])),[H,K]})}let ay=(0,eo.op)({qr_});var ab=V(49876);function computeWeightedLoss_(F,$,V=ab.I.SUM_BY_NONZERO_WEIGHTS){let G=(0,ea._1)(F,"losses","computeWeightedLoss"),H=null;null!=$&&(H=(0,ea._1)($,"weights","computeWeightedLoss"));let K=null==H?G:(0,eT.d)(G,H);if(V===ab.I.NONE)return K;if(V===ab.I.SUM)return(0,nl.S)(K);if(V===ab.I.MEAN){if(null==H)return(0,tZ.J)(K);{let F=G.size/H.size,$=(0,tn.h)((0,nl.S)(K),(0,nl.S)(H));return F>1?(0,tn.h)($,(0,rG.i)(F)):$}}if(V===ab.I.SUM_BY_NONZERO_WEIGHTS){if(null==H)return(0,tn.h)((0,nl.S)(K),(0,rG.i)(G.size));{let F=(0,eT.d)(H,(0,tY.i)(G.shape)),$=(0,ew.p)((0,nl.S)((0,rs.Q)(F,(0,rG.i)(0))),"float32");return(0,tn.h)((0,nl.S)(K),$)}}throw Error(`Unknown reduction: ${V}`)}let aw=(0,eo.op)({computeWeightedLoss_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function absoluteDifference_(F,$,V,G=ab.I.SUM_BY_NONZERO_WEIGHTS){let K=(0,ea._1)(F,"labels","absoluteDifference"),Z=(0,ea._1)($,"predictions","absoluteDifference"),ee=null;null!=V&&(ee=(0,ea._1)(V,"weights","absoluteDifference")),(0,ei.k5)(K.shape,Z.shape,"Error in absoluteDifference: ");let et=(0,H.W)((0,rt.l)(K,Z));return aw(et,ee,G)}let aS=(0,eo.op)({absoluteDifference_});function cosineDistance_(F,$,V,G,H=ab.I.SUM_BY_NONZERO_WEIGHTS){let K=(0,ea._1)(F,"labels","cosineDistance"),Z=(0,ea._1)($,"predictions","cosineDistance"),ee=null;null!=G&&(ee=(0,ea._1)(G,"weights","cosineDistance")),(0,ei.k5)(K.shape,Z.shape,"Error in cosineDistance: ");let et=(0,rG.i)(1),en=(0,rt.l)(et,(0,nl.S)((0,eT.d)(K,Z),V,!0));return aw(en,ee,H)}let a_=(0,eo.op)({cosineDistance_});function hingeLoss_(F,$,V,G=ab.I.SUM_BY_NONZERO_WEIGHTS){let H=(0,ea._1)(F,"labels","hingeLoss"),K=(0,ea._1)($,"predictions","hingeLoss"),Z=null;null!=V&&(Z=(0,ea._1)(V,"weights","hingeLoss")),(0,ei.k5)(H.shape,K.shape,"Error in hingeLoss: ");let ee=(0,rG.i)(1);H=(0,rt.l)((0,eT.d)((0,rG.i)(2),H),ee);let et=(0,rO.U)((0,rt.l)(ee,(0,eT.d)(H,K)));return aw(et,Z,G)}let aN=(0,eo.op)({hingeLoss_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function huberLoss_(F,$,V,G=1,K=ab.I.SUM_BY_NONZERO_WEIGHTS){let Z=(0,ea._1)(F,"labels","huberLoss"),et=(0,ea._1)($,"predictions","huberLoss"),en=null;null!=V&&(en=(0,ea._1)(V,"weights","huberLoss")),(0,ei.k5)(Z.shape,et.shape,"Error in huberLoss: ");let eo=(0,rG.i)(G),es=(0,H.W)((0,rt.l)(et,Z)),eu=(0,t6.L)(es,eo),ec=(0,rt.l)(es,eu),ep=(0,ee.I)((0,eT.d)((0,rG.i)(.5),(0,t7.h)(eu)),(0,eT.d)(eo,ec));return aw(ep,en,K)}let ak=(0,eo.op)({huberLoss_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logLoss_(F,$,V,G=1e-7,H=ab.I.SUM_BY_NONZERO_WEIGHTS){let K=(0,ea._1)(F,"labels","logLoss"),Z=(0,ea._1)($,"predictions","logLoss"),et=null;null!=V&&(et=(0,ea._1)(V,"weights","logLoss")),(0,ei.k5)(K.shape,Z.shape,"Error in logLoss: ");let en=(0,rG.i)(1),eo=(0,rG.i)(G),es=(0,ro.W)((0,eT.d)(K,(0,tO.c)((0,ee.I)(Z,eo)))),eu=(0,eT.d)((0,rt.l)(en,K),(0,tO.c)((0,ee.I)((0,rt.l)(en,Z),eo))),ec=(0,rt.l)(es,eu);return aw(ec,et,H)}let aI=(0,eo.op)({logLoss_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function meanSquaredError_(F,$,V,G=ab.I.SUM_BY_NONZERO_WEIGHTS){let H=(0,ea._1)(F,"labels","meanSquaredError"),K=(0,ea._1)($,"predictions","meanSquaredError"),Z=null;null!=V&&(Z=(0,ea._1)(V,"weights","meanSquaredError")),(0,ei.k5)(H.shape,K.shape,"Error in meanSquaredError: ");let ee=(0,nr.$)(H,K);return aw(ee,Z,G)}let aT=(0,eo.op)({meanSquaredError_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sigmoidCrossEntropyWithLogits_(F,$){let V=(0,ea._1)(F,"labels","sigmoidCrossEntropyWithLogits"),G=(0,ea._1)($,"logits","sigmoidCrossEntropyWithLogits");(0,ei.k5)(V.shape,G.shape,"Error in sigmoidCrossEntropyWithLogits: ");let K=(0,rO.U)(G),Z=(0,eT.d)(G,V),et=(0,tP.K)((0,tm.Q)((0,ro.W)((0,H.W)(G))));return(0,ee.I)((0,rt.l)(K,Z),et)}function sigmoidCrossEntropy_(F,$,V,G=0,H=ab.I.SUM_BY_NONZERO_WEIGHTS){let K=(0,ea._1)(F,"multiClassLabels","sigmoidCrossEntropy"),Z=(0,ea._1)($,"logits","sigmoidCrossEntropy"),et=null;if(null!=V&&(et=(0,ea._1)(V,"weights","sigmoidCrossEntropy")),(0,ei.k5)(K.shape,Z.shape,"Error in sigmoidCrossEntropy: "),G>0){let F=(0,rG.i)(G),$=(0,rG.i)(1),V=(0,rG.i)(.5);K=(0,ee.I)((0,eT.d)(K,(0,rt.l)($,F)),(0,eT.d)(V,F))}let en=sigmoidCrossEntropyWithLogits_(K,Z);return aw(en,et,H)}let aC=(0,eo.op)({sigmoidCrossEntropy_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmaxCrossEntropyWithLogits_(F,$,V=-1){if(-1===V&&(V=$.rank-1),V!==$.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${$.rank} and dim was ${V}`);let G=(0,nV.cb)((F,$,G)=>{let H=!0,K=(0,tL.l)($,[V],H),Z=(0,rt.l)((0,ew.p)($,"float32"),K);G([F,Z]);let ee=(0,ro.W)((0,eT.d)(Z,F)),et=(0,nl.S)(ee,[V]),gradFunc=(F,$)=>{let[G,H]=$,K=(0,t8.rv)(F.shape,[V]);return[(0,eT.d)((0,e_.X)(F,K),(0,rt.l)((0,ew.p)(G,"float32"),(0,tm.Q)(H))),(0,eT.d)((0,e_.X)(F,K),(0,rt.l)((0,tm.Q)(H),(0,ew.p)(G,"float32")))]};return{value:et,gradFunc}});return G(F,$)}function softmaxCrossEntropy_(F,$,V,G=0,H=ab.I.SUM_BY_NONZERO_WEIGHTS){let K=(0,ea._1)(F,"onehotLabels","softmaxCrossEntropy"),Z=(0,ea._1)($,"logits","softmaxCrossEntropy"),et=null;if(null!=V&&(et=(0,ea._1)(V,"weights","softmaxCrossEntropy")),(0,ei.k5)(K.shape,Z.shape,"Error in softmaxCrossEntropy: "),G>0){let F=(0,rG.i)(G),$=(0,rG.i)(1),V=(0,rG.i)(K.shape[1]);K=(0,ee.I)((0,eT.d)(K,(0,rt.l)($,F)),(0,tn.h)(F,V))}let en=softmaxCrossEntropyWithLogits_(K,Z);return aw(en,et,H)}let aE=(0,eo.op)({softmaxCrossEntropy_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseFillEmptyRows_(F,$,V,G){let H=(0,ea._1)(F,"indices","sparseFillEmptyRows","int32"),K=(0,ea._1)($,"values","sparseFillEmptyRows"),Z=(0,ea._1)(V,"denseShape","sparseFillEmptyRows","int32"),ee=(0,ea._1)(G,"defaultValue","sparseFillEmptyRows",K.dtype);if(2!==H.rank)throw Error(`Indices should be Tensor2D but received shape
        ${H.shape}`);if(1!==K.rank)throw Error(`Values should be Tensor1D but received shape ${K.shape}`);if(1!==Z.rank)throw Error(`Dense shape should be Tensor1D but received shape ${Z.shape}`);if(0!==ee.rank)throw Error(`Default value should be a scalar but received shape ${ee.shape}`);let ei={indices:H,values:K,denseShape:Z,defaultValue:ee},eo=et.BV.runKernel(en.O3z,ei);return{outputIndices:eo[0],outputValues:eo[1],emptyRowIndicator:eo[2],reverseIndexMap:eo[3]}}let aA=(0,eo.op)({sparseFillEmptyRows_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseReshape_(F,$,V){let G=(0,ea._1)(F,"inputIndices","sparseReshape","int32"),H=(0,ea._1)($,"inputShape","sparseReshape","int32"),K=(0,ea._1)(V,"newShape","sparseReshape","int32");if(2!==G.rank)throw Error(`Input indices should be Tensor2D but received shape
        ${G.shape}`);if(1!==H.rank)throw Error(`Input shape should be Tensor1D but received shape ${H.shape}`);if(1!==K.rank)throw Error(`New shape should be Tensor1D but received shape ${K.shape}`);let Z={inputIndices:G,inputShape:H,newShape:K},ee=et.BV.runKernel(en.nhH,Z);return{outputIndices:ee[0],outputShape:ee[1]}}let aD=(0,eo.op)({sparseReshape_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentMean_(F,$,V){let G=(0,ea._1)(F,"data","sparseSegmentMean"),H=(0,ea._1)($,"indices","sparseSegmentMean","int32"),K=(0,ea._1)(V,"segmentIds","sparseSegmentMean","int32");if(G.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==H.rank)throw Error(`Indices should be Tensor1D but received shape
          ${H.shape}`);if(1!==K.rank)throw Error(`Segment ids should be Tensor1D but received shape
          ${K.shape}`);let Z={data:G,indices:H,segmentIds:K};return et.BV.runKernel(en.w3H,Z)}let aM=(0,eo.op)({sparseSegmentMean_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentSum_(F,$,V){let G=(0,ea._1)(F,"data","sparseSegmentSum"),H=(0,ea._1)($,"indices","sparseSegmentSum","int32"),K=(0,ea._1)(V,"segmentIds","sparseSegmentSum","int32");if(G.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==H.rank)throw Error(`Indices should be Tensor1D but received shape
         ${H.shape}`);if(1!==K.rank)throw Error(`Segment ids should be Tensor1D but received shape
         ${K.shape}`);let Z={data:G,indices:H,segmentIds:K};return et.BV.runKernel(en.ZjV,Z)}let aR=(0,eo.op)({sparseSegmentSum_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringNGrams_(F,$,V,G,H,K,Z,ee){let ei=(0,ea._1)(F,"data","stringNGrams","string");if("string"!==ei.dtype)throw Error("Data must be of datatype string");if(1!==ei.shape.length)throw Error(`Data must be a vector, saw: ${ei.shape}`);let eo=(0,ea._1)($,"dataSplits","stringNGrams");if("int32"!==eo.dtype)throw Error("Data splits must be of datatype int32");let es={separator:V,nGramWidths:G,leftPad:H,rightPad:K,padWidth:Z,preserveShortSequences:ee},eu={data:ei,dataSplits:eo},ec=et.BV.runKernel(en._JP,eu,es);return{nGrams:ec[0],nGramsSplits:ec[1]}}let aF=(0,eo.op)({stringNGrams_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringSplit_(F,$,V=!0){let G=(0,ea._1)(F,"input","stringSplit","string"),H=(0,ea._1)($,"delimiter","stringSplit","string");if(1!==G.rank)throw Error(`Input should be Tensor1D but received shape ${G.shape}`);if(0!==H.rank)throw Error(`Delimiter should be a scalar but received shape ${H.shape}`);let K={skipEmpty:V},Z={input:G,delimiter:H},ee=et.BV.runKernel(en.s1s,Z,K);return{indices:ee[0],values:ee[1],shape:ee[2]}}let aO=(0,eo.op)({stringSplit_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringToHashBucketFast_(F,$){let V=(0,ea._1)(F,"input","stringToHashBucketFast","string"),G={numBuckets:$};if($<=0)throw Error("Number of buckets must be at least 1");let H={input:V};return et.BV.runKernel(en.XkS,H,G)}let aP=(0,eo.op)({stringToHashBucketFast_});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function staticRegexReplace_(F,$,V,G=!0){let H=(0,ea._1)(F,"input","staticRegexReplace","string"),K={pattern:$,rewrite:V,replaceGlobal:G};return et.BV.runKernel(en.e0R,{x:H},K)}let aB=(0,eo.op)({staticRegexReplace_}),a$={fft:r5.k,ifft:r9.S,rfft:r7.Q,irfft:r8.w},az={hammingWindow:nZ,hannWindow:nY,frame:nJ,stft:n3},aV={flipLeftRight:n6,grayscaleToRGB:n5,resizeNearestNeighbor:au.j,resizeBilinear:as.I,rgbToGrayscale:n9,rotateWithOffset:n8,cropAndResize:n4,nonMaxSuppression:n7,nonMaxSuppressionAsync:ar,nonMaxSuppressionWithScore:an,nonMaxSuppressionWithScoreAsync:aa,nonMaxSuppressionPadded:ai,nonMaxSuppressionPaddedAsync:ao,threshold:ac,transform:ap},aU={bandPart:ad,gramSchmidt:am,qr:ay},aW={absoluteDifference:aS,computeWeightedLoss:aw,cosineDistance:a_,hingeLoss:aN,huberLoss:ak,logLoss:aI,meanSquaredError:aT,sigmoidCrossEntropy:aC,softmaxCrossEntropy:aE},aj={sparseFillEmptyRows:aA,sparseReshape:aD,sparseSegmentMean:aM,sparseSegmentSum:aR},aG={stringNGrams:aF,stringSplit:aO,stringToHashBucketFast:aP,staticRegexReplace:aB}},39682:function(F,$,V){"use strict";V.d($,{v:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pad_(F,$,V=0){let Z=(0,K._1)(F,"x","pad");if(0===Z.rank)throw Error("pad(scalar) is not defined. Pass non-scalar to pad");let ee={paddings:$,constantValue:V},et={x:Z};return G.BV.runKernel(H.lyA,et,ee)}let ee=(0,Z.op)({pad_})},85860:function(F,$,V){"use strict";V.d($,{d:function(){return eo}});var G=V(43740),H=V(20569),K=V(15176),Z=V(28441),ee=V(2582),et=V(21174),en=V(2668),ea=V(4968),ei=V(27918);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pool_(F,$,V,en,eo,es,eu){let ec;null==eo&&(eo=[1,1]),null==es&&(es=1),0===en&&(en="valid");let ep=(0,G._1)(F,"x","maxPool"),eh=ep,ef=!1;3===ep.rank&&(ef=!0,eh=(0,ea.X)(ep,[1,ep.shape[0],ep.shape[1],ep.shape[2]])),H.hu(ee.jT(es,eo),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${es} and dilations '${eo}'`);let ed=ee.Xw(eh.shape,$,es,eo,en),em=[ed.dilationHeight,ed.dilationWidth];ec="same"===en?withSpaceToBatchBasePaddings([ed.filterHeight,ed.filterWidth],em):[[0,0],[0,0]];let eg=1===em[0]&&1===em[1],[ey,eb]=requiredSpaceToBatchPaddings([ed.inHeight,ed.inWidth],em,ec),ew=eg?en:"valid",eS=eg?eh:(0,ei.f)(eh,em,ey),e_="avg"===V?()=>(0,K.w)(eS,$,es,ew,eu):()=>(0,et._)(eS,$,es,ew,eu),eN=e_(),ek=eg?eN:(0,Z.E)(eN,em,eb);return ef?(0,ea.X)(ek,[ek.shape[1],ek.shape[2],ek.shape[3]]):ek}function requiredSpaceToBatchPaddings(F,$,V){let G=V.map(F=>F[0]),H=V.map(F=>F[1]),K=F.concat(G,H),Z=$.map((F,$)=>(F-K[$]%F)%F),ee=H.map((F,$)=>F+Z[$]),et=$.map((F,$)=>[G[$],ee[$]]),en=$.map((F,$)=>[0,Z[$]]);return[et,en]}function withSpaceToBatchBasePaddings(F,$){let V=F.map((F,V)=>F+(F-1)*($[V]-1)),G=V.map(F=>F-1),H=G.map(F=>Math.floor(F/2)),K=G.map((F,$)=>F-H[$]);return G.map((F,$)=>[H[$],K[$]])}let eo=(0,en.op)({pool_})},33453:function(F,$,V){"use strict";V.d($,{s:function(){return et}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pow_(F,$){let V=(0,Z._1)(F,"base","pow"),ee=(0,Z._1)($,"exp","pow");[V,ee]=(0,K.makeTypesMatch)(V,ee);let et={a:V,b:ee};return G.BV.runKernel(H.pe_,et)}let et=(0,ee.op)({pow_})},98151:function(F,$,V){"use strict";V.d($,{A:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prelu_(F,$){let V=(0,K._1)(F,"x","prelu"),Z=(0,K._1)($,"alpha","prelu"),ee={x:V,alpha:Z};return G.BV.runKernel(H.o0g,ee)}let ee=(0,Z.op)({prelu_})},29798:function(F,$,V){"use strict";/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function print(F,$=!1){console.log(F.toString($))}V.d($,{S:function(){return print}})},49451:function(F,$,V){"use strict";V.d($,{W:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(62271),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prod_(F,$=null,V=!1){let ee=(0,K._1)(F,"x","prod");"bool"===ee.dtype&&(ee=(0,Z.p)(ee,"int32"));let et={x:ee},en={axis:$,keepDims:V};return G.BV.runKernel(H.DlI,et,en)}let et=(0,ee.op)({prod_})},60766:function(F,$,V){"use strict";V.d($,{k:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real_(F){let $=(0,K._1)(F,"input","real"),V={input:$};return G.BV.runKernel(H.xJR,V)}let ee=(0,Z.op)({real_})},19036:function(F,$,V){"use strict";V.d($,{M:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reciprocal_(F){let $=(0,K._1)(F,"x","reciprocal"),V={x:$};return G.BV.runKernel(H.$HU,V)}let ee=(0,Z.op)({reciprocal_})},7409:function(F,$,V){"use strict";V.d($,{U:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function relu_(F){let $=(0,K._1)(F,"x","relu"),V={x:$};return G.BV.runKernel(H.qkr,V)}let ee=(0,Z.op)({relu_})},83582:function(F,$,V){"use strict";V.d($,{b:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function relu6_(F){let $=(0,K._1)(F,"x","relu6"),V={x:$};return G.BV.runKernel(H.SbG,V)}let ee=(0,Z.op)({relu6_})},4968:function(F,$,V){"use strict";V.d($,{X:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reshape_(F,$){let V=(0,K._1)(F,"x","reshape","string_or_numeric"),Z={x:V},ee={shape:$};return G.BV.runKernel(H.HZH,Z,ee)}let ee=(0,Z.op)({reshape_})},57486:function(F,$,V){"use strict";V.d($,{G:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse_(F,$){let V=(0,K._1)(F,"x","reverse"),Z={x:V},ee={dims:$};return G.BV.runKernel(H.mKl,Z,ee)}let ee=(0,Z.op)({reverse_})},97809:function(F,$,V){"use strict";V.d($,{N:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function round_(F){let $=(0,K._1)(F,"x","round"),V={x:$};return G.BV.runKernel(H.e07,V)}let ee=(0,Z.op)({round_})},32634:function(F,$,V){"use strict";V.d($,{b:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rsqrt_(F){let $=(0,K._1)(F,"x","rsqrt","float32"),V={x:$};return G.BV.runKernel(H.bV0,V)}let ee=(0,Z.op)({rsqrt_})},99494:function(F,$,V){"use strict";V.d($,{i:function(){return scalar}});var G=V(23418),H=V(57852);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scalar(F,$){if(((0,G.isTypedArray)(F)&&"string"!==$||Array.isArray(F))&&"complex64"!==$)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===$&&(0,G.isTypedArray)(F)&&!(F instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");let V=[],K=[];return(0,H.H)(F,V,K,$)}},33028:function(F,$,V){"use strict";V.r($),V.d($,{calculateShapes:function(){return calculateShapes},validateInput:function(){return validateInput},validateUpdateShape:function(){return validateUpdateShape}});var G=V(20569);function validateUpdateShape(F,$,V){let G=$.rank>1?$.shape[$.rank-1]:1,H=$.rank>1?$.rank-1:1,K=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${V.shape}, indices.shape: ${$.shape}, shape: ${F}, sliceDim: ${G}, and batchDim: ${H}.`;if(V.rank<H)throw Error(K+` update.rank < ${H}. `);if(F.length<G+(V.rank-H))throw Error(K+` Output shape length < ${G+(V.rank-H)}`);if(V.rank!==H+F.length-G)throw Error(K+` update.rank != ${H+F.length-G}`);for(let F=0;F<H;++F)if(V.shape[F]!==$.shape[F])throw Error(K+` updates.shape[${F}] (${V.shape[F]}) != indices.shape[${F}] (${$.shape[F]}).`);for(let $=0;$<V.rank-H;++$)if(V.shape[$+H]!==F[$+G])throw Error(K+` updates.shape[${$+H}] (${V.shape[$+H]}) != shape[${$+H}] (${F[$+H]})`)}function validateInput(F,$,V){if($.rank<1)throw Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${$.rank}.`);if(F.rank<1)throw Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${F.rank}.`);if("int32"!==$.dtype)throw Error(`The dtype of 'indices' should be int32, but got dtype: ${$.dtype}`);if(V.length<1)throw Error(`Output rank must be greater or equal to 1, but got shape: ${V}`);if(0===V.length){if(0===$.size)throw Error(`Indices specified for empty output. indices shape: ${$.shape}`);if(0===F.size)throw Error(`Updates specified for empty output. updates shape: ${F.shape}`)}validateUpdateShape(V,$,F)}function calculateShapes(F,$,V){let H=$.shape.length,K=H>1?$.shape[H-1]:1,Z=V.length,ee=1;for(let F=K;F<Z;++F)ee*=V[F];let et=K<1?1:K,en=(0,G.NA)($.shape)/et,ea=[...(0,G.e3)(V.slice(0,K)),1],ei=(0,G.NA)(V);return{sliceRank:K,numUpdates:en,sliceSize:ee,strides:ea,outputSize:ei}}},55503:function(F,$,V){"use strict";V.d($,{U:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function selu_(F){let $=(0,K._1)(F,"x","selu"),V={x:$};return G.BV.runKernel(H.oFR,V)}let ee=(0,Z.op)({selu_})},43179:function(F,$,V){"use strict";V.d($,{$:function(){return H},y:function(){return G}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let G=1.7580993408473768,H=1.0507009873554805},68678:function(F,$,V){"use strict";V.d($,{U:function(){return en}});var G=V(43740),H=V(20569),K=V(64794),Z=V(64718),ee=V(2668),et=V(4968);function separableConv2d_(F,$,V,ee,en,ea=[1,1],ei="NHWC"){let eo=(0,G._1)(F,"x","separableConv2d"),es=(0,G._1)($,"depthwiseFilter","separableConv2d"),eu=(0,G._1)(V,"pointwiseFilter","separableConv2d"),ec=eo,ep=!1;if(3===eo.rank&&(ep=!0,ec=(0,et.X)(eo,[1,eo.shape[0],eo.shape[1],eo.shape[2]])),"NCHW"===ei)throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");H.hu(4===ec.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${ec.rank}.`),H.hu(4===es.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${es.rank}.`),H.hu(4===eu.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${es.rank}.`),H.hu(1===eu.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${eu.shape[0]}.`),H.hu(1===eu.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${eu.shape[1]}.`);let eh=es.shape[2],ef=es.shape[3];H.hu(eu.shape[2]===eh*ef,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${eh*ef}, but got ${eu.shape[2]}.`);let ed=(0,Z.B)(ec,es,ee,en,ei,ea),em=1,eg=(0,K.T)(ed,eu,em,"valid",ei);return ep?(0,et.X)(eg,[eg.shape[1],eg.shape[2],eg.shape[3]]):eg}let en=(0,ee.op)({separableConv2d_})},30625:function(F,$,V){"use strict";V.d($,{X:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sigmoid_(F){let $=(0,K._1)(F,"x","sigmoid","float32"),V={x:$};return G.BV.runKernel(H.a5O,V)}let ee=(0,Z.op)({sigmoid_})},34434:function(F,$,V){"use strict";V.d($,{X:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sign_(F){let $=(0,K._1)(F,"x","sign"),V={x:$};return G.BV.runKernel(H.i5y,V)}let ee=(0,Z.op)({sign_})},99331:function(F,$,V){"use strict";V.d($,{O:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sin_(F){let $=(0,K._1)(F,"x","sin","float32"),V={x:$};return G.BV.runKernel(H.RQH,V)}let ee=(0,Z.op)({sin_})},83254:function(F,$,V){"use strict";V.d($,{R:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sinh_(F){let $=(0,K._1)(F,"x","sinh"),V={x:$};return G.BV.runKernel(H.wYB,V)}let ee=(0,Z.op)({sinh_})},22676:function(F,$,V){"use strict";V.d($,{t:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice_(F,$,V){let Z=(0,K._1)(F,"x","slice","string_or_numeric");if(0===Z.rank)throw Error("Slicing scalar is not possible");let ee={x:Z},et={begin:$,size:V};return G.BV.runKernel(H.p2w,ee,et)}let ee=(0,Z.op)({slice_})},37650:function(F,$,V){"use strict";V.r($),V.d($,{assertParamsValid:function(){return assertParamsValid},computeFlatOffset:function(){return computeFlatOffset},computeOutShape:function(){return computeOutShape},getNormalizedAxes:function(){return getNormalizedAxes},isSliceContinous:function(){return isSliceContinous},maskToAxes:function(){return maskToAxes},parseSliceParams:function(){return parseSliceParams},sliceInfo:function(){return sliceInfo},startForAxis:function(){return startForAxis},startIndicesWithElidedDims:function(){return startIndicesWithElidedDims},stopForAxis:function(){return stopForAxis},stopIndicesWithElidedDims:function(){return stopIndicesWithElidedDims},stridesForAxis:function(){return stridesForAxis},stridesWithElidedDims:function(){return stridesWithElidedDims}});var G=V(20569);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let H=-2,K=-1;function assertParamsValid(F,$,V){let H=F.shape.length;G.hu(H===$.length,()=>`Error in slice${H}D: Length of begin ${$} must match the rank of the array (${H}).`),G.hu(H===V.length,()=>`Error in slice${H}D: Length of size ${V} must match the rank of the array (${H}).`);for(let K=0;K<H;++K)G.hu($[K]+V[K]<=F.shape[K],()=>`Error in slice${H}D: begin[${K}] + size[${K}] (${$[K]+V[K]}) would overflow input.shape[${K}] (${F.shape[K]})`)}function maskToAxes(F){let $=[],V=0;for(;F>0;)1&F&&$.push(V),F/=2,V++;return $}function computeOutShape(F,$,V){let G=[];for(let H=0;H<F.length;H++)G[H]=Math.ceil(($[H]-F[H])/V[H]);return G}function stridesWithElidedDims(F,$,V,G){let H=[...F];for(let F=H.length;F<G.length;F++)H.push(1);for(let F=0;F<V;F++)0===F?H[$]=1:(H.splice($,0,1),H.pop());return H}function unnormalizeAxis(F,$,V){return V<=F?V:V-($-1)}function getElidedAxes(F,$){let V=[];for(let G=0;G<F;G++)V.push($+G);return V}function getNormalizedAxes(F,$,V,G,H,K,Z,ee,et){let en=F.length,ea=Array(en),ei=Array(en),eo=Array(en);if($.length&&V>0){let et=$[0],en=V+1;ea=startIndicesWithElidedDims(Z,et,en,G,F),ei=stopIndicesWithElidedDims(ee,et,en,H,F),eo=stridesWithElidedDims(K,et,en,F)}else for(let $=0;$<en;$++)ea[$]=startForAxis(Z,G,K,F,$,et),ei[$]=stopForAxis(ee,H,K,F,$,et),eo[$]=stridesForAxis(K,$,et);return{begin:ea,end:ei,strides:eo}}function startIndicesWithElidedDims(F,$,V,G,H){let K=[...H],Z=getElidedAxes(V,$);for(let H=0;H<K.length;H++)if(Z.indexOf(H)>-1)K[H]=0;else{let Z=unnormalizeAxis($,V,H),ee=G[Z];F&1<<Z&&(ee=0),K[H]=ee}return K}function stopIndicesWithElidedDims(F,$,V,H,K){let Z=[...K],ee=getElidedAxes(V,$);for(let G=0;G<Z.length;G++)if(ee.indexOf(G)>-1)Z[G]=Number.MAX_SAFE_INTEGER;else{let K=unnormalizeAxis($,V,G),ee=H[K];F&1<<K&&(ee=Number.MAX_SAFE_INTEGER),Z[G]=ee}for(let F=0;F<Z.length;F++){let $=K[F];Z[F]<0&&(Z[F]+=$),Z[F]=G.uZ(0,Z[F],K[F])}return Z}function stridesForAxis(F,$,V){let G=F[$];return(V&1<<$||null==G)&&(G=1),G}function startForAxis(F,$,V,H,K,Z){let ee=$[K],et=V[K]||1;(F&1<<K||Z&1<<K||null==ee)&&(ee=et>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let en=H[K];return ee<0&&(ee+=en),ee=G.uZ(0,ee,en-1)}function stopForAxis(F,$,V,H,K,Z){let ee=$[K],et=V[K]||1;(F&1<<K||Z&1<<K||null==ee)&&(ee=et>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let en=H[K];return ee<0&&(ee+=en),ee=et>0?G.uZ(0,ee,en):G.uZ(-1,ee,en-1)}function isSliceContinous(F,$,V){let G=V.length;for(let F=0;F<V.length;F++)if(V[F]>1){G=F;break}for(let H=G+1;H<V.length;H++)if($[H]>0||V[H]!==F[H])return!1;return!0}function computeFlatOffset(F,$){let V=F.length>0?F[F.length-1]:1;for(let G=0;G<F.length-1;G++)V+=F[G]*$[G];return V}function parseSliceParams(F,$,V){let H,K;let Z=F.shape.length;return(H="number"==typeof $?[$,...Array(Z-1).fill(0)]:$.length<Z?$.concat(Array(Z-$.length).fill(0)):$.slice()).forEach(F=>{G.hu(-1!==F,()=>"slice() does not support negative begin indexing.")}),K=(K=null==V?Array(Z).fill(-1):"number"==typeof V?[V,...Array(Z-1).fill(-1)]:V.length<Z?V.concat(Array(Z-V.length).fill(-1)):V).map(($,V)=>$>=0?$:(G.hu(-1===$,()=>`Negative size values should be exactly -1 but got ${$} for the slice() size at index ${V}.`),F.shape[V]-H[V])),[H,K]}function sliceInfo(F,$,V,G,K,Z,ee,et,en){let ea;if(null==G?(ea=Array($.length)).fill(1):ea=G,null!=ee&&(ee&ee-1)!=0)throw Error("Multiple ellipses in slice is not allowed.");let ei=!1,eo={dims:ea.length,numAddAxisAfterEllipsis:0,begin:$.slice(),end:V.slice(),strides:ea.slice(),beginMask:K,endMask:Z,ellipsisMask:ee,newAxisMask:et,shrinkAxisMask:en};for(let F=0;F<eo.dims;F++)ei&&(1<<F&et)!=0&&eo.numAddAxisAfterEllipsis++,1<<F&ee&&(ei=!0);!ei&&(eo.ellipsisMask|=1<<eo.dims,eo.dims++);let es={dims:F.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};buildDenseSpec(eo,es);let eu=!0,ec=!0,ep=!0,eh=[],ef=[];for(let $=0;$<F.length;++$){let V;if(0===es.strides[$])throw Error(`strides[${$}] must be non-zero`);let G=!!(es.shrinkAxisMask&1<<$),H=F[$];if(-1===H){eh.push(G?1:-1);continue}let K=[es.beginMask&1<<$,es.endMask&1<<$],Z=[es.strides[$]>0?0:-1,es.strides[$]>0?H:H-1];if(G&&es.strides[$]<=0)throw Error("only stride 1 allowed on non-range indexing.");ep=ep&&1===es.strides[$];let ee=!!(es.beginMask&1<<$&&es.endMask&1<<$);if(es.beginValid&&es.endValid){if(G){let F=es.begin[$]<0?H+es.begin[$]:es.begin[$];if(es.begin[$]=F,es.end[$]=es.begin[$]+1,F<0||F>=H)throw Error(`slice index ${es.begin[$]} of dimension ${$} out of bounds.`)}else es.begin[$]=canonical(es.begin[$],0,es.strides[$],H,K,Z),es.end[$]=canonical(es.end[$],1,es.strides[$],H,K,Z);let F=1===es.strides[$]&&0===es.begin[$]&&es.end[$]===H;eu=eu&&F,ec=ec&&(0===$&&1===es.strides[$]||F)}else eu=eu&&1===es.strides[$]&&ee,ec=ec&&(0===$&&1===es.strides[$]||ee);let et=!1;if(es.beginValid&&es.endValid?(V=es.end[$]-es.begin[$],et=!0):G?(V=1,et=!0):ee&&H>=0&&(V=es.strides[$]<0?-H:H,et=!0),et){let F;F=0===V||V<0!=es.strides[$]<0?0:Math.trunc(V/es.strides[$])+(V%es.strides[$]!=0?1:0),eh.push(F)}else eh.push(-1)}for(let F=0;F<es.finalShapeGatherIndices.length;++F){let $=es.finalShapeGatherIndices[F];$>=0?ef.push(eh[$]):$===H&&ef.push(1)}let ed=ef.filter((F,$)=>es.finalShapeGatherIndices[$]!==H);return{finalShapeSparse:ed,finalShape:ef,isIdentity:eu,sliceDim0:ec,isSimpleSlice:ep,begin:es.begin,end:es.end,strides:es.strides}}function buildDenseSpec(F,$){$.beginMask=0,$.endMask=0,$.shrinkAxisMask=0;let V=0;$.beginValid=null!=F.begin,$.endValid=null!=F.end,$.begin=Array($.dims),$.end=Array($.dims),$.strides=Array($.dims),$.finalShapeGatherIndices=[],$.finalShapeGatherIndicesSparse=[],$.inputShapeGatherIndicesSparse=Array($.dims);for(let G=0;G<F.dims;G++)if(1<<G&F.ellipsisMask){let H=Math.min($.dims-(F.dims-G)+1+F.numAddAxisAfterEllipsis,$.dims);for(;V<H;V++)$.begin[V]=0,$.end[V]=0,$.strides[V]=1,$.beginMask|=1<<V,$.endMask|=1<<V,$.finalShapeGatherIndices.push(V),$.finalShapeGatherIndicesSparse.push(-1),$.inputShapeGatherIndicesSparse[V]=G}else if(1<<G&F.newAxisMask)$.finalShapeGatherIndices.push(H),$.finalShapeGatherIndicesSparse.push(-1);else{if(V===$.begin.length)throw Error(`Index out of range using input dim ${V}; input has only ${$.dims} dims, ${$.begin.length}.`);null!=F.begin&&($.begin[V]=F.begin[G]),null!=F.end&&($.end[V]=F.end[G]),$.strides[V]=F.strides[G],F.beginMask&1<<G&&($.beginMask|=1<<V),F.endMask&1<<G&&($.endMask|=1<<V),F.shrinkAxisMask&1<<G?($.finalShapeGatherIndices.push(K),$.finalShapeGatherIndicesSparse.push(-1),$.shrinkAxisMask|=1<<V):($.finalShapeGatherIndices.push(V),$.finalShapeGatherIndicesSparse.push(G)),$.inputShapeGatherIndicesSparse[V]=G,V++}}function canonical(F,$,V,G,H,K){if(H[$])return V>0?K[$]:K[$+1&1];{let $=F<0?G+F:F;return $<K[0]?K[0]:$>K[1]?K[1]:$}}},80682:function(F,$,V){"use strict";V.d($,{X:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmax_(F,$=-1){let V=(0,K._1)(F,"logits","softmax","float32");if(-1===$&&($=V.rank-1),$!==V.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${V.rank} and dim was ${$}`);let Z={logits:V},ee={dim:$};return G.BV.runKernel(H.Gcp,Z,ee)}let ee=(0,Z.op)({softmax_})},3694:function(F,$,V){"use strict";V.d($,{W:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softplus_(F){let $=(0,K._1)(F,"x","softplus"),V={x:$};return G.BV.runKernel(H.MRv,V)}let ee=(0,Z.op)({softplus_})},27918:function(F,$,V){"use strict";V.d($,{f:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function spaceToBatchND_(F,$,V){let ee=(0,K._1)(F,"x","spaceToBatchND");Z.hu(ee.rank>=1+$.length,()=>`input rank ${ee.rank} should be > than [blockShape] ${$.length}`),Z.hu(V.length===$.length,()=>`paddings.shape[0] ${V.length} must be equal to [blockShape] ${$.length}`),Z.hu(ee.shape.reduce((F,G,H)=>H>0&&H<=$.length?F&&(G+V[H-1][0]+V[H-1][1])%$[H-1]==0:F,!0),()=>`input spatial dimensions ${ee.shape.slice(1)} with paddings ${V.toString()} must be divisible by blockShapes ${$.toString()}`);let et={x:ee},en={blockShape:$,paddings:V};return G.BV.runKernel(H.TQc,et,en)}let et=(0,ee.op)({spaceToBatchND_})},7020:function(F,$,V){"use strict";V.d($,{k:function(){return ee}});var G=V(50196),H=V(29121),K=V(20569),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fft_(F){(0,K.hu)("complex64"===F.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${F.dtype}.`);let $={input:F};return G.BV.runKernel(H.vwp,$)}let ee=(0,Z.op)({fft_})},88447:function(F,$,V){"use strict";V.d($,{S:function(){return ee}});var G=V(50196),H=V(29121),K=V(20569),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ifft_(F){(0,K.hu)("complex64"===F.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${F.dtype}.`);let $={input:F};return G.BV.runKernel(H.Qg5,$)}let ee=(0,Z.op)({ifft_})},84415:function(F,$,V){"use strict";V.d($,{w:function(){return eu}});var G=V(61661),H=V(46884),K=V(64386),Z=V(24841),ee=V(2668),et=V(60766),en=V(4968),ea=V(57486),ei=V(99494),eo=V(22676),es=V(88447);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function irfft_(F){let $;let V=F.shape[F.shape.length-1],ee=F.size/V;if(V<=2){let G=(0,en.X)(F,[ee,V]);$=(0,es.S)(G)}else{let eu=[ee,2*(V-1)],ec=(0,en.X)((0,et.k)(F),[ee,V]),ep=(0,en.X)((0,K.a)(F),[ee,V]),eh=(0,ea.G)((0,eo.t)(ec,[0,1],[ee,V-2]),1),ef=(0,Z.d)((0,ea.G)((0,eo.t)(ep,[0,1],[ee,V-2]),1),(0,ei.i)(-1)),ed=(0,H.z)([ec,eh],1),em=(0,H.z)([ep,ef],1),eg=(0,en.X)((0,G.P)(ed,em),[eu[0],eu[1]]);$=(0,es.S)(eg)}if($=(0,et.k)($),3===F.rank&&0!==F.shape[0]){let V=$,G=F.shape[0];$=(0,en.X)($,[G,$.shape[0]/G,$.shape[1]]),V.dispose()}return $}let eu=(0,ee.op)({irfft_})},13710:function(F,$,V){"use strict";V.d($,{Q:function(){return ec}});var G=V(20569),H=V(61661),K=V(46884),Z=V(64386),ee=V(2668),et=V(60766),en=V(4968),ea=V(22676),ei=V(28644),eo=V(59640),es=V(6577),eu=V(7020);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rfft_(F,$){let V;(0,G.hu)("float32"===F.dtype,()=>`The dtype for rfft() must be real value but got ${F.dtype}`);let ee=F.shape[F.shape.length-1],ec=F.size/ee;if(null!=$&&$<ee){let G=F.shape.map(F=>0),H=F.shape.map(F=>F);H[F.shape.length-1]=$,V=(0,ea.t)(F,G,H),ee=$}else if(null!=$&&$>ee){let G=F.shape.map(F=>F);G[F.shape.length-1]=$-ee,V=(0,K.z)([F,(0,eo.l)(G)],F.shape.length-1),ee=$}else V=F;let ep=(0,es.P)(V),eh=(0,en.X)((0,H.P)(V,ep),[ec,ee]),ef=(0,eu.k)(eh),ed=Math.floor(ee/2)+1,em=(0,et.k)(ef),eg=(0,Z.a)(ef),ey=(0,ei.V)(em,[ed,ee-ed],em.shape.length-1),eb=(0,ei.V)(eg,[ed,ee-ed],eg.shape.length-1),ew=V.shape.slice();return ew[V.shape.length-1]=ed,(0,en.X)((0,H.P)(ey[0],eb[0]),ew)}let ec=(0,ee.op)({rfft_})},28644:function(F,$,V){"use strict";V.d($,{V:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function split_(F,$,V=0){let Z=(0,K._1)(F,"x","split"),ee={x:Z},et={numOrSizeSplits:$,axis:V};return G.BV.runKernel(H.L8s,ee,et)}let ee=(0,Z.op)({split_})},13261:function(F,$,V){"use strict";V.d($,{_:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sqrt_(F){let $=(0,K._1)(F,"x","sqrt","float32"),V={x:$};return G.BV.runKernel(H.FKq,V)}let ee=(0,Z.op)({sqrt_})},50248:function(F,$,V){"use strict";V.d($,{h:function(){return Z}});var G=V(50196),H=V(43740),K=V(2668);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function square_(F){let $=(0,H._1)(F,"x","square"),V={};return G.BV.runKernel("Square",{x:$},V)}let Z=(0,K.op)({square_})},15265:function(F,$,V){"use strict";V.d($,{$:function(){return en}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(72200),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function squaredDifference_(F,$){let V=(0,Z._1)(F,"a","squaredDifference"),et=(0,Z._1)($,"b","squaredDifference");[V,et]=(0,K.makeTypesMatch)(V,et),(0,ee.assertAndGetBroadcastShape)(V.shape,et.shape);let en={a:V,b:et},ea={};return G.BV.runKernel(H._tC,en,ea)}let en=(0,et.op)({squaredDifference_})},79590:function(F,$,V){"use strict";V.d($,{L:function(){return ee}});var G=V(43740),H=V(20569),K=V(2668),Z=V(4968);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function squeeze_(F,$){let V=(0,G._1)(F,"x","squeeze","string_or_numeric");return(0,Z.X)(V,(0,H.bp)(V.shape,$).newShape)}let ee=(0,K.op)({squeeze_})},82991:function(F,$,V){"use strict";V.d($,{k:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stack_(F,$=0){let V=(0,K.sI)(F,"tensors","stack","string_or_numeric");Z.hu(V.length>=1,()=>"Pass at least one tensor to tf.stack"),V.length>0&&Z.hu($<=V[0].rank,()=>"Axis must be <= rank of the tensor");let ee=V,et={axis:$};return G.BV.runKernel(H.QiL,ee,et)}let et=(0,ee.op)({stack_})},71901:function(F,$,V){"use strict";V.d($,{N:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function step_(F,$=0){let V=(0,K._1)(F,"x","step"),Z={x:V},ee={alpha:$};return G.BV.runKernel(H.h8e,Z,ee)}let ee=(0,Z.op)({step_})},55158:function(F,$,V){"use strict";V.d($,{N:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stridedSlice_(F,$,V,Z,ee=0,et=0,en=0,ea=0,ei=0){let eo=(0,K._1)(F,"x","stridedSlice","string_or_numeric"),es={x:eo},eu={begin:$,end:V,strides:Z,beginMask:ee,endMask:et,ellipsisMask:en,newAxisMask:ea,shrinkAxisMask:ei};return G.BV.runKernel(H.jQk,es,eu)}let ee=(0,Z.op)({stridedSlice_})},70827:function(F,$,V){"use strict";V.d($,{l:function(){return et}});var G=V(50196),H=V(29121),K=V(80747),Z=V(43740),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sub_(F,$){let V=(0,Z._1)(F,"a","sub"),ee=(0,Z._1)($,"b","sub");[V,ee]=(0,K.makeTypesMatch)(V,ee);let et={a:V,b:ee};return G.BV.runKernel(H.Tr8,et)}let et=(0,ee.op)({sub_})},15475:function(F,$,V){"use strict";V.d($,{S:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(62271),ee=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sum_(F,$=null,V=!1){let ee=(0,K._1)(F,"x","sum");"bool"===ee.dtype&&(ee=(0,Z.p)(ee,"int32"));let et={x:ee},en={axis:$,keepDims:V};return G.BV.runKernel(H.GBy,et,en)}let et=(0,ee.op)({sum_})},61173:function(F,$,V){"use strict";V.d($,{O:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tan_(F){let $=(0,K._1)(F,"x","tan","float32"),V={x:$};return G.BV.runKernel(H.sEM,V)}let ee=(0,Z.op)({tan_})},21869:function(F,$,V){"use strict";V.d($,{A:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tanh_(F){let $=(0,K._1)(F,"x","tanh","float32"),V={x:$};return G.BV.runKernel(H.MIZ,V)}let ee=(0,Z.op)({tanh_})},10701:function(F,$,V){"use strict";V.d($,{X:function(){return tensor}});var G=V(43740),H=V(57852);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor(F,$,V){let K=(0,G.C)(F,V);return(0,H.H)(F,$,K,V)}},99906:function(F,$,V){"use strict";V.d($,{w:function(){return tensor3d}});var G=V(43740),H=V(20569),K=V(57852);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor3d(F,$,V){if((0,H.Cq)(F),null!=$&&3!==$.length)throw Error("tensor3d() requires shape to have three numbers");let Z=(0,G.C)(F,V);if(3!==Z.length&&1!==Z.length)throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===Z.length&&null==$)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,K.H)(F,$,Z,V)}},57852:function(F,$,V){"use strict";V.d($,{H:function(){return makeTensor}});var G=V(50196),H=V(71221),K=V(20569),Z=V(23418);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeTensor(F,$,V,ee){if(null==ee)ee=(0,K.D2)(F);else if("complex64"===ee)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,H.$F)(F)||(0,H.Oq)(F)){if("float32"!==ee&&"int32"!==ee)throw Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${ee}.`);return G.BV.backend.createTensorFromGPUData(F,$||V,ee)}if(!(0,Z.isTypedArray)(F)&&!Array.isArray(F)&&"number"!=typeof F&&"boolean"!=typeof F&&"string"!=typeof F)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=$){(0,K.Mu)($);let F=(0,K.NA)($),G=(0,K.NA)(V);(0,K.hu)(F===G,()=>`Based on the provided shape, [${$}], the tensor should have ${F} values but has ${G}`);for(let F=0;F<V.length;++F){let G=V[F],H=F!==V.length-1||G!==(0,K.NA)($.slice(F));(0,K.hu)(V[F]===$[F]||!H,()=>`Error creating a new Tensor. Inferred shape (${V}) does not match the provided shape (${$}). `)}}return(0,Z.isTypedArray)(F)||Array.isArray(F)||(F=[F]),$=$||V,F="string"!==ee?(0,Z.toTypedArray)(F,ee):(0,Z.flatten)(F,[],!0),G.BV.makeTensor(F,$,ee)}},47501:function(F,$,V){"use strict";V.d($,{G:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tile_(F,$){let V=(0,K._1)(F,"x","tile","string_or_numeric");Z.hu(V.rank===$.length,()=>`Error in transpose: rank of input ${V.rank} must match length of reps ${$}.`);let ee={x:V},et={reps:$};return G.BV.runKernel(H.n9L,ee,et)}let et=(0,ee.op)({tile_})},43243:function(F,$,V){"use strict";V.d($,{h:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function topk_(F,$=1,V=!0){let Z=(0,K._1)(F,"x","topk");if(0===Z.rank)throw Error("topk() expects the input to be of rank 1 or higher");let ee=Z.shape[Z.shape.length-1];if($<0)throw Error(`'k' passed to topk() must be >= 0 but got ${$}`);if($>ee)throw Error(`'k' passed to topk() must be <= the last dimension (${ee}) but got ${$}`);let et={x:Z},en={k:$,sorted:V},[ea,ei]=G.BV.runKernel(H.cWu,et,en);return{values:ea,indices:ei}}let ee=(0,Z.op)({topk_})},89065:function(F,$,V){"use strict";V.d($,{p:function(){return es}});var G=V(50196),H=V(4368),K=V(29121),Z=V(43740),ee=V(20569),et=V(61661),en=V(64386),ea=V(17370),ei=V(2668),eo=V(60766);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose_(F,$,V){let ei=(0,Z._1)(F,"x","transpose");if(null==$&&($=ei.shape.map((F,$)=>$).reverse()),ee.hu(ei.rank===$.length,()=>`Error in transpose: rank of input ${ei.rank} must match length of perm ${$}.`),$.forEach(F=>{ee.hu(F>=0&&F<ei.rank,()=>`All entries in 'perm' must be between 0 and ${ei.rank-1} but got ${$}`)}),ei.rank<=1)return ei.clone();let es={x:ei},eu={perm:$};return"complex64"===ei.dtype?(0,H.lu)(()=>{let F=(0,eo.k)(ei),$=(0,en.a)(ei);return F=G.BV.runKernel(K.G3Y,{x:F},eu),$=G.BV.runKernel(K.G3Y,{x:$},eu),V&&($=(0,ea.W)($)),(0,et.P)(F,$)}):G.BV.runKernel(K.G3Y,es,eu)}let es=(0,ei.op)({transpose_})},49608:function(F,$,V){"use strict";V.d($,{T:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unique_(F,$=0){let V=(0,K._1)(F,"x","unique","string_or_numeric");(0,Z.hu)(V.rank>0,()=>"The input tensor must be at least 1D");let ee={x:V},et={axis:$},[en,ea]=G.BV.runKernel(H.kpP,ee,et);return{values:en,indices:ea}}let et=(0,ee.op)({unique_})},98749:function(F,$,V){"use strict";V.d($,{p:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unsortedSegmentSum_(F,$,V){let ee=(0,K._1)(F,"x","unsortedSegmentSum"),et=(0,K._1)($,"segmentIds","unsortedSegmentSum","int32");(0,Z.hu)((0,Z.GN)(V),()=>"numSegments must be of dtype int");let en={x:ee,segmentIds:et},ea={numSegments:V};return G.BV.runKernel(H.Qvg,en,ea)}let et=(0,ee.op)({unsortedSegmentSum_})},24136:function(F,$,V){"use strict";V.d($,{H:function(){return et}});var G=V(50196),H=V(29121),K=V(43740),Z=V(20569),ee=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unstack_(F,$=0){let V=(0,K._1)(F,"x","unstack","string_or_numeric");Z.hu($>=-V.shape.length&&$<V.shape.length,()=>`Axis = ${$} is not in [-${V.shape.length}, ${V.shape.length})`);let ee={value:V},et={axis:$};return G.BV.runKernel(H.ToN,ee,et)}let et=(0,ee.op)({unstack_})},95912:function(F,$,V){"use strict";V.d($,{a:function(){return en}});var G=V(50196),H=V(29121),K=V(43740),Z=V(68247),ee=V(72200),et=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function where_(F,$,V){let et=(0,K._1)($,"a","where"),en=(0,K._1)(V,"b","where"),ea=(0,K._1)(F,"condition","where","bool"),ei=(0,ee.assertAndGetBroadcastShape)((0,ee.assertAndGetBroadcastShape)(ea.shape,et.shape),en.shape),eo=(0,Z.U)(ea,ei),es=(0,Z.U)(et,ei),eu=(0,Z.U)(en,ei),ec={condition:eo,t:es,e:eu};return G.BV.runKernel(H.PhF,ec)}let en=(0,et.op)({where_})},59640:function(F,$,V){"use strict";V.d($,{l:function(){return zeros}});var G=V(50196),H=V(20569),K=V(61661);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zeros(F,$="float32"){if((0,H.Mu)(F),"complex64"===$){let $=zeros(F,"float32"),V=zeros(F,"float32");return(0,K.P)($,V)}let V=(0,H.wT)((0,H.NA)(F),$);return G.BV.makeTensor(V,F,$)}},6577:function(F,$,V){"use strict";V.d($,{P:function(){return ee}});var G=V(50196),H=V(29121),K=V(43740),Z=V(2668);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike_(F){let $=(0,K._1)(F,"x","zerosLike"),V={x:$};return G.BV.runKernel(H.RuY,V)}let ee=(0,Z.op)({zerosLike_})},59742:function(F,$,V){"use strict";/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isTypedArrayBrowser(F){return F instanceof Float32Array||F instanceof Int32Array||F instanceof Uint8Array||F instanceof Uint8ClampedArray}V.d($,{j:function(){return isTypedArrayBrowser}})},40974:function(F,$,V){"use strict";V.d($,{es:function(){return Tensor},YD:function(){return TensorBuffer},_w:function(){return Variable},t3:function(){return getGlobalTensorClass},FZ:function(){return setDeprecationWarningFn},Vp:function(){return setOpHandler},Vi:function(){return setTensorTracker}});var G=V(55938),H=V(20569);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let K=20,Z=3,ee=7;function tensorToString(F,$,V,G){let K=(0,H.e3)($),Z=computeMaxSizePerColumn(F,$,V,K),ee=$.length,et=subTensorToString(F,$,V,K,Z),en=["Tensor"];return G&&(en.push(`  dtype: ${V}`),en.push(`  rank: ${ee}`),en.push(`  shape: [${$}]`),en.push("  values:")),en.push(et.map(F=>"    "+F).join("\n")),en.join("\n")}function computeMaxSizePerColumn(F,$,V,G){let K=(0,H.NA)($),Z=G[G.length-1],ee=Array(Z).fill(0),et=$.length,en="complex64"===V?createComplexTuples(F):F;if(et>1)for(let F=0;F<K/Z;F++){let $=F*Z;for(let F=0;F<Z;F++)ee[F]=Math.max(ee[F],valToString(en[$+F],0,V).length)}return ee}function valToString(F,$,V){let G;return G=Array.isArray(F)?`${parseFloat(F[0].toFixed(ee))} + ${parseFloat(F[1].toFixed(ee))}j`:(0,H.HD)(F)?`'${F}'`:"bool"===V?boolNumToString(F):parseFloat(F.toFixed(ee)).toString(),(0,H.oj)(G,$)}function boolNumToString(F){return 0===F?"false":"true"}function subTensorToString(F,$,V,G,H,ee=!0){let et="complex64"===V?2:1,en=$[0],ea=$.length;if(0===ea){if("complex64"===V){let $=createComplexTuples(F);return[valToString($[0],0,V)]}return"bool"===V?[boolNumToString(F[0])]:[F[0].toString()]}if(1===ea){if(en>K){let $=Z*et,G=Array.from(F.slice(0,$)),K=Array.from(F.slice((en-Z)*et,en*et));return"complex64"===V&&(G=createComplexTuples(G),K=createComplexTuples(K)),["["+G.map((F,$)=>valToString(F,H[$],V)).join(", ")+", ..., "+K.map((F,$)=>valToString(F,H[en-Z+$],V)).join(", ")+"]"]}let $="complex64"===V?createComplexTuples(F):Array.from(F);return["["+$.map((F,$)=>valToString(F,H[$],V)).join(", ")+"]"]}let ei=$.slice(1),eo=G.slice(1),es=G[0]*et,eu=[];if(en>K){for(let $=0;$<Z;$++){let G=$*es,K=G+es;eu.push(...subTensorToString(F.slice(G,K),ei,V,eo,H,!1))}eu.push("...");for(let $=en-Z;$<en;$++){let G=$*es,K=G+es;eu.push(...subTensorToString(F.slice(G,K),ei,V,eo,H,$===en-1))}}else for(let $=0;$<en;$++){let G=$*es,K=G+es;eu.push(...subTensorToString(F.slice(G,K),ei,V,eo,H,$===en-1))}let ec=2===ea?",":"";eu[0]="["+(en>0?eu[0]+ec:"");for(let F=1;F<eu.length-1;F++)eu[F]=" "+eu[F]+ec;let ep=",\n";for(let F=2;F<ea;F++)ep+="\n";return eu[eu.length-1]=" "+eu[eu.length-1]+"]"+(ee?"":ep),eu}function createComplexTuples(F){let $=[];for(let V=0;V<F.length;V+=2)$.push([F[V],F[V+1]]);return $}var et=V(23418);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TensorBuffer=class TensorBuffer{constructor(F,$,V){if(this.dtype=$,this.shape=F.slice(),this.size=H.NA(F),null!=V){let F=V.length;H.hu(F===this.size,()=>`Length of values '${F}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===$)throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=V||H.rQ($,this.size),this.strides=(0,H.e3)(F)}set(F,...$){0===$.length&&($=[0]),H.hu($.length===this.rank,()=>`The number of provided coordinates (${$.length}) must match the rank (${this.rank})`);let V=this.locToIndex($);this.values[V]=F}get(...F){0===F.length&&(F=[0]);let $=0;for(let V of F){if(V<0||V>=this.shape[$]){let $=`Requested out of range element at ${F}.   Buffer shape=${this.shape}`;throw Error($)}$++}let V=F[F.length-1];for(let $=0;$<F.length-1;++$)V+=this.strides[$]*F[$];return this.values[V]}locToIndex(F){if(0===this.rank)return 0;if(1===this.rank)return F[0];let $=F[F.length-1];for(let V=0;V<F.length-1;++V)$+=this.strides[V]*F[V];return $}indexToLoc(F){if(0===this.rank)return[];if(1===this.rank)return[F];let $=Array(this.shape.length);for(let V=0;V<$.length-1;++V)$[V]=Math.floor(F/this.strides[V]),F-=$[V]*this.strides[V];return $[$.length-1]=F,$}get rank(){return this.shape.length}toTensor(){return en().makeTensor(this.values,this.shape,this.dtype)}};let en=null,ea=null,ei=null;function setTensorTracker(F){en=F}function setOpHandler(F){ea=F}function setDeprecationWarningFn(F){ei=F}let Tensor=class Tensor{constructor(F,$,V,G){this.kept=!1,this.isDisposedInternal=!1,this.shape=F.slice(),this.dtype=$||"float32",this.size=H.NA(F),this.strides=(0,H.e3)(F),this.dataId=V,this.id=G,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let F=await this.data();return ea.buffer(this.shape,this.dtype,F)}bufferSync(){return ea.buffer(this.shape,this.dtype,this.dataSync())}async array(){let F=await this.data();return(0,H.GX)(this.shape,F,"complex64"===this.dtype)}arraySync(){return(0,H.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let F=en().read(this.dataId);if("string"===this.dtype){let $=await F;try{return $.map(F=>et.decodeString(F))}catch(F){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return F}dataToGPU(F){return this.throwIfDisposed(),en().readToGPU(this.dataId,F)}dataSync(){this.throwIfDisposed();let F=en().readSync(this.dataId);if("string"===this.dtype)try{return F.map(F=>et.decodeString(F))}catch(F){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return F}async bytes(){this.throwIfDisposed();let F=await en().read(this.dataId);return"string"===this.dtype?F:new Uint8Array(F.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),en().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw Error("Tensor is disposed.")}print(F=!1){return ea.print(this,F)}clone(){return this.throwIfDisposed(),ea.clone(this)}toString(F=!1){let $=this.dataSync();return tensorToString($,this.shape,this.dtype,F)}cast(F){return this.throwIfDisposed(),ea.cast(this,F)}variable(F=!0,$,V){return this.throwIfDisposed(),en().makeVariable(this,F,$,V)}};function getGlobalTensorClass(){return(0,G.R)("Tensor",()=>Tensor)}Object.defineProperty(Tensor,Symbol.hasInstance,{value:F=>!!F&&null!=F.data&&null!=F.dataSync&&null!=F.throwIfDisposed}),getGlobalTensorClass();let Variable=class Variable extends Tensor{constructor(F,$,V,G){super(F.shape,F.dtype,F.dataId,G),this.trainable=$,this.name=V}assign(F){if(F.dtype!==this.dtype)throw Error(`dtype of the new value (${F.dtype}) and previous value (${this.dtype}) must match`);if(!H.cO(F.shape,this.shape))throw Error(`shape of the new value (${F.shape}) and previous value (${this.shape}) must match`);en().disposeTensor(this),this.dataId=F.dataId,en().incRef(this,null)}dispose(){en().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Variable,Symbol.hasInstance,{value:F=>F instanceof Tensor&&null!=F.assign&&F.assign instanceof Function})},80747:function(F,$,V){"use strict";V.r($),V.d($,{assertTypesMatch:function(){return assertTypesMatch},getTensorsInContainer:function(){return getTensorsInContainer},isTensorInList:function(){return isTensorInList},makeTypesMatch:function(){return makeTypesMatch}});var G=V(40974),H=V(71221),K=V(20569);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeTypesMatch(F,$){if(F.dtype===$.dtype)return[F,$];let V=(0,H.x8)(F.dtype,$.dtype);return[F.cast(V),$.cast(V)]}function assertTypesMatch(F,$){(0,K.hu)(F.dtype===$.dtype,()=>`The dtypes of the first(${F.dtype}) and second(${$.dtype}) input must match`)}function isTensorInList(F,$){return $.some($=>$.id===F.id)}function getTensorsInContainer(F){let $=[],V=new Set;return walkTensorContainer(F,$,V),$}function walkTensorContainer(F,$,V){if(null==F)return;if(F instanceof G.es){$.push(F);return}if(!isIterable(F))return;let H=F;for(let F in H){let G=H[F];V.has(G)||(V.add(G),walkTensorContainer(G,$,V))}}function isIterable(F){return Array.isArray(F)||"object"==typeof F}},43740:function(F,$,V){"use strict";V.d($,{C:function(){return inferShape},_1:function(){return convertToTensor},sI:function(){return convertToTensorArray}});var G=V(50196),H=V(22885),K=V(40974),Z=V(71221),ee=V(23418),et=V(20569);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function inferShape(F,$){let V=F;if((0,ee.isTypedArray)(F))return"string"===$?[]:[F.length];if((0,Z.Oq)(F)){let $=F.channels||"RGBA";return[F.height,F.width*$.length]}if((0,Z.$F)(F))return[F.buffer.size/(null==$?4:(0,et.bT)($))];if(!Array.isArray(F))return[];let G=[];for(;Array.isArray(V)||(0,ee.isTypedArray)(V)&&"string"!==$;)G.push(V.length),V=V[0];return Array.isArray(F)&&(0,H.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&deepAssertShapeConsistency(F,G,[]),G}function deepAssertShapeConsistency(F,$,V){if(V=V||[],!Array.isArray(F)&&!(0,ee.isTypedArray)(F)){(0,et.hu)(0===$.length,()=>`Element arr[${V.join("][")}] is a primitive, but should be an array/TypedArray of ${$[0]} elements`);return}(0,et.hu)($.length>0,()=>`Element arr[${V.join("][")}] should be a primitive, but is an array of ${F.length} elements`),(0,et.hu)(F.length===$[0],()=>`Element arr[${V.join("][")}] should have ${$[0]} elements, but has ${F.length} elements`);let G=$.slice(1);for(let $=0;$<F.length;++$)deepAssertShapeConsistency(F[$],G,V.concat($))}function assertDtype(F,$,V,G){if("string_or_numeric"!==F){if(null==F)throw Error("Expected dtype cannot be null.");if("numeric"!==F&&F!==$||"numeric"===F&&"string"===$)throw Error(`Argument '${V}' passed to '${G}' must be ${F} tensor, but got ${$} tensor`)}}function convertToTensor(F,$,V,H="numeric"){if(F instanceof(0,K.t3)())return assertDtype(H,F.dtype,$,V),F;let Z=(0,et.D2)(F);if("string"!==Z&&["bool","int32","float32"].indexOf(H)>=0&&(Z=H),assertDtype(H,Z,$,V),null==F||!(0,ee.isTypedArray)(F)&&!Array.isArray(F)&&"number"!=typeof F&&"boolean"!=typeof F&&"string"!=typeof F){let G=null==F?"null":F.constructor.name;throw Error(`Argument '${$}' passed to '${V}' must be a Tensor or TensorLike, but got '${G}'`)}let en=inferShape(F,Z);(0,ee.isTypedArray)(F)||Array.isArray(F)||(F=[F]);let ea=!0,ei="string"!==Z?(0,ee.toTypedArray)(F,Z):(0,ee.flatten)(F,[],ea);return G.BV.makeTensor(ei,en,Z)}function convertToTensorArray(F,$,V,G="numeric"){if(!Array.isArray(F))throw Error(`Argument ${$} passed to ${V} must be a \`Tensor[]\` or \`TensorLike[]\``);let H=F;return H.map((F,H)=>convertToTensor(F,`${$}[${H}]`,V,G))}},71221:function(F,$,V){"use strict";var G,H,K,Z,ee;V.d($,{$F:function(){return isWebGPUData},Oq:function(){return isWebGLData},x8:function(){return upcastType},yw:function(){return G},z4:function(){return sumOutType}}),function(F){F.R0="R0",F.R1="R1",F.R2="R2",F.R3="R3",F.R4="R4",F.R5="R5",F.R6="R6"}(G||(G={})),function(F){F.float32="float32",F.int32="int32",F.bool="int32",F.complex64="complex64"}(H||(H={})),function(F){F.float32="float32",F.int32="int32",F.bool="bool",F.complex64="complex64"}(K||(K={})),function(F){F.float32="float32",F.int32="float32",F.bool="float32",F.complex64="complex64"}(Z||(Z={})),function(F){F.float32="complex64",F.int32="complex64",F.bool="complex64",F.complex64="complex64"}(ee||(ee={}));let et={float32:Z,int32:H,bool:K,complex64:ee};function upcastType(F,$){if("string"===F||"string"===$){if("string"===F&&"string"===$)return"string";throw Error(`Can not upcast ${F} with ${$}`)}return et[F][$]}function sumOutType(F){return upcastType(F,"int32")}function isWebGLData(F){return null!=F&&"object"==typeof F&&"texture"in F&&F.texture instanceof WebGLTexture}function isWebGPUData(F){return"undefined"!=typeof GPUBuffer&&null!=F&&"object"==typeof F&&"buffer"in F&&F.buffer instanceof GPUBuffer}},23418:function(F,$,V){"use strict";V.r($),V.d($,{arraysEqual:function(){return K.cO},arraysEqualWithNull:function(){return K.DK},assert:function(){return K.hu},assertNonNegativeIntegerDimensions:function(){return K.Mu},assertNonNull:function(){return K.Cq},assertShapesMatch:function(){return K.k5},bytesFromStringArray:function(){return K.Ub},bytesPerElement:function(){return K.bT},checkConversionForErrors:function(){return K.D5},clamp:function(){return K.uZ},computeStrides:function(){return K.e3},convertBackendValuesAndArrayBuffer:function(){return K.KS},createScalarValue:function(){return createScalarValue},createShuffledIndices:function(){return K.U$},decodeString:function(){return decodeString},distSquared:function(){return K.E7},encodeString:function(){return encodeString},fetch:function(){return util_fetch},fingerPrint64:function(){return fingerPrint64},flatten:function(){return flatten},getArrayFromDType:function(){return K.rQ},getTypedArrayFromDType:function(){return K.WP},hasEncodingLoss:function(){return K.QB},hexToLong:function(){return hexToLong},indexToLoc:function(){return K.NE},inferDtype:function(){return K.D2},inferFromImplicitShape:function(){return K.JZ},isBoolean:function(){return K.jn},isFunction:function(){return K.mf},isInt:function(){return K.GN},isNumber:function(){return K.hj},isPromise:function(){return K.tI},isScalarShape:function(){return K.xH},isString:function(){return K.HD},isTypedArray:function(){return isTypedArray},isValidDtype:function(){return K.LP},locToIndex:function(){return K.qy},makeOnesTypedArray:function(){return K.p8},makeZerosNestedTypedArray:function(){return K.l6},makeZerosTypedArray:function(){return K.wT},nearestDivisor:function(){return K.jP},nearestLargerEven:function(){return K.nY},now:function(){return now},parseAxisParam:function(){return K.EC},randUniform:function(){return K.bj},repeatedTry:function(){return K.WD},rightPad:function(){return K.oj},shuffle:function(){return K.TV},shuffleCombo:function(){return K.d7},sizeFromShape:function(){return K.NA},sizeToSquarishShape:function(){return K.YP},squeezeShape:function(){return K.bp},sum:function(){return K.Sm},swap:function(){return K.LF},tanh:function(){return K.AE},toNestedArray:function(){return K.GX},toTypedArray:function(){return toTypedArray}});var G=V(22885),H=V(59742),K=V(20569),Z=V(43720),ee=V.n(Z);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let et=ee()||Z;function hexToLong(F){return et.fromString(F,!0,16)}let en=hexToLong("c3a5c85c97cb3127"),ea=hexToLong("b492b66fbe98f273"),ei=hexToLong("9ae16a3b2f90404f");function shiftMix(F){return F.xor(F.shru(47))}function fetch(F,$,V){let G=F.slice($,$+V);return et.fromBytes(Array.from(G),!0,!0)}function fetch64(F,$){return fetch(F,$,8)}function fetch32(F,$){return fetch(F,$,4)}function rotate64(F,$){return 0===$?F:F.shru($).or(F.shl(64-$))}function hashLen16(F,$,V=hexToLong("9ddfea08eb382d69")){let G=F.xor($).mul(V);G=G.xor(G.shru(47));let H=$.xor(G).mul(V);return(H=H.xor(H.shru(47))).mul(V)}function weakHashLen32WithSeeds(F,$,V,G,H,K){H=H.add(F),K=rotate64(K.add(H).add(G),21);let Z=H;return H=(H=H.add($)).add(V),K=K.add(rotate64(H,44)),[H.add(G),K.add(Z)]}function weakHashLen32WithSeedsStr(F,$,V,G){return weakHashLen32WithSeeds(fetch64(F,$),fetch64(F,$+8),fetch64(F,$+16),fetch64(F,$+24),V,G)}function hashLen0to16(F,$=F.length){if($>=8){let V=ei.add(2*$),G=fetch64(F,0).add(ei),H=fetch64(F,$-8),K=rotate64(H,37).mul(V).add(G),Z=rotate64(G,25).add(H).mul(V);return hashLen16(K,Z,V)}if($>=4){let V=ei.add(2*$),G=fetch32(F,0);return hashLen16(G.shl(3).add($),fetch32(F,$-4),V)}if($>0){let V=F[0],G=F[$>>1],H=F[$-1],K=V+(G<<8),Z=$+(H<<2);return shiftMix(ei.mul(K).xor(en.mul(Z))).mul(ei)}return ei}function hashLen17to32(F,$=F.length){let V=ei.add(2*$),G=fetch64(F,0).mul(ea),H=fetch64(F,8),K=fetch64(F,$-8).mul(V),Z=fetch64(F,$-16).mul(ei);return hashLen16(rotate64(G.add(H),43).add(rotate64(K,30)).add(Z),G.add(rotate64(H.add(ei),18)).add(K),V)}function hashLen33to64(F,$=F.length){let V=ei.add(2*$),G=fetch64(F,0).mul(ei),H=fetch64(F,8),K=fetch64(F,$-8).mul(V),Z=fetch64(F,$-16).mul(ei),ee=rotate64(G.add(H),43).add(rotate64(K,30)).add(Z),et=hashLen16(ee,G.add(rotate64(H.add(ei),18)).add(K),V),en=fetch64(F,16).mul(V),ea=fetch64(F,24),eo=ee.add(fetch64(F,$-32)).mul(V),es=et.add(fetch64(F,$-24)).mul(V);return hashLen16(rotate64(en.add(ea),43).add(rotate64(eo,30)).add(es),en.add(rotate64(ea.add(G),18)).add(eo),V)}function fingerPrint64(F,$=F.length){let V=et.fromNumber(81,!0);if($<=32)return $<=16?hashLen0to16(F,$):hashLen17to32(F,$);if($<=64)return hashLen33to64(F,$);let G=V,H=V.mul(ea).add(113),K=shiftMix(H.mul(ei).add(113)).mul(ei),Z=[et.UZERO,et.UZERO],ee=[et.UZERO,et.UZERO];G=G.mul(ei).add(fetch64(F,0));let eo=0,es=($-1>>6)*64,eu=es+($-1&63)-63;do G=rotate64(G.add(H).add(Z[0]).add(fetch64(F,eo+8)),37).mul(ea),H=rotate64(H.add(Z[1]).add(fetch64(F,eo+48)),42).mul(ea),G=G.xor(ee[1]),H=H.add(Z[0]).add(fetch64(F,eo+40)),K=rotate64(K.add(ee[0]),33).mul(ea),Z=weakHashLen32WithSeedsStr(F,eo,Z[1].mul(ea),G.add(ee[0])),ee=weakHashLen32WithSeedsStr(F,eo+32,K.add(ee[1]),H.add(fetch64(F,eo+16))),[K,G]=[G,K],eo+=64;while(eo!==es);let ec=ea.add(K.and(255).shl(1));return eo=eu,ee[0]=ee[0].add($-1&63),Z[0]=Z[0].add(ee[0]),ee[0]=ee[0].add(Z[0]),G=rotate64(G.add(H).add(Z[0]).add(fetch64(F,eo+8)),37).mul(ec),H=rotate64(H.add(Z[1]).add(fetch64(F,eo+48)),42).mul(ec),G=G.xor(ee[1].mul(9)),H=H.add(Z[0].mul(9).add(fetch64(F,eo+40))),K=rotate64(K.add(ee[0]),33).mul(ec),Z=weakHashLen32WithSeedsStr(F,eo,Z[1].mul(ec),G.add(ee[0])),ee=weakHashLen32WithSeedsStr(F,eo+32,K.add(ee[1]),H.add(fetch64(F,eo+16))),[K,G]=[G,K],hashLen16(hashLen16(Z[0],ee[0],ec).add(shiftMix(H).mul(en)).add(K),hashLen16(Z[1],ee[1],ec).add(G),ec)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createScalarValue(F,$){return"string"===$?encodeString(F):toTypedArray([F],$)}function noConversionNeeded(F,$){return F instanceof Float32Array&&"float32"===$||F instanceof Int32Array&&"int32"===$||F instanceof Uint8Array&&"bool"===$}function toTypedArray(F,$){if("string"===$)throw Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(F)&&(F=flatten(F)),(0,G.OB)().getBool("DEBUG")&&K.D5(F,$),noConversionNeeded(F,$))return F;if(null==$||"float32"===$||"complex64"===$)return new Float32Array(F);if("int32"===$)return new Int32Array(F);if("bool"===$){let $=new Uint8Array(F.length);for(let V=0;V<$.length;++V)0!==Math.round(F[V])&&($[V]=1);return $}throw Error(`Unknown data type ${$}`)}function now(){return(0,G.OB)().platform.now()}function util_fetch(F,$){return(0,G.OB)().platform.fetch(F,$)}function encodeString(F,$="utf-8"){return $=$||"utf-8",(0,G.OB)().platform.encode(F,$)}function decodeString(F,$="utf-8"){return $=$||"utf-8",(0,G.OB)().platform.decode(F,$)}function isTypedArray(F){return null!=(0,G.OB)().platform.isTypedArray?(0,G.OB)().platform.isTypedArray(F):(0,H.j)(F)}function flatten(F,$=[],V=!1){if(null==$&&($=[]),"boolean"==typeof F||"number"==typeof F||"string"==typeof F||K.tI(F)||null==F||isTypedArray(F)&&V)$.push(F);else if(Array.isArray(F)||isTypedArray(F))for(let G=0;G<F.length;++G)flatten(F[G],$,V);else{let G=-1;for(let $ of Object.keys(F))/^([1-9]+[0-9]*|0)$/.test($)&&(G=Math.max(G,Number($)));for(let H=0;H<=G;H++)flatten(F[H],$,V)}return $}},20569:function(F,$,V){"use strict";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function shuffle(F){let $=F.length,V=0;for(;$>0;)V=Math.random()*$|0,swap(F,--$,V)}function shuffleCombo(F,$){if(F.length!==$.length)throw Error(`Array sizes must match to be shuffled together First array length was ${F.length}Second array length was ${$.length}`);let V=F.length,G=0;for(;V>0;)G=Math.random()*V|0,swap(F,--V,G),swap($,V,G)}function clamp(F,$,V){return Math.max(F,Math.min($,V))}function nearestLargerEven(F){return F%2==0?F:F+1}function swap(F,$,V){let G=F[$];F[$]=F[V],F[V]=G}function sum(F){let $=0;for(let V=0;V<F.length;V++)$+=F[V];return $}function randUniform(F,$){let V=Math.random();return $*V+(1-V)*F}function distSquared(F,$){let V=0;for(let G=0;G<F.length;G++){let H=Number(F[G])-Number($[G]);V+=H*H}return V}function assert(F,$){if(!F)throw Error("string"==typeof $?$:$())}function assertShapesMatch(F,$,V=""){assert(arraysEqual(F,$),()=>V+` Shapes ${F} and ${$} must match`)}function assertNonNull(F){assert(null!=F,()=>"The input to the tensor constructor must be a non-null value.")}function sizeFromShape(F){if(0===F.length)return 1;let $=F[0];for(let V=1;V<F.length;V++)$*=F[V];return $}function isScalarShape(F){return 0===F.length}function arraysEqualWithNull(F,$){if(F===$)return!0;if(null==F||null==$||F.length!==$.length)return!1;for(let V=0;V<F.length;V++)if(null!==F[V]&&null!==$[V]&&F[V]!==$[V])return!1;return!0}function arraysEqual(F,$){if(F===$)return!0;if(null==F||null==$||F.length!==$.length)return!1;for(let V=0;V<F.length;V++)if(F[V]!==$[V])return!1;return!0}function isInt(F){return F%1==0}function tanh(F){if(null!=Math.tanh)return Math.tanh(F);if(F===1/0)return 1;if(F===-1/0)return -1;{let $=Math.exp(2*F);return($-1)/($+1)}}function sizeToSquarishShape(F){let $=Math.ceil(Math.sqrt(F));return[$,Math.ceil(F/$)]}function createShuffledIndices(F){let $=new Uint32Array(F);for(let V=0;V<F;++V)$[V]=V;return shuffle($),$}function rightPad(F,$){return $<=F.length?F:F+" ".repeat($-F.length)}function repeatedTry(F,$=F=>0,V,G){return new Promise((H,K)=>{let Z=0,tryFn=()=>{if(F()){H();return}Z++;let ee=$(Z);if(null!=V&&Z>=V){K();return}null!=G?G(tryFn,ee):setTimeout(tryFn,ee)};tryFn()})}function inferFromImplicitShape(F,$){let V=1,G=-1;for(let $=0;$<F.length;++$)if(F[$]>=0)V*=F[$];else if(-1===F[$]){if(-1!==G)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${G} and dim ${$}`);G=$}else if(F[$]<0)throw Error(`Shapes can not be < 0. Found ${F[$]} at dim ${$}`);if(-1===G){if($>0&&$!==V)throw Error(`Size(${$}) must match the product of shape ${F}`);return F}if(0===V)throw Error(`Cannot infer the missing size in [${F}] when there are 0 elements`);if($%V!=0)throw Error(`The implicit shape can't be a fractional number. Got ${$} / ${V}`);let H=F.slice();return H[G]=$/V,H}function parseAxisParam(F,$){let V=$.length;return assert((F=null==F?$.map((F,$)=>$):[].concat(F)).every(F=>F>=-V&&F<V),()=>`All values in axis param must be in range [-${V}, ${V}) but got axis ${F}`),assert(F.every(F=>isInt(F)),()=>`All values in axis param must be integers but got axis ${F}`),F.map(F=>F<0?V+F:F)}function squeezeShape(F,$){let V=[],G=[],H=null!=$&&Array.isArray($)&&0===$.length,K=null==$||H?null:parseAxisParam($,F).sort(),Z=0;for(let $=0;$<F.length;++$){if(null!=K){if(K[Z]===$&&1!==F[$])throw Error(`Can't squeeze axis ${$} since its dim '${F[$]}' is not 1`);(null==K[Z]||K[Z]>$)&&1===F[$]&&(V.push(F[$]),G.push($)),K[Z]<=$&&Z++}1!==F[$]&&(V.push(F[$]),G.push($))}return{newShape:V,keptDims:G}}function getTypedArrayFromDType(F,$){return getArrayFromDType(F,$)}function getArrayFromDType(F,$){let V=null;if(null==F||"float32"===F)V=new Float32Array($);else if("int32"===F)V=new Int32Array($);else if("bool"===F)V=new Uint8Array($);else if("string"===F)V=Array($);else throw Error(`Unknown data type ${F}`);return V}function checkConversionForErrors(F,$){for(let V=0;V<F.length;V++){let G=F[V];if(isNaN(G)||!isFinite(G))throw Error(`A tensor of type ${$} being uploaded contains ${G}.`)}}function isValidDtype(F){return"bool"===F||"complex64"===F||"float32"===F||"int32"===F||"string"===F}function hasEncodingLoss(F,$){return"complex64"!==$&&("float32"!==$||"complex64"===F)&&("int32"!==$||"float32"===F||"complex64"===F)&&("bool"!==$||"bool"!==F)}function bytesPerElement(F){if("float32"===F||"int32"===F)return 4;if("complex64"===F)return 8;if("bool"===F)return 1;throw Error(`Unknown dtype ${F}`)}function bytesFromStringArray(F){if(null==F)return 0;let $=0;return F.forEach(F=>$+=F.length),$}function isString(F){return"string"==typeof F||F instanceof String}function isBoolean(F){return"boolean"==typeof F}function isNumber(F){return"number"==typeof F}function inferDtype(F){if(Array.isArray(F))return inferDtype(F[0]);if(F instanceof Float32Array);else if(F instanceof Int32Array||F instanceof Uint8Array||F instanceof Uint8ClampedArray)return"int32";else if(isNumber(F));else if(isString(F))return"string";else if(isBoolean(F))return"bool";return"float32"}function isFunction(F){return!!(F&&F.constructor&&F.call&&F.apply)}function nearestDivisor(F,$){for(let V=$;V<F;++V)if(F%V==0)return V;return F}function computeStrides(F){let $=F.length;if($<2)return[];let V=Array($-1);V[$-2]=F[$-1];for(let G=$-3;G>=0;--G)V[G]=V[G+1]*F[G+1];return V}function createNestedArray(F,$,V,G=!1){let H=[];if(1===$.length){let K=$[0]*(G?2:1);for(let $=0;$<K;$++)H[$]=V[F+$]}else{let K=$[0],Z=$.slice(1),ee=Z.reduce((F,$)=>F*$)*(G?2:1);for(let $=0;$<K;$++)H[$]=createNestedArray(F+$*ee,Z,V,G)}return H}function toNestedArray(F,$,V=!1){if(0===F.length)return $[0];let G=F.reduce((F,$)=>F*$)*(V?2:1);if(0===G)return[];if(G!==$.length)throw Error(`[${F}] does not match the input size ${$.length}${V?" for a complex tensor":""}.`);return createNestedArray(0,F,$,V)}function convertBackendValuesAndArrayBuffer(F,$){if(Array.isArray(F))return F;if("float32"===$)return F instanceof Float32Array?F:new Float32Array(F);if("int32"===$)return F instanceof Int32Array?F:new Int32Array(F);if("bool"===$||"string"===$)return Uint8Array.from(new Int32Array(F));throw Error(`Unknown dtype ${$}`)}function makeOnesTypedArray(F,$){let V=makeZerosTypedArray(F,$);for(let F=0;F<V.length;F++)V[F]=1;return V}function makeZerosTypedArray(F,$){if(null==$||"float32"===$||"complex64"===$)return new Float32Array(F);if("int32"===$)return new Int32Array(F);if("bool"===$)return new Uint8Array(F);throw Error(`Unknown data type ${$}`)}function makeZerosNestedTypedArray(F,$){let V=F.reduce((F,$)=>F*$,1);if(null==$||"float32"===$)return toNestedArray(F,new Float32Array(V));if("int32"===$)return toNestedArray(F,new Int32Array(V));if("bool"===$)return toNestedArray(F,new Uint8Array(V));throw Error(`Unknown data type ${$}`)}function assertNonNegativeIntegerDimensions(F){F.forEach($=>{assert(Number.isInteger($)&&$>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${F}].`)})}function locToIndex(F,$,V){if(0===$)return 0;if(1===$)return F[0];let G=F[F.length-1];for(let $=0;$<F.length-1;++$)G+=V[$]*F[$];return G}function indexToLoc(F,$,V){if(0===$)return[];if(1===$)return[F];let G=Array($);for(let $=0;$<G.length-1;++$)G[$]=Math.floor(F/V[$]),F-=G[$]*V[$];return G[G.length-1]=F,G}function isPromise(F){return F&&F.then&&"function"==typeof F.then}V.d($,{AE:function(){return tanh},Cq:function(){return assertNonNull},D2:function(){return inferDtype},D5:function(){return checkConversionForErrors},DK:function(){return arraysEqualWithNull},E7:function(){return distSquared},EC:function(){return parseAxisParam},GN:function(){return isInt},GX:function(){return toNestedArray},HD:function(){return isString},JZ:function(){return inferFromImplicitShape},KS:function(){return convertBackendValuesAndArrayBuffer},LF:function(){return swap},LP:function(){return isValidDtype},Mu:function(){return assertNonNegativeIntegerDimensions},NA:function(){return sizeFromShape},NE:function(){return indexToLoc},QB:function(){return hasEncodingLoss},Sm:function(){return sum},TV:function(){return shuffle},U$:function(){return createShuffledIndices},Ub:function(){return bytesFromStringArray},WD:function(){return repeatedTry},WP:function(){return getTypedArrayFromDType},YP:function(){return sizeToSquarishShape},bT:function(){return bytesPerElement},bj:function(){return randUniform},bp:function(){return squeezeShape},cO:function(){return arraysEqual},d7:function(){return shuffleCombo},e3:function(){return computeStrides},hj:function(){return isNumber},hu:function(){return assert},jP:function(){return nearestDivisor},jn:function(){return isBoolean},k5:function(){return assertShapesMatch},l6:function(){return makeZerosNestedTypedArray},mf:function(){return isFunction},nY:function(){return nearestLargerEven},oj:function(){return rightPad},p8:function(){return makeOnesTypedArray},qy:function(){return locToIndex},rQ:function(){return getArrayFromDType},tI:function(){return isPromise},uZ:function(){return clamp},wT:function(){return makeZerosTypedArray},xH:function(){return isScalarShape}})},28819:function(F,$,V){"use strict";V.d($,{GD:function(){return serializeActivation},Gc:function(){return Softmax},aI:function(){return getActivation}});var G=V(15949),H=V(39840),K=V(2931);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Activation=class Activation extends G.m7h.Serializable{getConfig(){return{}}};let Elu=class Elu extends Activation{apply(F,$=1){return H.py(F,$)}};Elu.className="elu",G.m7h.registerClass(Elu);let Selu=class Selu extends Activation{apply(F){return G.U8D(F)}};Selu.className="selu",G.m7h.registerClass(Selu);let Relu=class Relu extends Activation{apply(F){return G.UYe(F)}};Relu.className="relu",G.m7h.registerClass(Relu);let Relu6=class Relu6 extends Activation{apply(F){return(0,G.lub)(()=>G.LTh(6,G.UYe(F)))}};Relu6.className="relu6",G.m7h.registerClass(Relu6);let Linear=class Linear extends Activation{apply(F){return F}};Linear.className="linear",G.m7h.registerClass(Linear);let Sigmoid=class Sigmoid extends Activation{apply(F){return G.XD2(F)}};Sigmoid.className="sigmoid",G.m7h.registerClass(Sigmoid);let HardSigmoid=class HardSigmoid extends Activation{apply(F){return H.HX(F)}};HardSigmoid.className="hardSigmoid",G.m7h.registerClass(HardSigmoid);let Softplus=class Softplus extends Activation{apply(F){return G.Wvh(F)}};Softplus.className="softplus",G.m7h.registerClass(Softplus);let Softsign=class Softsign extends Activation{apply(F){return H.O(F)}};Softsign.className="softsign",G.m7h.registerClass(Softsign);let Tanh=class Tanh extends Activation{apply(F){return G.AEp(F)}};Tanh.className="tanh",G.m7h.registerClass(Tanh);let Softmax=class Softmax extends Activation{apply(F,$=-1){return G.XAC(F,$)}};Softmax.className="softmax",G.m7h.registerClass(Softmax);let LogSoftmax=class LogSoftmax extends Activation{apply(F,$=-1){return G.CmS(F,$)}};LogSoftmax.className="logSoftmax",G.m7h.registerClass(LogSoftmax);let Swish=class Swish extends Activation{apply(F,$=1){return(0,G.lub)(()=>G.dC7(G.XD2(G.dC7(F,$)),F))}};Swish.className="swish",G.m7h.registerClass(Swish);let Mish=class Mish extends Activation{apply(F){return(0,G.lub)(()=>G.dC7(F,G.AEp(G.Wvh(F))))}};function serializeActivation(F){return F.getClassName()}function deserializeActivation(F,$={}){return(0,K.tU)(F,G.m7h.SerializationMap.getMap().classNameMap,$,"activation")}function getActivation(F){if(null==F){let F={};return F.className="linear",F.config={},deserializeActivation(F)}if("string"==typeof F){let $={};return $.className=F,$.config={},deserializeActivation($)}return F instanceof Activation?F:deserializeActivation(F)}Mish.className="mish",G.m7h.registerClass(Mish)},12012:function(F,$,V){"use strict";let G;V.d($,{Ho:function(){return epsilon},rf:function(){return imageDataFormat}});var H=V(15949);function epsilon(){return null==G&&(G=(0,H.y3$)().epsilon()),G}function imageDataFormat(){return"channelsLast"}},79608:function(F,$,V){"use strict";V.d($,{L:function(){return getNextUniqueTensorId},s:function(){return getUid}});/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let G=0;function getNextUniqueTensorId(){return G++}let H={};function getUid(F=""){return F in H||(H[F]=0),H[F]+=1,F+H[F].toString()}},39840:function(F,$,V){"use strict";V.d($,{AK:function(){return dot},GZ:function(){return concatAlongFirstAxis},Gg:function(){return tile},HX:function(){return hardSigmoid},Iq:function(){return gather},KC:function(){return inTrainPhase},O:function(){return softsign},Uz:function(){return batchFlatten},a2:function(){return biasAdd},c9:function(){return sliceAlongFirstAxis},dt:function(){return expandDims},h6:function(){return square},mV:function(){return concatenate},nG:function(){return randomNormal},pj:function(){return cast},py:function(){return elu},rv:function(){return dropout},rx:function(){return repeat},uI:function(){return sliceAlongAxis},xH:function(){return flatten}});var G=V(15949),H=V(48090),K=V(40588),Z=V(96040),ee=V(12012);function cast(F,$){return G.pju(F,$)}function expandDims(F,$=-1){let V=F.shape.slice();return $<0&&($=V.length+$+1),V.splice($,0,1),G.XLQ(F,V)}function repeat(F,$){return(0,G.lub)(()=>{if(2!==F.shape.length)throw new K.nu(`repeat() expects a rank-2 tensor, but received a rank-${F.shape.length} tensor.`);let V=expandDims(F,1);return tile(V,[1,$,1])})}function flatten(F){let $=[Z.NS(F.shape)];return G.XLQ(F,$)}function batchFlatten(F){if(F.rank<=1)throw new K.nu(`batchFlatten requires a minimum rank of 2. Got rank: ${F.rank}.`);let $=[F.shape[0],Z.NS(F.shape,1)];return G.XLQ(F,$)}function sliceAlongFirstAxis(F,$,V){return(0,G.lub)(()=>{switch(F.rank){case 1:return G.jZU(F,$,V);case 2:return G.SmN(F,[$,0],[V,F.shape[1]]);case 3:return G.CnO(F,[$,0,0],[V,F.shape[1],F.shape[2]]);case 4:return G.p0P(F,[$,0,0,0],[V,F.shape[1],F.shape[2],F.shape[3]]);case 5:return G.tPi(F,[$,0,0,0,0],[V,F.shape[1],F.shape[2],F.shape[3],F.shape[4]]);case 6:return G.tPi(F,[$,0,0,0,0,0],[V,F.shape[1],F.shape[2],F.shape[3],F.shape[4],F.shape[5]]);default:throw new K.nu(`sliceAlongFirstAxis() received an unsupported tensor rank: ${F.rank}`)}})}function sliceAlongLastAxis(F,$,V){return(0,G.lub)(()=>{switch(F.rank){case 1:return G.jZU(F,$,V);case 2:return G.SmN(F,[0,$],[F.shape[0],V]);case 3:return G.CnO(F,[0,0,$],[F.shape[0],F.shape[1],V]);case 4:return G.p0P(F,[0,0,0,$],[F.shape[0],F.shape[1],F.shape[2],V]);default:throw new K.nu(`sliceAlongLastAxis() received an unsupported tensor rank: ${F.rank}`)}})}function sliceAlongAxis(F,$,V,H){return(0,G.lub)(()=>{switch(F.rank){case 1:return G.jZU(F,$,V);case 2:switch(H){case 1:return sliceAlongFirstAxis(F,$,V);case 2:return sliceAlongLastAxis(F,$,V);default:throw new K.nu(`The axis is not within the rank of the tensor ${H}`)}case 3:switch(H){case 1:return sliceAlongFirstAxis(F,$,V);case 2:return G.CnO(F,[0,$,0],[F.shape[0],V,F.shape[2]]);case 3:return sliceAlongLastAxis(F,$,V);default:throw new K.nu(`The axis is not within the rank of the tensor ${H}`)}case 4:switch(H){case 1:return sliceAlongFirstAxis(F,$,V);case 2:return G.p0P(F,[0,$,0,0],[F.shape[0],V,F.shape[2],F.shape[3]]);case 3:return G.p0P(F,[0,0,$,0],[F.shape[0],F.shape[1],V,F.shape[3]]);case 4:return sliceAlongLastAxis(F,$,V);default:throw new K.nu(`The axis is not within the rank of the tensor ${H}`)}default:throw new K.nu(`sliceAlongLastAxis() received an unsupported tensor rank: ${F.rank}`)}})}function concatenate(F,$=-1){let V;return $<0&&($=0!==(V=F[0].rank)?V:0),$===F[0].rank&&($=-1),G.zoF(F,$)}function concatAlongFirstAxis(F,$){switch(F.rank){case 1:return G.gME([F,$]);case 2:return G.Izb([F,$],0);case 3:return G.MNy([F,$],0);case 4:return G.ZaL([F,$],0);default:throw new K.nu(`concatAlongFirstAxis() received an unsupported tensor rank: ${F.rank}`)}}function tile(F,$){if(Array.isArray($)||($=[$]),F.rank!==$.length)throw new K.nu(`The length of input n (${$.length}) does not match the number of dimensions in input x (${F.rank})`);return G.Gg6(F,$)}function randomNormal(F,$=0,V=1,H,K){return G.nGf(F,$,V,H,K)}function dot(F,$,V,H){if(F.rank<2||$.rank<2)throw new K.nj(`dot requires both inputs to be rank >= 2 but got x shape = ${F.shape} and y shape = ${$.shape}`);if($.rank>=3){let V=F.shape.slice(-1)[0],G=$.shape.slice(-2)[0];if(V!==G)throw new K.nj(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${F.shape} and  y shape = ${$.shape}`)}if(2===F.rank&&2===$.rank){let K=!1,Z=!1;return G.imm.matMul({a:F,b:$,transposeA:K,transposeB:Z,bias:H?reshapeBias(F.rank,H,(0,ee.rf)()):null,activation:V})}{let K=F.shape.slice(),Z=K.pop();F=G.XLQ(F,[-1,Z]);let et=$.shape.slice(),en=et.pop(),ea=et.pop(),ei=[...et,en],eo=Array.from({length:$.rank},(F,V)=>0===V?$.rank-2:V<=$.rank-2?V-1:V);$=G.XLQ(G.p4s($,eo),[ea,-1]);let es=[...K,...ei],eu=!1,ec=!1;return G.XLQ(G.imm.matMul({a:F,b:$,transposeA:eu,transposeB:ec,bias:H?reshapeBias(F.rank,H,(0,ee.rf)()):null,activation:V}),es)}}function gather(F,$,V){return(0,G.lub)(()=>($=Array.isArray($)?(0,G.RRF)($,"int32"):G.pju($,"int32"),G.Iqj(F,$,V)))}function square(F){return G.dC7(F,F)}function reshapeBias(F,$,V){let H=$.shape;if(1!==$.rank&&$.rank!==F)throw new K.nu(`Unexpected bias dimensions: ${$.rank}; expected it to be 1 or ${F}`);if(5===F){if("channelsFirst"===V)return 1===H.length?G.XLQ($,[1,H[0],1,1,1]):G.XLQ($,[1,H[3],H[0],H[1],H[2]]);if("channelsLast"===V)return 1===H.length?G.XLQ($,[1,1,1,1,H[0]]):G.XLQ($,[1].concat(H))}else if(4===F){if("channelsFirst"===V)return 1===H.length?G.XLQ($,[1,H[0],1,1]):G.XLQ($,[1,H[2],H[0],H[1]]);if("channelsLast"===V)return 1===H.length?G.XLQ($,[1,1,1,H[0]]):G.XLQ($,[1].concat(H))}else if(3===F){if("channelsFirst"===V)return 1===H.length?G.XLQ($,[1,H[0],1]):G.XLQ($,[1,H[1],H[0]]);if("channelsLast"===V)return 1===H.length?G.XLQ($,[1,1,H[0]]):G.XLQ($,[1].concat(H))}else if(F<3)return $;throw new K.nu(`Unsupported input rank by biasAdd: ${$.rank}`)}function biasAdd(F,$,V){return(0,G.lub)(()=>(null==V&&(V=(0,ee.rf)()),(0,H.cj)(V),G.IHx(F,reshapeBias(F.rank,$,V))))}function elu(F,$=1){if(1!==$)throw new K.nj(`Support for alpha values other than 1 (${$}) is not implemented yet.`);return G.pyx(F)}function softsign(F){return(0,G.lub)(()=>G.hiC(F,G.IHx(G.WnP(F),1)))}function dropout(F,$,V,H){return(0,G.lub)(()=>G.rvX(F,$,V,H))}function hardSigmoid(F){return(0,G.lub)(()=>{let $=G.IHx(.5,G.dC7(.2,F));return G.iUl($,0,1)})}function inTrainPhase(F,$,V=!1){return V?F():$()}},28891:function(F,$,V){"use strict";V.d($,{Ay:function(){return History},BO:function(){return CallbackList},CZ:function(){return standardizeCallbacks},Sk:function(){return CallbackConstructorRegistry},ex:function(){return BaseCallback},iT:function(){return CustomCallback},m$:function(){return configureCallbacks}});var G,H=V(15949),K=V(40588),Z=V(73146),ee=V(2931);!function(F){F[F.SILENT=0]="SILENT",F[F.VERBOSE=1]="VERBOSE"}(G||(G={}));let et=125;let BaseCallback=class BaseCallback{constructor(){this.validationData=null}setParams(F){this.params=F}async onEpochBegin(F,$){}async onEpochEnd(F,$){}async onBatchBegin(F,$){}async onBatchEnd(F,$){}async onTrainBegin(F){}async onTrainEnd(F){}setModel(F){}};let CallbackList=class CallbackList{constructor(F,$=10){null==F&&(F=[]),this.callbacks=F,this.queueLength=$}append(F){this.callbacks.push(F)}setParams(F){for(let $ of this.callbacks)$.setParams(F)}setModel(F){for(let $ of this.callbacks)$.setModel(F)}async onEpochBegin(F,$){for(let V of(null==$&&($={}),this.callbacks))await V.onEpochBegin(F,$)}async onEpochEnd(F,$){for(let V of(null==$&&($={}),this.callbacks))await V.onEpochEnd(F,$)}async onBatchBegin(F,$){for(let V of(null==$&&($={}),this.callbacks))await V.onBatchBegin(F,$)}async onBatchEnd(F,$){for(let V of(null==$&&($={}),this.callbacks))await V.onBatchEnd(F,$)}async onTrainBegin(F){for(let $ of(null==F&&(F={}),this.callbacks))await $.onTrainBegin(F)}async onTrainEnd(F){for(let $ of(null==F&&(F={}),this.callbacks))await $.onTrainEnd(F)}};let BaseLogger=class BaseLogger extends BaseCallback{constructor(){super()}async onEpochBegin(F){this.seen=0,this.totals={}}async onBatchEnd(F,$){null==$&&($={});let V=null==$.size?0:$.size;for(let F in this.seen+=V,$){let G=$[F];if("number"==typeof G)this.totals.hasOwnProperty(F)||(this.totals[F]=0),this.totals[F]=this.totals[F]+G*V;else{let $;F in this.totals?$=this.totals[F]:this.totals[F]=0;let K=(0,H.lub)(()=>(0,H.IHx)(this.totals[F],(0,H.dC7)(G,V)));this.totals[F]=K,null!=$&&$.dispose()}}}async onEpochEnd(F,$){if(null!=$)for(let F of this.params.metrics)null!=this.totals[F]&&("number"==typeof this.totals[F]?$[F]=this.totals[F]/this.seen:(0,H.lub)(()=>{let V=(0,H.dC7)((0,H.hiC)(1,this.seen),this.totals[F]);$[F]=V,this.totals[F].dispose(),(0,H.CnY)($[F])}))}};let History=class History extends BaseCallback{async onTrainBegin(F){this.epoch=[],this.history={}}async onEpochEnd(F,$){for(let V in null==$&&($={}),this.epoch.push(F),$)null==this.history[V]&&(this.history[V]=[]),this.history[V].push($[V])}async syncData(){let F=[],$=[],V=[];for(let G in this.history){let H=this.history[G];for(let K=0;K<H.length;++K)if("number"!=typeof H[K]){let Z=H[K];F.push(Z.data()),$.push(G),V.push(K)}}let G=await Promise.all(F);for(let F=0;F<G.length;++F){let H=this.history[$[F]][V[F]];H.dispose(),this.history[$[F]][V[F]]=G[F][0]}}};let CustomCallback=class CustomCallback extends BaseCallback{constructor(F,$){if(super(),this.currentEpoch=0,this.nowFunc=F.nowFunc,this.nextFrameFunc=F.nextFrameFunc||H.glt,this.yieldEvery=$||"auto","auto"===this.yieldEvery&&(this.yieldEvery=et),"never"===this.yieldEvery&&null!=F.onYield)throw Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");H.D5U.isNumber(this.yieldEvery)&&(this.maybeWait=ee.Ds(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=F.onTrainBegin,this.trainEnd=F.onTrainEnd,this.epochBegin=F.onEpochBegin,this.epochEnd=F.onEpochEnd,this.batchBegin=F.onBatchBegin,this.batchEnd=F.onBatchEnd,this.yield=F.onYield}async maybeWait(F,$,V){let G=[];null!=this.yield&&(await (0,Z.Z)(V),G.push(this.yield(F,$,V))),G.push(this.nextFrameFunc()),await Promise.all(G)}async onEpochBegin(F,$){this.currentEpoch=F,null!=this.epochBegin&&(await (0,Z.Z)($),await this.epochBegin(F,$))}async onEpochEnd(F,$){let V=[];null!=this.epochEnd&&(await (0,Z.Z)($),V.push(this.epochEnd(F,$))),"epoch"===this.yieldEvery&&V.push(this.nextFrameFunc()),await Promise.all(V)}async onBatchBegin(F,$){null!=this.batchBegin&&(await (0,Z.Z)($),await this.batchBegin(F,$))}async onBatchEnd(F,$){let V=[];null!=this.batchEnd&&(await (0,Z.Z)($),V.push(this.batchEnd(F,$))),"batch"===this.yieldEvery?V.push(this.nextFrameFunc()):H.D5U.isNumber(this.yieldEvery)&&V.push(this.maybeWait(this.currentEpoch,F,$)),await Promise.all(V)}async onTrainBegin(F){null!=this.trainBegin&&(await (0,Z.Z)(F),await this.trainBegin(F))}async onTrainEnd(F){null!=this.trainEnd&&(await (0,Z.Z)(F),await this.trainEnd(F))}};function standardizeCallbacks(F,$){if(null==F&&(F={}),F instanceof BaseCallback)return[F];if(Array.isArray(F)&&F[0]instanceof BaseCallback)return F;let V=ee.zZ(F);return V.map(F=>new CustomCallback(F,$))}let CallbackConstructorRegistry=class CallbackConstructorRegistry{constructor(){}static registerCallbackConstructor(F,$){H.D5U.assert(F>=0&&Number.isInteger(F),()=>`Verbosity level is expected to be an integer >= 0, but got ${F}`),CallbackConstructorRegistry.checkForDuplicate($),null==CallbackConstructorRegistry.constructors[F]&&(CallbackConstructorRegistry.constructors[F]=[]),CallbackConstructorRegistry.constructors[F].push($)}static checkForDuplicate(F){for(let $ in CallbackConstructorRegistry.constructors){let V=CallbackConstructorRegistry.constructors[+$];V.forEach($=>{if($===F)throw new K.nu("Duplicate callback constructor.")})}}static clear(){CallbackConstructorRegistry.constructors={}}static createCallbacks(F){let $=[];for(let V in CallbackConstructorRegistry.constructors){let G=+V;F>=G&&$.push(...CallbackConstructorRegistry.constructors[G])}return $.map(F=>new F)}};function configureCallbacks(F,$,V,G,H,K,Z,ee,et){let en=new History,ea=[new BaseLogger,...CallbackConstructorRegistry.createCallbacks($)];null!=F&&ea.push(...F),ea.push(en);let ei=new CallbackList(ea);return ei.setParams({epochs:V,initialEpoch:G,samples:H,steps:K,batchSize:Z,verbose:$,doValidation:ee,metrics:et}),{callbackList:ei,history:en}}CallbackConstructorRegistry.constructors={}},48090:function(F,$,V){"use strict";V.d($,{Lp:function(){return checkPoolMode},MU:function(){return getScopedTensorName},cj:function(){return checkDataFormat},f4:function(){return nameScope},w8:function(){return getUniqueTensorName},wU:function(){return checkInterpolationFormat},zb:function(){return checkPaddingMode}});var G=V(44685),H=V(2931);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let K=new Map;function checkDataFormat(F){(0,H.xn)(G.PS,"DataFormat",F)}function checkInterpolationFormat(F){(0,H.xn)(G.Mz,"InterpolationFormat",F)}function checkPaddingMode(F){(0,H.xn)(G.zx,"PaddingMode",F)}function checkPoolMode(F){(0,H.xn)(G.MK,"PoolMode",F)}let Z=[],ee="/";function nameScope(F,$){Z.push(F);try{let F=$();return Z.pop(),F}catch(F){throw Z.pop(),F}}function currentNameScopePrefix(){return 0===Z.length?"":Z.join(ee)+ee}function getScopedTensorName(F){if(!isValidTensorName(F))throw Error("Not a valid tensor name: '"+F+"'");return currentNameScopePrefix()+F}function getUniqueTensorName(F){if(!isValidTensorName(F))throw Error("Not a valid tensor name: '"+F+"'");K.has(F)||K.set(F,0);let $=K.get(F);if(K.set(F,K.get(F)+1),!($>0))return F;{let V=`${F}_${$}`;return K.set(V,1),V}}let et=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function isValidTensorName(F){return!!F.match(et)}},64079:function(F,$,V){"use strict";V.d($,{Ad:function(){return getConstraint},Yq:function(){return MaxNorm},cK:function(){return UnitNorm},he:function(){return NonNeg},iL:function(){return MinMaxNorm},xF:function(){return serializeConstraint}});var G=V(15949),H=V(12012),K=V(2931);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function calcL2Norms(F,$){return(0,G.lub)(()=>G._b3(G.Smz(G.dC7(F,F),$,!0)))}let Constraint=class Constraint extends G.m7h.Serializable{getConfig(){return{}}};let MaxNorm=class MaxNorm extends Constraint{constructor(F){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=F.maxValue?F.maxValue:this.defaultMaxValue,this.axis=null!=F.axis?F.axis:this.defaultAxis}apply(F){return(0,G.lub)(()=>{let $=calcL2Norms(F,this.axis),V=G.iUl($,0,this.maxValue);return G.dC7(F,G.hiC(V,G.IHx((0,H.Ho)(),$)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};MaxNorm.className="MaxNorm",G.m7h.registerClass(MaxNorm);let UnitNorm=class UnitNorm extends Constraint{constructor(F){super(),this.defaultAxis=0,this.axis=null!=F.axis?F.axis:this.defaultAxis}apply(F){return(0,G.lub)(()=>G.hiC(F,G.IHx((0,H.Ho)(),calcL2Norms(F,this.axis))))}getConfig(){return{axis:this.axis}}};UnitNorm.className="UnitNorm",G.m7h.registerClass(UnitNorm);let NonNeg=class NonNeg extends Constraint{apply(F){return G.UYe(F)}};NonNeg.className="NonNeg",G.m7h.registerClass(NonNeg);let MinMaxNorm=class MinMaxNorm extends Constraint{constructor(F){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=F.minValue?F.minValue:this.defaultMinValue,this.maxValue=null!=F.maxValue?F.maxValue:this.defaultMaxValue,this.rate=null!=F.rate?F.rate:this.defaultRate,this.axis=null!=F.axis?F.axis:this.defaultAxis}apply(F){return(0,G.lub)(()=>{let $=calcL2Norms(F,this.axis),V=G.IHx(G.dC7(this.rate,G.iUl($,this.minValue,this.maxValue)),G.dC7(1-this.rate,$));return G.dC7(F,G.hiC(V,G.IHx((0,H.Ho)(),$)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};MinMaxNorm.className="MinMaxNorm",G.m7h.registerClass(MinMaxNorm);let Z={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function serializeConstraint(F){return(0,K.Kj)(F)}function deserializeConstraint(F,$={}){return(0,K.tU)(F,G.m7h.SerializationMap.getMap().classNameMap,$,"constraint")}function getConstraint(F){if(null==F)return null;if("string"==typeof F){let $=F in Z?Z[F]:F,V={className:$,config:{}};return deserializeConstraint(V)}return F instanceof Constraint?F:deserializeConstraint(F)}},41111:function(F,$,V){"use strict";V.d($,{l2:function(){return FeedDict},ht:function(){return execute},kS:function(){return updateCacheMaxEntries}});var G=V(15949),H=V(40588);/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let LruCache=class LruCache{constructor(F){this.maxEntries=F||100,this.cache=new Map}get(F){let $;return this.cache.has(F)&&($=this.cache.get(F),this.cache.delete(F),this.cache.set(F,$)),$}put(F,$){if(this.cache.has(F))this.cache.delete(F);else if(this.cache.size>=this.maxEntries){let F=this.cache.keys().next().value;this.cache.delete(F)}this.cache.set(F,$)}getMaxEntries(){return this.maxEntries}setMaxEntries(F){if(F<0)throw Error(`The maxEntries of LRU caches must be at least 0, but got ${F}.`);if(this.maxEntries>F)for(let $=0;$<this.maxEntries-F;$++){let F=this.cache.keys().next().value;this.cache.delete(F)}this.maxEntries=F}};var K=V(2931),Z=V(34396),ee=V(20163);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function assertFeedCompatibility(F,$){if(null==F.dtype||F.dtype===$.dtype)return $;try{return(0,G.pju)($,F.dtype)}catch(V){throw new H.nu(`The dtype of the feed (${$.dtype}) can not be cast to the dtype of the key '${F.name}' (${F.dtype}).`)}}let FeedDict=class FeedDict{constructor(F){if(this.id2Value={},this.id2Mask={},this.name2Id={},F instanceof FeedDict)for(let $ in F.id2Value)this.id2Value[$]=F.id2Value[$],$ in F.id2Mask&&(this.id2Mask[$]=F.id2Mask[$]);else{if(null==F)return;for(let $ of F)this.add($.key,$.value)}}add(F,$,V){if(null==this.id2Value[F.id])this.id2Value[F.id]=assertFeedCompatibility(F,$),this.name2Id[F.name]=F.id,null!=V&&(this.id2Mask[F.id]=V);else throw new H.nu(`Duplicate key: name=${F.name}, id=${F.id}`);return this}addFeed(F){this.add(F.key,F.value)}hasKey(F){return null!=this.id2Value[F.id]}names(){return Object.keys(this.name2Id)}getValue(F){if(F instanceof ee.Iy){if(null!=this.id2Value[F.id])return this.id2Value[F.id];throw new H.nu(`Nonexistent key: ${F.name}`)}{let $=this.name2Id[F];if(null==$)throw new H.nu(`Feed dict has no SymbolicTensor name: ${F}`);return this.id2Value[$]}}getMask(F){if(F instanceof ee.Iy){if(null!=this.id2Value[F.id])return this.id2Mask[F.id];throw new H.nu(`Nonexistent key: ${F.name}`)}{let $=this.name2Id[F];if(null==$)throw new H.nu(`Feed dict has no SymbolicTensor name: ${F}`);return this.id2Mask[$]}}disposeMasks(){null!=this.id2Mask&&(0,G.B90)(this.id2Mask)}};let et=new LruCache,en=new LruCache;function updateCacheMaxEntries(F){null!=et&&et.setMaxEntries(F),null!=en&&en.setMaxEntries(F)}function execute(F,$,V,H){let ee;let ea=null!=V&&V.training,ei=Array.isArray(F),eo=ei?F:[F],es=eo.map(F=>F.name),eu=[],ec=$.names();for(let F of es)-1!==ec.indexOf(F)?eu.push($.getValue(F)):eu.push(null);null!=H&&(H.maxNumTensors=-1/0,H.minNumTensors=1/0);let ep=es.join(",")+"|"+$.names().sort().join(","),eh=et.get(ep);if(null==eh){let F=getTopologicalSortAndRecipientCounts(eo,$);eh=F.sorted,ee=F.recipientCounts,et.put(ep,eh),en.put(ep,ee)}ee={},ea||Object.assign(ee,en.get(ep));let ef=new FeedDict($);for(let F=0;F<eh.length;++F){if(null!=H){let F=(0,G.sq6)().numTensors;F>H.maxNumTensors&&(H.maxNumTensors=F),F<H.minNumTensors&&(H.minNumTensors=F)}let et=eh[F],en=et.sourceLayer;if(en instanceof Z.l)continue;let ei=[],eo=[],ec=[],ep=!1;for(let F of et.inputs){let V=ef.getValue(F),G=ef.getMask(F);ei.push(V),eo.push(G),null!=G&&(ep=!0),ea||(ee[F.name]--,0!==ee[F.name]||$.hasKey(F)||-1!==es.indexOf(F.name)||V.isDisposed||!0===F.sourceLayer.stateful||ec.push(V))}ep&&((V=V||{}).mask=eo[0]);let ed=(0,K.zZ)(en.apply(ei,V)),em=null;en.supportsMasking&&(em=en.computeMask(ei,eo));let eg=getNodeOutputs(et),ey=Array.isArray(eg)?eg:[eg];for(let F=0;F<ey.length;++F){ef.hasKey(ey[F])||ef.add(ey[F],ed[F],Array.isArray(em)?em[0]:em);let $=es.indexOf(ey[F].name);-1!==$&&(eu[$]=ed[F])}ea||(0,G.B90)(ec)}return ef.disposeMasks(),ei?eu:eu[0]}function getTopologicalSortAndRecipientCounts(F,$){G.D5U.assert(null!=F&&F.length>0,()=>"Expected at least one fetch, got none");let V=[],H={};if(1===F.length){let G=getTopologicalSortAndRecipientCountsForOneFetch(F[0],$);V=G.sorted,H=G.recipientMap}else{let G=new Set;for(let K of F){let{sorted:F,recipientMap:Z}=getTopologicalSortAndRecipientCountsForOneFetch(K,$);for(let $ of F)G.has($.name)||(V.push($),G.add($.name));for(let F in Z)null==H[F]&&(H[F]=new Set),Z[F].forEach($=>H[F].add($))}}return{sorted:V,recipientCounts:recipientMap2Counts(H)}}function recipientMap2Counts(F){let $={};for(let V in F)$[V]=F[V].size;return $}function getTopologicalSortAndRecipientCountsForOneFetch(F,$){let V=new Set,G=[],H={};for(let F of $.names())V.add(F);let K=[],Z=[];for(K.push(F);K.length>0;){let F=K[K.length-1];if(V.has(F.name)){K.pop();continue}let $=Z[Z.length-1]===K.length-1;if(0===F.inputs.length||$)K.pop(),G.push(F),V.add(F.name),$&&Z.pop();else for(let $ of(Z.push(K.length-1),F.inputs))null==H[$.name]&&(H[$.name]=new Set),H[$.name].add(F.name),V.has($.name)||K.push($)}return{sorted:G,recipientMap:H}}function getNodeOutputs(F){let $;if(1===F.sourceLayer.inboundNodes.length)$=F.sourceLayer.output;else{let V=null;for(let $=0;$<F.sourceLayer.inboundNodes.length;++$)for(let G of F.sourceLayer.inboundNodes[$].outputTensors)if(G.id===F.id){V=$;break}$=F.sourceLayer.getOutputAt(V)}return $}},34396:function(F,$,V){"use strict";V.d($,{I:function(){return Input},l:function(){return InputLayer}});var G=V(15949),H=V(79608),K=V(40588),Z=V(20163);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let InputLayer=class InputLayer extends Z.mh{constructor(F){if(super({dtype:F.dtype,name:null!=F.name?F.name:(0,H.s)("input").toString()}),null==F.batchSize&&(F.batchSize=null),null==F.sparse&&(F.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=F.sparse,null!=F.inputShape&&null!=F.batchInputShape)throw new K.nu("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let $=F.batchInputShape;if(null==$){if(null==F.inputShape)throw new K.nu("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");$=[F.batchSize].concat(F.inputShape)}else if(null!=F.batchSize)throw new K.nu("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let V=F.dtype||"float32";this.batchInputShape=$,this.dtype=V,this.inputSpec=[{shape:$}];let G=new Z.Iy(this.dtype,this.batchInputShape,this,[],{},this.name);G.nodeIndex=0,G.tensorIndex=0,new Z.NB({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[G],outputTensors:[G],inputMasks:[null],outputMasks:[null],inputShapes:[$],outputShapes:[$]})}apply(F,$){throw new K.nu(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function Input(F){if(null==F.batchShape&&null==F.shape)throw Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=F.batchShape&&null!=F.shape)throw new K.nu("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let $=F.batchShape;null!=F.shape&&null==$&&($=[null].concat(F.shape));let V=F.dtype;null==V&&(V="float32");let G=new InputLayer({batchInputShape:$,name:F.name,dtype:V,sparse:F.sparse}),H=G.inboundNodes[0].outputTensors;return H[0]}InputLayer.className="InputLayer",G.m7h.registerClass(InputLayer)},20163:function(F,$,V){"use strict";V.d($,{Iy:function(){return SymbolicTensor},NB:function(){return Node},Zg:function(){return InputSpec},hA:function(){return getSourceInputs},mh:function(){return Layer}});var G=V(15949),H=V(79608),K=V(48090),Z=V(40588),ee=V(92599),et=V(2931),en=V(87538),ea=V(23013),ei=V(41653);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let InputSpec=class InputSpec{constructor(F){this.dtype=F.dtype,this.shape=F.shape,null!=F.shape?this.ndim=F.shape.length:this.ndim=F.ndim,this.maxNDim=F.maxNDim,this.minNDim=F.minNDim,this.axes=F.axes||{}}};let SymbolicTensor=class SymbolicTensor{constructor(F,$,V,G,Z,ee,et){this.dtype=F,this.shape=$,this.sourceLayer=V,this.inputs=G,this.callArgs=Z,this.outputTensorIndex=et,this.id=(0,H.L)(),null!=ee&&(this.originalName=(0,K.MU)(ee),this.name=(0,K.w8)(this.originalName)),this.rank=$.length}};let eo=0;let Node=class Node{constructor(F,$){for(let V of(this.callArgs=$,this.id=eo++,this.outboundLayer=F.outboundLayer,this.inboundLayers=F.inboundLayers,this.nodeIndices=F.nodeIndices,this.tensorIndices=F.tensorIndices,this.inputTensors=F.inputTensors,this.outputTensors=F.outputTensors,this.inputMasks=F.inputMasks,this.outputMasks=F.outputMasks,this.inputShapes=F.inputShapes,this.outputShapes=F.outputShapes,F.inboundLayers))null!=V&&V.outboundNodes.push(this);F.outboundLayer.inboundNodes.push(this)}getConfig(){let F=[];for(let $ of this.inboundLayers)null!=$?F.push($.name):F.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:F,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}};let es=0;let Layer=class Layer extends G.m7h.Serializable{constructor(F={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=es++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let $=F.name;if(!$){let F=this.getClassName();$=et.D1(F)+"_"+(0,H.s)(F)}if(this.name=$,this.trainable_=null==F.trainable||F.trainable,null!=F.inputShape||null!=F.batchInputShape){let $;if(null!=F.batchInputShape)$=F.batchInputShape;else if(null!=F.inputShape){let V=null;null!=F.batchSize&&(V=F.batchSize),$=[V].concat(F.inputShape)}this.batchInputShape=$;let V=F.dtype;null==V&&(V=F.inputDType),null==V&&(V="float32"),this.dtype=V}null!=F.weights?this.initialWeights=F.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(F,$){return F.name+"_ib-"+$.toString()}getNodeAtIndex(F,$){if(0===this.inboundNodes.length)throw new Z.LH(`The layer has never been called and thus has no defined ${$}.`);if(this.inboundNodes.length<=F)throw new Z.nu(`Asked to get ${$} at node ${F}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[F]}getInputAt(F){return et.Bq(this.getNodeAtIndex(F,"input").inputTensors)}getOutputAt(F){return et.Bq(this.getNodeAtIndex(F,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Z.j1(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Z.j1(`Layer ${this.name} is not connected, no input to return.`);return et.Bq(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Z.j1(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Z.j1(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return et.Bq(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(F=>F())}get updates(){return this._updates}get built(){return this._built}set built(F){this._built=F}get trainable(){return this.trainable_}set trainable(F){this._trainableWeights.forEach($=>$.trainable=F),this.trainable_=F}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(F=>F.trainable):[]}set trainableWeights(F){this._trainableWeights=F}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(F=>!F.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(F){this._nonTrainableWeights=F}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(F){let $=et.zZ(F);if(null==this.inputSpec||0===this.inputSpec.length)return;let V=et.zZ(this.inputSpec);if($.length!==V.length)throw new Z.nu(`Layer ${this.name} expects ${V.length} inputs, but it received ${$.length} input tensors. Input received: ${F}`);for(let F=0;F<$.length;F++){let G=$[F],H=V[F];if(null==H)continue;let K=G.rank;if(null!=H.ndim&&K!==H.ndim)throw new Z.nu(`Input ${F} is incompatible with layer ${this.name}: expected ndim=${H.ndim}, found ndim=${K}`);if(null!=H.maxNDim&&K>H.maxNDim)throw new Z.nu(`Input ${F} is incompatible with layer ${this.name}: expected max_ndim=${H.maxNDim}, found ndim=${K}`);if(null!=H.minNDim&&K<H.minNDim)throw new Z.nu(`Input ${F} is incompatible with layer ${this.name}: expected min_ndim=${H.minNDim}, found ndim=${K}.`);if(null!=H.dtype&&G.dtype!==H.dtype)throw new Z.nu(`Input ${F} is incompatible with layer ${this.name} : expected dtype=${H.dtype}, found dtype=${G.dtype}.`);if(H.axes){let $=G.shape;for(let V in H.axes){let G=Number(V),K=H.axes[V],ee=G>=0?$[G]:$[$.length+G];if(null!=K&&-1===[K,null].indexOf(ee))throw new Z.nu(`Input ${F} is incompatible with layer ${this.name}: expected axis ${G} of input shape to have value ${K} but got shape ${$}.`)}}if(null!=H.shape)for(let $=0;$<H.shape.length;++$){let V=H.shape[$],K=G.shape[$];if(null!=V&&null!=K&&V!==K)throw new Z.nu(`Input ${F} is incompatible with layer ${this.name}: expected shape=${H.shape}, found shape=${G.shape}.`)}}}call(F,$){return F}invokeCallHook(F,$){null!=this._callHook&&this._callHook(F,$)}setCallHook(F){this._callHook=F}clearCallHook(){this._callHook=null}apply(F,$){$=$||{},this.assertNotDisposed();let V=et.zZ(F),G=checkAllSymbolic(F),H=checkNoneSymbolic(F);if(G===H)throw new Z.nu("Arguments to apply() must be all SymbolicTensors or all Tensors");return(0,K.f4)(this.name,()=>{if(!this.built){this.assertInputCompatibility(F);let $=[];for(let V of et.zZ(F))$.push(V.shape);this.build(et.Bq($)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&H&&(this._refCount=1)}if(this.assertInputCompatibility(F),H){let G=this.call(F,$);this.supportsMasking&&this.setMaskMetadata(F,G);let H=et.zZ(G),K=[];for(let F of H)-1!==V.indexOf(F)&&(F=F.clone()),K.push(F);if(G=et.Bq(K),null!=this.activityRegularizer)throw new Z.nj("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return G}{let V;let G=collectInputShape(F),H=this.computeOutputShape(G),K=guessOutputDType(F);if(this.warnOnIncompatibleInputShape(Array.isArray(F)?G[0]:G),V=null!=H&&H.length>0&&Array.isArray(H[0])?H.map((V,G)=>new SymbolicTensor(K,V,this,et.zZ(F),$,this.name,G)):new SymbolicTensor(K,H,this,et.zZ(F),$,this.name),this.addInboundNode(F,V,null,null,G,H,$),this._refCount++,null!=this.activityRegularizer)throw new Z.nj("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return V}})}warnOnIncompatibleInputShape(F){if(null!=this.batchInputShape){if(F.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(F)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let $=!1;this.batchInputShape.forEach((V,G)=>{null!=V&&null!=F[G]&&F[G]!==V&&($=!0)}),$&&console.warn(`The shape of the input tensor (${JSON.stringify(F)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Z.j1(`The layer ${this.name} has never been called and thus has no defined output shape.`);let F=[];for(let $ of this.inboundNodes){let V=JSON.stringify($.outputShapes);-1===F.indexOf(V)&&F.push(V)}if(1===F.length){let F=this.inboundNodes[0].outputShapes;return Array.isArray(F)&&Array.isArray(F[0])&&1===F.length?F[0]:F}throw new Z.j1(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Z.LH(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return ea.t(this.weights)}build(F){this.built=!0}getWeights(F=!1){return(0,ei.FQ)(F?this.trainableWeights:this.weights)}setWeights(F){(0,G.lub)(()=>{let $=this.weights;if($.length!==F.length)throw new Z.nu(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${F.length}, but the layer was expecting ${$.length} weights. Provided weights: ${F}...`);if(0===$.length)return;let V=[],H=(0,ei.FQ)($);for(let K=0;K<H.length;++K){let ee=H[K],et=$[K],en=F[K];if(!G.D5U.arraysEqual(ee.shape,en.shape))throw new Z.nu(`Layer weight shape ${ee.shape} not compatible with provided weight shape ${en.shape}`);V.push([et,en])}(0,ei.zb)(V)})}addWeight(F,$,V,G,H,K,et,en){if(-1!==this._addedWeightNames.indexOf(F))throw new Z.nu(`Duplicate weight name ${F} for layer ${this.name}`);this._addedWeightNames.push(F),null==V&&(V="float32"),this.fastWeightInitDuringBuild&&(G=null!=en?en():(0,ee.L5)("zeros"));let ea=G.apply($,V),eo=new ei.fU(ea,V,F,K,et);return ea.dispose(),null!=H&&this.addLoss(()=>H.apply(eo.read())),null==K&&(K=!0),K?this._trainableWeights.push(eo):this._nonTrainableWeights.push(eo),eo}setFastWeightInitDuringBuild(F){this.fastWeightInitDuringBuild=F}addLoss(F){null==F||Array.isArray(F)&&0===F.length||(F=et.zZ(F),void 0!==this._losses&&null!==this._losses&&this.losses.push(...F))}computeOutputShape(F){return F}computeMask(F,$){if(!this.supportsMasking){if(null!=$){if(Array.isArray($))$.forEach(F=>{if(null!=F)throw TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}return null}return $}setMaskMetadata(F,$,V){if(!this.supportsMasking)return;let G=this.computeMask(F,V),H=et.zZ($),K=et.zZ(G);if(H.length!==K.length)throw Error(`${this.name} outputs ${H.length} tensors but ${H.length} masks for those tensors`);for(let F=0;F<H.length;F++)H[F].kerasMask=K[F]}addInboundNode(F,$,V,G,H,K,Z=null){let ee=et.zZ(F);$=et.zZ($),V=et.zZ(V),G=et.zZ(G),H=en.x6(H),K=en.x6(K);let ea=[],ei=[],eo=[];for(let F of ee)ea.push(F.sourceLayer),ei.push(F.nodeIndex),eo.push(F.tensorIndex);new Node({outboundLayer:this,inboundLayers:ea,nodeIndices:ei,tensorIndices:eo,inputTensors:ee,outputTensors:$,inputMasks:V,outputMasks:G,inputShapes:H,outputShapes:K},Z);for(let F=0;F<$.length;F++)$[F].sourceLayer=this,$[F].nodeIndex=this.inboundNodes.length-1,$[F].tensorIndex=F}getConfig(){let F={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(F.batchInputShape=this.batchInputShape),null!=this.dtype&&(F.dtype=this.dtype),F}disposeWeights(){return this.weights.forEach(F=>F.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let F=0;return 0==--this._refCount&&(F=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:F}}};function collectInputShape(F){F=et.zZ(F);let $=[];for(let V of F)$.push(V.shape);return et.Bq($)}function guessOutputDType(F){return"float32"}function getSourceInputs(F,$,V){if((null==$||null!=V&&V>0)&&($=F.sourceLayer,V=F.nodeIndex),0===$.inboundNodes.length)return[F];{let F=$.inboundNodes[V];if(0===F.inboundLayers.length)return F.inputTensors;{let $=[];for(let V=0;V<F.inboundLayers.length;V++){let G=F.inputTensors[V],H=F.inboundLayers[V],K=F.nodeIndices[V],Z=getSourceInputs(G,H,K);for(let F of Z)-1===$.indexOf(F)&&$.push(F)}return $}}}function checkAllSymbolic(F){let $=!0;for(let V of et.zZ(F))if(!(V instanceof SymbolicTensor)){$=!1;break}return $}function checkNoneSymbolic(F){let $=!0;for(let V of et.zZ(F))if(V instanceof SymbolicTensor){$=!1;break}return $}},28913:function(F,$,V){"use strict";V.d($,{D:function(){return evaluateDataset},y:function(){return fitDataset}});var G=V(15949),H=V(28891),K=V(40588),Z=V(73146),ee=V(2931),et=V(86529);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let en=32;function standardizeDataIteratorOutput(F,$){let V,H;let K=$;V=K.xs,H=K.ys,G.D5U.assert(null!=V&&null!=H,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${$}`);let Z=flattenTensorOrArrayOrMap("input",F.inputNames,V),ee=flattenTensorOrArrayOrMap("output",F.outputNames,H),et=Z[0].shape[0];G.D5U.assert(Z.length===F.inputs.length,()=>`LayersModel has ${F.inputs.length} inputs, but the dataset provides ${Z.length} inputs.  (Expected input keys: ${JSON.stringify(F.inputNames)})`),G.D5U.assert(ee.length===F.outputs.length,()=>`LayersModel has ${F.outputs.length} outputs, but the dataset provides ${ee.length} outputs.  (Expected output keys: ${JSON.stringify(F.outputNames)})`);for(let $=0;$<Z.length;$++)G.D5U.assert(Z[$].shape[0]===et,()=>`Batch size mismatch: input ${F.inputNames[$]} has ${Z[$].shape[0]}; expected  ${et} based on input ${F.inputNames[0]}.`);for(let $=0;$<ee.length;$++)G.D5U.assert(ee[$].shape[0]===et,()=>`Batch size mismatch: output ${F.outputNames[$]} has ${ee[$].shape[0]}; expected  ${et} based on input ${F.inputNames[0]}.`);return{xs:Z,ys:ee}}function flattenTensorOrArrayOrMap(F,$,V){if(V instanceof G.esB)return[V];if(Array.isArray(V))return G.D5U.assert(V.length===$.length,()=>`Received an array of ${V.length} Tensors, but expected ${$.length} to match the ${F} keys ${$}.`),V;{let G=[];for(let H of $){if(null==V[H])throw new K.nu(`The feature data generated by the dataset lacks the required ${F} key '${H}'.`);G.push(V[H])}return G}}function standardizeTensorValidationData(F){if(3===F.length)throw new K.nj("Validation with sample weights is not implemented yet.");return{xs:F[0],ys:F[1]}}async function fitDataset(F,$,V){let K=null!=V.batchesPerEpoch;if(G.D5U.assert(null!=F.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),G.D5U.assert(null!=V,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),G.D5U.assert(null!=V.epochs&&V.epochs>0&&Number.isInteger(V.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${V.epochs}`),G.D5U.assert(!K||V.batchesPerEpoch>0&&Number.isInteger(V.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${V.batchesPerEpoch}`),G.D5U.assert(null==V.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),F.isTraining)throw Error("Cannot start training because another fit() call is ongoing.");F.isTraining=!0;try{let ea,ei,eo;let es=null!=V.validationData;if(es){if(isDatasetObject(V.validationData))G.D5U.assert(null==V.validationBatches||V.validationBatches>0&&Number.isInteger(V.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${V.validationBatches}`);else{let F=standardizeTensorValidationData(V.validationData);ea=F.xs,ei=F.ys}}let eu=F.makeTrainFunction(),ec=F.getDedupedMetricsNames();eo=es?ec.slice().concat(ec.map(F=>"val_"+F)):ec.slice();let ep=(0,H.CZ)(V.callbacks,V.yieldEvery),eh=null==V.verbose?1:V.verbose,{callbackList:ef,history:ed}=(0,H.m$)(ep,eh,V.epochs,null,null,getStepsPerEpoch($,V),null,es,eo);ef.setModel(F),F.history=ed,await ef.onTrainBegin(),F.stopTraining_=!1;let em=null==V.initialEpoch?0:V.initialEpoch,eg=await $.iterator();for(;em<V.epochs;){let H={};await ef.onEpochBegin(em);let eo=0,ep=0;for(K||(eg=await $.iterator());!K||eo<V.batchesPerEpoch;){let $=await eg.next();if(K&&$.done){console.warn(`You provided \`batchesPerEpoch\` as ${V.batchesPerEpoch}, but your dataset iterator ran out of data after ${eo} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${V.batchesPerEpoch*V.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=$.value){let{xs:H,ys:K}=standardizeDataIteratorOutput(F,$.value),ee={};ee.batch=ep,ee.size=H[0].shape[0],await ef.onBatchBegin(ep,ee);let en=[];if(null!=V.classWeight){let $=(0,et.Vf)(V.classWeight,F.outputNames);for(let F=0;F<$.length;++F)en.push(await (0,et.tl)(K[F],null,$[F]))}let ea=H.concat(K).concat(en),ei=eu(ea);G.B90(ea);for(let F=0;F<ec.length;++F){let $=ec[F],V=ei[F];ee[$]=V,G.CnY(V)}await ef.onBatchEnd(ep,ee),(0,Z.i)(ee),ep++,eo++}if(K?eo>=V.batchesPerEpoch:$.done){if(es){let $;$=isDatasetObject(V.validationData)?(0,ee.zZ)(await F.evaluateDataset(V.validationData,{batches:V.validationBatches})):(0,ee.zZ)(F.evaluate(ea,ei,{batchSize:null==V.validationBatchSize?en:V.validationBatchSize,verbose:0}));for(let V=0;V<F.metricsNames.length;++V)H[`val_${F.metricsNames[V]}`]=$[V]}break}if(F.stopTraining_)break}if(await ef.onEpochEnd(em,H),em++,F.stopTraining_)break}return await ef.onTrainEnd(),await F.history.syncData(),F.history}finally{F.isTraining=!1}}function getStepsPerEpoch(F,$){let V=null;return null!=$.batchesPerEpoch?V=$.batchesPerEpoch:Number.isFinite(F.size)&&(V=F.size),V}function isDatasetObject(F){return"function"==typeof F.iterator}function isLazyIteratorObject(F){return"function"==typeof F.next}async function evaluateDataset(F,$,V){V=V||{};let H=null!=V.batches,Z=F.testFunction,et=[];if(V.verbose>0)throw new K.nj("Verbose mode is not implemented yet.");G.D5U.assert(!H||V.batches>0&&Number.isInteger(V.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(V.batches)}`);let en=isLazyIteratorObject($)?$:await $.iterator(),ea=0,ei=0;for(;!H||ei<V.batches;){let $=await en.next();if(et=G.lub(()=>{if($.value){let{xs:V,ys:H}=standardizeDataIteratorOutput(F,$.value),K=V.concat(H),ee=G.lub(()=>Z(K));if(G.B90(K),0===ei)for(let F=0;F<ee.length;++F)et.push((0,G.iD$)(0));let en=K[0].shape[0];for(let F=0;F<ee.length;++F){let $=ee[F],V=et[F];et[F]=G.lub(()=>G.IHx(et[F],G.dC7(en,$))),ei>0&&G.B90(V)}G.B90(ee),ea+=en,++ei}return et}),$.done){H&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${V.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let F=0;F<et.length;++F){let $=et[F];et[F]=G.hiC(et[F],ea),G.B90($)}return(0,ee.Bq)(et)}},26347:function(F,$,V){"use strict";V.d($,{R_:function(){return makeBatches},YV:function(){return ensureTensorsRank2OrHigher},YX:function(){return sliceArraysByIndices},fQ:function(){return checkBatchSize},kS:function(){return disposeNewTensors},sf:function(){return sliceArrays}});var G=V(15949),H=V(39840);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function checkBatchSize(F){G.D5U.assert(F>0&&Number.isInteger(F),()=>`batchSize is required to be a positive integer, but got ${F}`)}function sliceArrays(F,$,V){return null==F?[null]:Array.isArray(F)?F.map(F=>(0,H.c9)(F,$,V-$)):(0,H.c9)(F,$,V-$)}function sliceArraysByIndices(F,$){return G.lub(()=>null==F?null:Array.isArray(F)?F.map(F=>sliceArraysByIndices(F,$)):(0,H.Iq)(F,"int32"===$.dtype?$:G.pju($,"int32")))}function makeBatches(F,$){let V=[],G=0,H=null;for(;G<F;)(H=G+$)>=F&&(H=F),V.push([G,H]),G=H;return V}function ensureTensorsRank2OrHigher(F){let $=[];F instanceof G.esB&&(F=[F]);for(let V=0;V<F.length;++V){let G=F[V];if(1===G.rank)$.push((0,H.dt)(G,1));else if(0===G.rank)throw Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");else $.push(G)}return $}function disposeNewTensors(F,$){if(null==F)return;let V=[];if($ instanceof G.esB)V.push($.id);else if(Array.isArray($))$.forEach(F=>V.push(F.id));else if(null!=$)for(let F in $){let G=$[F];V.push(G.id)}let H=[];if(F instanceof G.esB)-1===V.indexOf(F.id)&&H.push(F);else if(Array.isArray(F))F.forEach(F=>{-1===V.indexOf(F.id)&&H.push(F)});else if(null!=F)for(let $ in F){let G=F[$];-1===V.indexOf(G.id)&&H.push(G)}H.forEach(F=>{F.isDisposed||F.dispose()})}},86529:function(F,$,V){"use strict";V.d($,{Vf:function(){return standardizeClassWeights},mo:function(){return computeWeightedLoss},tl:function(){return standardizeWeights}});var G=V(15949);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function standardizeSampleOrClassWeights(F,$,V){let G=$.length;if(null==F||Array.isArray(F)&&0===F.length)return $.map(F=>null);if(1===G)return Array.isArray(F)&&1===F.length?F:"object"==typeof F&&$[0]in F?[F[$[0]]]:[F];if(Array.isArray(F)){if(F.length!==G)throw Error(`Provided ${V} is an array of ${F.length} element(s), but the model has ${G} outputs. Make sure a set of weights is provided for each model output.`);return F}if("object"==typeof F&&Object.keys(F).length>0&&"object"==typeof F[Object.keys(F)[0]]){let V=[];return $.forEach($=>{$ in F?V.push(F[$]):V.push(null)}),V}throw Error(`The model has multiple (${G}) outputs, so ${V} must be either an array with ${G} elements or an object with ${$} keys. Provided ${V} not understood: ${JSON.stringify(F)}`)}function standardizeClassWeights(F,$){return standardizeSampleOrClassWeights(F,$,"classWeight")}async function standardizeWeights(F,$,V,H){if(null!=$||null!=H)throw Error("Support sampleWeight is not implemented yet");if(null==V)return null;{let $=(0,G.lub)(()=>{if(1===F.shape.length)return(0,G.d9v)(F);if(2===F.shape.length){if(F.shape[1]>1){let $=1;return(0,G.NqF)(F,$)}if(1===F.shape[1])return(0,G.XLQ)(F,[F.shape[0]]);throw Error(`Encountered unexpected last-dimension size (${F.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw Error(`Unexpected rank of target (y) tensor (${F.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),H=Array.from(await $.data());(0,G.B90)($);let K=[];return H.forEach(F=>{if(null==V[F])throw Error(`classWeight must contain all classes in the training data. The class ${F} exists in the data but not in classWeight`);K.push(V[F])}),(0,G.RRF)(K,"float32")}}function computeWeightedLoss(F,$){return(0,G.dC7)(F,$)}},40588:function(F,$,V){"use strict";V.d($,{LH:function(){return RuntimeError},j1:function(){return AttributeError},nj:function(){return NotImplementedError},nu:function(){return ValueError},ps:function(){return AssertionError}});/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let AttributeError=class AttributeError extends Error{constructor(F){super(F),Object.setPrototypeOf(this,AttributeError.prototype)}};let RuntimeError=class RuntimeError extends Error{constructor(F){super(F),Object.setPrototypeOf(this,RuntimeError.prototype)}};let ValueError=class ValueError extends Error{constructor(F){super(F),Object.setPrototypeOf(this,ValueError.prototype)}};let NotImplementedError=class NotImplementedError extends Error{constructor(F){super(F),Object.setPrototypeOf(this,NotImplementedError.prototype)}};let AssertionError=class AssertionError extends Error{constructor(F){super(F),Object.setPrototypeOf(this,AssertionError.prototype)}}},39603:function(F,$,V){"use strict";V.d($,{FB:function(){return Z.FB},Pe:function(){return sequential},gl:function(){return registerCallbackConstructor},o4:function(){return model},qH:function(){return input}});var G=V(28891),H=V(34396),K=V(85337),Z=V(83066);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function model(F){return new K.QV(F)}function sequential(F){return new Z.sb(F)}function input(F){return(0,H.I)(F)}function registerCallbackConstructor(F,$){G.Sk.registerCallbackConstructor(F,$)}},92599:function(F,$,V){"use strict";V.d($,{sr:function(){return Constant},Jf:function(){return GlorotNormal},sq:function(){return GlorotUniform},RP:function(){return HeNormal},rB:function(){return HeUniform},iJ:function(){return Identity},m7:function(){return Initializer},V9:function(){return LeCunNormal},yD:function(){return LeCunUniform},M6:function(){return Ones},vG:function(){return Orthogonal},MD:function(){return RandomNormal},Is:function(){return RandomUniform},w8:function(){return TruncatedNormal},xc:function(){return VarianceScaling},H_:function(){return Zeros},L5:function(){return getInitializer},Cx:function(){return serializeInitializer}});var G=V(15949),H=V(39840),K=V(48090),Z=V(40588);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ee=["fanIn","fanOut","fanAvg"],et=["normal","uniform","truncatedNormal"];var en=V(2931),ea=V(96040);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function checkFanMode(F){(0,en.xn)(ee,"FanMode",F)}function checkDistribution(F){(0,en.xn)(et,"Distribution",F)}let Initializer=class Initializer extends G.m7h.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}};let Zeros=class Zeros extends Initializer{apply(F,$){return(0,G.lls)(F,$)}};Zeros.className="Zeros",G.m7h.registerClass(Zeros);let Ones=class Ones extends Initializer{apply(F,$){return(0,G.iUs)(F,$)}};Ones.className="Ones",G.m7h.registerClass(Ones);let Constant=class Constant extends Initializer{constructor(F){if(super(),"object"!=typeof F)throw new Z.nu(`Expected argument of type ConstantConfig but got ${F}`);if(void 0===F.value)throw new Z.nu(`config must have value set but got ${F}`);this.value=F.value}apply(F,$){return(0,G.lub)(()=>(0,G.dC7)((0,G.iD$)(this.value),(0,G.iUs)(F,$)))}getConfig(){return{value:this.value}}};Constant.className="Constant",G.m7h.registerClass(Constant);let RandomUniform=class RandomUniform extends Initializer{constructor(F){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=F.minval||this.DEFAULT_MINVAL,this.maxval=F.maxval||this.DEFAULT_MAXVAL,this.seed=F.seed}apply(F,$){return(0,G.LGj)(F,this.minval,this.maxval,$,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};RandomUniform.className="RandomUniform",G.m7h.registerClass(RandomUniform);let RandomNormal=class RandomNormal extends Initializer{constructor(F){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=F.mean||this.DEFAULT_MEAN,this.stddev=F.stddev||this.DEFAULT_STDDEV,this.seed=F.seed}apply(F,$){if("float32"!==($=$||"float32")&&"int32"!==$)throw new Z.nj(`randomNormal does not support dType ${$}.`);return H.nG(F,this.mean,this.stddev,$,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};RandomNormal.className="RandomNormal",G.m7h.registerClass(RandomNormal);let TruncatedNormal=class TruncatedNormal extends Initializer{constructor(F){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=F.mean||this.DEFAULT_MEAN,this.stddev=F.stddev||this.DEFAULT_STDDEV,this.seed=F.seed}apply(F,$){if("float32"!==($=$||"float32")&&"int32"!==$)throw new Z.nj(`truncatedNormal does not support dType ${$}.`);return(0,G.Xu6)(F,this.mean,this.stddev,$,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};TruncatedNormal.className="TruncatedNormal",G.m7h.registerClass(TruncatedNormal);let Identity=class Identity extends Initializer{constructor(F){super(),this.gain=null!=F.gain?F.gain:1}apply(F,$){return(0,G.lub)(()=>{if(2===F.length&&F[0]===F[1])return(0,G.dC7)(this.gain,(0,G.iyy)(F[0]));throw new Z.nu("Identity matrix initializer can only be used for 2D square matrices.")})}getConfig(){return{gain:this.gain}}};function computeFans(F,$="channelsLast"){let V,G;if((0,K.cj)($),2===F.length)V=F[0],G=F[1];else if(-1!==[3,4,5].indexOf(F.length)){if("channelsFirst"===$){let $=(0,ea.NS)(F,2);V=F[1]*$,G=F[0]*$}else if("channelsLast"===$){let $=(0,ea.NS)(F,0,F.length-2);V=F[F.length-2]*$,G=F[F.length-1]*$}}else{let $=(0,ea.NS)(F);V=Math.sqrt($),G=Math.sqrt($)}return[V,G]}Identity.className="Identity",G.m7h.registerClass(Identity);let VarianceScaling=class VarianceScaling extends Initializer{constructor(F){if(super(),F.scale<0)throw new Z.nu(`scale must be a positive float. Got: ${F.scale}`);this.scale=null==F.scale?1:F.scale,this.mode=null==F.mode?"fanIn":F.mode,checkFanMode(this.mode),this.distribution=null==F.distribution?"normal":F.distribution,checkDistribution(this.distribution),this.seed=F.seed}apply(F,$){let V=computeFans(F),H=V[0],K=V[1],ee=this.scale;if("fanIn"===this.mode?ee/=Math.max(1,H):"fanOut"===this.mode?ee/=Math.max(1,K):ee/=Math.max(1,(H+K)/2),"normal"===this.distribution){let V=Math.sqrt(ee);if("float32"!==($=$||"float32")&&"int32"!==$)throw new Z.nj(`${this.getClassName()} does not support dType ${$}.`);return(0,G.Xu6)(F,0,V,$,this.seed)}{let V=Math.sqrt(3*ee);return(0,G.LGj)(F,-V,V,$,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};VarianceScaling.className="VarianceScaling",G.m7h.registerClass(VarianceScaling);let GlorotUniform=class GlorotUniform extends VarianceScaling{constructor(F){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==F?null:F.seed})}getClassName(){return VarianceScaling.className}};GlorotUniform.className="GlorotUniform",G.m7h.registerClass(GlorotUniform);let GlorotNormal=class GlorotNormal extends VarianceScaling{constructor(F){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==F?null:F.seed})}getClassName(){return VarianceScaling.className}};GlorotNormal.className="GlorotNormal",G.m7h.registerClass(GlorotNormal);let HeNormal=class HeNormal extends VarianceScaling{constructor(F){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==F?null:F.seed})}getClassName(){return VarianceScaling.className}};HeNormal.className="HeNormal",G.m7h.registerClass(HeNormal);let HeUniform=class HeUniform extends VarianceScaling{constructor(F){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==F?null:F.seed})}getClassName(){return VarianceScaling.className}};HeUniform.className="HeUniform",G.m7h.registerClass(HeUniform);let LeCunNormal=class LeCunNormal extends VarianceScaling{constructor(F){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==F?null:F.seed})}getClassName(){return VarianceScaling.className}};LeCunNormal.className="LeCunNormal",G.m7h.registerClass(LeCunNormal);let LeCunUniform=class LeCunUniform extends VarianceScaling{constructor(F){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==F?null:F.seed})}getClassName(){return VarianceScaling.className}};LeCunUniform.className="LeCunUniform",G.m7h.registerClass(LeCunUniform);let Orthogonal=class Orthogonal extends Initializer{constructor(F){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==F.gain?this.DEFAULT_GAIN:F.gain,this.seed=F.seed}apply(F,$){return(0,G.lub)(()=>{if(F.length<2)throw new Z.nj("Shape must be at least 2D.");if("int32"!==$&&"float32"!==$&&void 0!==$)throw TypeError(`Unsupported data type ${$}.`);let V=G.D5U.sizeFromShape(F.slice(0,-1)),K=F[F.length-1],ee=V*K;ee>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${ee}) elements: Slowness may result.`);let et=[Math.max(K,V),Math.min(K,V)],en=H.nG(et,0,1,$,this.seed),ea=G.$r2.qr(en,!1),ei=ea[0],eo=ea[1],es=eo.flatten().stridedSlice([0],[Math.min(K,V)*Math.min(K,V)],[Math.min(K,V)+1]);return ei=(0,G.dC7)(ei,es.sign()),V<K&&(ei=ei.transpose()),(0,G.dC7)((0,G.iD$)(this.gain),ei.reshape(F))})}getConfig(){return{gain:this.gain,seed:this.seed}}};Orthogonal.className="Orthogonal",G.m7h.registerClass(Orthogonal);let ei={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function deserializeInitializer(F,$={}){return(0,en.tU)(F,G.m7h.SerializationMap.getMap().classNameMap,$,"initializer")}function serializeInitializer(F){return(0,en.Kj)(F)}function getInitializer(F){if("string"==typeof F){let $=F in ei?ei[F]:F;if("GlorotNormal"===$)return new GlorotNormal;if("GlorotUniform"===$)return new GlorotUniform;{if("HeNormal"===$)return new HeNormal;if("HeUniform"===$)return new HeUniform;if("LeCunNormal"===$)return new LeCunNormal;if("LeCunUniform"===$)return new LeCunUniform;let F={};return F.className=$,F.config={},deserializeInitializer(F)}}return F instanceof Initializer?F:deserializeInitializer(F)}},44685:function(F,$,V){"use strict";V.d($,{MK:function(){return Z},Mz:function(){return H},PS:function(){return G},eY:function(){return ee},zx:function(){return K}});/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let G=["channelsFirst","channelsLast"],H=["nearest","bilinear"],K=["valid","same","causal"],Z=["max","avg"],ee=["sum","mul","concat","ave"]},27870:function(F,$,V){"use strict";V.d($,{Cv:function(){return ELU},Gc:function(){return Softmax},Ln:function(){return ThresholdedReLU},UH:function(){return LeakyReLU},_H:function(){return PReLU},qi:function(){return ReLU}});var G=V(15949),H=V(28819),K=V(64079),Z=V(20163),ee=V(40588),et=V(92599),en=V(10539),ea=V(87538);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ReLU=class ReLU extends Z.mh{constructor(F){super(null==F?{}:F),this.supportsMasking=!0,null!=F&&(this.maxValue=F.maxValue)}call(F,$){F=(0,ea.nQ)(F);let V=(0,G.UYe)(F);return null!=this.maxValue&&(V=(0,G.iUl)(V,0,this.maxValue)),V}computeOutputShape(F){return F}getConfig(){let F={maxValue:this.maxValue},$=super.getConfig();return Object.assign(F,$),F}};ReLU.className="ReLU",G.m7h.registerClass(ReLU);let LeakyReLU=class LeakyReLU extends Z.mh{constructor(F){super(null==F?{}:F),this.DEFAULT_ALPHA=.3,null==F&&(F={}),this.alpha=null==F.alpha?this.DEFAULT_ALPHA:F.alpha}call(F,$){let V=(0,ea.nQ)(F);return(0,G.hi7)(V,this.alpha)}computeOutputShape(F){return F}getConfig(){let F={alpha:this.alpha},$=super.getConfig();return Object.assign(F,$),F}};LeakyReLU.className="LeakyReLU",G.m7h.registerClass(LeakyReLU);let PReLU=class PReLU extends Z.mh{constructor(F){if(super(null==F?{}:F),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==F&&(F={}),this.supportsMasking=!0,this.alphaInitializer=(0,et.L5)(F.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=(0,en.EC)(F.alphaRegularizer),this.alphaConstraint=(0,K.Ad)(F.alphaConstraint),null==F.sharedAxes)this.sharedAxes=null;else if(Array.isArray(F.sharedAxes))this.sharedAxes=F.sharedAxes;else if("number"==typeof F.sharedAxes)this.sharedAxes=[F.sharedAxes];else throw new ee.nu(`Expected sharedAxes to be a number or an array of numbers, but got ${F.sharedAxes}`)}build(F){F=(0,ea.Wf)(F);let $=F.slice(1);if(null!=this.sharedAxes)for(let F of this.sharedAxes)$[F-1]=1;this.alpha=this.addWeight("alpha",$,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let V={};if(null!=this.sharedAxes)for(let $=1;$<F.length;++$)V[$]=F[$];this.inputSpec=[new Z.Zg({ndim:F.length,axes:V})],this.built=!0}call(F,$){return F=(0,ea.nQ)(F),(0,G.AL3)(F,this.alpha.read())}getConfig(){let F={alphaInitializer:(0,et.Cx)(this.alphaInitializer),alphaRegularizer:(0,en.SG)(this.alphaRegularizer),alphaConstraint:(0,K.xF)(this.alphaConstraint),sharedAxes:this.sharedAxes},$=super.getConfig();return Object.assign(F,$),F}};PReLU.className="PReLU",G.m7h.registerClass(PReLU);let ELU=class ELU extends Z.mh{constructor(F){if(super(null==F?{}:F),this.DEFAULT_ALPHA=1,null==F&&(F={}),null!=F.alpha&&F.alpha!==this.DEFAULT_ALPHA)throw new ee.nj(`Non-default alpha value (${F.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==F.alpha?this.DEFAULT_ALPHA:F.alpha}call(F,$){let V=(0,ea.nQ)(F);return(0,G.pyx)(V)}computeOutputShape(F){return F}getConfig(){let F={alpha:this.alpha},$=super.getConfig();return Object.assign(F,$),F}};ELU.className="ELU",G.m7h.registerClass(ELU);let ThresholdedReLU=class ThresholdedReLU extends Z.mh{constructor(F){super(null==F?{}:F),this.DEFAULT_THETA=1,null==F&&(F={}),this.theta=null==F.theta?this.DEFAULT_THETA:F.theta}call(F,$){let V=(0,ea.nQ)(F);return(0,G.dC7)(V,(0,G.pju)((0,G.pjt)(V,this.theta),"float32"))}computeOutputShape(F){return F}getConfig(){let F={theta:this.theta},$=super.getConfig();return Object.assign(F,$),F}};ThresholdedReLU.className="ThresholdedReLU",G.m7h.registerClass(ThresholdedReLU);let Softmax=class Softmax extends Z.mh{constructor(F){super(null==F?{}:F),this.DEFAULT_AXIS=1,null==F&&(F={}),this.softmax=new H.Gc().apply,this.axis=null==F.axis?this.DEFAULT_AXIS:F.axis}call(F,$){return(0,G.lub)(()=>{let V=(0,ea.nQ)(F),H=$.mask;if(null!=H){let F=(0,G.dC7)((0,G.luU)((0,G.iUs)(V.shape),(0,G.pju)(H,V.dtype)),(0,G.iD$)(-1e9));V=(0,G.IHx)(V,F)}return this.axis instanceof Array?this.axis.length>1?(0,G.Qqt)((0,G.luU)(V,(0,G.l_t)(V,this.axis,!0))):this.softmax(V,this.axis[0]):this.softmax(V,this.axis)})}computeOutputShape(F){return F}getConfig(){let F={axis:this.axis},$=super.getConfig();return Object.assign(F,$),F}};Softmax.className="Softmax",G.m7h.registerClass(Softmax)},34121:function(F,$,V){"use strict";V.d($,{$:function(){return DepthwiseConv2D}});var G=V(15949),H=V(12012),K=V(39840),Z=V(48090),ee=V(64079),et=V(40588),en=V(92599),ea=V(10539),ei=V(26517),eo=V(87538),es=V(75650);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function depthwiseConv2d(F,$,V=[1,1],K="valid",ee,en){return(0,G.lub)(()=>{null==ee&&(ee=(0,H.rf)()),(0,Z.cj)(ee);let ea=(0,es.aP)(F,ee);if(4!==F.rank)throw new et.nu(`Input for depthwiseConv2d is required to be 4-D, but is instead ${F.rank}-D`);if(4!==$.rank)throw new et.nu(`depthwiseKernel is required to be 4-D, but is instead ${$.rank}-D`);return ea=G.B10(ea,$,V,"same"===K?"same":"valid","NHWC",en),"channelsFirst"===ee&&(ea=G.p4s(ea,[0,3,1,2])),ea})}let DepthwiseConv2D=class DepthwiseConv2D extends es.nx{constructor(F){super(2,F),this.depthwiseKernel=null,this.depthMultiplier=null==F.depthMultiplier?1:F.depthMultiplier,this.depthwiseInitializer=(0,en.L5)(F.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=(0,ee.Ad)(F.depthwiseConstraint),this.depthwiseRegularizer=(0,ea.EC)(F.depthwiseRegularizer)}build(F){if((F=(0,eo.Wf)(F)).length<4)throw new et.nu(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(F)}.`);let $="channelsFirst"===this.dataFormat?1:3;if(null==F[$]||F[$]<0)throw new et.nu(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${F[$]}).`);let V=F[$],G=[this.kernelSize[0],this.kernelSize[1],V,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",G,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[V*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(F,$){return(0,G.lub)(()=>{let $=depthwiseConv2d(F=(0,eo.nQ)(F),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&($=K.a2($,this.bias.read(),this.dataFormat)),null!=this.activation&&($=this.activation.apply($)),$})}computeOutputShape(F){F=(0,eo.Wf)(F);let $="channelsFirst"===this.dataFormat?F[2]:F[1],V="channelsFirst"===this.dataFormat?F[3]:F[2],G="channelsFirst"===this.dataFormat?F[1]*this.depthMultiplier:F[3]*this.depthMultiplier,H=(0,ei.kt)($,this.kernelSize[0],this.padding,this.strides[0]),K=(0,ei.kt)(V,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[F[0],G,H,K]:[F[0],H,K,G]}getConfig(){let F=super.getConfig();return F.depthMultiplier=this.depthMultiplier,F.depthwiseInitializer=(0,en.Cx)(this.depthwiseInitializer),F.depthwiseRegularizer=(0,ea.SG)(this.depthwiseRegularizer),F.depthwiseConstraint=(0,ee.xF)(this.depthwiseRegularizer),F}};DepthwiseConv2D.className="DepthwiseConv2D",G.m7h.registerClass(DepthwiseConv2D)},5819:function(F,$,V){"use strict";V.d($,{a:function(){return ConvLSTM2DCell},p:function(){return ConvLSTM2D}});var G=V(15949),H=V(39840),K=V(48090),Z=V(20163),ee=V(40588),et=V(92599),en=V(26517),ea=V(2931),ei=V(87538),eo=V(76014),__rest=function(F,$){var V={};for(var G in F)Object.prototype.hasOwnProperty.call(F,G)&&0>$.indexOf(G)&&(V[G]=F[G]);if(null!=F&&"function"==typeof Object.getOwnPropertySymbols)for(var H=0,G=Object.getOwnPropertySymbols(F);H<G.length;H++)0>$.indexOf(G[H])&&Object.prototype.propertyIsEnumerable.call(F,G[H])&&(V[G[H]]=F[G[H]]);return V};let ConvRNN2D=class ConvRNN2D extends eo.$p{constructor(F){if(F.unroll)throw new ee.nj("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(F.cell))throw new ee.nj("It is not possible at the moment to stack convolutional cells.");super(F),this.inputSpec=[new Z.Zg({ndim:5})]}call(F,$){return G.lub(()=>{if(null!=this.cell.dropoutMask&&(G.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(G.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),$&&$.constants)throw new ee.nu("ConvRNN2D cell does not support constants");let V=null==$?null:$.mask,H=null==$?null:$.training,K=null==$?null:$.initialState;return super.call(F,{mask:V,training:H,initialState:K})})}computeOutputShape(F){let $=this.computeSingleOutputShape(F);return this.returnSequences||($=[$[0],...$.slice(2)]),this.returnState&&($=[$,...[,,].fill([F[0],...$.slice(-3)])]),$}getInitialState(F){return G.lub(()=>{let{stateSize:$}=this.cell,V=F.shape,H=this.computeSingleOutputShape(V),K=[H[0],...H.slice(2)],Z=G.lls(K);return Array.isArray($)?Array($.length).fill(Z):[Z]})}resetStates(F,$=!1){G.lub(()=>{if(!this.stateful)throw new ee.j1("Cannot call resetStates() on an RNN Layer that is not stateful.");let V=this.inputSpec[0].shape,H=this.computeSingleOutputShape(V),K=[H[0],...H.slice(2)],Z=V[0];if(null==Z)throw new ee.nu("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>G.lls(K)):this.states_=[G.lls(K)];else if(null==F)G.B90(this.states_),null!=this.keptStates&&(G.B90(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>G.lls(K)):this.states_[0]=G.lls(K);else{if(Array.isArray(F)||(F=[F]),F.length!==this.states_.length)throw new ee.nu(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${F.length} state value(s). Input received: ${F}`);$?this.keptStates.push(this.states_.slice()):G.B90(this.states_);for(let $=0;$<this.states_.length;++$){let V=F[$],H=K;if(!G.D5U.arraysEqual(V.shape,H))throw new ee.nu(`State ${$} is incompatible with layer ${this.name}: expected shape=${H}, received shape=${V.shape}`);this.states_[$]=V}}this.states_=this.states_.map(F=>G.CnY(F.clone()))})}computeSingleOutputShape(F){let{dataFormat:$,filters:V,kernelSize:G,padding:H,strides:K,dilationRate:Z}=this.cell,ee="channelsFirst"===$,et=F[ee?3:2],ea=F[ee?4:3],ei=(0,en.kt)(et,G[0],H,K[0],Z[0]),eo=(0,en.kt)(ea,G[1],H,K[1],Z[1]),es=[...F.slice(0,2),...ee?[V,ei,eo]:[ei,eo,V]];return es}};ConvRNN2D.className="ConvRNN2D";let ConvLSTM2DCell=class ConvLSTM2DCell extends eo.U7{constructor(F){let{filters:$,kernelSize:V,strides:G,padding:H,dataFormat:Z,dilationRate:ee}=F;super(Object.assign(Object.assign({},F),{units:$})),this.filters=$,(0,ea.iQ)(this.filters,"filters"),this.kernelSize=(0,en.AF)(V,2,"kernelSize"),this.kernelSize.forEach(F=>(0,ea.iQ)(F,"kernelSize")),this.strides=(0,en.AF)(G||1,2,"strides"),this.strides.forEach(F=>(0,ea.iQ)(F,"strides")),this.padding=H||"valid",(0,K.zb)(this.padding),this.dataFormat=Z||"channelsLast",(0,K.cj)(this.dataFormat),this.dilationRate=(0,en.AF)(ee||1,2,"dilationRate"),this.dilationRate.forEach(F=>(0,ea.iQ)(F,"dilationRate"))}build(F){var $;F=(0,ei.Wf)(F);let V="channelsFirst"===this.dataFormat?1:F.length-1;if(null==F[V])throw new ee.nu(`The channel dimension of the input should be defined. Found ${F[V]}`);let K=F[V],Z=4,en=this.kernelSize.concat([K,this.filters*Z]);this.kernel=this.addWeight("kernel",en,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let ea=this.kernelSize.concat([this.filters,this.filters*Z]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",ea,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let F;if(this.unitForgetBias){let V=this.biasInitializer,K=this.filters;F=new(($=class extends et.m7{apply(F,$){let Z=V.apply([K]),ee=G.iUs([K]),et=V.apply([2*K]);return H.mV([Z,ee,et])}}).className="CustomInit",$)}else F=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*Z],null,F,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(F,$){return G.lub(()=>{if(3!==F.length)throw new ee.nu(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${F.length}.`);let V=$.training||!1,H=F[0],K=F[1],Z=F[2],et=4;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=(0,eo._0)({ones:()=>G.JpU(H),rate:this.dropout,training:V,count:et,dropoutFunc:this.dropoutFunc}));let en=this.dropoutMask,applyDropout=(F,$,V)=>$&&$[V]?G.dC7($[V],F):F,ea=applyDropout(H,en,0),ei=applyDropout(H,en,1),es=applyDropout(H,en,2),eu=applyDropout(H,en,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=(0,eo._0)({ones:()=>G.JpU(K),rate:this.recurrentDropout,training:V,count:et,dropoutFunc:this.dropoutFunc}));let ec=this.recurrentDropoutMask,ep=applyDropout(K,ec,0),eh=applyDropout(K,ec,1),ef=applyDropout(K,ec,2),ed=applyDropout(K,ec,3),em=3,[eg,ey,eb,ew]=G.Vl2(this.kernel.read(),et,em),[eS,e_,eN,ek]=this.useBias?G.Vl2(this.bias.read(),et):[null,null,null,null];ea=this.inputConv(ea,eg,eS,this.padding),ei=this.inputConv(ei,ey,e_,this.padding),es=this.inputConv(es,eb,eN,this.padding),eu=this.inputConv(eu,ew,ek,this.padding);let[eI,eT,eC,eE]=G.Vl2(this.recurrentKernel.read(),et,em);ep=this.recurrentConv(ep,eI),eh=this.recurrentConv(eh,eT),ef=this.recurrentConv(ef,eC),ed=this.recurrentConv(ed,eE);let eA=this.recurrentActivation.apply(G.IHx(ea,ep)),eD=this.recurrentActivation.apply(G.IHx(ei,eh)),eM=G.IHx(G.dC7(eD,Z),G.dC7(eA,this.activation.apply(G.IHx(es,ef)))),eR=G.dC7(this.recurrentActivation.apply(G.IHx(eu,ed)),this.activation.apply(eM));return[eR,eR,eM]})}getConfig(){let F=super.getConfig(),{units:$}=F,V=__rest(F,["units"]),G={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},V),G)}inputConv(F,$,V,K){let Z=G.Tek(F,$,this.strides,K||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return V?H.a2(Z,V,this.dataFormat):Z}recurrentConv(F,$){let V=1;return G.Tek(F,$,V,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};ConvLSTM2DCell.className="ConvLSTM2DCell",G.m7h.registerClass(ConvLSTM2DCell);let ConvLSTM2D=class ConvLSTM2D extends ConvRNN2D{constructor(F){let $=new ConvLSTM2DCell(F);super(Object.assign(Object.assign({},F),{cell:$}))}static fromConfig(F,$){return new F($)}};ConvLSTM2D.className="ConvLSTM2D",G.m7h.registerClass(ConvLSTM2D)},53636:function(F,$,V){"use strict";V.d($,{E7:function(){return RepeatVector},Ex:function(){return SpatialDropout1D},HZ:function(){return Reshape},Jq:function(){return Activation},Jw:function(){return Masking},mb:function(){return Dense},qj:function(){return Flatten},vf:function(){return Dropout},xV:function(){return Permute}});var G=V(15949),H=V(28819),K=V(39840),Z=V(64079),ee=V(20163),et=V(40588),en=V(92599),ea=V(10539),ei=V(2931),eo=V(96040),es=V(87538);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Dropout=class Dropout extends ee.mh{constructor(F){super(F),this.rate=Math.max(Math.min(F.rate,1),0),this.noiseShape=F.noiseShape,this.seed=F.seed,this.supportsMasking=!0}getNoiseShape(F){if(null==this.noiseShape)return this.noiseShape;let $=F.shape,V=[];for(let F=0;F<this.noiseShape.length;++F)V.push(null==this.noiseShape[F]?$[F]:this.noiseShape[F]);return V}call(F,$){return(0,G.lub)(()=>{this.invokeCallHook(F,$);let V=(0,es.nQ)(F);if(0<this.rate&&this.rate<1){let F=null!=$.training&&$.training,G=this.getNoiseShape(V),H=K.KC(()=>K.rv(V,this.rate,G,this.seed),()=>V,F);return H}return F})}getConfig(){let F={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},$=super.getConfig();return Object.assign(F,$),F}dispose(){return super.dispose()}};Dropout.className="Dropout",G.m7h.registerClass(Dropout);let SpatialDropout1D=class SpatialDropout1D extends Dropout{constructor(F){super(F),this.inputSpec=[{ndim:3}]}getNoiseShape(F){let $=F.shape;return[$[0],1,$[2]]}};SpatialDropout1D.className="SpatialDropout1D",G.m7h.registerClass(SpatialDropout1D);let Dense=class Dense extends ee.mh{constructor(F){if(super(F),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==F.batchInputShape&&null==F.inputShape&&null!=F.inputDim){let $=null;null!=F.batchSize&&($=F.batchSize),this.batchInputShape=[$,F.inputDim]}this.units=F.units,(0,ei.iQ)(this.units,"units"),this.activation=(0,H.aI)(F.activation),null!=F.useBias&&(this.useBias=F.useBias),this.kernelInitializer=(0,en.L5)(F.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=(0,en.L5)(F.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=(0,Z.Ad)(F.kernelConstraint),this.biasConstraint=(0,Z.Ad)(F.biasConstraint),this.kernelRegularizer=(0,ea.EC)(F.kernelRegularizer),this.biasRegularizer=(0,ea.EC)(F.biasRegularizer),this.activityRegularizer=(0,ea.EC)(F.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(F){F=(0,es.Wf)(F);let $=F[F.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[$,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:$}}],this.built=!0}computeOutputShape(F){F=(0,es.Wf)(F);let $=F.slice();return $[$.length-1]=this.units,$}call(F,$){return(0,G.lub)(()=>{let V;this.invokeCallHook(F,$);let G=(0,es.nQ)(F),H=(0,ei.WT)(this.activation.getClassName());return null!=H?V=K.AK(G,this.kernel.read(),H,this.bias?this.bias.read():null):(V=K.AK(G,this.kernel.read()),null!=this.bias&&(V=K.a2(V,this.bias.read())),null!=this.activation&&(V=this.activation.apply(V))),V})}getConfig(){let F={units:this.units,activation:(0,H.GD)(this.activation),useBias:this.useBias,kernelInitializer:(0,en.Cx)(this.kernelInitializer),biasInitializer:(0,en.Cx)(this.biasInitializer),kernelRegularizer:(0,ea.SG)(this.kernelRegularizer),biasRegularizer:(0,ea.SG)(this.biasRegularizer),activityRegularizer:(0,ea.SG)(this.activityRegularizer),kernelConstraint:(0,Z.xF)(this.kernelConstraint),biasConstraint:(0,Z.xF)(this.biasConstraint)},$=super.getConfig();return Object.assign(F,$),F}};Dense.className="Dense",G.m7h.registerClass(Dense);let Flatten=class Flatten extends ee.mh{constructor(F){super(F=F||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=F.dataFormat}computeOutputShape(F){for(let $ of(F=(0,es.Wf)(F)).slice(1))if(null==$)throw new et.nu(`The shape of the input to "Flatten" is not fully defined (got ${F.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[F[0],(0,eo.NS)(F,1)]}call(F,$){return(0,G.lub)(()=>{this.invokeCallHook(F,$);let V=(0,es.nQ)(F);if("channelsFirst"===this.dataFormat&&V.rank>1){let F=[0];for(let $=2;$<V.rank;++$)F.push($);F.push(1),V=(0,G.p4s)(V,F)}return K.Uz(V)})}getConfig(){let F={};null!=this.dataFormat&&(F.dataFormat=this.dataFormat);let $=super.getConfig();return Object.assign(F,$),F}};Flatten.className="Flatten",G.m7h.registerClass(Flatten);let Activation=class Activation extends ee.mh{constructor(F){super(F),this.supportsMasking=!0,this.activation=(0,H.aI)(F.activation)}call(F,$){return(0,G.lub)(()=>{this.invokeCallHook(F,$);let V=(0,es.nQ)(F);return this.activation.apply(V)})}getConfig(){let F={activation:(0,H.GD)(this.activation)},$=super.getConfig();return Object.assign(F,$),F}};Activation.className="Activation",G.m7h.registerClass(Activation);let RepeatVector=class RepeatVector extends ee.mh{constructor(F){super(F),this.n=F.n,this.inputSpec=[{ndim:2}]}computeOutputShape(F){return[F[0],this.n,F[1]]}call(F,$){return(0,G.lub)(()=>(F=(0,es.nQ)(F),K.rx(F,this.n)))}getConfig(){let F={n:this.n},$=super.getConfig();return Object.assign(F,$),F}};RepeatVector.className="RepeatVector",G.m7h.registerClass(RepeatVector);let Reshape=class Reshape extends ee.mh{constructor(F){super(F),this.targetShape=F.targetShape;for(let F=0;F<this.targetShape.length;++F)this.isUnknown(this.targetShape[F])&&(this.targetShape[F]=null)}isUnknown(F){return F<0||null==F}fixUnknownDimension(F,$){let V="Total size of new array must be unchanged.",G=$.slice(),H=1,K=null;for(let F=0;F<G.length;++F){let $=G[F];if(this.isUnknown($)){if(null===K)K=F;else throw new et.nu("Can only specifiy one unknown dimension.")}else H*=$}let Z=(0,eo.NS)(F);if(null!==K){if(0===H||Z%H!=0)throw new et.nu(V);G[K]=Z/H}else if(Z!==H)throw new et.nu(V);return G}computeOutputShape(F){let $=!1;for(let V=0;V<F.length;++V)if(this.isUnknown(F[V])){$=!0;break}return $?F.slice(0,1).concat(this.targetShape):F.slice(0,1).concat(this.fixUnknownDimension(F.slice(1),this.targetShape))}call(F,$){return(0,G.lub)(()=>{this.invokeCallHook(F,$);let V=(0,es.nQ)(F),H=V.shape,K=H.slice(0,1).concat(this.fixUnknownDimension(H.slice(1),this.targetShape));return(0,G.XLQ)(V,K)})}getConfig(){let F={targetShape:this.targetShape},$=super.getConfig();return Object.assign(F,$),F}};Reshape.className="Reshape",G.m7h.registerClass(Reshape);let Permute=class Permute extends ee.mh{constructor(F){if(super(F),null==F.dims)throw Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(F.dims))throw Error(`Permute constructor requires \`dims\` to be an Array, but received ${F.dims} instead.`);let $=(0,eo.w6)(1,F.dims.length+1);if(!G.D5U.arraysEqual(F.dims.slice().sort(),$))throw Error("Invalid permutation `dims`: "+JSON.stringify(F.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=F.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ee.Zg({ndim:this.dims.length+1})]}computeOutputShape(F){F=(0,es.Wf)(F);let $=F.slice();return this.dims.forEach((V,G)=>{$[G+1]=F[V]}),$}call(F,$){return(0,G.p4s)((0,es.nQ)(F),this.dimsIncludingBatch)}getConfig(){let F={dims:this.dims},$=super.getConfig();return Object.assign(F,$),F}};Permute.className="Permute",G.m7h.registerClass(Permute);let Masking=class Masking extends ee.mh{constructor(F){super(null==F?{}:F),this.supportsMasking=!0,null!=F?this.maskValue=null==F.maskValue?0:F.maskValue:this.maskValue=0}computeOutputShape(F){return F}getConfig(){let F=super.getConfig(),$={maskValue:this.maskValue};return Object.assign($,F),$}computeMask(F,$){let V=(0,es.nQ)(F),H=-1;return(0,G.YjB)((0,G.Quu)(V,this.maskValue),H)}call(F,$){return(0,G.lub)(()=>{this.invokeCallHook(F,$);let V=(0,es.nQ)(F),H=-1,K=!0,Z=(0,G.YjB)((0,G.Quu)(V,this.maskValue),H,K),ee=(0,G.dC7)(V,(0,G.pju)(Z,V.dtype));return ee})}};Masking.className="Masking",G.m7h.registerClass(Masking)},2784:function(F,$,V){"use strict";V.d($,{C:function(){return Embedding}});var G=V(15949),H=V(39840),K=V(64079),Z=V(20163),ee=V(40588),et=V(92599),en=V(10539),ea=V(2931),ei=V(87538);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Embedding=class Embedding extends Z.mh{constructor(F){if(super(F),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==F.batchInputShape&&null==F.inputShape){let $=null;null!=F.batchSize&&($=F.batchSize),null==F.inputLength?this.batchInputShape=[$,null]:this.batchInputShape=[$].concat(ea.zZ(F.inputLength))}this.inputDim=F.inputDim,ea.iQ(this.inputDim,"inputDim"),this.outputDim=F.outputDim,ea.iQ(this.outputDim,"outputDim"),this.embeddingsInitializer=(0,et.L5)(F.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=(0,en.EC)(F.embeddingsRegularizer),this.activityRegularizer=(0,en.EC)(F.activityRegularizer),this.embeddingsConstraint=(0,K.Ad)(F.embeddingsConstraint),this.maskZero=F.maskZero,this.supportsMasking=F.maskZero,this.inputLength=F.inputLength}build(F){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(F){}computeMask(F,$){return(0,G.lub)(()=>this.maskZero?(F=(0,ei.nQ)(F),(0,G.Quu)(F,(0,G.P84)(F))):null)}computeOutputShape(F){if(F=(0,ei.Wf)(F),null==this.inputLength)return[...F,this.outputDim];let $=ea.zZ(this.inputLength);if($.length!==F.length-1)throw new ee.nu(`"inputLength" is ${this.inputLength}, but received input shape has shape ${F}`);{let V=0;for(let G=0;G<$.length;++G){let H=$[G],K=F[G+1];if(null!=H&&null!=K&&H!==K)throw new ee.nu(`"inputLength" is ${this.inputLength}, but received input shape has shape ${F}`);null==H&&($[V]=K),V++}}return[F[0],...$,this.outputDim]}call(F,$){return(0,G.lub)(()=>{this.invokeCallHook(F,$);let V=(0,ei.nQ)(F);"int32"!==V.dtype&&(V=H.pj(V,"int32"));let K=H.Iq(this.embeddings.read(),(0,G.XLQ)(V,[V.size]));return(0,G.XLQ)(K,(0,ei.Wf)(this.computeOutputShape(V.shape)))})}getConfig(){let F={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:(0,et.Cx)(this.embeddingsInitializer),embeddingsRegularizer:(0,en.SG)(this.embeddingsRegularizer),activityRegularizer:(0,en.SG)(this.activityRegularizer),embeddingsConstraint:(0,K.xF)(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},$=super.getConfig();return Object.assign(F,$),F}};Embedding.className="Embedding",G.m7h.registerClass(Embedding)},64140:function(F,$,V){"use strict";V.d($,{Ag:function(){return Average},BM:function(){return Maximum},mm:function(){return Add},oT:function(){return Dot},q8:function(){return Minimum},wY:function(){return Multiply},yR:function(){return Concatenate}});var G=V(15949),H=V(39840),K=V(20163),Z=V(40588),ee=V(86275),et=V(2931),en=V(96040),ea=V(87538);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Merge=class Merge extends K.mh{constructor(F){super(F||{}),this.supportsMasking=!0}mergeFunction(F){throw new Z.nj}computeElementwiseOpOutputShape(F,$){if(null==F||null==$)return null;if(F.length<$.length)return this.computeElementwiseOpOutputShape($,F);if(0===$.length)return F;let V=F.slice(0,F.length-$.length);for(let G=0;G<$.length;++G){let H=F[F.length-$.length+G],K=$[G];if(null==H||null==K||H<0||K<0)V.push(null);else if(1===H)V.push(K);else if(1===K)V.push(H);else{if(H!==K)throw new Z.nu("Operands could not be broadcast together with shapes "+JSON.stringify(F)+" "+JSON.stringify($));V.push(H)}}return V}build(F){if(Array.isArray(F)&&!Array.isArray(F[0])&&(F=[(0,ea.Wf)(F)]),F.length<2)throw new Z.nu(`A merge layer should be called on an Array of at least 2 inputs. Got ${F.length} input(s).`);let $=[];for(let V of F)null!=V&&null!==V[0]&&$.push(V[0]);if(($=et.Tw($)).length>1)throw new Z.nu(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(F)}.`);let V=null==F[0]?null:F[0].slice(1);for(let $=1;$<F.length;++$){let G=null==F[$]?null:F[$].slice(1);V=this.computeElementwiseOpOutputShape(V,G)}let G=F.map(F=>F.length);-1===F.indexOf(null)&&1===et.Tw(G).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(F,$){return(0,G.lub)(()=>{if(!this.reshapeRequired)return this.mergeFunction(F);{let $=[],V=F.map(F=>F.rank);if(-1===V.indexOf(null)){let G=en.Fp(V);for(let V of F){let F=V.rank;for(let $=0;$<G-F;++$)V=H.dt(V,1);$.push(V)}return this.mergeFunction($)}{let V=!1;for(let H of F){let F=H.rank;if(null==F){let F=H.shape,K=F[0],Z=F.slice(1).concat([K]),ee=G.XLQ(H,[K].concat(en.NS(F.slice(1))));ee=G.p4s(ee,[1,0]),ee=G.XLQ(ee,Z),$.push(ee),V=!0}else if(F>1){let K=en.w6(1,F).concat([0]);$.push(G.p4s(H,K)),V=!0}else $.push(H)}let H=this.mergeFunction($),K=H.rank;if(V){if(null==K){let F=H.shape,$=F.length,V=F[$-1],K=[V].concat(F.slice(0,F.length-1));H=G.XLQ(G.p4s(G.XLQ(H,[-1,V]),[1,0]),K)}else if(K>1){let F=[K-1].concat(en.w6(0,K-1));H=G.p4s(H,F)}}return H}}})}computeOutputShape(F){let $;$=null==F[0]?null:F[0].slice(1);for(let V=1;V<F.length;++V){let G=null==F[V]?null:F[V].slice(1);$=this.computeElementwiseOpOutputShape($,G)}let V=[];for(let $ of F)null!=$&&null!==$[0]&&V.push($[0]);return 1===(V=et.Tw(V)).length?V.concat($):[null].concat($)}computeMask(F,$){return G.lub(()=>{if(null==$)return null;if(!Array.isArray($))throw new Z.nu("`mask` should be an Array");if(!Array.isArray(F))throw new Z.nu("`inputs` should be an Array");if($.length!==F.length)throw new Z.nu(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${F.length} vs ${$.length})`);if($.every(F=>null==F))return null;let V=($=$.map(F=>null==F?F:G.dt4(F,0)))[0];for(let F=1;F<$.length-1;++F)V=G.HvI(V,$[F]);return V})}};let Add=class Add extends Merge{constructor(F){super(F)}mergeFunction(F){return(0,G.lub)(()=>{let $=F[0].clone();for(let V=1;V<F.length;++V)$=G.IHx($,F[V]);return $})}};Add.className="Add",G.m7h.registerClass(Add);let Multiply=class Multiply extends Merge{constructor(F){super(F)}mergeFunction(F){return(0,G.lub)(()=>{let $=F[0].clone();for(let V=1;V<F.length;++V)$=G.dC7($,F[V]);return $})}};Multiply.className="Multiply",G.m7h.registerClass(Multiply);let Average=class Average extends Merge{constructor(F){super(F)}mergeFunction(F){return(0,G.lub)(()=>{let $=F[0].clone();for(let V=1;V<F.length;++V)$=G.IHx($,F[V]);return G.dC7(1/F.length,$)})}};Average.className="Average",G.m7h.registerClass(Average);let Maximum=class Maximum extends Merge{constructor(F){super(F)}mergeFunction(F){return(0,G.lub)(()=>{let $=F[0];for(let V=1;V<F.length;++V)$=G.gWQ($,F[V]);return $})}};Maximum.className="Maximum",G.m7h.registerClass(Maximum);let Minimum=class Minimum extends Merge{constructor(F){super(F)}mergeFunction(F){return(0,G.lub)(()=>{let $=F[0];for(let V=1;V<F.length;++V)$=G.LTh($,F[V]);return $})}};Minimum.className="Minimum",G.m7h.registerClass(Minimum);let Concatenate=class Concatenate extends Merge{constructor(F){super(F),this.DEFAULT_AXIS=-1,null==F&&(F={}),this.axis=null==F.axis?this.DEFAULT_AXIS:F.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(F){if(!(Array.isArray(F)&&Array.isArray(F[0]))||1===F.length)throw new Z.nu("A `Concatenate` layer should be called on a list of at least 2 inputs");let $=!0;for(let V of F)if(null!=V){$=!1;break}if($)return;let V=[];for(let $=0;$<F.length;++$){let H=F[$].slice();H.splice(this.axis,1);let K=!1;for(let F of V)if(G.D5U.arraysEqual(F,H)){K=!0;break}K||V.push(H)}if(V.length>1)throw new Z.nu("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(F))}mergeFunction(F){return(0,G.lub)(()=>H.mV(F,this.axis))}computeOutputShape(F){if(!(Array.isArray(F)&&Array.isArray(F[0])))throw new Z.nu("A `Concatenate` layer should be called on a list of inputs.");let $=F,V=$[0].slice(),G=this.axis<0?V.length+this.axis:this.axis;for(let F of $.slice(1)){if(null==V[G]||null==F[G]){V[G]=null;break}V[G]+=F[G]}return V}computeMask(F,$){if(null==$)return null;if(!Array.isArray($))throw new Z.nu("`mask` should be an array for Concatenate");if(!Array.isArray(F))throw new Z.nu("`inputs` should be an array for Concatenate");if($.length!==F.length)throw new Z.nu(`Mismatch in the length of mask (${$.length}) and the legnth of inputs (${F.length})`);return G.lub(()=>{let V=!0;if($.forEach(F=>{if(null!=F){V=!1;return}}),V)return null;let H=[];for(let V=0;V<F.length;++V)null==$[V]?H.push(G.pju(G.JpU(F[V]),"bool")):$[V].rank<F[V].rank?H.push(G.dt4($[V],-1)):H.push($[V]);let K=G.zoF(H,this.axis);return G.$6P(K,-1,!1)})}getConfig(){let F={axis:this.axis},$=super.getConfig();return Object.assign(F,$),F}};function interpretAxis(F,$){for(;F<0;)F+=$;return F}function batchDot(F,$,V){if(F.shape.length>3||$.shape.length>3)throw new Z.nj("batchDot is not implemented for tensors of 4D or higher rank yet");if(G.D5U.assert(F.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${F.shape.length}`),G.D5U.assert(F.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${$.shape.length}`),"number"==typeof V&&(V=[V,V]),"complex64"===F.dtype||"complex64"===$.dtype)throw new Z.nj("batchDot is not implemented for complex64-type Tensors yet.");let H=F.shape.length,K=$.shape.length;null==V&&(V=[H-1,K-2]);let ee=V;return G.lub(()=>{let V,Z;if(H>K){V=H-K;let F=[];for(let $=0;$<V;++$)F.push(1);$=G.XLQ($,$.shape.concat(F))}else if(K>H){V=K-H;let $=[];for(let F=0;F<V;++F)$.push(1);F=G.XLQ(F,F.shape.concat($))}else V=0;if(2===F.shape.length&&2===$.shape.length)Z=ee[0]===ee[1]?G.Smz(G.dC7(F,$),ee[0]):G.Smz(G.dC7(G.p4s(F,[1,0]),$),ee[1]);else{let V=ee[0]!==F.shape.length-1,H=ee[1]===$.shape.length-1;Z=G.OI3(F,$,V,H)}if(V>0){let F;F=H>K?H+K-3:H-1;let $=[];for(let G=F;G<F+V;++G)$.push(G);Z=G.L9e(Z,$)}return 1===Z.shape.length&&(Z=G.dt4(Z,1)),Z})}Concatenate.className="Concatenate",G.m7h.registerClass(Concatenate);let Dot=class Dot extends Merge{constructor(F){super(F),this.axes=F.axes,this.normalize=null!=F.normalize&&F.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(F){G.D5U.assert(Array.isArray(F)&&2===F.length&&Array.isArray(F[0])&&Array.isArray(F[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let $=F[0],V=F[1];if($.length>3||V.length>3)throw new Z.nj("Dot layer does not support tensors of 4D or higher rank yet.");let H=this.interpretAxes($,V);if($[H[0]]!==V[H[1]])throw new Z.nu(`Dimension incompatibility: ${$[H[0]]} !== ${V[H[1]]}`)}mergeFunction(F){let $;if(2!==F.length)throw new Z.nu(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${F.length} input(s).`);let V=F[0],G=F[1];return $=Array.isArray(this.axes)?this.axes.map(($,V)=>interpretAxis($,F[V].shape.length)):[interpretAxis(this.axes,V.shape.length),interpretAxis(this.axes,G.shape.length)],this.normalize&&(V=(0,ee.Eq)(V,$[0]),G=(0,ee.Eq)(G,$[1])),batchDot(V,G,$)}interpretAxes(F,$){return Array.isArray(this.axes)?this.axes:[interpretAxis(this.axes,F.length),interpretAxis(this.axes,$.length)]}computeOutputShape(F){G.D5U.assert(Array.isArray(F)&&2===F.length&&Array.isArray(F[0])&&Array.isArray(F[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let $=F[0].slice(),V=F[1].slice();if($.length>3||V.length>3)throw new Z.nj("Dot layer does not support tensors of 4D or higher rank yet.");let H=this.interpretAxes($,V);$.splice(H[0],1),V.splice(H[1],1),V.splice(0,1);let K=$.concat(V);return 1===K.length&&K.push(1),K}computeMask(F,$){return null}getConfig(){let F={axes:this.axes,normalize:this.normalize},$=super.getConfig();return Object.assign(F,$),F}};Dot.className="Dot",G.m7h.registerClass(Dot)},76177:function(F,$,V){"use strict";V.d($,{Qt:function(){return GaussianNoise},ZM:function(){return GaussianDropout},aj:function(){return AlphaDropout}});var G=V(15949),H=V(39840),K=V(20163),Z=V(87538);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let GaussianNoise=class GaussianNoise extends K.mh{constructor(F){super(F),this.supportsMasking=!0,this.stddev=F.stddev}computeOutputShape(F){return F}getConfig(){let F=super.getConfig(),$={stddev:this.stddev};return Object.assign($,F),$}call(F,$){return(0,G.lub)(()=>{this.invokeCallHook(F,$);let V=(0,Z.nQ)(F),noised=()=>(0,G.IHx)(H.nG(V.shape,0,this.stddev),V),K=H.KC(noised,()=>V,$.training||!1);return K})}};GaussianNoise.className="GaussianNoise",G.m7h.registerClass(GaussianNoise);let GaussianDropout=class GaussianDropout extends K.mh{constructor(F){super(F),this.supportsMasking=!0,this.rate=F.rate}computeOutputShape(F){return F}getConfig(){let F=super.getConfig(),$={rate:this.rate};return Object.assign($,F),$}call(F,$){return(0,G.lub)(()=>{this.invokeCallHook(F,$);let V=(0,Z.nQ)(F);if(this.rate>0&&this.rate<1){let noised=()=>{let F=Math.sqrt(this.rate/(1-this.rate));return(0,G.dC7)(V,H.nG(V.shape,1,F))};return H.KC(noised,()=>V,$.training||!1)}return V})}};GaussianDropout.className="GaussianDropout",G.m7h.registerClass(GaussianDropout);let AlphaDropout=class AlphaDropout extends K.mh{constructor(F){super(F),this.supportsMasking=!0,this.rate=F.rate,this.noiseShape=F.noiseShape}_getNoiseShape(F){return this.noiseShape||(0,Z.nQ)(F).shape}computeOutputShape(F){return F}getConfig(){let F=super.getConfig(),$={rate:this.rate};return Object.assign($,F),$}call(F,$){return(0,G.lub)(()=>{if(this.rate<1&&this.rate>0){let V=this._getNoiseShape(F),droppedInputs=()=>{let $=(0,Z.nQ)(F),K=1.6732632423543772,ee=1.0507009873554805,et=-K*ee,en=(0,G.brS)((0,G.LGj)(V),this.rate);en=H.pj(en,"float32");let ea=((1-this.rate)*(1+this.rate*et**2))**-.5,ei=-ea*et*this.rate,eo=(0,G.IHx)((0,G.dC7)($,en),(0,G.dC7)((0,G.IHx)(en,-1),et));return(0,G.IHx)((0,G.dC7)(eo,ea),ei)};return H.KC(droppedInputs,()=>(0,Z.nQ)(F),$.training||!1)}return F})}};AlphaDropout.className="AlphaDropout",G.m7h.registerClass(AlphaDropout)},67280:function(F,$,V){"use strict";V.d($,{XM:function(){return BatchNormalization},pz:function(){return LayerNormalization}});var G=V(15949),H=V(64079),K=V(20163),Z=V(40588),ee=V(92599),et=V(10539),en=V(2931),ea=V(96040),ei=V(87538);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function batchNormalization(F,$,V,H,K,ee=.001){let et;if(2===F.rank)et=G.Dxk(F,$,V,H,K,ee);else if(3===F.rank)et=G.JY5(F,$,V,H,K,ee);else if(4===F.rank)et=G.p3b(F,$,V,H,K,ee);else throw new Z.nj(`batchNormalization is not implemented for array of rank ${F.rank} yet`);return et}function regularNormalizeBatchInTraining(F,$,V,H,K=.001){return(0,G.lub)(()=>{let Z=G.Gi7(F,H),ee=Z.mean,et=Z.variance,en=batchNormalization(F,ee,et,V,$,K);return[en,ee,et]})}function broadcastNormalizeBatchInTraining(F,$,V,H,K=.001){return(0,G.lub)(()=>{let Z=G.Gi7(F,H),ee=Z.mean,et=Z.variance,en=[];for(let $ of ea.w6(0,F.rank))-1!==H.indexOf($)?en.push(1):en.push(F.shape[$]);let ei=(0,G.XLQ)(ee,en),eo=(0,G.XLQ)(et,en),es=null==$?null:(0,G.XLQ)($,en),eu=null==V?null:(0,G.XLQ)(V,en),ec=batchNormalization(F,ei,eo,eu,es,K);return[ec,ee,et]})}function normalizeBatchInTraining(F,$,V,H,K=.001){return G.D5U.arraysEqual(H.slice().sort(),ea.w6(0,F.rank-1))?regularNormalizeBatchInTraining(F,$,V,H,K):broadcastNormalizeBatchInTraining(F,$,V,H,K)}let BatchNormalization=class BatchNormalization extends K.mh{constructor(F){null==F&&(F={}),super(F),this.supportsMasking=!0,this.axis=null==F.axis?-1:F.axis,this.momentum=null==F.momentum?.99:F.momentum,this.epsilon=null==F.epsilon?.001:F.epsilon,this.center=null==F.center||F.center,this.scale=null==F.scale||F.scale,this.betaInitializer=(0,ee.L5)(F.betaInitializer||"zeros"),this.gammaInitializer=(0,ee.L5)(F.gammaInitializer||"ones"),this.movingMeanInitializer=(0,ee.L5)(F.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=(0,ee.L5)(F.movingVarianceInitializer||"ones"),this.betaConstraint=(0,H.Ad)(F.betaConstraint),this.gammaConstraint=(0,H.Ad)(F.gammaConstraint),this.betaRegularizer=(0,et.EC)(F.betaRegularizer),this.gammaRegularizer=(0,et.EC)(F.gammaRegularizer)}build(F){F=(0,ei.Wf)(F);let $=this.axis>=0?this.axis:this.axis+F.length,V=F[$];if(null==V)throw new Z.nu(`Axis ${$} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(F)}.`);this.inputSpec=[new K.Zg({ndim:F.length,axes:{[$]:V}})];let G=[V];this.scale&&(this.gamma=this.addWeight("gamma",G,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",G,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",G,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",G,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(F,$){return(0,G.lub)(()=>{let V=null!=$.training&&$.training,H=(0,ei.nQ)(F),K=H.shape,Z=K.length,ee=ea.w6(0,Z),et=this.axis>=0?this.axis:this.axis+Z;ee.splice(et,1);let eo=en.JE(1,Z);eo[et]=K[et];let es=ee.slice();es.sort();let eu=!G.D5U.arraysEqual(es,ea.w6(0,Z).slice(0,Z-1)),normalizeInference=()=>{if(!eu)return batchNormalization(H,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon);{let F=(0,G.XLQ)(this.movingMean.read(),eo),$=(0,G.XLQ)(this.movingVariance.read(),eo),V=this.center?(0,G.XLQ)(this.beta.read(),eo):null,K=this.scale?(0,G.XLQ)(this.gamma.read(),eo):null;return batchNormalization(H,F,$,V,K,this.epsilon)}};if(!V)return normalizeInference();let[ec,ep,eh]=normalizeBatchInTraining(H,this.gamma.read(),this.beta.read(),ee,this.epsilon),doMovingAverage=(F,$,V)=>{G.lub(()=>{let H=1-V,K=F.read(),Z=G.dC7(G.luU(K,$),H);F.write(G.luU(K,Z))})},updateMovingMeanAndVariance=()=>{doMovingAverage(this.movingMean,ep,this.momentum),doMovingAverage(this.movingVariance,eh,this.momentum)};return updateMovingMeanAndVariance(),ec})}getConfig(){let F={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:(0,ee.Cx)(this.betaInitializer),gammaInitializer:(0,ee.Cx)(this.gammaInitializer),movingMeanInitializer:(0,ee.Cx)(this.movingMeanInitializer),movingVarianceInitializer:(0,ee.Cx)(this.movingVarianceInitializer),betaRegularizer:(0,et.SG)(this.betaRegularizer),gammaRegularizer:(0,et.SG)(this.gammaRegularizer),betaConstraint:(0,H.xF)(this.betaConstraint),gammaConstraint:(0,H.xF)(this.gammaConstraint)},$=super.getConfig();return Object.assign(F,$),F}};BatchNormalization.className="BatchNormalization",G.m7h.registerClass(BatchNormalization);let LayerNormalization=class LayerNormalization extends K.mh{constructor(F){if(null==F&&(F={}),super(F),this.axis=null==F.axis?-1:F.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let F of this.axis)if(!Number.isInteger(F))throw Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=null==F.epsilon?.001:F.epsilon,this.center=null==F.center||F.center,this.scale=null==F.scale||F.scale,this.betaInitializer=(0,ee.L5)(F.betaInitializer||"zeros"),this.gammaInitializer=(0,ee.L5)(F.gammaInitializer||"ones"),this.betaRegularizer=(0,et.EC)(F.betaRegularizer),this.gammaRegularizer=(0,et.EC)(F.gammaRegularizer),this.supportsMasking=!0}build(F){F=(0,ei.Wf)(F);let $=F.length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let F=0;F<this.axis.length;++F)this.axis[F]<0&&(this.axis[F]+=$);for(let F of this.axis)if(F<0||F>=$)throw Error(`Invalid axis: ${F}`);if(this.axis.length!==en.Tw(this.axis).length)throw Error(`Found duplicate axes in: ${this.axis}`);let V=this.axis.map($=>F[$]),G=!0;this.scale?this.gamma=this.addWeight("gamma",V,"float32",this.gammaInitializer,this.gammaRegularizer,G):this.gamma=null,this.center?this.beta=this.addWeight("beta",V,"float32",this.betaInitializer,this.betaRegularizer,G):this.beta=null,this.built=!0}call(F,$){let V=(0,ei.nQ)(F),H=V.shape,K=H.length;return(0,G.lub)(()=>{let F=!0,{mean:$,variance:Z}=(0,G.Gi7)(V,this.axis,F),ee=en.JE(1,K);for(let F of this.axis)ee[F]=H[F];let broadcast=F=>null!=F&&F.shape.length!==K?G.XLQ(F,ee):F,et=this.scale?broadcast(this.gamma.read()):null,ea=this.center?broadcast(this.beta.read()):null,ei=[],eo=[];for(let F=0;F<K;++F)-1!==this.axis.indexOf(F)?(ei.push(H[F]),eo.push(1)):(ei.push(1),eo.push(H[F]));return $=G.Gg6($,ei),Z=G.Gg6(Z,ei),null!=et&&(et=G.Gg6(et,eo)),null!=ea&&(ea=G.Gg6(ea,eo)),batchNormalization(V,$,Z,ea,et,this.epsilon)})}getConfig(){let F={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:(0,ee.Cx)(this.betaInitializer),gammaInitializer:(0,ee.Cx)(this.gammaInitializer),betaRegularizer:(0,et.SG)(this.betaRegularizer),gammaRegularizer:(0,et.SG)(this.gammaRegularizer)},$=super.getConfig();return Object.assign(F,$),F}};LayerNormalization.className="LayerNormalization",G.m7h.registerClass(LayerNormalization)},505:function(F,$,V){"use strict";V.d($,{Zm:function(){return ZeroPadding2D}});var G=V(15949),H=V(12012),K=V(20163),Z=V(40588),ee=V(87538);function spatial2dPadding(F,$,V){return(0,G.lub)(()=>{let K;if(4!==F.rank)throw new Z.nu(`temporalPadding expects input tensor to be 4-D, but received a ${F.rank}-D tensor.`);if(null==$&&($=[[1,1],[1,1]]),2!==$.length||2!==$[0].length||2!==$[1].length)throw new Z.nu("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==V&&(V=(0,H.rf)()),"channelsLast"!==V&&"channelsFirst"!==V)throw new Z.nu(`Unknown data format: ${V}. Supported data formats are 'channelsLast' and 'channelsFirst.`);return K="channelsFirst"===V?[[0,0],[0,0],$[0],$[1]]:[[0,0],$[0],$[1],[0,0]],G.vku(F,K)})}let ZeroPadding2D=class ZeroPadding2D extends K.mh{constructor(F){if(null==F&&(F={}),super(F),this.dataFormat=null==F.dataFormat?(0,H.rf)():F.dataFormat,null==F.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof F.padding)this.padding=[[F.padding,F.padding],[F.padding,F.padding]];else{let $,V;if(F.padding=F.padding,2!==F.padding.length)throw new Z.nu(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${F.padding.length} array.`);if("number"==typeof F.padding[0])$=[F.padding[0],F.padding[0]],V=[F.padding[1],F.padding[1]];else{if(F.padding=F.padding,2!==F.padding[0].length)throw new Z.nu(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${F.padding[0].length} array.`);if($=F.padding[0],2!==F.padding[1].length)throw new Z.nu(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${F.padding[1].length} array.`);V=F.padding[1]}this.padding=[$,V]}this.inputSpec=[new K.Zg({ndim:4})]}computeOutputShape(F){let $,V;return(F=(0,ee.Wf)(F),"channelsFirst"===this.dataFormat)?($=null!=F[2]&&F[2]>=0?F[2]+this.padding[0][0]+this.padding[0][1]:null,V=null!=F[3]&&F[3]>=0?F[3]+this.padding[1][0]+this.padding[1][1]:null,[F[0],F[1],$,V]):($=null!=F[1]&&F[1]>=0?F[1]+this.padding[0][0]+this.padding[0][1]:null,V=null!=F[2]&&F[2]>=0?F[2]+this.padding[1][0]+this.padding[1][1]:null,[F[0],$,V,F[3]])}call(F,$){return(0,G.lub)(()=>spatial2dPadding((0,ee.nQ)(F),this.padding,this.dataFormat))}getConfig(){let F={padding:this.padding,dataFormat:this.dataFormat},$=super.getConfig();return Object.assign(F,$),F}};ZeroPadding2D.className="ZeroPadding2D",G.m7h.registerClass(ZeroPadding2D)},60756:function(F,$,V){"use strict";V.d($,{B1:function(){return MaxPooling1D},CQ:function(){return AveragePooling2D},FG:function(){return GlobalAveragePooling1D},Sc:function(){return MaxPooling3D},e5:function(){return GlobalMaxPooling1D},g8:function(){return AveragePooling1D},rQ:function(){return GlobalAveragePooling2D},ux:function(){return MaxPooling2D},vu:function(){return GlobalMaxPooling2D},xv:function(){return AveragePooling3D}});var G=V(15949),H=V(12012),K=V(39840),Z=V(48090),ee=V(20163),et=V(40588),en=V(26517),ea=V(2931),ei=V(87538),eo=V(75650);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pool2d(F,$,V,K,ee,et){return(0,G.lub)(()=>{let en;(0,Z.cj)(ee),(0,Z.Lp)(et),(0,Z.zb)(K),null==V&&(V=[1,1]),null==K&&(K="valid"),null==ee&&(ee=(0,H.rf)()),null==et&&(et="max"),F=(0,eo.aP)(F,ee);let ea="same"===K?"same":"valid";return en="max"===et?G._sB(F,$,V,ea):G.wS1(F,$,V,ea),"channelsFirst"===ee&&(en=G.p4s(en,[0,3,1,2])),en})}function pool3d(F,$,V,K,ee,et){return(0,G.lub)(()=>{let en;(0,Z.cj)(ee),(0,Z.Lp)(et),(0,Z.zb)(K),null==V&&(V=[1,1,1]),null==K&&(K="valid"),null==ee&&(ee=(0,H.rf)()),null==et&&(et="max"),F=(0,eo.fN)(F,ee);let ea="same"===K?"same":"valid";return en="max"===et?G.YQQ(F,$,V,ea):G.uR5(F,$,V,ea),"channelsFirst"===ee&&(en=G.p4s(en,[0,4,1,2,3])),en})}let Pooling1D=class Pooling1D extends ee.mh{constructor(F){if(null==F.poolSize&&(F.poolSize=2),super(F),"number"==typeof F.poolSize)this.poolSize=[F.poolSize];else if(Array.isArray(F.poolSize)&&1===F.poolSize.length&&"number"==typeof F.poolSize[0])this.poolSize=F.poolSize;else throw new et.nu(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(F.poolSize)}`);if((0,ea.iQ)(this.poolSize,"poolSize"),null==F.strides)this.strides=this.poolSize;else if("number"==typeof F.strides)this.strides=[F.strides];else if(Array.isArray(F.strides)&&1===F.strides.length&&"number"==typeof F.strides[0])this.strides=F.strides;else throw new et.nu(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(F.strides)}`);(0,ea.iQ)(this.strides,"strides"),this.padding=null==F.padding?"valid":F.padding,(0,Z.zb)(this.padding),this.inputSpec=[new ee.Zg({ndim:3})]}computeOutputShape(F){F=(0,ei.Wf)(F);let $=(0,en.kt)(F[1],this.poolSize[0],this.padding,this.strides[0]);return[F[0],$,F[2]]}call(F,$){return(0,G.lub)(()=>{this.invokeCallHook(F,$),F=K.dt((0,ei.nQ)(F),2);let V=this.poolingFunction((0,ei.nQ)(F),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return G.L9e(V,[2])})}getConfig(){let F={poolSize:this.poolSize,padding:this.padding,strides:this.strides},$=super.getConfig();return Object.assign(F,$),F}};let MaxPooling1D=class MaxPooling1D extends Pooling1D{constructor(F){super(F)}poolingFunction(F,$,V,G,H){return(0,Z.cj)(H),(0,Z.zb)(G),pool2d(F,$,V,G,H,"max")}};MaxPooling1D.className="MaxPooling1D",G.m7h.registerClass(MaxPooling1D);let AveragePooling1D=class AveragePooling1D extends Pooling1D{constructor(F){super(F)}poolingFunction(F,$,V,G,H){return(0,Z.cj)(H),(0,Z.zb)(G),pool2d(F,$,V,G,H,"avg")}};AveragePooling1D.className="AveragePooling1D",G.m7h.registerClass(AveragePooling1D);let Pooling2D=class Pooling2D extends ee.mh{constructor(F){if(null==F.poolSize&&(F.poolSize=[2,2]),super(F),this.poolSize=Array.isArray(F.poolSize)?F.poolSize:[F.poolSize,F.poolSize],null==F.strides)this.strides=this.poolSize;else if(Array.isArray(F.strides)){if(2!==F.strides.length)throw new et.nu(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${F.strides.length}.`);this.strides=F.strides}else this.strides=[F.strides,F.strides];(0,ea.iQ)(this.poolSize,"poolSize"),(0,ea.iQ)(this.strides,"strides"),this.padding=null==F.padding?"valid":F.padding,this.dataFormat=null==F.dataFormat?"channelsLast":F.dataFormat,(0,Z.cj)(this.dataFormat),(0,Z.zb)(this.padding),this.inputSpec=[new ee.Zg({ndim:4})]}computeOutputShape(F){F=(0,ei.Wf)(F);let $="channelsFirst"===this.dataFormat?F[2]:F[1],V="channelsFirst"===this.dataFormat?F[3]:F[2];return($=(0,en.kt)($,this.poolSize[0],this.padding,this.strides[0]),V=(0,en.kt)(V,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat)?[F[0],F[1],$,V]:[F[0],$,V,F[3]]}call(F,$){return(0,G.lub)(()=>(this.invokeCallHook(F,$),this.poolingFunction((0,ei.nQ)(F),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let F={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},$=super.getConfig();return Object.assign(F,$),F}};let MaxPooling2D=class MaxPooling2D extends Pooling2D{constructor(F){super(F)}poolingFunction(F,$,V,G,H){return(0,Z.cj)(H),(0,Z.zb)(G),pool2d(F,$,V,G,H,"max")}};MaxPooling2D.className="MaxPooling2D",G.m7h.registerClass(MaxPooling2D);let AveragePooling2D=class AveragePooling2D extends Pooling2D{constructor(F){super(F)}poolingFunction(F,$,V,G,H){return(0,Z.cj)(H),(0,Z.zb)(G),pool2d(F,$,V,G,H,"avg")}};AveragePooling2D.className="AveragePooling2D",G.m7h.registerClass(AveragePooling2D);let Pooling3D=class Pooling3D extends ee.mh{constructor(F){if(null==F.poolSize&&(F.poolSize=[2,2,2]),super(F),this.poolSize=Array.isArray(F.poolSize)?F.poolSize:[F.poolSize,F.poolSize,F.poolSize],null==F.strides)this.strides=this.poolSize;else if(Array.isArray(F.strides)){if(3!==F.strides.length)throw new et.nu(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${F.strides.length}.`);this.strides=F.strides}else this.strides=[F.strides,F.strides,F.strides];(0,ea.iQ)(this.poolSize,"poolSize"),(0,ea.iQ)(this.strides,"strides"),this.padding=null==F.padding?"valid":F.padding,this.dataFormat=null==F.dataFormat?"channelsLast":F.dataFormat,(0,Z.cj)(this.dataFormat),(0,Z.zb)(this.padding),this.inputSpec=[new ee.Zg({ndim:5})]}computeOutputShape(F){F=(0,ei.Wf)(F);let $="channelsFirst"===this.dataFormat?F[2]:F[1],V="channelsFirst"===this.dataFormat?F[3]:F[2],G="channelsFirst"===this.dataFormat?F[4]:F[3];return($=(0,en.kt)($,this.poolSize[0],this.padding,this.strides[0]),V=(0,en.kt)(V,this.poolSize[1],this.padding,this.strides[1]),G=(0,en.kt)(G,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat)?[F[0],F[1],$,V,G]:[F[0],$,V,G,F[4]]}call(F,$){return(0,G.lub)(()=>(this.invokeCallHook(F,$),this.poolingFunction((0,ei.nQ)(F),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let F={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},$=super.getConfig();return Object.assign(F,$),F}};let MaxPooling3D=class MaxPooling3D extends Pooling3D{constructor(F){super(F)}poolingFunction(F,$,V,G,H){return(0,Z.cj)(H),(0,Z.zb)(G),pool3d(F,$,V,G,H,"max")}};MaxPooling3D.className="MaxPooling3D",G.m7h.registerClass(MaxPooling3D);let AveragePooling3D=class AveragePooling3D extends Pooling3D{constructor(F){super(F)}poolingFunction(F,$,V,G,H){return(0,Z.cj)(H),(0,Z.zb)(G),pool3d(F,$,V,G,H,"avg")}};AveragePooling3D.className="AveragePooling3D",G.m7h.registerClass(AveragePooling3D);let GlobalPooling1D=class GlobalPooling1D extends ee.mh{constructor(F){super(F),this.inputSpec=[new ee.Zg({ndim:3})]}computeOutputShape(F){return[F[0],F[2]]}call(F,$){throw new et.nj}};let GlobalAveragePooling1D=class GlobalAveragePooling1D extends GlobalPooling1D{constructor(F){super(F||{})}call(F,$){return(0,G.lub)(()=>{let $=(0,ei.nQ)(F);return G.J69($,1)})}};GlobalAveragePooling1D.className="GlobalAveragePooling1D",G.m7h.registerClass(GlobalAveragePooling1D);let GlobalMaxPooling1D=class GlobalMaxPooling1D extends GlobalPooling1D{constructor(F){super(F||{})}call(F,$){return(0,G.lub)(()=>{let $=(0,ei.nQ)(F);return G.Fp7($,1)})}};GlobalMaxPooling1D.className="GlobalMaxPooling1D",G.m7h.registerClass(GlobalMaxPooling1D);let GlobalPooling2D=class GlobalPooling2D extends ee.mh{constructor(F){super(F),this.dataFormat=null==F.dataFormat?"channelsLast":F.dataFormat,(0,Z.cj)(this.dataFormat),this.inputSpec=[new ee.Zg({ndim:4})]}computeOutputShape(F){return"channelsLast"===this.dataFormat?[F[0],F[3]]:[F[0],F[1]]}call(F,$){throw new et.nj}getConfig(){let F={dataFormat:this.dataFormat},$=super.getConfig();return Object.assign(F,$),F}};let GlobalAveragePooling2D=class GlobalAveragePooling2D extends GlobalPooling2D{call(F,$){return(0,G.lub)(()=>{let $=(0,ei.nQ)(F);return"channelsLast"===this.dataFormat?G.J69($,[1,2]):G.J69($,[2,3])})}};GlobalAveragePooling2D.className="GlobalAveragePooling2D",G.m7h.registerClass(GlobalAveragePooling2D);let GlobalMaxPooling2D=class GlobalMaxPooling2D extends GlobalPooling2D{call(F,$){return(0,G.lub)(()=>{let $=(0,ei.nQ)(F);return"channelsLast"===this.dataFormat?G.Fp7($,[1,2]):G.Fp7($,[2,3])})}};GlobalMaxPooling2D.className="GlobalMaxPooling2D",G.m7h.registerClass(GlobalMaxPooling2D)},90650:function(F,$,V){"use strict";V.d($,{Q:function(){return CategoryEncoding}});var G=V(20163),H=V(15949),K=V(87538),Z=V(40588),ee=V(39840);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function encodeCategoricalInputs(F,$,V,G){let et,en=(0,K.nQ)(F);if("int32"!==en.dtype&&(en=ee.pj(en,"int32")),"int"===$)return en;let ea=en.shape;if(0===en.rank&&(en=(0,H.dt4)(en,-1)),"oneHot"===$&&1!==en.shape[en.shape.length-1]&&(en=(0,H.dt4)(en,-1)),en.rank>2)throw new Z.nu(`When outputMode is not int, maximum output rank is 2 Received outputMode ${$} and input shape ${ea} which would result in output rank ${en.rank}.`);let ei=["multiHot","oneHot"].includes($),eo=en;if(et=void 0!==G&&"count"===$?(0,H.ppE)(eo,G,V,ei):(0,H.ppE)(eo,[],V,ei),"tfIdf"!==$)return et;if(G)return(0,H.dC7)(et,G);throw new Z.nu("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let CategoryEncoding=class CategoryEncoding extends G.mh{constructor(F){super(F),this.numTokens=F.numTokens,F.outputMode?this.outputMode=F.outputMode:this.outputMode="multiHot"}getConfig(){let F={numTokens:this.numTokens,outputMode:this.outputMode},$=super.getConfig();return Object.assign(F,$),F}computeOutputShape(F){return null==(F=(0,K.Wf)(F))?[this.numTokens]:("oneHot"===this.outputMode&&1!==F[F.length-1]?F.push(this.numTokens):F[F.length-1]=this.numTokens,F)}call(F,$){return(0,H.lub)(()=>{let V;if("int32"!==(F=(0,K.nQ)(F)).dtype&&(F=ee.pj(F,"int32")),void 0!==$.countWeights){if("count"!==this.outputMode)throw new Z.nu(`countWeights is not used when outputMode !== count.
              Received countWeights=${$.countWeights}`);V=(0,K.nQ)($.countWeights)}let G=(0,H.Fp7)(F),et=(0,H.VV$)(F),en=(0,H.pjt)(this.numTokens,G).bufferSync().get(0),ea=(0,H.brS)(et,0).bufferSync().get(0);if(!(en&&ea))throw new Z.nu(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return encodeCategoricalInputs(F,this.outputMode,this.numTokens,V)})}};CategoryEncoding.className="CategoryEncoding",H.m7h.registerClass(CategoryEncoding)},770:function(F,$,V){"use strict";V.d($,{d:function(){return CenterCrop}});var G=V(15949),H=V(87538),K=V(20163),Z=V(39840);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let{resizeBilinear:ee,cropAndResize:et}=G.image;let CenterCrop=class CenterCrop extends K.mh{constructor(F){super(F),this.height=F.height,this.width=F.width}centerCrop(F,$,V,K,ee,en,ea,ei){return(0,G.lub)(()=>{let eo;let es=!1,eu=$/en,ec=V/ea,ep=(K+$)/en,eh=(ee+V)/ea,ef=[eu,ec,ep,eh],ed=[];3===F.rank?(es=!0,eo=(0,G.knu)([F])):eo=F;for(let F=0;F<eo.shape[0];F++)ed.push(ef);let em=(0,G.XeE)(ed,[ed.length,4]),eg=(0,G.w6H)(0,ed.length,1,"int32"),ey=[K,ee],eb=et(eo,em,eg,ey,"nearest");return es?Z.pj((0,H.nQ)((0,G.HHK)(eb)),ei):Z.pj(eb,ei)})}upsize(F,$,V,H){return(0,G.lub)(()=>{let G=ee(F,[$,V]);return Z.pj(G,H)})}call(F,$){return(0,G.lub)(()=>{let $=(0,H.nQ)(F),V=$.dtype,G=$.shape,K=G[G.length-3],Z=G[G.length-2],ee=0;K!==this.height&&(ee=Math.floor((K-this.height)/2));let et=0;return(Z!==this.width&&0===(et=Math.floor((Z-this.width)/2))&&(et=1),ee>=0&&et>=0)?this.centerCrop($,ee,et,this.height,this.width,K,Z,V):this.upsize(F,this.height,this.width,V)})}getConfig(){let F={height:this.height,width:this.width},$=super.getConfig();return Object.assign(F,$),F}computeOutputShape(F){F=(0,H.Wf)(F);let $=F.length-3,V=F.length-2;return F[$]=this.height,F[V]=this.width,F}};CenterCrop.className="CenterCrop",G.m7h.registerClass(CenterCrop)},98710:function(F,$,V){"use strict";V.d($,{L:function(){return Rescaling}});var G=V(20163),H=V(15949),K=V(87538),Z=V(39840);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Rescaling=class Rescaling extends G.mh{constructor(F){super(F),this.scale=F.scale,F.offset?this.offset=F.offset:this.offset=0}getConfig(){let F={scale:this.scale,offset:this.offset},$=super.getConfig();return Object.assign(F,$),F}call(F,$){return(0,H.lub)(()=>("float32"!==(F=(0,K.nQ)(F)).dtype&&(F=Z.pj(F,"float32")),(0,H.IHx)((0,H.dC7)(F,this.scale),this.offset)))}};Rescaling.className="Rescaling",H.m7h.registerClass(Rescaling)},36184:function(F,$,V){"use strict";V.d($,{D:function(){return Resizing}});var G=V(15949),H=V(20163),K=V(40588),Z=V(87538);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ee=["bilinear","nearest"],et=new Set(ee);let Resizing=class Resizing extends H.mh{constructor(F){if(super(F),this.height=F.height,this.width=F.width,F.interpolation){if(et.has(F.interpolation))this.interpolation=F.interpolation;else throw new K.nu(`Invalid interpolation parameter: ${F.interpolation} is not implemented`)}else this.interpolation="bilinear";this.cropToAspectRatio=!!F.cropToAspectRatio}computeOutputShape(F){F=(0,Z.Wf)(F);let $=F[2];return[this.height,this.width,$]}getConfig(){let F={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},$=super.getConfig();return Object.assign(F,$),F}call(F,$){return(0,G.lub)(()=>{let $=[this.height,this.width];if("bilinear"===this.interpolation)return G.image.resizeBilinear(F,$,!this.cropToAspectRatio);if("nearest"===this.interpolation)return G.image.resizeNearestNeighbor(F,$,!this.cropToAspectRatio);throw Error(`Interpolation is ${this.interpolation} but only ${[...et]} are supported`)})}};Resizing.className="Resizing",G.m7h.registerClass(Resizing)},14906:function(F,$,V){"use strict";V.d($,{z:function(){return RandomWidth}});var G=V(15949),H=V(87538),K=V(40588),Z=V(20163);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let RandomSeed=class RandomSeed{constructor(F){this.seed=F}next(){if(void 0!==this.seed)return this.seed++}};RandomSeed.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let BaseRandomLayer=class BaseRandomLayer extends Z.mh{constructor(F){super(F),this.randomGenerator=new RandomSeed(F.seed)}getConfig(){let F={seed:this.randomGenerator.seed},$=super.getConfig();return Object.assign(F,$),F}};BaseRandomLayer.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ee=["bilinear","nearest"],et=new Set(ee);let RandomWidth=class RandomWidth extends BaseRandomLayer{constructor(F){super(F);let{factor:$,interpolation:V="bilinear"}=F;if(this.factor=$,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new K.nu(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new K.nu(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new K.nu(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(V){if(et.has(V))this.interpolation=V;else throw new K.nu(`Invalid interpolation parameter: ${V} is not implemented`)}}getConfig(){let F={factor:this.factor,interpolation:this.interpolation},$=super.getConfig();return Object.assign(F,$),F}computeOutputShape(F){F=(0,H.Wf)(F);let $=F[2];return[this.imgHeight,-1,$]}call(F,$){return(0,G.lub)(()=>{let $=(0,H.nQ)(F);this.imgHeight=$.shape[$.shape.length-3];let V=$.shape[$.shape.length-2];this.widthFactor=(0,G.LGj)([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let K=this.widthFactor.dataSync()[0]*V;K=Math.round(K);let Z=[this.imgHeight,K];switch(this.interpolation){case"bilinear":return G.image.resizeBilinear(F,Z);case"nearest":return G.image.resizeNearestNeighbor(F,Z);default:throw Error(`Interpolation is ${this.interpolation}
          but only ${[...et]} are supported`)}})}};RandomWidth.className="RandomWidth",G.m7h.registerClass(RandomWidth)},49897:function(F,$,V){"use strict";V.d($,{v:function(){return deserialize}});var G=V(15949),H=V(2931);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function deserialize(F,$={},V=!1){return(0,H.tU)(F,G.m7h.SerializationMap.getMap().classNameMap,$,"layer",V)}},18012:function(F,$,V){"use strict";V.d($,{V9:function(){return TimeDistributed},j8:function(){return Bidirectional}});var G=V(15949),H=V(39840),K=V(48090),Z=V(20163),ee=V(40588),et=V(44685),en=V(2931),ea=V(87538),ei=V(76014),eo=V(49897);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Wrapper=class Wrapper extends Z.mh{constructor(F){super(F),this.layer=F.layer}build(F){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(F){null!=this.layer&&(this.layer.trainable=F)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(F){this.layer.setWeights(F)}getConfig(){let F={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},$=super.getConfig();return Object.assign(F,$),F}setFastWeightInitDuringBuild(F){super.setFastWeightInitDuringBuild(F),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(F)}static fromConfig(F,$,V={}){let G=$.layer,H=(0,eo.v)(G,V);delete $.layer;let K={layer:H};return Object.assign(K,$),new F(K)}};let TimeDistributed=class TimeDistributed extends Wrapper{constructor(F){super(F),this.supportsMasking=!0}build(F){if((F=(0,ea.Wf)(F)).length<3)throw new ee.nu(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(F)}`);this.inputSpec=[{shape:F}];let $=[F[0]].concat(F.slice(2));this.layer.built||(this.layer.build($),this.layer.built=!0),super.build(F)}computeOutputShape(F){F=(0,ea.Wf)(F);let $=[F[0]].concat(F.slice(2)),V=this.layer.computeOutputShape($),G=F[1];return[V[0],G].concat(V.slice(1))}call(F,$){return(0,G.lub)(()=>{F=(0,ea.nQ)(F);let step=(F,V)=>{let G=(0,ea.nQ)(this.layer.call(F,$));return[G,[]]},V=(0,ei.nd)(step,F,[],!1,null,null,!1,!0),G=V[1];return G})}};function checkBidirectionalMergeMode(F){en.xn(et.eY,"BidirectionalMergeMode",F)}TimeDistributed.className="TimeDistributed",G.m7h.registerClass(TimeDistributed);let es="concat";let Bidirectional=class Bidirectional extends Wrapper{constructor(F){super(F);let $=F.layer.getConfig(),V={};V.className=F.layer.getClassName(),V.config=$,this.forwardLayer=(0,eo.v)(V),$.goBackwards=!0!==$.goBackwards;let G={};if(G.className=F.layer.getClassName(),G.config=$,this.backwardLayer=(0,eo.v)(G),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===F.mergeMode?es:F.mergeMode,checkBidirectionalMergeMode(this.mergeMode),F.weights)throw new ee.nj("weights support is not implemented for Bidirectional layer yet.");this._stateful=F.layer.stateful,this.returnSequences=F.layer.returnSequences,this.returnState=F.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=F.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(F){this._trainable=F,null!=this.forwardLayer&&(this.forwardLayer.trainable=F),null!=this.backwardLayer&&(this.backwardLayer.trainable=F)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(F){let $=F.length,V=Math.floor($/2);this.forwardLayer.setWeights(F.slice(0,V)),this.backwardLayer.setWeights(F.slice(V))}computeOutputShape(F){let $,V,G,H=this.forwardLayer.computeOutputShape(F);return(Array.isArray(H)&&Array.isArray(H[0])||(H=[H]),this.returnState&&(G=H.slice(1)),$=H[0],"concat"===this.mergeMode?($[$.length-1]*=2,V=[$]):V=null==this.mergeMode?[$,$.slice()]:[$],this.returnState)?null==this.mergeMode?V.concat(G).concat(G.slice()):[$].concat(G).concat(G.slice()):en.Bq(V)}apply(F,$){let V=null==$?null:$.initialState,G=null==$?null:$.constants;null==$&&($={});let H=(0,ei.lx)(F,V,G,this.numConstants);if(F=H.inputs,V=H.initialState,G=H.constants,Array.isArray(F)&&(V=F.slice(1),F=F[0]),(null==V||0===V.length)&&null==G)return super.apply(F,$);let K=[],et=[];if(null!=V){let F=V.length;if(F%2>0)throw new ee.nu("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");$.initialState=V,K.push(...V);let G=V.map(F=>new Z.Zg({shape:F.shape}));this.forwardLayer.stateSpec=G.slice(0,F/2),this.backwardLayer.stateSpec=G.slice(F/2),et.push(...G)}if(null!=G)throw new ee.nj("Support for constants in Bidirectional layers is not implemented yet.");let en=K[0]instanceof Z.Iy;for(let F of K)if(F instanceof Z.Iy!==en)throw new ee.nu("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(!en)return super.apply(F,$);{let V=[F].concat(K),G=this.inputSpec.concat(et),H=this.inputSpec;this.inputSpec=G;let Z=super.apply(V,$);return this.inputSpec=H,Z}}call(F,$){return(0,G.lub)(()=>{let V,K,Z,ee;let et=$.initialState;if(null==et)V=this.forwardLayer.call(F,$),K=this.backwardLayer.call(F,$);else{let G=et.slice(0,et.length/2),H=et.slice(et.length/2);V=this.forwardLayer.call(F,Object.assign($,{initialState:G})),K=this.backwardLayer.call(F,Object.assign($,{initialState:H}))}return(this.returnState&&(Array.isArray(V)&&(Z=V.slice(1).concat(K.slice(1))),V=V[0],K=K[0]),this.returnSequences&&(K=G.GYS(K,1)),"concat"===this.mergeMode?ee=H.mV([V,K]):"sum"===this.mergeMode?ee=G.IHx(V,K):"ave"===this.mergeMode?ee=G.dC7(.5,G.IHx(V,K)):"mul"===this.mergeMode?ee=G.dC7(V,K):null==this.mergeMode&&(ee=[V,K]),this.returnState)?null==this.mergeMode?ee.concat(Z):[ee].concat(Z):ee})}resetStates(F){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(F){(0,K.f4)(this.forwardLayer.name,()=>{this.forwardLayer.build(F)}),(0,K.f4)(this.backwardLayer.name,()=>{this.backwardLayer.build(F)}),this.built=!0}computeMask(F,$){let V;if(Array.isArray($)&&($=$[0]),V=this.returnSequences?null==this.mergeMode?[$,$]:$:null==this.mergeMode?[null,null]:null,!this.returnState)return V;{let F=this.forwardLayer.states,$=F.map(F=>null);return Array.isArray(V)?V.concat($).concat($):[V].concat($).concat($)}}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(F){super.setFastWeightInitDuringBuild(F),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(F),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(F)}getConfig(){let F={mergeMode:this.mergeMode},$=super.getConfig();return Object.assign(F,$),F}static fromConfig(F,$){let V=(0,eo.v)($.layer);if(delete $.layer,null!=$.numConstants)throw new ee.nj("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let G=$;return G.layer=V,new F(G)}};Bidirectional.className="Bidirectional",G.m7h.registerClass(Bidirectional)},73146:function(F,$,V){"use strict";V.d($,{Z:function(){return resolveScalarsInLogs},i:function(){return disposeTensorsInLogs}});var G=V(15949);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function resolveScalarsInLogs(F){if(null==F)return;let $=[],V=[],H=[];for(let G in F){let K=F[G];if("number"!=typeof K){let F=K;$.push(F.data()),V.push(G),H.push(F)}}if($.length>0){let K=await Promise.all($);for(let $=0;$<K.length;++$)F[V[$]]=K[$][0];(0,G.B90)(H)}}function disposeTensorsInLogs(F){if(null!=F)for(let $ in F){let V=F[$];"number"!=typeof V&&V.dispose()}}},86275:function(F,$,V){"use strict";V.d($,{Eq:function(){return l2Normalize},FD:function(){return meanSquaredError},KM:function(){return sparseCategoricalCrossentropy},Ls:function(){return cosineProximity},U2:function(){return get},dr:function(){return ee},fO:function(){return binaryCrossentropy},ke:function(){return meanAbsoluteError},t3:function(){return meanAbsolutePercentageError},uq:function(){return categoricalCrossentropy}});var G=V(15949),H=V(12012),K=V(39840),Z=V(40588);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function l2Normalize(F,$){return(0,G.lub)(()=>{"float32"!==F.dtype&&(F=G.pju(F,"float32"));let V=G.Smz(K.h6(F),$,!0),Z=G.hlL(V.shape,(0,H.Ho)()),ee=G._b3(G.gWQ(V,Z));return G.hiC(F,ee)})}function meanSquaredError(F,$){return(0,G.lub)(()=>G.J69(K.h6(G.luU($,F)),-1))}function meanAbsoluteError(F,$){return(0,G.lub)(()=>G.J69(G.WnP(G.luU($,F)),-1))}function meanAbsolutePercentageError(F,$){return(0,G.lub)(()=>{let V=G.luU(F,$),K=G.iUl(G.WnP(F),(0,H.Ho)(),Number.MAX_VALUE),Z=G.WnP(G.hiC(V,K));return G.dC7(100,G.J69(Z,-1))})}function meanSquaredLogarithmicError(F,$){return(0,G.lub)(()=>{let V=G.iUl($,(0,H.Ho)(),Number.MAX_VALUE),Z=G.cM7(G.IHx(1,V)),ee=G.iUl(F,(0,H.Ho)(),Number.MAX_VALUE),et=G.cM7(G.IHx(1,ee));return G.J69(K.h6(G.luU(Z,et)),-1)})}function squaredHinge(F,$){return(0,G.lub)(()=>{let V=G.gWQ(0,G.luU(1,G.dC7(F,$)));return G.J69(K.h6(V),-1)})}function hinge(F,$){return(0,G.lub)(()=>{let V=G.gWQ(0,G.luU(1,G.dC7(F,$)));return G.J69(V,-1)})}function categoricalHinge(F,$){return(0,G.lub)(()=>{let V=G.Smz(G.dC7(F,$),-1),H=G.Fp7(G.dC7(G.luU(1,F),$),-1);return G.gWQ(0,G.IHx(1,G.luU(H,V)))})}function logcosh(F,$){return(0,G.lub)(()=>{let V=Math.log(2),H=G.luU($,F),K=G.luU(G.IHx(H,G.Wvh(G.dC7(-2,H))),V);return G.J69(K,-1)})}function categoricalCrossentropy(F,$,V=!1){return(0,G.lub)(()=>{if(V)$=G.XAC($);else{let F=G.Smz($,$.shape.length-1,!0);$=G.hiC($,F)}return $=G.iUl($,(0,H.Ho)(),1-(0,H.Ho)()),G.W76(G.Smz(G.dC7(G.pju(F,"float32"),G.cM7($)),$.shape.length-1))})}function sparseCategoricalCrossentropy(F,$,V=!1){return(0,G.lub)(()=>{let Z=G.pju(G.GWj(K.xH(F)),"int32");$=G.iUl($,(0,H.Ho)(),1-(0,H.Ho)());let ee=$.shape,et=G.XLQ(G.lfX(Z,ee[ee.length-1]),ee);return categoricalCrossentropy(et,$,V)})}function sigmoidCrossEntropyWithLogits(F,$){if(!G.D5U.arraysEqual(F.shape,$.shape))throw new Z.nu(`logits and labels must have the same shape, but got shapes ${JSON.stringify(F.shape)} and ${JSON.stringify($.shape)}`);return(0,G.lub)(()=>{let V=G.UYe($),H=G.W76(G.WnP($));return G.IHx(G.luU(V,G.dC7($,F)),G.Krr(G.Qqt(H)))})}function binaryCrossentropy(F,$){return(0,G.lub)(()=>{let V;return V=G.iUl($,(0,H.Ho)(),1-(0,H.Ho)()),V=G.cM7(G.hiC(V,G.luU(1,V))),G.J69(sigmoidCrossEntropyWithLogits(F,V),-1)})}function kullbackLeiblerDivergence(F,$){return(0,G.lub)(()=>{let V=G.iUl(F,(0,H.Ho)(),1),K=G.iUl($,(0,H.Ho)(),1);return G.Smz(G.dC7(F,G.cM7(G.hiC(V,K))),-1)})}function poisson(F,$){return(0,G.lub)(()=>{let V=G.cM7(G.IHx((0,H.Ho)(),$));return G.J69(G.luU($,G.dC7(F,V)),-1)})}function cosineProximity(F,$){return(0,G.lub)(()=>{let V=l2Normalize(F,-1),H=l2Normalize($,-1),K=G.dC7(V,H);return G.W76(G.Smz(K,-1))})}let ee={meanSquaredError,meanAbsoluteError,meanAbsolutePercentageError,meanSquaredLogarithmicError,squaredHinge,hinge,categoricalHinge,logcosh,categoricalCrossentropy,sparseCategoricalCrossentropy,binaryCrossentropy,kullbackLeiblerDivergence,poisson,cosineProximity};function get(F){if("string"!=typeof F)return F;{if(F in ee)return ee[F];let $=`Unknown loss ${F}`;throw F.toLowerCase().includes("softmaxcrossentropy")&&($=`Unknown loss ${F}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Z.nu($)}}},38678:function(F,$,V){"use strict";V.d($,{G5:function(){return categoricalAccuracy},KM:function(){return ep},TY:function(){return sparseCategoricalAccuracy},U2:function(){return get},_F:function(){return binaryAccuracy},aI:function(){return getLossOrMetricName},ch:function(){return precision},fO:function(){return binaryCrossentropy},uq:function(){return eu},wC:function(){return recall}});var G=V(15949),H=V(39840),K=V(40588),Z=V(86275),ee=V(2931);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function binaryAccuracy(F,$){return(0,G.lub)(()=>{let V=G.dC7(.5,G.JpU($)),K=H.pj(G.pjt($,V),F.dtype);return G.J69(G.DgJ(F,K),-1)})}function categoricalAccuracy(F,$){return(0,G.lub)(()=>H.pj(G.DgJ(G.NqF(F,-1),G.NqF($,-1)),"float32"))}function truePositives(F,$){return(0,G.lub)(()=>G.pju(G.Smz(G.HvI(G.DgJ(F,1),G.DgJ($,1))),"float32"))}function falseNegatives(F,$){return(0,G.lub)(()=>G.pju(G.Smz(G.HvI(G.DgJ(F,1),G.DgJ($,0))),"float32"))}function falsePositives(F,$){return(0,G.lub)(()=>G.pju(G.Smz(G.HvI(G.DgJ(F,0),G.DgJ($,1))),"float32"))}function precision(F,$){return(0,G.lub)(()=>{let V=truePositives(F,$),H=falsePositives(F,$),K=G.IHx(V,H);return G.pju(G.arb(G.pjt(K,0),G.hiC(V,K),0),"float32")})}function recall(F,$){return(0,G.lub)(()=>{let V=truePositives(F,$),H=falseNegatives(F,$),K=G.IHx(V,H);return G.pju(G.arb(G.pjt(K,0),G.hiC(V,K),0),"float32")})}function binaryCrossentropy(F,$){return(0,Z.fO)(F,$)}function sparseCategoricalAccuracy(F,$){return F.rank===$.rank&&(F=G.L9e(F,[F.rank-1])),($=G.NqF($,-1)).dtype!==F.dtype&&($=G.pju($,F.dtype)),G.pju(G.DgJ(F,$),"float32")}let et=Z.FD,en=Z.FD,ea=Z.ke,ei=Z.ke,eo=Z.t3,es=Z.t3,eu=Z.uq,ec=Z.Ls,ep=Z.KM,eh={binaryAccuracy,categoricalAccuracy,precision,categoricalCrossentropy:eu,sparseCategoricalCrossentropy:ep,mse:et,MSE:en,mae:ea,MAE:ei,mape:eo,MAPE:es,cosine:ec};function get(F){if("string"==typeof F&&F in eh)return eh[F];if("string"!=typeof F&&null!=F)return F;throw new K.nu(`Unknown metric ${F}`)}function getLossOrMetricName(F){if(ee.hu(null!==F,`Unknown LossOrMetricFn ${F}`),"string"==typeof F)return F;{let $;for(let V of Object.keys(Z.dr))if(Z.dr[V]===F){$=V;break}if(void 0!==$)return $;for(let V of Object.keys(eh))if(eh[V]===F){$=V;break}return void 0!==$?$:F.name}}},83066:function(F,$,V){"use strict";V.d($,{FB:function(){return loadLayersModel},p5:function(){return modelFromJSON},sb:function(){return Sequential}});var G=V(15949),H=V(79608),K=V(34396),Z=V(20163),ee=V(85337),et=V(40588),en=V(49897),ea=V(2931),ei=V(51977),eo=V(87538);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function modelFromJSON(F,$){"modelTopology"in F||(F={modelTopology:F});let V=F.modelTopology;null!=V.model_config&&(V=V.model_config);let H=(0,ei.a)(V),K=(0,en.v)(H,$);if(null!=F.weightsManifest){let $=await G.io.loadWeights(F.weightsManifest,F.pathPrefix,K.weights.map(F=>F.originalName)),V={};for(let F of K.weights)V[F.originalName]=$[F.originalName];K.loadWeights(V),(0,G.B90)($)}return K}async function loadLayersModel(F,$){if(null==$&&($={}),"string"==typeof F){let V=G.io.getLoadHandlers(F,$);if(0===V.length)V.push(G.io.browserHTTPRequest(F,$));else if(V.length>1)throw new et.nu(`Found more than one (${V.length}) load handlers for URL '${F}'`);F=V[0]}return loadLayersModelFromIOHandler(F,void 0,$)}async function loadLayersModelFromIOHandler(F,$,V){if(null==V&&(V={}),null==F.load)throw new et.nu("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let H=await F.load(),K=H.modelTopology;null!=K.model_config&&(K=K.model_config);let Z=null==V.strict||V.strict,ee=null!=H.weightData&&null!=H.weightSpecs&&Z,ea=(0,en.v)((0,ei.a)(K),$,ee),eo=H.trainingConfig;if(null!=eo&&ea.loadTrainingConfig(eo),null!=H.userDefinedMetadata&&ea.setUserDefinedMetadata(H.userDefinedMetadata),null!=H.weightData){if(null==H.weightSpecs)throw new et.nu("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:F,optimizerWeights:$}=decodeModelAndOptimizerWeights(H.weightData,H.weightSpecs);ea.loadWeights(F,Z),null!=ea.optimizer&&$.length>0&&await ea.optimizer.setWeights($),(0,G.B90)(F),(0,G.B90)($.map(F=>F.tensor))}return ea}function decodeModelAndOptimizerWeights(F,$){let V=G.io.decodeWeights(F,$),H={},K=[];return $.forEach(F=>{"optimizer"===F.group?K.push({name:F.name,tensor:V[F.name]}):H[F.name]=V[F.name]}),{modelWeights:H,optimizerWeights:K}}let Sequential=class Sequential extends ee.QV{constructor(F){if(super({inputs:[],outputs:[]}),F=F||{},this.trainable=!0,this.built=!1,this.name=null!=F.name?F.name:(0,H.s)("sequential_"),null!=F.layers)for(let $ of F.layers)this.add($)}checkShape(F){let $=F.inboundNodes[0].outputTensors[0].shape;if($.some(F=>F<0))throw new et.nu(`Negative dimension size caused by adding layer ${F.name} with input shape [${F.inboundNodes[0].inputTensors[0].shape}]`)}add(F){let $;let V=F instanceof Sequential||F instanceof ee.QV;if(V){if(1!==($=F).outputs.length)throw new et.nu("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==$.inputs.length)throw new et.nu("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===F.inboundNodes.length){if(null==F.batchInputShape)throw new et.nu("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let $=(0,K.I)({batchShape:F.batchInputShape,dtype:F.dtype,name:F.name+"_input"});F.apply($)}if(V)this.outputs=$.outputs,this.inputs=$.inputs;else{if(1!==F.inboundNodes.length)throw new et.nu(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${F.name} which has ${F.inboundNodes.length} pre-existing inbound connections.`);if(1!==F.inboundNodes[0].outputTensors.length)throw new et.nu("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(F),this.outputs=[F.inboundNodes[0].outputTensors[0]],this.inputs=(0,Z.hA)(this.outputs[0])}this.inboundNodes=[],new Z.NB({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ea.JE(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(F=>F.shape),outputShapes:this.outputs[0].shape})}else{let $=F.apply(this.outputs[0]);if(Array.isArray($))throw TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(F),this.outputs=[$],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(F),this.built=!1}pop(){if(0===this.layers.length)throw TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let F=this.layers.length-1;this.layers[F].outboundNodes=[],this.outputs=[this.layers[F].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(F,$){return null==this.model&&this.build(),this.model.call(F,$)}build(F){if((0,eo.Wf)(F),0===this.inputs.length||0===this.outputs.length)throw TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ee.QV({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(F,$,V=console.log){this.built||this.build(),super.summary(F,$,V)}setWeights(F){null==this.model&&this.build(),this.model.setWeights(F)}evaluate(F,$,V={}){if(!this.built)throw new et.LH("The model needs to be compiled before being used.");return this.model.evaluate(F,$,V)}async evaluateDataset(F,$){if(!this.built)throw new et.LH("The model needs to be compiled before being used.");return this.model.evaluateDataset(F,$)}predict(F,$={}){return null==this.model&&this.build(),this.model.predict(F,$)}predictOnBatch(F){return null==this.model&&this.build(),this.model.predictOnBatch(F)}compile(F){this.build(),this.model.compile(F),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(F){this.model.optimizer=F}async fit(F,$,V={}){if(!this.built)throw new et.LH("The model needs to be compiled before being used.");return this.model.fit(F,$,V)}async fitDataset(F,$){if(!this.built)throw new et.LH("The model needs to be compiled before being used.");return this.model.fitDataset(F,$)}async trainOnBatch(F,$){return this.model.trainOnBatch(F,$)}static fromConfig(F,$,V={},H=!1){let K;let Z={};if($ instanceof Array){if(!(null!=$[0].className)||"Merge"===$[0].className)throw new et.nu("Legacy serialization format not supported yet.");K=$}else G.D5U.assert(null!=$.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),K=$.layers,delete $.layers,Z=$;let ee=new F(Z);if(!(ee instanceof Sequential))throw new et.nj(`Sequential.fromConfig called on non-Sequential input: ${ee}`);for(let F of K){let $=void 0,V=(0,en.v)(F,$,H);H&&V.setFastWeightInitDuringBuild(!0),ee.add(V)}return ee}set stopTraining(F){if(null==this.model)throw new et.nu("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=F}get stopTraining(){if(null==this.model)throw new et.nu("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let F=[];for(let $ of this.layers){let V={};V.className=$.getClassName(),V.config=$.getConfig(),F.push(V)}return{name:this.name,layers:F}}};Sequential.className="Sequential",G.m7h.registerClass(Sequential)},92328:function(F,$,V){"use strict";V.d($,{j:function(){return getOptimizer}});var G=V(15949),H=V(12012),K=V(40588);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function getOptimizer(F){let $={Adagrad:()=>G.p_j.adagrad(.01),Adadelta:()=>G.p_j.adadelta(1,.95,(0,H.Ho)()),Adam:()=>G.p_j.adam(.001,.9,.999,(0,H.Ho)()),Adamax:()=>G.p_j.adamax(.002,.9,.999,(0,H.Ho)(),0),RMSProp:()=>G.p_j.rmsprop(.001,.9,0,(0,H.Ho)()),SGD:()=>G.p_j.sgd(.01)};if($.adagrad=$.Adagrad,$.adadelta=$.Adadelta,$.adam=$.Adam,$.adamax=$.Adamax,$.rmsprop=$.RMSProp,$.sgd=$.SGD,F in $)return $[F]();throw new K.nu(`Unknown Optimizer ${F}`)}},10539:function(F,$,V){"use strict";V.d($,{EC:function(){return getRegularizer},SG:function(){return serializeRegularizer},Xm:function(){return L1L2},l1:function(){return l1},l2:function(){return l2}});var G=V(15949),H=V(39840),K=V(2931);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function assertObjectArgs(F){if(null!=F&&"object"!=typeof F)throw Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${F}`)}let Regularizer=class Regularizer extends G.m7h.Serializable{};let L1L2=class L1L2 extends Regularizer{constructor(F){super(),assertObjectArgs(F),this.l1=null==F||null==F.l1?.01:F.l1,this.l2=null==F||null==F.l2?.01:F.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(F){return(0,G.lub)(()=>{let $=(0,G.lls)([1]);return this.hasL1&&($=(0,G.IHx)($,(0,G.Smz)(G.dC7(this.l1,(0,G.WnP)(F))))),this.hasL2&&($=(0,G.IHx)($,(0,G.Smz)(G.dC7(this.l2,H.h6(F))))),G.XLQ($,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(F,$){return new F({l1:$.l1,l2:$.l2})}};function l1(F){return assertObjectArgs(F),new L1L2({l1:null!=F?F.l1:null,l2:0})}function l2(F){return assertObjectArgs(F),new L1L2({l2:null!=F?F.l2:null,l1:0})}L1L2.className="L1L2",G.m7h.registerClass(L1L2);let Z={l1l2:"L1L2"};function serializeRegularizer(F){return(0,K.Kj)(F)}function deserializeRegularizer(F,$={}){return(0,K.tU)(F,G.m7h.SerializationMap.getMap().classNameMap,$,"regularizer")}function getRegularizer(F){if(null==F)return null;if("string"==typeof F){let $=F in Z?Z[F]:F,V={className:$,config:{}};return deserializeRegularizer(V)}return F instanceof Regularizer?F:deserializeRegularizer(F)}},38374:function(F,$,V){"use strict";V.d($,{WE:function(){return checkUserDefinedMetadata}});/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let G=1048576;function checkUserDefinedMetadata(F,$,V=!1){if(null==F||"object"!=typeof F||Object.getPrototypeOf(F)!==Object.prototype||!plainObjectCheck(F))throw Error("User-defined metadata is expected to be a JSON object, but is not.");if(V){let V=JSON.stringify(F);V.length>G&&console.warn(`User-defined metadata of model "${$}" is too large in size (length=${V.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${G}.`)}}function plainObjectCheck(F){if(null===F)return!0;if("object"==typeof F){if(Object.getPrototypeOf(F)===Object.prototype){let $=Object.keys(F);for(let V of $)if("string"!=typeof V||!plainObjectCheck(F[V]))return!1;return!0}if(!Array.isArray(F))return!1;for(let $ of F)if(!plainObjectCheck($))return!1;return!0}{let $=typeof F;return"string"===$||"number"===$||"boolean"===$}}},26517:function(F,$,V){"use strict";V.d($,{$U:function(){return deconvLength},AF:function(){return normalizeArray},kt:function(){return convOutputLength}});var G=V(40588),H=V(2931),K=V(96040);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function normalizeArray(F,$,V){if("number"==typeof F)return(0,H.JE)(F,$);if(F.length!==$)throw new G.nu(`The ${V} argument must be an integer or tuple of ${$} integers. Received: ${F.length} elements.`);for(let H=0;H<$;++H){let Z=F[H];if(!(0,K.U)(Z))throw new G.nu(`The ${V} argument must be an integer or tuple of ${$} integers. Received: ${JSON.stringify(F)} including a non-integer number ${Z}`)}return F}function convOutputLength(F,$,V,G,H=1){let K;if(null==F)return F;let Z=$+($-1)*(H-1);return Math.floor(((K="same"===V?F:F-Z+1)+G-1)/G)}function deconvLength(F,$,V,H){if(null==F)return null;if("valid"===H)F=F*$+(0,K.Fp)([V-$,0]);else if("same"===H)F*=$;else throw new G.nu(`Unsupport padding mode: ${H}.`);return F}},2931:function(F,$,V){"use strict";V.d($,{Bq:function(){return singletonOrArray},D1:function(){return toSnakeCase},Ds:function(){return debounce},JE:function(){return pyListRepeat},Kj:function(){return serializeKerasObject},L7:function(){return reverseNumberCompare},Mx:function(){return checkArrayTypeAndLength},QX:function(){return count},Tw:function(){return unique},WT:function(){return mapActivationToFusedKernel},hu:function(){return assert},iQ:function(){return assertPositiveInteger},nK:function(){return isObjectEmpty},tU:function(){return deserializeKerasObject},xn:function(){return checkStringTypeUnionValue},zW:function(){return toCamelCase},zZ:function(){return toList}});var G=V(15949),H=V(40588);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pyListRepeat(F,$){if(Array.isArray(F)){let V=[];for(let G=0;G<$;G++)V=V.concat(F);return V}{let V=Array($);return V.fill(F),V}}function assert(F,$){if(!F)throw new H.ps($)}function count(F,$){let V=0;for(let G of F)G===$&&V++;return V}function singletonOrArray(F){return 1===F.length?F[0]:F}function toList(F){return Array.isArray(F)?F:[F]}function toSnakeCase(F){let $=F.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2"),V=$.replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==V[0]?V:"private"+V}function toCamelCase(F){return F.length<=1||-1===F.indexOf("_")?F:F.replace(/[_]+(\w|$)/g,(F,$)=>$.toUpperCase())}let K={};function serializeKerasObject(F){if(null==F)return null;let $={};return $.className=F.getClassName(),$.config=F.getConfig(),$}function convertNDArrayScalarsInConfig(F){if(null!=F&&"object"==typeof F){if(Array.isArray(F))F.forEach(F=>convertNDArrayScalarsInConfig(F));else{let $=Object.keys(F);for(let V of $){let $=F[V];null!=$&&"object"==typeof $&&(Array.isArray($)||"ndarray"!==$.type||"number"!=typeof $.value?convertNDArrayScalarsInConfig($):F[V]=$.value)}}}}function deserializeKerasObject(F,$={},V={},G="object",Z=!1){if("string"==typeof F){let Z;let ee=F;if(ee in V)Z=V[ee];else if(ee in K)Z=K[ee];else if(null==(Z=$[ee]))throw new H.nu(`Unknown ${G}: ${F}. This may be due to one of the following reasons:
1. The ${G} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${G} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return Z}{let ee,et;let en=F;if(null==en.className||null==en.config)throw new H.nu(`${G}: Improper config format: ${JSON.stringify(en)}.
'className' and 'config' must set.`);let ea=en.className;if(ea in V?[ee,et]=V[ea]:ea in K?[ee,et]=K.className:ea in $&&([ee,et]=$[ea]),null==ee)throw new H.nu(`Unknown ${G}: ${ea}. This may be due to one of the following reasons:
1. The ${G} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${G} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=et){let F={};for(let $ of Object.keys(K))F[$]=K[$];for(let $ of Object.keys(V))F[$]=V[$];let $=en.config;$.customObjects=F;let G=Object.assign({},K);for(let F of Object.keys(V))K[F]=V[F];convertNDArrayScalarsInConfig(en.config);let H=et(ee,en.config,V,Z);return K=Object.assign({},G),H}{let F=Object.assign({},K);for(let F of Object.keys(V))K[F]=V[F];let $=new ee(en.config);return K=Object.assign({},F),$}}}function numberCompare(F,$){return F<$?-1:F>$?1:0}function reverseNumberCompare(F,$){return -1*numberCompare(F,$)}function unique(F){if(null==F)return F;let $=[];for(let V of F)-1===$.indexOf(V)&&$.push(V);return $}function isObjectEmpty(F){if(null==F)throw new H.nu(`Invalid value in obj: ${JSON.stringify(F)}`);for(let $ in F)if(F.hasOwnProperty($))return!1;return!0}function checkStringTypeUnionValue(F,$,V){if(null!=V&&0>F.indexOf(V))throw new H.nu(`${V} is not a valid ${$}.  Valid values are ${F} or null/undefined.`)}function checkArrayTypeAndLength(F,$,V=0,G=1/0){return assert(V>=0),assert(G>=V),Array.isArray(F)&&F.length>=V&&F.length<=G&&F.every(F=>typeof F===$)}function assertPositiveInteger(F,$){Array.isArray(F)?(G.D5U.assert(F.length>0,()=>`${$} is unexpectedly an empty array.`),F.forEach((F,V)=>assertPositiveInteger(F,`element ${V+1} of ${$}`))):G.D5U.assert(Number.isInteger(F)&&F>0,()=>`Expected ${$} to be a positive integer, but got ${formatAsFriendlyString(F)}.`)}function formatAsFriendlyString(F){return null===F?"null":Array.isArray(F)?"["+F.map(F=>formatAsFriendlyString(F)).join(",")+"]":"string"==typeof F?`"${F}"`:`${F}`}function debounce(F,$,V){let H,K=null!=V?V():G.D5U.now(),f2=(...Z)=>{let ee=null!=V?V():G.D5U.now();return ee-K<$?H:(K=ee,H=F(...Z))};return f2}function mapActivationToFusedKernel(F){return"relu"===F?"relu":"linear"===F?"linear":"elu"===F?"elu":null}},30618:function(F,$,V){"use strict";V.d($,{I:function(){return printSummary}});var G=V(23013);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function printSummary(F,$,V,H=console.log){let K;let Z=isModelSequentialLike(F),ee=["Layer (type)","Input Shape","Output shape","Param #"];if(Z?($=$||90,V=V||[.32,.61,.89,1]):($=$||115,V=V||[.24,.48,.7,.8,1]),V[V.length-1]<=1&&(V=V.map(F=>Math.floor($*F))),!Z)for(let $ in ee.push("Receives inputs"),K=[],F.nodesByDepth)K.push(...F.nodesByDepth[$]);H("_".repeat($)),printRow(ee,V,H),H("=".repeat($));let et=F.layers;for(let F=0;F<et.length;++F)Z?printLayerSummary(et[F],V,H):printLayerSummaryWithConnections(et[F],V,K,H),H((F===et.length-1?"=":"_").repeat($));F.checkTrainableWeightsConsistency();let en=countTrainableParams(F),ea=(0,G.t)(F.nonTrainableWeights);H(`Total params: ${en+ea}`),H(`Trainable params: ${en}`),H(`Non-trainable params: ${ea}`),H("_".repeat($))}function countTrainableParams(F){return null!=F.collectedTrainableWeights?(0,G.t)(F.collectedTrainableWeights):(0,G.t)(F.trainableWeights)}function isModelSequentialLike(F){let $=!0,V=[],G=[];for(let $ in F.nodesByDepth)V.push(F.nodesByDepth[$]);for(let F of V){if(F.length>1||1===F.length&&F[0].inboundLayers.length>1){$=!1;break}G.push(...F)}if($)for(let V of F.layers){let F=!1;for(let H of V.inboundNodes)if(-1!==G.indexOf(H)){if(F){$=!1;break}F=!0}if(!$)break}return $}function printRow(F,$,V=console.log){let G="";for(let V=0;V<F.length;++V)V>0&&(G=G.slice(0,G.length-1)+" "),G+=F[V],G=G.slice(0,$[V]),G+=" ".repeat($[V]-G.length);V(G)}function printLayerSummary(F,$,V){let G,H;try{H=F.inboundNodes.map(F=>JSON.stringify(F.inputShapes)).join(",")}catch(F){H="multiple"}try{G=JSON.stringify(F.outputShape)}catch(F){G="multiple"}let K=F.name,Z=F.getClassName(),ee=[`${K} (${Z})`,H,G,F.countParams().toString()];printRow(ee,$,V)}function printLayerSummaryWithConnections(F,$,V,G){let H,K;try{K=F.inboundNodes.map(F=>JSON.stringify(F.inputShapes)).join(",")}catch(F){K="multiple"}try{H=JSON.stringify(F.outputShape)}catch(F){H="multiple"}let Z=[];for(let $ of F.inboundNodes)if(null==V||!(V.length>0)||-1!==V.indexOf($))for(let F=0;F<$.inboundLayers.length;++F){let V=$.inboundLayers[F].name,G=$.nodeIndices[F],H=$.tensorIndices[F];Z.push(`${V}[${G}][${H}]`)}let ee=F.name,et=F.getClassName(),en=0===Z.length?"":Z[0],ea=[`${ee} (${et})`,K,H,F.countParams().toString(),en];printRow(ea,$,G);for(let F=1;F<Z.length;++F)printRow(["","","","",Z[F]],$,G)}},96040:function(F,$,V){"use strict";V.d($,{Fp:function(){return max},NS:function(){return arrayProd},U:function(){return isInteger},VV:function(){return min},w6:function(){return range}});var G=V(40588);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function isInteger(F){return F===parseInt(F.toString(),10)}function arrayProd(F,$,V){null==$&&($=0),null==V&&(V=F.length);let G=1;for(let H=$;H<V;++H)G*=F[H];return G}function min(F){if(0===F.length)return Number.NaN;let $=Number.POSITIVE_INFINITY;for(let V=0;V<F.length;V++){let G=F[V];G<$&&($=G)}return $}function max(F){if(0===F.length)return Number.NaN;let $=Number.NEGATIVE_INFINITY;for(let V=0;V<F.length;V++){let G=F[V];G>$&&($=G)}return $}function range(F,$){if($<F)throw new G.nu(`end (${$}) < begin (${F}) is forbidden.`);let V=[];for(let G=F;G<$;++G)V.push(G);return V}},51977:function(F,$,V){"use strict";V.d($,{a:function(){return convertPythonicToTs},q:function(){return convertTsToPythonic}});var G=V(2931);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function isArrayItemInputOrOutputName(F,$,V){return("inboundNodes"===F||"outputLayers"===F||"inputLayers"===F)&&0===$&&"string"==typeof V}function convertPythonicToTs(F,$){if(null===F)return null;if("string"==typeof F)return G.zW(F);if("number"==typeof F||"boolean"==typeof F)return F;if(F instanceof Array){let V=[],G=F.length;for(let H=0;H<G;++H){let G=F[H];isArrayItemInputOrOutputName($,H,G)?V.push(G):V.push(convertPythonicToTs(G,$))}return V}{let $={};for(let V of Object.keys(F)){let H=F[V];if("name"===V&&"string"==typeof H)$[V]=H;else{let F=G.zW(V);$[F]=convertPythonicToTs(H,F)}}return $}}function convertTsToPythonic(F,$){if(null==F)return null;if("string"==typeof F)return G.D1(F);if("number"==typeof F||"boolean"==typeof F)return F;if(F instanceof Array){let V=[],G=F.length;for(let H=0;H<G;++H){let G=F[H];isArrayItemInputOrOutputName($,H,G)?V.push(G):V.push(convertTsToPythonic(G,$))}return V}{let $={};for(let V of Object.keys(F)){let H=F[V],K=G.D1(V);("name"===V||"className"===V)&&"string"==typeof H?$[K]=H:$[K]=convertTsToPythonic(H,V)}return $}}},87538:function(F,$,V){"use strict";V.d($,{Wf:function(){return getExactlyOneShape},XO:function(){return isArrayOfShapes},nQ:function(){return getExactlyOneTensor},x6:function(){return normalizeShapeList}});var G=V(40588);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function isArrayOfShapes(F){return Array.isArray(F)&&Array.isArray(F[0])}function normalizeShapeList(F){return 0===F.length?[]:Array.isArray(F[0])?F:[F]}function getExactlyOneTensor(F){let $;if(Array.isArray(F)){if(1!==F.length)throw new G.nu(`Expected Tensor length to be 1; got ${F.length}`);$=F[0]}else $=F;return $}function getExactlyOneShape(F){if(!(Array.isArray(F)&&Array.isArray(F[0])))return F;if(1===F.length)return F[0];throw new G.nu(`Expected exactly 1 Shape; got ${F.length}`)}},23013:function(F,$,V){"use strict";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function countParamsInWeights(F){let $=0;for(let V of F)0===V.shape.length?$+=1:$+=V.shape.reduce((F,$)=>F*$);return $}V.d($,{t:function(){return countParamsInWeights}})},41653:function(F,$,V){"use strict";V.d($,{FQ:function(){return batchGetValue},fU:function(){return LayerVariable},zb:function(){return batchSetValue}});var G=V(15949),H=V(79608),K=V(48090);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Z="Variable";let LayerVariable=class LayerVariable{constructor(F,$="float32",V=Z,ee=!0,et=null){this.dtype=null==$?"float32":$,this.shape=F.shape,this.id=(0,H.L)(),V=null==V?Z:V,this.originalName=(0,K.MU)(V),this.name=(0,K.w8)(this.originalName),this.trainable_=ee,this.constraint=et,this.val=G.VD$(F,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(F){return this.assertNotDisposed(),checkShapesMatch(this.val,F),this.val.id!==F.id&&(this.val.assign(F),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(F){this.trainable_=F,this.val.trainable=F}};function checkShapesMatch(F,$){if(F.shape.toString()!==$.shape.toString())throw Error("Shape mismatch: "+JSON.stringify(F.shape)+" vs. "+JSON.stringify($.shape))}function batchGetValue(F){return F.map(F=>F.read())}function batchSetValue(F){F.forEach(F=>{let $=F[0];$.write(F[1])})}},77385:function(F,$,V){"use strict";V.d($,{i:function(){return G}});/** @license See the LICENSE file. */let G="4.15.0"},18323:function(F,$,V){"use strict";let G;V.r($),V.d($,{Abs:function(){return eD.SYM},Acos:function(){return eD.VGw},Acosh:function(){return eD.SpW},AdadeltaOptimizer:function(){return eD.zJI},AdagradOptimizer:function(){return eD.HeW},AdamOptimizer:function(){return eD.a4z},AdamaxOptimizer:function(){return eD.DBS},Add:function(){return eD.mm_},AddN:function(){return eD.Xze},All:function(){return eD.oT6},Any:function(){return eD.IKK},ArgMax:function(){return eD.sJF},ArgMin:function(){return eD.aJk},Asin:function(){return eD.M2y},Asinh:function(){return eD.qw7},Atan:function(){return eD.jMg},Atan2:function(){return eD.QCc},Atanh:function(){return eD.Oyi},AvgPool:function(){return eD.JhU},AvgPool3D:function(){return eD._k9},AvgPool3DGrad:function(){return eD.IMb},AvgPoolGrad:function(){return eD.ROF},BatchMatMul:function(){return eD.XLW},BatchToSpaceND:function(){return eD.zws},Bincount:function(){return eD.zvY},BitwiseAnd:function(){return eD.hCO},BroadcastArgs:function(){return eD.eEB},BroadcastTo:function(){return eD.Ly9},Callback:function(){return Callback},CallbackList:function(){return iw.BO},Cast:function(){return eD.RFZ},Ceil:function(){return eD.gJX},ClipByValue:function(){return eD.xnO},Complex:function(){return eD.Zz9},ComplexAbs:function(){return eD.yj2},Concat:function(){return eD.Eh3},Conv2D:function(){return eD.mhS},Conv2DBackpropFilter:function(){return eD.wUP},Conv2DBackpropInput:function(){return eD.wm},Conv3D:function(){return eD.x12},Conv3DBackpropFilterV2:function(){return eD.o2y},Conv3DBackpropInputV2:function(){return eD.ik2},Cos:function(){return eD.mc4},Cosh:function(){return eD.TR1},CropAndResize:function(){return eD.VcC},Cumprod:function(){return eD.Byc},Cumsum:function(){return eD.iHb},CustomCallback:function(){return iw.iT},DataStorage:function(){return eD.JLz},DenseBincount:function(){return eD.QRR},DepthToSpace:function(){return eD.T0n},DepthwiseConv2dNative:function(){return eD.cie},DepthwiseConv2dNativeBackpropFilter:function(){return eD.sL$},DepthwiseConv2dNativeBackpropInput:function(){return eD.y7R},Diag:function(){return eD.$w},Dilation2D:function(){return eD.p4S},Dilation2DBackpropFilter:function(){return eD.Vn9},Dilation2DBackpropInput:function(){return eD.ekb},Draw:function(){return eD.hGc},ENV:function(){return eD.ViN},EarlyStopping:function(){return EarlyStopping},Einsum:function(){return eD.$g6},Elu:function(){return eD.SX0},EluGrad:function(){return eD.HEU},Environment:function(){return eD.qAh},Equal:function(){return eD.hdR},Erf:function(){return eD.Omj},Exp:function(){return eD.NEP},ExpandDims:function(){return eD.YFo},Expm1:function(){return eD.Y0y},FFT:function(){return eD.vwp},Fill:function(){return eD.deh},FlipLeftRight:function(){return eD.Uyb},Floor:function(){return eD.OR},FloorDiv:function(){return eD.jeX},FromPixels:function(){return eD.eBW},FusedBatchNorm:function(){return eD.sHE},FusedConv2D:function(){return eD._V0},FusedDepthwiseConv2D:function(){return eD.luS},GPGPUContext:function(){return cB.A},GatherNd:function(){return eD.q1x},GatherV2:function(){return eD.qi_},GraphModel:function(){return GraphModel},Greater:function(){return eD.iZT},GreaterEqual:function(){return eD.Acj},History:function(){return iw.Ay},IFFT:function(){return eD.Qg5},Identity:function(){return eD.iJz},Imag:function(){return eD.J_u},InputSpec:function(){return iT.Zg},IsFinite:function(){return eD.avt},IsInf:function(){return eD.iWB},IsNan:function(){return eD.r7n},KernelBackend:function(){return eD.Zuw},LRN:function(){return eD.eZ0},LRNGrad:function(){return eD.Hhh},LayerVariable:function(){return iA.fU},LayersModel:function(){return iS.QV},LeakyRelu:function(){return eD.J$2},Less:function(){return eD.vtC},LessEqual:function(){return eD.CAk},LinSpace:function(){return eD.e7N},Log:function(){return eD.ZbH},Log1p:function(){return eD.kU},LogSoftmax:function(){return eD.qCd},LogicalAnd:function(){return eD.PYm},LogicalNot:function(){return eD.VfG},LogicalOr:function(){return eD.MZg},LogicalXor:function(){return eD.w6g},LowerBound:function(){return eD.qIC},MathBackendCPU:function(){return MathBackendCPU},MathBackendWebGL:function(){return cM.QC},MatrixBandPart:function(){return eD.J7O},Max:function(){return eD.YoZ},MaxPool:function(){return eD.mTV},MaxPool3D:function(){return eD.OAf},MaxPool3DGrad:function(){return eD.OU7},MaxPoolGrad:function(){return eD.OV7},MaxPoolWithArgmax:function(){return eD.vFR},Maximum:function(){return eD.BMI},Mean:function(){return eD.q2K},Min:function(){return eD.c17},Minimum:function(){return eD.q8u},MirrorPad:function(){return eD.jQs},Mod:function(){return eD.Vbg},MomentumOptimizer:function(){return eD.rIn},Multinomial:function(){return eD.NZg},Multiply:function(){return eD.wYn},Neg:function(){return eD.kuV},NonMaxSuppressionV3:function(){return eD.uv1},NonMaxSuppressionV4:function(){return eD.cye},NonMaxSuppressionV5:function(){return eD.W0H},NotEqual:function(){return eD.yQU},OP_SCOPE_SUFFIX:function(){return eD.zvA},OneHot:function(){return eD.we_},OnesLike:function(){return eD.qWM},Optimizer:function(){return eD.gaJ},OptimizerConstructors:function(){return eD.eEe},Pack:function(){return eD.QiL},PadV2:function(){return eD.lyA},Pool:function(){return eD.Kgp},Pow:function(){return eD.pe_},Prelu:function(){return eD.o0g},Prod:function(){return eD.DlI},RMSPropOptimizer:function(){return eD.gVI},RNN:function(){return iE.$p},RaggedGather:function(){return eD.dDz},RaggedRange:function(){return eD.CQl},RaggedTensorToTensor:function(){return eD.BiW},Range:function(){return eD.e6w},Rank:function(){return eD.yw1},Real:function(){return eD.xJR},RealDiv:function(){return eD.oHH},Reciprocal:function(){return eD.$HU},Reduction:function(){return eD.IH3},Relu:function(){return eD.qkr},Relu6:function(){return eD.SbG},Reshape:function(){return eD.HZH},ResizeBilinear:function(){return eD._Yw},ResizeBilinearGrad:function(){return eD.zbQ},ResizeNearestNeighbor:function(){return eD.dpD},ResizeNearestNeighborGrad:function(){return eD.Hmb},Reverse:function(){return eD.mKl},RotateWithOffset:function(){return eD.b9H},Round:function(){return eD.e07},Rsqrt:function(){return eD.bV0},SGDOptimizer:function(){return eD.DYp},ScatterNd:function(){return eD.xQA},SearchSorted:function(){return eD.nr8},Select:function(){return eD.PhF},Selu:function(){return eD.oFR},Sequential:function(){return ix.sb},Sigmoid:function(){return eD.a5O},Sign:function(){return eD.i5y},Sin:function(){return eD.RQH},Sinh:function(){return eD.wYB},Slice:function(){return eD.p2w},Softmax:function(){return eD.Gcp},Softplus:function(){return eD.MRv},SpaceToBatchND:function(){return eD.TQc},SparseFillEmptyRows:function(){return eD.O3z},SparseReshape:function(){return eD.nhH},SparseSegmentMean:function(){return eD.w3H},SparseSegmentSum:function(){return eD.ZjV},SparseToDense:function(){return eD.D2d},SplitV:function(){return eD.L8s},Sqrt:function(){return eD.FKq},Square:function(){return eD.bK0},SquaredDifference:function(){return eD._tC},StaticRegexReplace:function(){return eD.e0R},Step:function(){return eD.h8e},StridedSlice:function(){return eD.jQk},StringNGrams:function(){return eD._JP},StringSplit:function(){return eD.s1s},StringToHashBucketFast:function(){return eD.XkS},Sub:function(){return eD.Tr8},Sum:function(){return eD.GBy},SymbolicTensor:function(){return iT.Iy},Tan:function(){return eD.sEM},Tanh:function(){return eD.MIZ},Tensor:function(){return eD.esB},TensorBuffer:function(){return eD.YDk},TensorScatterUpdate:function(){return eD.SIB},Tile:function(){return eD.n9L},TopK:function(){return eD.cWu},Transform:function(){return eD.wx7},Transpose:function(){return eD.G3Y},Unique:function(){return eD.kpP},Unpack:function(){return eD.ToN},UnsortedSegmentSum:function(){return eD.Qvg},UpperBound:function(){return eD.XDQ},Variable:function(){return eD._wD},ZerosLike:function(){return eD.RuY},_FusedMatMul:function(){return eD.usg},abs:function(){return eD.WnP},acos:function(){return eD.Khb},acosh:function(){return eD.__u},add:function(){return eD.IHx},addN:function(){return eD.QBD},all:function(){return eD.$6P},any:function(){return eD.YjB},argMax:function(){return eD.NqF},argMin:function(){return eD.vHJ},asin:function(){return eD.ZRM},asinh:function(){return eD.VfV},atan:function(){return eD.z4N},atan2:function(){return eD.fvJ},atanh:function(){return eD.C80},avgPool:function(){return eD.wS1},avgPool3d:function(){return eD.uR5},backend:function(){return eD.y3$},backend_util:function(){return eD.backend_util},basicLSTMCell:function(){return eD.zEQ},batchNorm:function(){return eD.tgs},batchNorm2d:function(){return eD.Dxk},batchNorm3d:function(){return eD.JY5},batchNorm4d:function(){return eD.p3b},batchToSpaceND:function(){return eD.E4h},bincount:function(){return eD.yE8},bitwiseAnd:function(){return eD.ycw},booleanMaskAsync:function(){return eD.anm},broadcastArgs:function(){return eD.XsQ},broadcastTo:function(){return eD.UFq},broadcast_util:function(){return eD.Jyw},browser:function(){return eD.Xhn},buffer:function(){return eD.f3b},callbacks:function(){return iI},cast:function(){return eD.pju},ceil:function(){return eD.mDi},clipByValue:function(){return eD.iUl},clone:function(){return eD.d9v},complex:function(){return eD.PYB},concat:function(){return eD.zoF},concat1d:function(){return eD.gME},concat2d:function(){return eD.Izb},concat3d:function(){return eD.MNy},concat4d:function(){return eD.ZaL},constraints:function(){return et},conv1d:function(){return eD.PAt},conv2d:function(){return eD.Tek},conv2dTranspose:function(){return eD.bc},conv3d:function(){return eD.pdZ},conv3dTranspose:function(){return eD.$QV},copyRegisteredKernels:function(){return eD.T3b},cos:function(){return eD.mCk},cosh:function(){return eD.f9Y},cosineWindow:function(){return eD.mew},cumprod:function(){return eD.$Gn},cumsum:function(){return eD.zbp},customGrad:function(){return eD.cbc},data:function(){return eA},denseBincount:function(){return eD.ppE},deprecationWarn:function(){return eD.MXe},depthToSpace:function(){return eD.nTT},depthwiseConv2d:function(){return eD.B10},deregisterOp:function(){return deregisterOp},device_util:function(){return eD.C2$},diag:function(){return eD.Ka3},dilation2d:function(){return eD.WmZ},disableDeprecationWarnings:function(){return eD.cFr},dispose:function(){return eD.B90},disposeVariables:function(){return eD.N8o},div:function(){return eD.hiC},divNoNan:function(){return eD.NTj},dot:function(){return eD.AKD},dropout:function(){return eD.rvX},einsum:function(){return eD.WYO},elu:function(){return eD.pyx},enableDebugMode:function(){return eD.Ra$},enableProdMode:function(){return eD.G48},enclosingPowerOfTwo:function(){return eD.GRh},engine:function(){return eD.SRH},ensureShape:function(){return eD.EDe},env:function(){return eD.OBj},equal:function(){return eD.DgJ},erf:function(){return eD.qNN},euclideanNorm:function(){return eD.d2q},exp:function(){return eD.Qqt},expandDims:function(){return eD.dt4},expm1:function(){return eD.t$B},eye:function(){return eD.iyy},fft:function(){return eD.kp_},fill:function(){return eD.hlL},findBackend:function(){return eD.x3e},findBackendFactory:function(){return eD.zel},floor:function(){return eD.GWj},floorDiv:function(){return eD.qPi},forceHalfFloat:function(){return forceHalfFloat},fused:function(){return eD.imm},gather:function(){return eD.Iqj},gatherND:function(){return eD.dbB},gather_util:function(){return eD.DaI},getBackend:function(){return eD.N_N},getGradient:function(){return eD.ukX},getKernel:function(){return eD.pIF},getKernelsForBackend:function(){return eD.trD},gpgpu_util:function(){return cF},grad:function(){return eD.UQy},grads:function(){return eD.tiA},greater:function(){return eD.pjt},greaterEqual:function(){return eD.brS},ifft:function(){return eD.Sxn},imag:function(){return eD.asL},image:function(){return eD.image},inTopKAsync:function(){return eD.V3u},initializers:function(){return en},input:function(){return iC.qH},io:function(){return eD.io},irfft:function(){return eD.wx0},isFinite:function(){return eD.xVT},isInf:function(){return eD.UWc},isNaN:function(){return eD.i2d},keep:function(){return eD.CnY},kernel_impls:function(){return eD.GDt},layers:function(){return ih},leakyRelu:function(){return eD.hi7},less:function(){return eD.d9m},lessEqual:function(){return eD.zN1},linalg:function(){return eD.$r2},linspace:function(){return eD.SX3},loadGraphModel:function(){return loadGraphModel},loadGraphModelSync:function(){return loadGraphModelSync},loadLayersModel:function(){return iC.FB},localResponseNormalization:function(){return eD.G9k},log:function(){return eD.cM7},log1p:function(){return eD.Krr},logSigmoid:function(){return eD.e_t},logSoftmax:function(){return eD.CmS},logSumExp:function(){return eD.l_t},logicalAnd:function(){return eD.HvI},logicalNot:function(){return eD.hJK},logicalOr:function(){return eD.K5V},logicalXor:function(){return eD.egP},losses:function(){return eD.MB5},lowerBound:function(){return eD.eab},matMul:function(){return eD.OI3},math:function(){return eD.mAU},max:function(){return eD.Fp7},maxPool:function(){return eD._sB},maxPool3d:function(){return eD.YQQ},maxPoolWithArgmax:function(){return eD.Ip$},maximum:function(){return eD.gWQ},mean:function(){return eD.J69},memory:function(){return eD.sq6},meshgrid:function(){return eD.ry_},metrics:function(){return ea},min:function(){return eD.VV$},minimum:function(){return eD.LTh},mirrorPad:function(){return eD.VdP},mod:function(){return eD.wQq},model:function(){return iC.o4},models:function(){return ei},moments:function(){return eD.Gi7},movingAverage:function(){return eD.p_},mul:function(){return eD.dC7},multiRNNCell:function(){return eD.rq4},multinomial:function(){return eD.SJ_},neg:function(){return eD.W76},nextFrame:function(){return eD.glt},norm:function(){return eD.KOy},notEqual:function(){return eD.Quu},oneHot:function(){return eD.lfX},ones:function(){return eD.iUs},onesLike:function(){return eD.JpU},op:function(){return eD.op},outerProduct:function(){return eD.N2O},pad:function(){return eD.vku},pad1d:function(){return eD.pNR},pad2d:function(){return eD.koy},pad3d:function(){return eD.t1L},pad4d:function(){return eD.lGY},pool:function(){return eD.d_R},pow:function(){return eD.sQ3},prelu:function(){return eD.AL3},print:function(){return eD.S0v},prod:function(){return eD.WVs},profile:function(){return eD.N5s},raggedGather:function(){return eD.$gW},raggedRange:function(){return eD.VT$},raggedTensorToTensor:function(){return eD.N89},rand:function(){return eD.TN_},randomGamma:function(){return eD.wzB},randomNormal:function(){return eD.nGf},randomStandardNormal:function(){return eD.ruB},randomUniform:function(){return eD.LGj},randomUniformInt:function(){return eD.pe5},range:function(){return eD.w6H},ready:function(){return eD.Cd_},real:function(){return eD.kwC},reciprocal:function(){return eD.M25},registerBackend:function(){return eD.jqO},registerCallbackConstructor:function(){return iC.gl},registerGradient:function(){return eD.LiG},registerKernel:function(){return eD.wCN},registerOp:function(){return registerOp},regularizers:function(){return eo},relu:function(){return eD.UYe},relu6:function(){return eD.btT},removeBackend:function(){return eD.cjG},reshape:function(){return eD.XLQ},reverse:function(){return eD.GYS},reverse1d:function(){return eD.SDf},reverse2d:function(){return eD.diP},reverse3d:function(){return eD.sx7},reverse4d:function(){return eD.mG2},rfft:function(){return eD.QEs},round:function(){return eD.NMM},rsqrt:function(){return eD.bp0},scalar:function(){return eD.iD$},scatterND:function(){return eD.snQ},scatter_util:function(){return eD.yV1},searchSorted:function(){return eD.zcT},selu:function(){return eD.U8D},separableConv2d:function(){return eD.U_I},sequential:function(){return iC.Pe},serialization:function(){return eD.m7h},setBackend:function(){return eD.CQI},setPlatform:function(){return eD.VYu},setWebGLContext:function(){return cP.nd},setdiff1dAsync:function(){return eD.ODp},shared:function(){return of},sigmoid:function(){return eD.XD2},sign:function(){return eD.Xxe},signal:function(){return eD.tdS},sin:function(){return eD.O$l},sinh:function(){return eD.R_K},slice:function(){return eD.tPi},slice1d:function(){return eD.jZU},slice2d:function(){return eD.SmN},slice3d:function(){return eD.CnO},slice4d:function(){return eD.p0P},slice_util:function(){return eD.kuN},softmax:function(){return eD.XAC},softplus:function(){return eD.Wvh},spaceToBatchND:function(){return eD.fBT},sparse:function(){return eD.rVs},sparseToDense:function(){return eD.ers},spectral:function(){return eD.uN7},split:function(){return eD.Vl2},sqrt:function(){return eD._b3},square:function(){return eD.h62},squaredDifference:function(){return eD.$i},squeeze:function(){return eD.L9e},stack:function(){return eD.knu},step:function(){return eD.Nbs},stridedSlice:function(){return eD.NXj},string:function(){return eD.Z_8},sub:function(){return eD.luU},sum:function(){return eD.Smz},sumOutType:function(){return eD.z4k},tan:function(){return eD.ORZ},tanh:function(){return eD.AEp},tensor:function(){return eD.XeE},tensor1d:function(){return eD.RRF},tensor2d:function(){return eD.odF},tensor3d:function(){return eD.wOQ},tensor4d:function(){return eD.yXz},tensor5d:function(){return eD.Bfx},tensor6d:function(){return eD.xZs},tensorScatterUpdate:function(){return eD.Pg0},tensor_util:function(){return eD.piX},test_util:function(){return eD.p3L},tidy:function(){return eD.lub},tile:function(){return eD.Gg6},time:function(){return eD.XVJ},topk:function(){return eD.hg7},train:function(){return eD.p_j},transpose:function(){return eD.p4s},truncatedNormal:function(){return eD.Xu6},unique:function(){return eD.Two},unregisterGradient:function(){return eD.bt3},unregisterKernel:function(){return eD.nEe},unsortedSegmentSum:function(){return eD.pUJ},unstack:function(){return eD.HHK},upcastType:function(){return eD.x8V},upperBound:function(){return eD.GaM},util:function(){return eD.D5U},valueAndGrad:function(){return eD.h76},valueAndGrads:function(){return eD.fNQ},variable:function(){return eD.VD$},variableGrads:function(){return eD.pnJ},version:function(){return g$},version_converter:function(){return i7},version_core:function(){return eD.jTM},version_cpu:function(){return od},version_layers:function(){return iD.i},version_webgl:function(){return cR},webgl:function(){return c$},webgl_util:function(){return cO},where:function(){return eD.arb},whereAsync:function(){return eD.itS},zeros:function(){return eD.lls},zerosLike:function(){return eD.P84}});var H,K,Z,ee,et={};V.r(et),V.d(et,{maxNorm:function(){return maxNorm},minMaxNorm:function(){return minMaxNorm},nonNeg:function(){return nonNeg},unitNorm:function(){return unitNorm}});var en={};V.r(en),V.d(en,{constant:function(){return constant},glorotNormal:function(){return glorotNormal},glorotUniform:function(){return glorotUniform},heNormal:function(){return heNormal},heUniform:function(){return heUniform},identity:function(){return identity},leCunNormal:function(){return leCunNormal},leCunUniform:function(){return leCunUniform},ones:function(){return exports_initializers_ones},orthogonal:function(){return orthogonal},randomNormal:function(){return randomNormal},randomUniform:function(){return randomUniform},truncatedNormal:function(){return truncatedNormal},varianceScaling:function(){return varianceScaling},zeros:function(){return exports_initializers_zeros}});var ea={};V.r(ea),V.d(ea,{MAPE:function(){return MAPE},MSE:function(){return MSE},binaryAccuracy:function(){return binaryAccuracy},binaryCrossentropy:function(){return binaryCrossentropy},categoricalAccuracy:function(){return categoricalAccuracy},categoricalCrossentropy:function(){return categoricalCrossentropy},cosineProximity:function(){return cosineProximity},mape:function(){return mape},meanAbsoluteError:function(){return meanAbsoluteError},meanAbsolutePercentageError:function(){return meanAbsolutePercentageError},meanSquaredError:function(){return meanSquaredError},mse:function(){return mse},precision:function(){return precision},recall:function(){return recall},sparseCategoricalAccuracy:function(){return sparseCategoricalAccuracy}});var ei={};V.r(ei),V.d(ei,{modelFromJSON:function(){return ix.p5}});var eo={};V.r(eo),V.d(eo,{l1:function(){return l1},l1l2:function(){return l1l2},l2:function(){return l2}});var es={};V.r(es),V.d(es,{json:function(){return iF}});var eu={};V.r(eu),V.d(eu,{json:function(){return iO}});var ec={};V.r(ec),V.d(ec,{json:function(){return iP}});var ep={};V.r(ep),V.d(ep,{json:function(){return iB}});var eh={};V.r(eh),V.d(eh,{json:function(){return i$}});var ef={};V.r(ef),V.d(ef,{json:function(){return iL}});var ed={};V.r(ed),V.d(ed,{json:function(){return iz}});var em={};V.r(em),V.d(em,{json:function(){return iV}});var eg={};V.r(eg),V.d(eg,{json:function(){return iU}});var ey={};V.r(ey),V.d(ey,{json:function(){return iW}});var eb={};V.r(eb),V.d(eb,{json:function(){return iG}});var ew={};V.r(ew),V.d(ew,{json:function(){return iq}});var eS={};V.r(eS),V.d(eS,{json:function(){return iH}});var e_={};V.r(e_),V.d(e_,{json:function(){return iX}});var eN={};V.r(eN),V.d(eN,{json:function(){return iK}});var ek={};V.r(ek),V.d(ek,{json:function(){return iQ}});var eI={};V.r(eI),V.d(eI,{json:function(){return iZ}});var eT={};V.r(eT),V.d(eT,{json:function(){return iY}});var eC={};V.r(eC),V.d(eC,{json:function(){return iJ}});var eE={};V.r(eE),V.d(eE,{OP_SCOPE_SUFFIX:function(){return i2.zvA},abs:function(){return i2.WnP},acos:function(){return i2.Khb},acosh:function(){return i2.__u},add:function(){return i2.IHx},addN:function(){return i2.QBD},all:function(){return i2.$6P},any:function(){return i2.YjB},argMax:function(){return i2.NqF},argMin:function(){return i2.vHJ},asin:function(){return i2.ZRM},asinh:function(){return i2.VfV},atan:function(){return i2.z4N},atan2:function(){return i2.fvJ},atanh:function(){return i2.C80},avgPool:function(){return i2.wS1},avgPool3d:function(){return i2.uR5},basicLSTMCell:function(){return i2.zEQ},batchNorm:function(){return i2.tgs},batchNorm2d:function(){return i2.Dxk},batchNorm3d:function(){return i2.JY5},batchNorm4d:function(){return i2.p3b},batchToSpaceND:function(){return i2.E4h},bincount:function(){return i2.yE8},bitwiseAnd:function(){return i2.ycw},booleanMaskAsync:function(){return i2.anm},broadcastArgs:function(){return i2.XsQ},broadcastTo:function(){return i2.UFq},buffer:function(){return i2.f3b},cast:function(){return i2.pju},ceil:function(){return i2.mDi},clipByValue:function(){return i2.iUl},clone:function(){return i2.d9v},complex:function(){return i2.PYB},concat:function(){return i2.zoF},concat1d:function(){return i2.gME},concat2d:function(){return i2.Izb},concat3d:function(){return i2.MNy},concat4d:function(){return i2.ZaL},conv1d:function(){return i2.PAt},conv2d:function(){return i2.Tek},conv2dTranspose:function(){return i2.bc},conv3d:function(){return i2.pdZ},conv3dTranspose:function(){return i2.$QV},cos:function(){return i2.mCk},cosh:function(){return i2.f9Y},cosineWindow:function(){return i2.mew},cumprod:function(){return i2.$Gn},cumsum:function(){return i2.zbp},denseBincount:function(){return i2.ppE},depthToSpace:function(){return i2.nTT},depthwiseConv2d:function(){return i2.B10},diag:function(){return i2.Ka3},dilation2d:function(){return i2.WmZ},div:function(){return i2.hiC},divNoNan:function(){return i2.NTj},dot:function(){return i2.AKD},dropout:function(){return i2.rvX},einsum:function(){return i2.WYO},elu:function(){return i2.pyx},enclosingPowerOfTwo:function(){return i2.GRh},ensureShape:function(){return i2.EDe},equal:function(){return i2.DgJ},erf:function(){return i2.qNN},euclideanNorm:function(){return i2.d2q},exp:function(){return i2.Qqt},expandDims:function(){return i2.dt4},expm1:function(){return i2.t$B},eye:function(){return i2.iyy},fft:function(){return i2.kp_},fill:function(){return i2.hlL},floor:function(){return i2.GWj},floorDiv:function(){return i2.qPi},fused:function(){return i2.imm},gather:function(){return i2.Iqj},gatherND:function(){return i2.dbB},greater:function(){return i2.pjt},greaterEqual:function(){return i2.brS},ifft:function(){return i2.Sxn},imag:function(){return i2.asL},image:function(){return i2.BHj},inTopKAsync:function(){return i2.V3u},irfft:function(){return i2.wx0},isFinite:function(){return i2.xVT},isInf:function(){return i2.UWc},isNaN:function(){return i2.i2d},leakyRelu:function(){return i2.hi7},less:function(){return i2.d9m},lessEqual:function(){return i2.zN1},linalg:function(){return i2.$r2},linspace:function(){return i2.SX3},localResponseNormalization:function(){return i2.G9k},log:function(){return i2.cM7},log1p:function(){return i2.Krr},logSigmoid:function(){return i2.e_t},logSoftmax:function(){return i2.CmS},logSumExp:function(){return i2.l_t},logicalAnd:function(){return i2.HvI},logicalNot:function(){return i2.hJK},logicalOr:function(){return i2.K5V},logicalXor:function(){return i2.egP},losses:function(){return i2.MB5},lowerBound:function(){return i2.eab},matMul:function(){return i2.OI3},max:function(){return i2.Fp7},maxPool:function(){return i2._sB},maxPool3d:function(){return i2.YQQ},maxPoolWithArgmax:function(){return i2.Ip$},maximum:function(){return i2.gWQ},mean:function(){return i2.J69},meshgrid:function(){return i2.ry_},min:function(){return i2.VV$},minimum:function(){return i2.LTh},mirrorPad:function(){return i2.VdP},mod:function(){return i2.wQq},moments:function(){return i2.Gi7},movingAverage:function(){return i2.p_},mul:function(){return i2.dC7},multiRNNCell:function(){return i2.rq4},multinomial:function(){return i2.SJ_},neg:function(){return i2.W76},norm:function(){return i2.KOy},notEqual:function(){return i2.Quu},oneHot:function(){return i2.lfX},ones:function(){return i2.iUs},onesLike:function(){return i2.JpU},op:function(){return i2.op},outerProduct:function(){return i2.N2O},pad:function(){return i2.vku},pad1d:function(){return i2.pNR},pad2d:function(){return i2.koy},pad3d:function(){return i2.t1L},pad4d:function(){return i2.lGY},pool:function(){return i2.d_R},pow:function(){return i2.sQ3},prelu:function(){return i2.AL3},print:function(){return i2.S0v},prod:function(){return i2.WVs},raggedGather:function(){return i2.$gW},raggedRange:function(){return i2.VT$},raggedTensorToTensor:function(){return i2.N89},rand:function(){return i2.TN_},randomGamma:function(){return i2.wzB},randomNormal:function(){return i2.nGf},randomStandardNormal:function(){return i2.ruB},randomUniform:function(){return i2.LGj},randomUniformInt:function(){return i2.pe5},range:function(){return i2.w6H},real:function(){return i2.kwC},reciprocal:function(){return i2.M25},relu:function(){return i2.UYe},relu6:function(){return i2.btT},reshape:function(){return i2.XLQ},reverse:function(){return i2.GYS},reverse1d:function(){return i2.SDf},reverse2d:function(){return i2.diP},reverse3d:function(){return i2.sx7},reverse4d:function(){return i2.mG2},rfft:function(){return i2.QEs},round:function(){return i2.NMM},rsqrt:function(){return i2.bp0},scalar:function(){return i2.iD$},scatterND:function(){return i2.snQ},searchSorted:function(){return i2.zcT},selu:function(){return i2.U8D},separableConv2d:function(){return i2.U_I},setdiff1dAsync:function(){return i2.ODp},sigmoid:function(){return i2.XD2},sign:function(){return i2.Xxe},signal:function(){return i2.tdS},sin:function(){return i2.O$l},sinh:function(){return i2.R_K},slice:function(){return i2.tPi},slice1d:function(){return i2.jZU},slice2d:function(){return i2.SmN},slice3d:function(){return i2.CnO},slice4d:function(){return i2.p0P},softmax:function(){return i2.XAC},softplus:function(){return i2.Wvh},spaceToBatchND:function(){return i2.fBT},sparse:function(){return i2.rVs},sparseToDense:function(){return i2.ers},spectral:function(){return i2.uN7},split:function(){return i2.Vl2},sqrt:function(){return i2._b3},square:function(){return i2.h62},squaredDifference:function(){return i2.$i},squeeze:function(){return i2.L9e},stack:function(){return i2.knu},step:function(){return i2.Nbs},stridedSlice:function(){return i2.NXj},string:function(){return i2.Z_8},sub:function(){return i2.luU},sum:function(){return i2.Smz},tan:function(){return i2.ORZ},tanh:function(){return i2.AEp},tensor:function(){return i2.XeE},tensor1d:function(){return i2.RRF},tensor2d:function(){return i2.odF},tensor3d:function(){return i2.wOQ},tensor4d:function(){return i2.yXz},tensor5d:function(){return i2.Bfx},tensor6d:function(){return i2.xZs},tensorScatterUpdate:function(){return i2.Pg0},tile:function(){return i2.Gg6},topk:function(){return i2.hg7},transpose:function(){return i2.p4s},truncatedNormal:function(){return i2.Xu6},unique:function(){return i2.Two},unsortedSegmentSum:function(){return i2.pUJ},unstack:function(){return i2.HHK},upperBound:function(){return i2.GaM},variable:function(){return i2.VD$},where:function(){return i2.arb},whereAsync:function(){return i2.itS},zeros:function(){return i2.lls},zerosLike:function(){return i2.P84}});var eA={};V.r(eA),V.d(eA,{CSVDataset:function(){return CSVDataset},Dataset:function(){return Dataset},FileDataSource:function(){return FileDataSource},TextLineDataset:function(){return TextLineDataset},URLDataSource:function(){return URLDataSource},array:function(){return array},csv:function(){return csv},func:function(){return func},generator:function(){return generator},microphone:function(){return microphone},version_data:function(){return ol},webcam:function(){return webcam},zip:function(){return zip}});var eD=V(15949),eM=V(29121),eR=V(62271),eF=V(24841),eO=V(71901);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eP={kernelName:eM.SYM,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)(F,(0,eO.N)((0,eR.p)(V,"float32"),-1))}}};var eB=V(41274),e$=V(17370),eL=V(99494),ez=V(13261),eV=V(50248),eU=V(70827);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eW={kernelName:eM.VGw,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>{let $=(0,eV.h)((0,eR.p)(V,"float32")),G=(0,ez._)((0,eU.l)((0,eL.i)(1),$));return(0,e$.W)((0,eB.h)(F,G))}}}},ej={kernelName:eM.SpW,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>{let $=(0,ez._)((0,eU.l)((0,eV.h)((0,eR.p)(V,"float32")),1));return(0,eB.h)(F,$)}}}};var eG=V(72200),eH=V(4968),eX=V(15475);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eK={kernelName:eM.mm_,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$,H=eG.assertAndGetBroadcastShape(V.shape,G.shape),derA=()=>{let $=F,G=eG.getReductionAxes(V.shape,H);return G.length>0&&($=(0,eX.S)($,G)),(0,eH.X)($,V.shape)},derB=()=>{let $=F,V=eG.getReductionAxes(G.shape,H);return V.length>0&&($=(0,eX.S)($,V)),(0,eH.X)($,G.shape)};return{a:derA,b:derB}}},eQ={kernelName:eM.Xze,saveAllInputs:!0,gradFunc:(F,$)=>{let V={};return $.forEach(($,G)=>{V[G]=()=>F.clone()}),V}};var eZ=V(6577);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eY={kernelName:eM.sJF,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eZ.P)(V)}}},eJ={kernelName:eM.aJk,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eZ.P)(V)}}},e1={kernelName:eM.M2y,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eB.h)(F,(0,ez._)((0,eU.l)((0,eL.i)(1),(0,eV.h)((0,eR.p)(V,"float32")))))}}};var e2=V(56407);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let e3={kernelName:eM.qw7,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>{let $=(0,ez._)((0,e2.I)((0,eL.i)(1),(0,eV.h)((0,eR.p)(V,"float32"))));return(0,eB.h)(F,$)}}}},e4={kernelName:eM.QCc,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$,H=(0,eG.assertAndGetBroadcastShape)(V.shape,G.shape),derA=()=>{let $=(0,e2.I)((0,eV.h)(V),(0,eV.h)(G)),K=(0,eF.d)(F,(0,eB.h)(G,$)),Z=(0,eG.getReductionAxes)(V.shape,H);return Z.length>0&&(K=(0,eX.S)(K,Z)),(0,eH.X)(K,V.shape)},derB=()=>{let $=(0,e2.I)((0,eV.h)(V),(0,eV.h)(G)),K=(0,e$.W)((0,eF.d)(F,(0,eB.h)(V,$))),Z=(0,eG.getReductionAxes)(G.shape,H);return Z.length>0&&(K=(0,eX.S)(K,Z)),(0,eH.X)(K,G.shape)};return{a:derA,b:derB}}},e6={kernelName:eM.jMg,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eB.h)(F,(0,e2.I)((0,eV.h)((0,eR.p)(V,"float32")),1))}}},e5={kernelName:eM.Oyi,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eB.h)(F,(0,eU.l)((0,eL.i)(1),(0,eV.h)((0,eR.p)(V,"float32"))))}}};var e9=V(50196),e8=V(43740),e7=V(20569),te=V(2582),tt=V(2668);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3dGrad_(F,$,V,G,H,K){let Z=(0,e8._1)(F,"dy","avgPool3dGrad"),ee=(0,e8._1)($,"input","avgPool3dGrad"),et=Z,en=ee,ea=!1;4===ee.rank&&(ea=!0,et=(0,eH.X)(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2],Z.shape[3]]),en=(0,eH.X)(ee,[1,ee.shape[0],ee.shape[1],ee.shape[2],ee.shape[3]])),e7.hu(5===et.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${et.rank}.`),e7.hu(5===en.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${en.rank}.`),(0,te.m)("avgPool3dGrad",H,K);let ei={dy:et,input:en},eo={filterSize:V,strides:G,pad:H,dimRoundingMode:K},es=e9.BV.runKernel(eM.IMb,ei,eo);return ea?(0,eH.X)(es,[es.shape[1],es.shape[2],es.shape[3],es.shape[4]]):es}let tr=(0,tt.op)({avgPool3dGrad_}),tn={kernelName:eM._k9,inputsToSave:["x"],gradFunc:(F,$,V)=>{let[G]=$,{filterSize:H,strides:K,pad:Z,dimRoundingMode:ee}=V;return{x:()=>tr(F,G,H,K,Z,ee)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPoolGrad_(F,$,V,G,H){let K=(0,e8._1)(F,"dy","avgPoolGrad"),Z=(0,e8._1)($,"input","avgPoolGrad");e7.hu(Z.rank===K.rank,()=>`Rank of input (${Z.rank}) does not match rank of dy (${K.rank})`);let ee=Z,et=K,en=!1;3===Z.rank&&(en=!0,ee=(0,eH.X)(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2]]),et=(0,eH.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]])),e7.hu(4===et.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${et.rank}.`),e7.hu(4===ee.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${ee.rank}.`);let ea={dy:et,input:ee},ei={filterSize:V,strides:G,pad:H},eo=e9.BV.runKernel(eM.ROF,ea,ei);return en?(0,eH.X)(eo,[eo.shape[1],eo.shape[2],eo.shape[3]]):eo}let ta=(0,tt.op)({avgPoolGrad_}),ti={kernelName:eM.JhU,inputsToSave:["x"],gradFunc:(F,$,V)=>{let[G]=$,{filterSize:H,strides:K,pad:Z}=V;return{x:()=>ta(F,G,H,K,Z)}}};var ts=V(28687);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tu={kernelName:eM.XLW,inputsToSave:["a","b"],gradFunc:(F,$,V)=>{let[G,H]=$,{transposeA:K,transposeB:Z}=V;return K||Z?!K&&Z?{a:()=>(0,ts.O)(F,H,!1,!1),b:()=>(0,ts.O)(F,G,!0,!1)}:K&&!Z?{a:()=>(0,ts.O)(H,F,!1,!0),b:()=>(0,ts.O)(G,F,!1,!1)}:{a:()=>(0,ts.O)(H,F,!0,!0),b:()=>(0,ts.O)(F,G,!0,!0)}:{a:()=>(0,ts.O)(F,H,!1,!0),b:()=>(0,ts.O)(G,F,!0,!1)}}};var tl=V(27918);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tc={kernelName:eM.zws,gradFunc:(F,$,V)=>{let{blockShape:G,crops:H}=V;return{x:()=>(0,tl.f)(F,G,H)}}},th={kernelName:eM.Ly9,gradFunc:(F,$,V)=>{let G=V,H=G.inputShape,K=G.shape,Z=Array.from(K);for(let F=H.length-1;F>=0;F--)if(H[F]===K[F])Z[F]=1;else if(1!==H[F])throw Error(`broadcastTo(): [${H}] cannot be broadcast to [${K}].`);let ee=[];for(let F=0;F<Z.length;F++)Z[F]>1&&ee.push(F);return{x:()=>(0,eX.S)(F,ee,!0)}}},td={kernelName:eM.RFZ,gradFunc:F=>({x:()=>F.clone()})},tm={kernelName:eM.gJX,gradFunc:F=>({x:()=>(0,eZ.P)(F)})};var tg=V(17630),ty=V(50624),tb=V(2856),tv=V(95912);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tw={kernelName:eM.xnO,inputsToSave:["x"],gradFunc:(F,$,V)=>{let[G]=$,{clipValueMin:H,clipValueMax:K}=V;return{x:()=>(0,tv.a)((0,tb.H)((0,tg.b)(G,H),(0,ty.z)(G,K)),F,(0,eZ.P)(F))}}},tS={kernelName:eM.yj2,inputsToSave:["x"],gradFunc:eP.gradFunc};var t_=V(28644);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tN={kernelName:eM.Eh3,saveAllInputs:!0,gradFunc:(F,$,V)=>{let G=$.map(F=>F.shape),{axis:H}=V,K=(0,e7.EC)(H,$[0].shape)[0],Z=G.map(F=>F[K]),ee=(0,t_.V)(F,Z,K);return ee.map(F=>()=>F)}};var tk=V(36013),tI=V(39832);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tT={kernelName:eM.mhS,inputsToSave:["x","filter"],gradFunc:(F,$,V)=>{let[G,H]=$,{dilations:K,strides:Z,pad:ee,dataFormat:et}=V;return e7.hu(te.I0(K),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${K}'`),{x:()=>(0,tI._)(G.shape,F,H,Z,ee,et),filter:()=>(0,tk.p)(G,F,H.shape,Z,ee,et)}}};var tC=V(64794);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tE={kernelName:eM.wm,inputsToSave:["dy","filter"],gradFunc:(F,$,V)=>{let[G,H]=$,{strides:K,pad:Z,dataFormat:ee,dimRoundingMode:et}=V;return{dy:()=>(0,tC.T)(F,H,K,Z,ee,1,et),filter:()=>(0,tk.p)(F,G,H.shape,K,Z,ee,et)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropFilter_(F,$,V,G,H){let K=F;4===F.rank&&(K=(0,eH.X)(F,[1,F.shape[0],F.shape[1],F.shape[2],F.shape[3]]));let Z=$;4===Z.rank&&(Z=(0,eH.X)($,[1,$.shape[0],$.shape[1],$.shape[2],$.shape[3]])),e7.hu(5===K.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${K.shape}.`),e7.hu(5===Z.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${Z.shape}.`),e7.hu(5===V.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${V}.`),e7.hu(K.shape[4]===V[3],()=>`Error in conv3dDerFilter: depth of input ${K.shape[4]}) must match input depth in filter (${V[3]}.`),e7.hu(Z.shape[4]===V[4],()=>`Error in conv3dDerFilter: depth of dy (${Z.shape[4]}) must match output depth for filter (${V[4]}).`);let ee={x:K,dy:Z},et={strides:G,pad:H,filterShape:V};return e9.BV.runKernel(eM.o2y,ee,et)}let tA=(0,tt.op)({conv3DBackpropFilter_});var tD=V(97594);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tM={kernelName:eM.x12,inputsToSave:["x","filter"],gradFunc:(F,$,V)=>{let{dilations:G,strides:H,pad:K}=V;e7.hu((0,te.I0)(G),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${G}'`);let[Z,ee]=$;return{x:()=>(0,tD._)(Z.shape,F,ee,H,K),filter:()=>tA(Z,F,ee.shape,H,K)}}};var tR=V(99331);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tF={kernelName:eM.mc4,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)((0,e$.W)((0,tR.O)((0,eR.p)(V,"float32"))),F)}}};var tO=V(83254);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tP={kernelName:eM.TR1,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)((0,tO.R)((0,eR.p)(V,"float32")),F)}}};var tB=V(83591),t$=V(37405),tL=V(89065);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tz={kernelName:eM.iHb,inputsToSave:["x"],gradFunc:(F,$,V)=>{let[G]=$,{axis:H,exclusive:K,reverse:Z}=V;return{x:()=>{let $=(0,tB.Q3)([H],G.rank),V=(0,t$.z)(F,H,K,!Z);return null!=$&&(V=(0,tL.p)(V,$)),V}}}};var tV=V(88098),tU=V(54375);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tW={kernelName:eM.cie,inputsToSave:["x","filter"],gradFunc:(F,$,V)=>{let{dilations:G,strides:H,pad:K,dimRoundingMode:Z}=V,ee=null==G?[1,1]:G;e7.hu(te.I0(ee),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${ee}'`);let[et,en]=$;return e7.hu(4===et.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${et.rank}.`),e7.hu(4===en.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${en.rank}.`),e7.hu(et.shape[3]===en.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${et.shape[3]}) must match the inChannels dimension in filter ${en.shape[2]}.`),e7.hu(te.jT(H,ee),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${H} and dilations '${ee}'.`),te.m("depthwiseConv2d",K,Z),{x:()=>(0,tU.v)(et.shape,F,en,H,K,ee,Z),filter:()=>(0,tV.z)(et,F,en.shape,H,K,ee,Z)}}},tj={kernelName:eM.p4S,inputsToSave:["x","filter"],gradFunc:(F,$,V)=>{let[G,H]=$,K={x:G,filter:H,dy:F},Z={x:G,filter:H,dy:F};return{x:()=>e9.BV.runKernel(eM.ekb,K,V),filter:()=>e9.BV.runKernel(eM.Vn9,Z,V)}}},tG={kernelName:eM.SX0,outputsToSave:[!0],gradFunc:(F,$)=>{let[V]=$,G={dy:F,y:V};return{x:()=>e9.BV.runKernel(eM.HEU,G)}}};var tq=V(44842);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tH={kernelName:eM.Omj,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$,G=(0,eF.d)((0,tq.Q)((0,e$.W)((0,eV.h)(V))),2/Math.sqrt(Math.PI));return{x:()=>(0,eF.d)(F,G)}}},tX={kernelName:eM.NEP,outputsToSave:[!0],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)(F,V)}}},tK={kernelName:eM.YFo,inputsToSave:["input"],gradFunc:(F,$)=>{let[V]=$;return{input:()=>(0,eH.X)(F,V.shape)}}},tQ={kernelName:eM.Y0y,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)(F,(0,tq.Q)(V))}}},tZ={kernelName:eM.OR,gradFunc:F=>({x:()=>(0,eZ.P)(F)})},tY={kernelName:eM.jeX,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$,H=(0,eG.assertAndGetBroadcastShape)(V.shape,G.shape),derA=()=>{let $=(0,eB.h)(F,(0,eR.p)(G,"float32")),K=(0,eG.getReductionAxes)(V.shape,H);return K.length>0?(0,eH.X)((0,eX.S)($,K),V.shape):$},derB=()=>{let $=(0,eF.d)(F,(0,eR.p)(V,"float32")),K=(0,eG.getReductionAxes)(G.shape,H);K.length>0&&($=(0,eH.X)((0,eX.S)($,K),G.shape));let Z=(0,eV.h)(G);return(0,e$.W)((0,eB.h)($,(0,eR.p)(Z,"float32")))};return{a:derA,b:derB}}};var tJ=V(32634),t4=V(47501);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let t6={kernelName:eM.sHE,inputsToSave:["x","mean","variance","scale"],gradFunc:(F,$,V)=>{let{varianceEpsilon:G}=V,[H,K,Z,ee]=$,et=null==ee?(0,eL.i)(1):ee,en=(0,eG.getReductionAxes)(K.shape,H.shape),ea=[];if(1===K.rank){for(let F=0;F<H.shape.length-1;++F)ea.push(H.shape[F]);ea.push(1)}let ei=(0,eU.l)(H,K),eo=(0,eF.d)(F,et),es=(0,tJ.b)((0,e2.I)(Z,(0,eL.i)(G))),eu=(0,eF.d)((0,eF.d)((0,eF.d)(es,es),es),(0,eL.i)(-.5)),derX=()=>1===K.rank?(0,eH.X)((0,eF.d)((0,eF.d)(F,(0,t4.G)((0,eH.X)(es,[1,1,1,K.shape[0]]),ea)),et),H.shape):(0,eH.X)((0,eF.d)((0,eF.d)(F,es),et),H.shape),derMean=()=>{let F=(0,eF.d)((0,eF.d)(es,(0,eL.i)(-1)),eo);return 1===K.rank&&(F=(0,eX.S)(F,en)),(0,eH.X)(F,K.shape)},derVariance=()=>{let F=(0,eF.d)((0,eF.d)(eu,ei),eo);return 1===K.rank&&(F=(0,eX.S)(F,en)),(0,eH.X)(F,K.shape)},derScale=()=>{let $=(0,eF.d)(ei,es),V=(0,eF.d)(F,$);return 1===K.rank&&(V=(0,eX.S)(V,en)),(0,eH.X)(V,K.shape)},derOffset=()=>{let $=F;return 1===K.rank&&($=(0,eX.S)($,en)),(0,eH.X)($,K.shape)};return{x:derX,mean:derMean,variance:derVariance,scale:derScale,offset:derOffset}}};var t5=V(82991),t9=V(98749);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let t8={kernelName:eM.qi_,inputsToSave:["x","indices"],gradFunc:(F,$,V)=>{let[G,H]=$,{axis:K,batchDims:Z}=V,ee=(0,e7.EC)(K,G.shape)[0],derXBatch=(F,$,V)=>()=>{let G=F.shape,H=$.size,Z=G.slice(0,ee),et=Z.length,en=G.slice(K,G.length).slice(1),ea=en.length,ei=arrayRange(0,et),eo=arrayRange(et+1,et+1+ea),es=arrayConcat([Z,[H],en]),eu=(0,eH.X)(V,es),ec=(0,eH.X)($,[H]),ep=arrayConcat([[et],ei,eo]),eh=(0,tL.p)(eu,ep),ef=(0,t9.p)(eh,ec,F.shape[ee]),ed=(0,tB.LJ)(ep);return(0,tL.p)(ef,ed)};if(1!==Z)return{x:derXBatch(G,H,F),indices:()=>H};{let $=G.shape[0],V=G.split($,0),derXBatched=()=>{let $=(0,t5.k)(V.map(($,V)=>derXBatch($,H.slice(V,1),F.slice(V,1))()));return $.reshape(G.shape)};return{x:derXBatched,indices:()=>H}}}};function arrayRange(F,$){let V=[];for(let G=F;G<$;++G)V.push(G);return V}function arrayConcat(F){let $=[];for(let V=0;V<F.length;++V)for(let G=0;G<F[V].length;++G)$.push(F[V][G]);return $}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let t7={kernelName:eM.Acj,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$;return{a:()=>(0,eZ.P)(V),b:()=>(0,eZ.P)(G)}}},rt={kernelName:eM.iJz,gradFunc:F=>({x:()=>(0,eR.p)(F,"float32")})},rr={kernelName:eM.avt,gradFunc:F=>({x:()=>(0,eZ.P)(F)})},rn={kernelName:eM.iWB,gradFunc:F=>({x:()=>(0,eZ.P)(F)})},ra={kernelName:eM.r7n,gradFunc:F=>({x:()=>(0,eZ.P)(F)})};var ro=V(20636);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rs={kernelName:eM.J$2,inputsToSave:["x"],gradFunc:(F,$,V)=>{let[G]=$,{alpha:H}=V,K=(0,ro.p)(G,0);return{x:()=>(0,tv.a)(K,F,(0,eF.d)(F,H))}}},ru={kernelName:eM.kU,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eB.h)(F,(0,e2.I)(V,1))}}},rl={kernelName:eM.ZbH,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eB.h)(F,(0,eR.p)(V,"float32"))}}},rc={kernelName:eM.qCd,inputsToSave:[],outputsToSave:[!0],gradFunc:(F,$,V)=>{let[G]=$,{axis:H}=V;return{logits:()=>{let $=!0,V=(0,tq.Q)(G);return(0,eU.l)(F,(0,eF.d)((0,eX.S)(F,H,$),V))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function localResponseNormalizationBackprop_(F,$,V,G=5,H=1,K=1,Z=.5){let ee={x:F,y:$,dy:V},et={depthRadius:G,bias:H,alpha:K,beta:Z};return e9.BV.runKernel(eM.Hhh,ee,et)}let rp=(0,tt.op)({localResponseNormalizationBackprop_}),rh={kernelName:eM.eZ0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(F,$,V)=>{let[G,H]=$,{depthRadius:K,bias:Z,alpha:ee,beta:et}=V;return{x:()=>rp(G,H,F,K,Z,ee,et)}}};var rf=V(26477);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gradForMinAndMax(F,$,V,G){return $.rank<V.rank&&($=(0,eH.X)($,tB.rv($.shape,G))),F.rank<V.rank&&(F=(0,eH.X)(F,tB.rv(F.shape,G))),{x:()=>{let G=(0,eF.d)(F,(0,eR.p)((0,rf.D)(V,$),F.dtype));return G}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rg={kernelName:eM.YoZ,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(F,$,V)=>{let G=V,{reductionIndices:H}=G,K=$[0],Z=$[1],ee=e7.EC(H,K.shape),et=gradForMinAndMax(F,Z,K,ee);return{x:()=>et.x()}}};var ry=V(86573);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rb={kernelName:eM.BMI,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$,derA=()=>(0,eF.d)(F,(0,eR.p)((0,tg.b)(V,G),"float32")),derB=()=>(0,eF.d)(F,(0,eR.p)((0,ry.d)(V,G),"float32"));return{a:derA,b:derB}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3dGrad_(F,$,V,G,H,K,Z){let ee=(0,e8._1)(F,"dy","maxPool3dGrad"),et=(0,e8._1)($,"input","maxPool3dGrad"),en=(0,e8._1)(V,"output","maxPool3dGrad"),ea=ee,ei=et,eo=en,es=!1;4===et.rank&&(es=!0,ea=(0,eH.X)(ee,[1,ee.shape[0],ee.shape[1],ee.shape[2],ee.shape[3]]),ei=(0,eH.X)(et,[1,et.shape[0],et.shape[1],et.shape[2],et.shape[3]]),eo=(0,eH.X)(en,[1,en.shape[0],en.shape[1],en.shape[2],en.shape[3]])),e7.hu(5===ea.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${ea.rank}.`),e7.hu(5===ei.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${ei.rank}.`),e7.hu(5===eo.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${eo.rank}.`),(0,te.m)("maxPool3dGrad",K,Z);let eu={dy:ea,input:ei,output:eo},ec={filterSize:G,strides:H,pad:K,dimRoundingMode:Z},ep=e9.BV.runKernel(eM.OU7,eu,ec);return es?(0,eH.X)(ep,[ep.shape[1],ep.shape[2],ep.shape[3],ep.shape[4]]):ep}let rx=(0,tt.op)({maxPool3dGrad_}),rv={kernelName:eM.OAf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(F,$,V)=>{let[G,H]=$,{filterSize:K,strides:Z,pad:ee,dimRoundingMode:et}=V;return{x:()=>rx(F,G,H,K,Z,ee,et)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolGrad_(F,$,V,G,H,K,Z){let ee=(0,e8._1)(F,"dy","maxPoolGrad"),et=(0,e8._1)($,"input","maxPoolGrad"),en=(0,e8._1)(V,"output","maxPoolGrad");e7.hu(et.rank===ee.rank,()=>`Rank of input (${et.rank}) does not match rank of dy (${ee.rank})`),e7.hu(4===ee.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${ee.rank}.`),e7.hu(4===et.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${et.rank}.`),te.m("maxPoolGrad",K,Z);let ea={dy:ee,input:et,output:en},ei={filterSize:G,strides:H,pad:K,dimRoundingMode:Z};return e9.BV.runKernel(eM.OV7,ea,ei)}let rw=(0,tt.op)({maxPoolGrad_}),rS={kernelName:eM.mTV,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(F,$,V)=>{let[G,H]=$,{filterSize:K,strides:Z,pad:ee}=V;return{x:()=>rw(F,G,H,K,Z,ee)}}};var r_=V(44917);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rN={kernelName:eM.q2K,inputsToSave:["x"],gradFunc:(F,$,V)=>{let[G]=$,{axis:H}=V,K=e7.EC(H,G.shape),Z=(0,tB.kz)(G.shape,K),ee=Z[1],et=e7.NA(ee),derX=()=>{let $=G.shape.slice();K.forEach(F=>{$[F]=1});let V=(0,eH.X)(F,$),H=(0,eB.h)((0,eF.d)(V,(0,r_.i)(G.shape,"float32")),et);return H};return{x:derX}}},rk={kernelName:eM.c17,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(F,$,V)=>{let G=V,{axis:H}=G,[K,Z]=$,ee=e7.EC(H,K.shape),et=gradForMinAndMax(F,Z,K,ee);return{x:()=>et.x()}}},rI={kernelName:eM.q8u,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$,derA=()=>(0,eF.d)(F,(0,eR.p)((0,ty.z)(V,G),"float32")),derB=()=>(0,eF.d)(F,(0,eR.p)((0,ro.p)(V,G),"float32"));return{a:derA,b:derB}}};var rT=V(22676);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rC={kernelName:eM.jQs,inputsToSave:["x"],gradFunc:(F,$,V)=>{let G=$[0],{paddings:H}=V,K=H.map(F=>F[0]);return{x:()=>(0,rT.t)(F,K,G.shape)}}};var rE=V(26943);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rA={kernelName:eM.Vbg,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$,H=(0,eG.assertAndGetBroadcastShape)(V.shape,G.shape),derA=()=>{let $=(0,eG.getReductionAxes)(V.shape,H);return $.length>0?(0,eH.X)((0,eX.S)(F,$),V.shape):F},derB=()=>{let $=(0,eF.d)(F,(0,e$.W)((0,rE.G)((0,eB.h)(V,G)))),K=(0,eG.getReductionAxes)(G.shape,H);return K.length>0?(0,eH.X)((0,eX.S)($,K),G.shape):$};return{a:derA,b:derB}}},rD={kernelName:eM.wYn,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$,H=(0,eG.assertAndGetBroadcastShape)(V.shape,G.shape),derA=()=>{let $=(0,eF.d)(F,(0,eR.p)(G,"float32")),K=(0,eG.getReductionAxes)(V.shape,H);return K.length>0?(0,eH.X)((0,eX.S)($,K),V.shape):$},derB=()=>{let $=(0,eF.d)(F,(0,eR.p)(V,"float32")),K=(0,eG.getReductionAxes)(G.shape,H);return K.length>0?(0,eH.X)((0,eX.S)($,K),G.shape):$};return{a:derA,b:derB}}},rM={kernelName:eM.kuV,gradFunc:F=>({x:()=>(0,e$.W)(F)})};var rR=V(59640);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rF={kernelName:eM.we_,inputsToSave:["indices"],gradFunc:(F,$)=>{let V=$[0];return{indices:()=>(0,rR.l)(V.shape,"float32")}}},rO={kernelName:eM.qWM,gradFunc:F=>({x:()=>(0,eZ.P)(F)})};var rP=V(24136);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rB={kernelName:eM.QiL,saveAllInputs:!0,gradFunc:(F,$,V)=>{let{axis:G}=V,H=(0,rP.H)(F,G);return H.map(F=>()=>F)}},r$={kernelName:eM.lyA,inputsToSave:["x"],gradFunc:(F,$,V)=>{let G=$[0],{paddings:H}=V,K=H.map(F=>F[0]);return{x:()=>(0,rT.t)(F,K,G.shape)}}};var rz=V(82597),rV=V(33453);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rU={kernelName:eM.pe_,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(F,$)=>{let[V,G,H]=$,K=V,Z=G,ee=eG.assertAndGetBroadcastShape(K.shape,Z.shape),derBase=()=>{let $=(0,eR.p)(Z,"float32"),V=(0,eF.d)(F,(0,eF.d)($,(0,rV.s)(K,(0,eU.l)($,(0,eL.i)(1))))),G=eG.getReductionAxes(K.shape,ee);return G.length>0&&(V=(0,eX.S)(V,G)),(0,eH.X)(V,K.shape)},derExp=()=>{let $=(0,ro.p)(K,0),V=(0,tv.a)($,(0,rz.c)(K),(0,eZ.P)(K)),G=(0,eF.d)(F,(0,eF.d)(H,V)),et=eG.getReductionAxes(Z.shape,ee);return et.length>0&&(G=(0,eX.S)(G,et)),(0,eH.X)(G,Z.shape)};return{a:derBase,b:derExp}}},rW={kernelName:eM.o0g,inputsToSave:["x","alpha"],gradFunc:(F,$)=>{let[V,G]=$,H=(0,ro.p)(V,0);return{x:()=>(0,tv.a)(H,F,(0,eF.d)(F,G)),alpha:()=>{let $=(0,tv.a)(H,(0,eZ.P)(F),(0,eF.d)(F,V)),K=(0,eG.getReductionAxes)(G.shape,F.shape);return K.length>0&&($=(0,eX.S)($,K)),(0,eH.X)($,G.shape)}}}};var rj=V(9640);/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prodGradFn_(F,$,V){let G=F.shape.slice();G[V]=1;let H=(0,eH.X)($,G),K=(0,rj.$)(F,V,!0,!1),Z=(0,rj.$)(F,V,!0,!0),ee=(0,eF.d)(K,Z);return(0,eF.d)(H,ee)}function prodsGradFn_(F,$,V){let G=F.shape.length,H=G-V.length,K=tB.Q3(V,G),Z=F;null!=K&&(Z=(0,tL.p)(F,K));let ee=Z.shape.slice(),et=ee.splice(G-V.length,V.length),en=et.reduce((F,$)=>F*$,1);ee.push(en);let ea=Z.reshape(ee),ei=prodGradFn_(ea,$,H);if(ei=ei.reshape(Z.shape),null!=K){let F=tB.LJ(K);ei=(0,tL.p)(ei,F)}return ei}let rG={kernelName:eM.DlI,inputsToSave:["x"],gradFunc:(F,$,V)=>{let[G]=$,{axis:H}=V,K=[];return K=null==H?G.shape.map((F,$)=>$):"number"==typeof H?[H]:H,{x:()=>prodsGradFn_(G,F,K)}}},rq={kernelName:eM.oHH,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$,H=eG.assertAndGetBroadcastShape(V.shape,G.shape),derA=()=>{let $=(0,eB.h)(F,(0,eR.p)(G,"float32")),K=eG.getReductionAxes(V.shape,H);return K.length>0?(0,eH.X)((0,eX.S)($,K),V.shape):$},derB=()=>{let $=(0,eF.d)(F,(0,eR.p)(V,"float32")),K=eG.getReductionAxes(G.shape,H);K.length>0&&($=(0,eH.X)((0,eX.S)($,K),G.shape));let Z=(0,eV.h)(G);return(0,e$.W)((0,eB.h)($,(0,eR.p)(Z,"float32")))};return{a:derA,b:derB}}},rH={kernelName:eM.$HU,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eB.h)(F,(0,e$.W)((0,eV.h)(V)))}}},rX={kernelName:eM.SbG,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$,G=(0,eF.d)((0,ty.z)(V,6),(0,eO.N)(V));return{x:()=>(0,eF.d)(F,(0,eR.p)(G,"float32"))}}},rK={kernelName:eM.qkr,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)(F,(0,eR.p)((0,eO.N)(V),"float32"))}}},rQ={kernelName:eM.HZH,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eH.X)(F,V.shape)}}},rZ={kernelName:eM._Yw,inputsToSave:["images"],gradFunc:(F,$,V)=>{let[G]=$,H={dy:F,images:G},imagesDer=()=>e9.BV.runKernel(eM.zbQ,H,V);return{images:imagesDer}}},rY={kernelName:eM.dpD,inputsToSave:["images"],gradFunc:(F,$,V)=>{let[G]=$,H={dy:F,images:G},imagesDer=()=>e9.BV.runKernel(eM.Hmb,H,V);return{images:imagesDer}}};var rJ=V(57486);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let r0={kernelName:eM.mKl,gradFunc:(F,$,V)=>{let{dims:G}=V,H=(0,e7.EC)(G,F.shape);return{x:()=>(0,rJ.G)(F,H)}}},r2={kernelName:eM.e07,gradFunc:F=>({x:()=>(0,eZ.P)(F)})},r3={kernelName:eM.bV0,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,e$.W)((0,eB.h)(F,(0,eF.d)((0,rV.s)(V,1.5),2)))}}};var r4=V(38651);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let r6={kernelName:eM.PhF,inputsToSave:["condition"],gradFunc:(F,$)=>{let[V]=$;return{condition:()=>(0,eR.p)((0,eZ.P)(V),"float32"),t:()=>(0,eF.d)(F,(0,eR.p)(V,F.dtype)),e:()=>(0,eF.d)(F,(0,eR.p)((0,r4.h)(V),F.dtype))}}};var r5=V(43179);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let r9={kernelName:eM.oFR,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>{let $=(0,ro.p)(V,(0,eL.i)(0)),G=(0,eL.i)(r5.y),H=(0,eL.i)(r5.$),K=(0,eF.d)(F,H),Z=(0,eF.d)((0,eF.d)(F,G),(0,tq.Q)((0,eR.p)(V,"float32")));return(0,tv.a)($,K,Z)}}}},r8={kernelName:eM.a5O,outputsToSave:[!0],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)(F,(0,eF.d)(V,(0,eU.l)((0,eL.i)(1),V)))}}},r7={kernelName:eM.i5y,gradFunc:F=>({x:()=>(0,eZ.P)(F)})};var ne=V(70173);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nt={kernelName:eM.RQH,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)((0,ne.m)((0,eR.p)(V,"float32")),F)}}};var nr=V(2699);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nn={kernelName:eM.wYB,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)((0,nr.f)((0,eR.p)(V,"float32")),F)}}};var ni=V(39682),no=V(37650);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nu={kernelName:eM.p2w,inputsToSave:["x"],gradFunc:(F,$,V)=>{let[G]=$,{begin:H,size:K}=V,Z=G.shape,[ee,et]=(0,no.parseSliceParams)(G,H,K),en=[];for(let $=0;$<F.rank;$++)en.push([ee[$],Z[$]-ee[$]-et[$]]);return{x:()=>(0,ni.v)(F,en)}}},nl={kernelName:eM.Gcp,outputsToSave:[!0],gradFunc:(F,$,V)=>{let[G]=$,{dim:H}=V,K=!0,Z=(0,eF.d)(F,G);return{logits:()=>(0,eU.l)(Z,(0,eF.d)((0,eX.S)(Z,[H],K),G))}}};var np=V(30625);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nh={kernelName:eM.MRv,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)(F,(0,np.X)(V))}}};var nf=V(28441);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nm={kernelName:eM.TQc,gradFunc:(F,$,V)=>{let{blockShape:G,paddings:H}=V;return{x:()=>(0,nf.E)(F,G,H)}}};var ng=V(46884);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ny={kernelName:eM.L8s,gradFunc:(F,$,V)=>{let{axis:G}=V;return{x:()=>(0,ng.z)(F,G)}}},nx={kernelName:eM.FKq,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eB.h)(F,(0,eF.d)((0,ez._)((0,eR.p)(V,"float32")),2))}}},nw={kernelName:eM.bK0,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)(F,(0,eF.d)((0,eR.p)(V,"float32"),2))}}},nS={kernelName:eM._tC,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$,H=(0,eL.i)(2),derA=()=>(0,eF.d)(F,(0,eF.d)(H,(0,eU.l)(V,G))),derB=()=>(0,eF.d)(F,(0,eF.d)(H,(0,eU.l)(G,V)));return{a:derA,b:derB}}},n_={kernelName:eM.h8e,gradFunc:F=>({x:()=>(0,eZ.P)(F)})},nN={kernelName:eM.Tr8,inputsToSave:["a","b"],gradFunc:(F,$)=>{let[V,G]=$,H=eG.assertAndGetBroadcastShape(V.shape,G.shape),derA=()=>{let $=F,G=eG.getReductionAxes(V.shape,H);return G.length>0&&($=(0,eX.S)($,G)),(0,eH.X)($,V.shape)},derB=()=>{let $=F,V=eG.getReductionAxes(G.shape,H);return V.length>0&&($=(0,eX.S)($,V)),(0,eH.X)((0,e$.W)($),G.shape)};return{a:derA,b:derB}}},nk={kernelName:eM.GBy,inputsToSave:["x"],gradFunc:(F,$,V)=>{let[G]=$,H=G.shape.slice(),{axis:K}=V,Z=(0,e7.EC)(K,G.shape);Z.forEach(F=>{H[F]=1});let ee=(0,eH.X)(F,H),et=(0,eF.d)(ee,(0,r_.i)(G.shape,"float32"));return{x:()=>et}}},nI={kernelName:eM.sEM,inputsToSave:["x"],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eB.h)(F,(0,eV.h)((0,ne.m)(V)))}}},nT={kernelName:eM.MIZ,outputsToSave:[!0],gradFunc:(F,$)=>{let[V]=$;return{x:()=>(0,eF.d)((0,eU.l)((0,eL.i)(1),(0,eV.h)(V)),F)}}},nC={kernelName:eM.n9L,inputsToSave:["x"],gradFunc:(F,$,V)=>{let[G]=$,{reps:H}=V,derX=()=>{let $=(0,eZ.P)(G);if(1===G.rank)for(let V=0;V<H[0];++V)$=(0,e2.I)($,(0,rT.t)(F,[V*G.shape[0]],[G.shape[0]]));else if(2===G.rank)for(let V=0;V<H[0];++V)for(let K=0;K<H[1];++K)$=(0,e2.I)($,(0,rT.t)(F,[V*G.shape[0],K*G.shape[1]],[G.shape[0],G.shape[1]]));else if(3===G.rank)for(let V=0;V<H[0];++V)for(let K=0;K<H[1];++K)for(let Z=0;Z<H[2];++Z)$=(0,e2.I)($,(0,rT.t)(F,[V*G.shape[0],K*G.shape[1],Z*G.shape[2]],[G.shape[0],G.shape[1],G.shape[2]]));else if(4===G.rank)for(let V=0;V<H[0];++V)for(let K=0;K<H[1];++K)for(let Z=0;Z<H[2];++Z)for(let ee=0;ee<H[3];++ee)$=(0,e2.I)($,(0,rT.t)(F,[V*G.shape[0],K*G.shape[1],Z*G.shape[2],ee*G.shape[3]],[G.shape[0],G.shape[1],G.shape[2],G.shape[3]]));else throw Error(`Gradient for tile operation is not implemented for rank-${G.rank} tensors yet.`);return $};return{x:derX}}},nE={kernelName:eM.G3Y,gradFunc:(F,$,V)=>{let G=V,{perm:H}=G,K=tB.LJ(H);return{x:()=>(0,tL.p)(F,K)}}},nA={kernelName:eM.ToN,gradFunc:(F,$,V)=>{let G=V,{axis:H}=G;return{value:()=>(0,t5.k)(F,H)}}};var nD=V(81300),nM=V(24926),nR=V(80632);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nF={kernelName:eM.Qvg,inputsToSave:["segmentIds"],gradFunc:(F,$)=>{let[V]=$,derX=()=>gatherDropNegatives(F,V);return{x:derX}}};function gatherDropNegatives(F,$){let V=(0,nR.g)($,(0,eZ.P)($)),G=(0,nM.I)(F,V),H=(0,tg.b)($,(0,eL.i)(0,"int32")),K=G.rank-H.rank;for(let F=0;F<K;++F)H=(0,nD.d)(H,F+1);H=(0,tb.H)(H,(0,r_.i)(G.shape,"bool"));let Z=(0,eZ.P)(G);return(0,tv.a)(H,G,Z)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nO={kernelName:eM.RuY,gradFunc:F=>({x:()=>(0,eZ.P)(F)})};var nP=V(26151);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nB=[eP,eW,ej,eK,eQ,eY,eJ,e1,e3,e4,e6,e5,tn,ti,tu,tc,th,td,tm,tw,tS,tN,tE,tT,tM,tF,tP,tz,tW,tj,rq,tG,tH,tX,tK,tQ,tY,tZ,t6,t8,t7,rt,rr,rn,ra,rs,ru,rl,rc,rh,rg,rg,rb,rv,rS,rN,rk,rI,rC,rA,rD,rM,rF,rO,rB,r$,r$,rU,rW,rG,rH,rX,rK,rQ,rZ,rY,r0,r2,r3,r6,r9,r8,r7,nt,nn,nu,nl,nh,nm,nm,ny,ny,nx,nS,nw,n_,nN,nk,nI,nT,nC,nE,nA,nF,nO];for(let F of nB)(0,nP.Li)(F);var n$=V(96235),nL=V(40974);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.abs=function(){return this.throwIfDisposed(),(0,n$.W)(this)};var nV=V(17839);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.acos=function(){return this.throwIfDisposed(),(0,nV.K)(this)};var nU=V(91470);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.acosh=function(){return this.throwIfDisposed(),(0,nU._)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.add=function(F){return this.throwIfDisposed(),(0,e2.I)(this,F)};var nW=V(90781);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.all=function(F,$){return this.throwIfDisposed(),(0,nW.$)(this,F,$)};var nj=V(92998);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.any=function(F,$){return this.throwIfDisposed(),(0,nj.Y)(this,F,$)};var nG=V(40047);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.argMax=function(F){return this.throwIfDisposed(),(0,nG.N)(this,F)};var nq=V(27394);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.argMin=function(F){return this.throwIfDisposed(),(0,nq.v)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,e7.hu)(1===this.size,()=>"The array must have only 1 element."),(0,eH.X)(this,[])},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.asType=function(F){return this.throwIfDisposed(),(0,eR.p)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.as1D=function(){return this.throwIfDisposed(),(0,eH.X)(this,[this.size])},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.as2D=function(F,$){return this.throwIfDisposed(),(0,eH.X)(this,[F,$])},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.as3D=function(F,$,V){return this.throwIfDisposed(),(0,eH.X)(this,[F,$,V])},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.as4D=function(F,$,V,G){return this.throwIfDisposed(),(0,eH.X)(this,[F,$,V,G])},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.as5D=function(F,$,V,G,H){return this.throwIfDisposed(),(0,eH.X)(this,[F,$,V,G,H])};var nH=V(72421);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.asin=function(){return this.throwIfDisposed(),(0,nH.Z)(this)};var nX=V(21891);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.asinh=function(){return this.throwIfDisposed(),(0,nX.V)(this)};var nK=V(77037);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.atan=function(){return this.throwIfDisposed(),(0,nK.z)(this)};var nQ=V(29812);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.atan2=function(F){return this.throwIfDisposed(),(0,nQ.f)(this,F)};var nZ=V(80369);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.atanh=function(){return this.throwIfDisposed(),(0,nZ.C)(this)};var nY=V(15176);(0,nL.t3)().prototype.avgPool=function(F,$,V,G){return this.throwIfDisposed(),(0,nY.w)(this,F,$,V,G)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.batchToSpaceND=function(F,$){return this.throwIfDisposed(),(0,nf.E)(this,F,$)};var nJ=V(40094);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.batchNorm=function(F,$,V,G,H){return this.throwIfDisposed(),(0,nJ.t)(this,F,$,V,G,H)};var n3=V(68247);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.broadcastTo=function(F){return this.throwIfDisposed(),(0,n3.U)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.cast=function(F){return this.throwIfDisposed(),(0,eR.p)(this,F)};var n4=V(6825);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.ceil=function(){return this.throwIfDisposed(),(0,n4.m)(this)};var n6=V(42279);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.clipByValue=function(F,$){return this.throwIfDisposed(),(0,n6.i)(this,F,$)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.concat=function(F,$){return this.throwIfDisposed(),F instanceof nL.es&&(F=[F]),(0,ng.z)([this,...F],$)};var n5=V(11355);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.conv1d=function(F,$,V,G,H,K){return this.throwIfDisposed(),(0,n5.P)(this,F,$,V,G,H,K)};var n9=V(71405);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.conv2dTranspose=function(F,$,V,G,H){return this.throwIfDisposed(),(0,n9.b)(this,F,$,V,G,H)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.conv2d=function(F,$,V,G,H,K){return this.throwIfDisposed(),(0,tC.T)(this,F,$,V,G,H,K)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.cos=function(){return this.throwIfDisposed(),(0,ne.m)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.cosh=function(){return this.throwIfDisposed(),(0,nr.f)(this)},/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.cumprod=function(F,$,V){return this.throwIfDisposed(),(0,rj.$)(this,F,$,V)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.cumsum=function(F,$,V){return this.throwIfDisposed(),(0,t$.z)(this,F,$,V)};var n8=V(89112);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.depthToSpace=function(F,$){return this.throwIfDisposed(),(0,n8.n)(this,F,$)};var n7=V(64718);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.depthwiseConv2d=function(F,$,V,G,H,K){return this.throwIfDisposed(),(0,n7.B)(this,F,$,V,G,H,K)};var ae=V(70557);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.dilation2d=function(F,$,V,G,H){return this.throwIfDisposed(),(0,ae.W)(this,F,$,V,G,H)};var ar=V(49322);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.divNoNan=function(F){return this.throwIfDisposed(),(0,ar.N)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.div=function(F){return this.throwIfDisposed(),(0,eB.h)(this,F)};var an=V(30548);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.dot=function(F){return this.throwIfDisposed(),(0,an.A)(this,F)};var aa=V(83233);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.elu=function(){return this.throwIfDisposed(),(0,aa.p)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.equal=function(F){return this.throwIfDisposed(),(0,rf.D)(this,F)};var ai=V(34650);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.erf=function(){return this.throwIfDisposed(),(0,ai.q)(this)};var ao=V(31954);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.euclideanNorm=function(F,$){return this.throwIfDisposed(),(0,ao.d)(this,F,$)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.exp=function(){return this.throwIfDisposed(),(0,tq.Q)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.expandDims=function(F){return this.throwIfDisposed(),(0,nD.d)(this,F)};var as=V(53426);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.expm1=function(){return this.throwIfDisposed(),(0,as.t)(this)};var au=V(7020);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.fft=function(){return this.throwIfDisposed(),(0,au.k)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.flatten=function(){return this.throwIfDisposed(),(0,eH.X)(this,[this.size])},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.floor=function(){return this.throwIfDisposed(),(0,rE.G)(this)};var ac=V(9165);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.floorDiv=function(F){return this.throwIfDisposed(),(0,ac.q)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.gather=function(F,$,V){return this.throwIfDisposed(),(0,nM.I)(this,F,$,V)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.greaterEqual=function(F){return this.throwIfDisposed(),(0,tg.b)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.greater=function(F){return this.throwIfDisposed(),(0,ro.p)(this,F)};var ap=V(88447);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.ifft=function(){return this.throwIfDisposed(),(0,ap.S)(this)};var ad=V(84415);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.irfft=function(){return this.throwIfDisposed(),(0,ad.w)(this)};var am=V(13963);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,am.x)(this)};var ag=V(4365);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.isInf=function(){return this.throwIfDisposed(),(0,ag.U)(this)};var ay=V(96230);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,ay.i)(this)};var ab=V(99133);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.leakyRelu=function(F){return this.throwIfDisposed(),(0,ab.h)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.lessEqual=function(F){return this.throwIfDisposed(),(0,ty.z)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.less=function(F){return this.throwIfDisposed(),(0,ry.d)(this,F)};var aw=V(79648);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.localResponseNormalization=function(F,$,V,G){return this.throwIfDisposed(),(0,aw.G)(this,F,$,V,G)};var aS=V(13888);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,aS.e)(this)};var a_=V(31510);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.logSoftmax=function(F){return this.throwIfDisposed(),(0,a_.C)(this,F)};var aN=V(11391);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.logSumExp=function(F,$){return this.throwIfDisposed(),(0,aN.l)(this,F,$)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.log=function(){return this.throwIfDisposed(),(0,rz.c)(this)};var ak=V(17474);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.log1p=function(){return this.throwIfDisposed(),(0,ak.K)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.logicalAnd=function(F){return this.throwIfDisposed(),(0,tb.H)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,r4.h)(this)};var aI=V(15750);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.logicalOr=function(F){return this.throwIfDisposed(),(0,aI.K)(this,F)};var aT=V(10596);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.logicalXor=function(F){return this.throwIfDisposed(),(0,aT.e)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.matMul=function(F,$,V){return this.throwIfDisposed(),(0,ts.O)(this,F,$,V)};var aC=V(21174);(0,nL.t3)().prototype.maxPool=function(F,$,V,G){return this.throwIfDisposed(),(0,aC._)(this,F,$,V,G)};var aE=V(83307);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.max=function(F,$){return this.throwIfDisposed(),(0,aE.F)(this,F,$)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.maximum=function(F){return this.throwIfDisposed(),(0,nR.g)(this,F)};var aA=V(75130);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.mean=function(F,$){return this.throwIfDisposed(),(0,aA.J)(this,F,$)};var aD=V(25735);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.min=function(F,$){return this.throwIfDisposed(),(0,aD.V)(this,F,$)};var aM=V(24513);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.minimum=function(F){return this.throwIfDisposed(),(0,aM.L)(this,F)};var aR=V(71483);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.mirrorPad=function(F,$){return this.throwIfDisposed(),(0,aR.V)(this,F,$)};var aF=V(85228);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.mod=function(F){return this.throwIfDisposed(),(0,aF.w)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.mul=function(F){return this.throwIfDisposed(),(0,eF.d)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.neg=function(){return this.throwIfDisposed(),(0,e$.W)(this)};var aO=V(3561);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.norm=function(F,$,V){return this.throwIfDisposed(),(0,aO.K)(this,F,$,V)};var aP=V(16500);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.notEqual=function(F){return this.throwIfDisposed(),(0,aP.Q)(this,F)};var aB=V(76708);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.oneHot=function(F,$=1,V=0){return this.throwIfDisposed(),(0,aB.l)(this,F,$,V)};var a$=V(7846);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,a$.J)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.pad=function(F,$){return this.throwIfDisposed(),(0,ni.v)(this,F,$)};var az=V(85860);(0,nL.t3)().prototype.pool=function(F,$,V,G,H,K){return this.throwIfDisposed(),(0,az.d)(this,F,$,V,G,H,K)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.pow=function(F){return this.throwIfDisposed(),(0,rV.s)(this,F)};var aV=V(98151);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.prelu=function(F){return this.throwIfDisposed(),(0,aV.A)(this,F)};var aU=V(49451);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.prod=function(F,$){return this.throwIfDisposed(),(0,aU.W)(this,F,$)};var aW=V(19036);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,aW.M)(this)};var aj=V(7409);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.relu=function(){return this.throwIfDisposed(),(0,aj.U)(this)};var aG=V(83582);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.relu6=function(){return this.throwIfDisposed(),(0,aG.b)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.reshapeAs=function(F){return this.throwIfDisposed(),(0,eH.X)(this,F.shape)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.reshape=function(F){return this.throwIfDisposed(),(0,eH.X)(this,F)};var aq=V(13305);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.resizeBilinear=function(F,$,V){return this.throwIfDisposed(),(0,aq.I)(this,F,$,V)};var aH=V(95098);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.resizeNearestNeighbor=function(F,$,V){return this.throwIfDisposed(),(0,aH.j)(this,F,$,V)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.reverse=function(F){return this.throwIfDisposed(),(0,rJ.G)(this,F)};var aX=V(13710);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.rfft=function(){return this.throwIfDisposed(),(0,aX.Q)(this)};var aK=V(97809);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.round=function(){return this.throwIfDisposed(),(0,aK.N)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,tJ.b)(this)};var aQ=V(55503);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.selu=function(){return this.throwIfDisposed(),(0,aQ.U)(this)};var aZ=V(68678);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.separableConv2d=function(F,$,V,G,H,K){return this.throwIfDisposed(),(0,aZ.U)(this,F,$,V,G,H,K)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,np.X)(this)};var aY=V(34434);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.sign=function(){return this.throwIfDisposed(),(0,aY.X)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.sin=function(){return this.throwIfDisposed(),(0,tR.O)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.sinh=function(){return this.throwIfDisposed(),(0,tO.R)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.slice=function(F,$){return this.throwIfDisposed(),(0,rT.t)(this,F,$)};var aJ=V(80682);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.softmax=function(F){return this.throwIfDisposed(),(0,aJ.X)(this,F)};var a0=V(3694);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.softplus=function(){return this.throwIfDisposed(),(0,a0.W)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.spaceToBatchND=function(F,$){return this.throwIfDisposed(),(0,tl.f)(this,F,$)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.split=function(F,$){return this.throwIfDisposed(),(0,t_.V)(this,F,$)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,ez._)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.square=function(){return this.throwIfDisposed(),(0,eV.h)(this)};var a6=V(15265);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.squaredDifference=function(F){return this.throwIfDisposed(),(0,a6.$)(this,F)};var a9=V(79590);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.squeeze=function(F){return this.throwIfDisposed(),(0,a9.L)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.stack=function(F,$){this.throwIfDisposed();let V=F instanceof nL.es?[this,F]:[this,...F];return(0,t5.k)(V,$)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.step=function(F){return this.throwIfDisposed(),(0,eO.N)(this,F)};var a8=V(55158);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.stridedSlice=function(F,$,V,G,H,K,Z,ee){return this.throwIfDisposed(),(0,a8.N)(this,F,$,V,G,H,K,Z,ee)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.sub=function(F){return this.throwIfDisposed(),(0,eU.l)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.sum=function(F,$){return this.throwIfDisposed(),(0,eX.S)(this,F,$)};var a7=V(61173);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.tan=function(){return this.throwIfDisposed(),(0,a7.O)(this)};var ie=V(21869);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.tanh=function(){return this.throwIfDisposed(),(0,ie.A)(this)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.tile=function(F){return this.throwIfDisposed(),(0,t4.G)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.toBool=function(){return this.throwIfDisposed(),(0,eR.p)(this,"bool")},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,eR.p)(this,"float32")},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.toInt=function(){return this.throwIfDisposed(),(0,eR.p)(this,"int32")};var ir=V(43243);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.topk=function(F,$){return this.throwIfDisposed(),(0,ir.h)(this,F,$)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.transpose=function(F){return this.throwIfDisposed(),(0,tL.p)(this,F)};var io=V(49608);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.unique=function(F){return this.throwIfDisposed(),(0,io.T)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.unsortedSegmentSum=function(F,$){return this.throwIfDisposed(),(0,t9.p)(this,F,$)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.unstack=function(F){return this.throwIfDisposed(),(0,rP.H)(this,F)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.where=function(F,$){return this.throwIfDisposed(),(0,tv.a)(F,this,$)},/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,nL.t3)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,eZ.P)(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var is=V(41111);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iu=(0,eD.OBj)();iu.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,is.kS);var il=V(64079);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function maxNorm(F){return new il.Yq(F)}function unitNorm(F){return new il.cK(F)}function nonNeg(){return new il.he}function minMaxNorm(F){return new il.iL(F)}var ip=V(92599);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function exports_initializers_zeros(){return new ip.H_}function exports_initializers_ones(){return new ip.M6}function constant(F){return new ip.sr(F)}function randomUniform(F){return new ip.Is(F)}function randomNormal(F){return new ip.MD(F)}function truncatedNormal(F){return new ip.w8(F)}function identity(F){return new ip.iJ(F)}function varianceScaling(F){return new ip.xc(F)}function glorotUniform(F){return new ip.sq(F)}function glorotNormal(F){return new ip.Jf(F)}function heNormal(F){return new ip.RP(F)}function heUniform(F){return new ip.rB(F)}function leCunNormal(F){return new ip.V9(F)}function leCunUniform(F){return new ip.yD(F)}function orthogonal(F){return new ip.vG(F)}var ih=V(466),ig=V(86275),iy=V(38678);function binaryAccuracy(F,$){return iy._F(F,$)}function binaryCrossentropy(F,$){return iy.fO(F,$)}function sparseCategoricalAccuracy(F,$){return iy.TY(F,$)}function categoricalAccuracy(F,$){return iy.G5(F,$)}function categoricalCrossentropy(F,$){return iy.uq(F,$)}function precision(F,$){return iy.ch(F,$)}function recall(F,$){return iy.wC(F,$)}function cosineProximity(F,$){return ig.Ls(F,$)}function meanAbsoluteError(F,$){return ig.ke(F,$)}function meanAbsolutePercentageError(F,$){return ig.t3(F,$)}function MAPE(F,$){return ig.t3(F,$)}function mape(F,$){return ig.t3(F,$)}function meanSquaredError(F,$){return ig.FD(F,$)}function MSE(F,$){return ig.FD(F,$)}function mse(F,$){return ig.FD(F,$)}var ix=V(83066),iv=V(10539);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function l1l2(F){return new iv.Xm(F)}function l1(F){return iv.l1(F)}function l2(F){return iv.l2(F)}var iw=V(28891),iS=V(85337),iN=V(40588),ik=V(73146);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Callback=class Callback extends iw.ex{constructor(){super(...arguments),this.model=null}setModel(F){if(!(F instanceof iS.QV))throw Error("model must be a LayersModel, not some other Container");this.model=F}};function callbacks_less(F,$){return F<$}function callbacks_greater(F,$){return F>$}let EarlyStopping=class EarlyStopping extends Callback{constructor(F){if(super(),null==F&&(F={}),F.restoreBestWeights)throw new iN.nj("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=F.monitor||"val_loss",this.minDelta=Math.abs(F.minDelta||0),this.patience=F.patience||0,this.verbose=F.verbose||0,this.mode=F.mode||"auto",this.baseline=F.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=callbacks_less:"max"===this.mode?this.monitorFunc=callbacks_greater:-1!==this.monitor.indexOf("acc")?this.monitorFunc=callbacks_greater:this.monitorFunc=callbacks_less,this.monitorFunc===callbacks_less&&(this.minDelta*=-1)}async onTrainBegin(F){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===callbacks_less?1/0:-1/0}async onEpochEnd(F,$){await (0,ik.Z)($);let V=this.getMonitorValue($);null!=V&&(this.monitorFunc(V-this.minDelta,this.best)?(this.best=V,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=F,this.model.stopTraining=!0)))}async onTrainEnd(F){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(F){null==F&&(F={});let $=F[this.monitor];return null==$&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(F)}`),$}};function earlyStopping(F){return new EarlyStopping(F)}let iI={earlyStopping};var iT=V(20163),iC=V(39603),iE=V(76014),iA=V(41653),iD=V(77385);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iM=(0,eD.OBj)();iM.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,F=>{F&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(F){F[F.DT_INVALID=0]="DT_INVALID",F[F.DT_FLOAT=1]="DT_FLOAT",F[F.DT_DOUBLE=2]="DT_DOUBLE",F[F.DT_INT32=3]="DT_INT32",F[F.DT_UINT8=4]="DT_UINT8",F[F.DT_INT16=5]="DT_INT16",F[F.DT_INT8=6]="DT_INT8",F[F.DT_STRING=7]="DT_STRING",F[F.DT_COMPLEX64=8]="DT_COMPLEX64",F[F.DT_INT64=9]="DT_INT64",F[F.DT_BOOL=10]="DT_BOOL",F[F.DT_QINT8=11]="DT_QINT8",F[F.DT_QUINT8=12]="DT_QUINT8",F[F.DT_QINT32=13]="DT_QINT32",F[F.DT_BFLOAT16=14]="DT_BFLOAT16",F[F.DT_QINT16=15]="DT_QINT16",F[F.DT_QUINT16=16]="DT_QUINT16",F[F.DT_UINT16=17]="DT_UINT16",F[F.DT_COMPLEX128=18]="DT_COMPLEX128",F[F.DT_HALF=19]="DT_HALF",F[F.DT_RESOURCE=20]="DT_RESOURCE",F[F.DT_VARIANT=21]="DT_VARIANT",F[F.DT_UINT32=22]="DT_UINT32",F[F.DT_UINT64=23]="DT_UINT64",F[F.DT_FLOAT_REF=101]="DT_FLOAT_REF",F[F.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",F[F.DT_INT32_REF=103]="DT_INT32_REF",F[F.DT_UINT8_REF=104]="DT_UINT8_REF",F[F.DT_INT16_REF=105]="DT_INT16_REF",F[F.DT_INT8_REF=106]="DT_INT8_REF",F[F.DT_STRING_REF=107]="DT_STRING_REF",F[F.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",F[F.DT_INT64_REF=109]="DT_INT64_REF",F[F.DT_BOOL_REF=110]="DT_BOOL_REF",F[F.DT_QINT8_REF=111]="DT_QINT8_REF",F[F.DT_QUINT8_REF=112]="DT_QUINT8_REF",F[F.DT_QINT32_REF=113]="DT_QINT32_REF",F[F.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",F[F.DT_QINT16_REF=115]="DT_QINT16_REF",F[F.DT_QUINT16_REF=116]="DT_QUINT16_REF",F[F.DT_UINT16_REF=117]="DT_UINT16_REF",F[F.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",F[F.DT_HALF_REF=119]="DT_HALF_REF",F[F.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",F[F.DT_VARIANT_REF=121]="DT_VARIANT_REF",F[F.DT_UINT32_REF=122]="DT_UINT32_REF",F[F.DT_UINT64_REF=123]="DT_UINT64_REF"}(H||(H={})),function(F){let $;!function(F){F[F.LEGACY=0]="LEGACY",F[F.V1=1]="V1",F[F.V2=2]="V2"}($=F.CheckpointFormatVersion||(F.CheckpointFormatVersion={}))}(K||(K={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iR={};function registerOp(F,$){let V={tfOpName:F,category:"custom",inputs:[],attrs:[],customExecutor:$};iR[F]=V}function getRegisteredOp(F){return iR[F]}function deregisterOp(F){delete iR[F]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getParamValue(F,$,V,G,H){let K=$.inputParams[F];if(K&&void 0!==K.inputIndexStart){let F=K.inputIndexStart,Z=0===K.inputIndexEnd?void 0:void 0===K.inputIndexEnd?F+1:K.inputIndexEnd,ee=F<0?$.inputNames.length+F:F;if("tensor"===K.type)return getTensor($.inputNames[ee],V,G,H);if("tensors"===K.type){let K=$.inputs.slice(F,Z),ee=$.inputNames.slice(F,Z).filter((F,$)=>{var V;return(null===(V=K[$])||void 0===V?void 0:V.op)!=="NoOp"});return ee.map(F=>getTensor(F,V,G,H))}let et=getTensor($.inputNames[ee],V,G,H),en=et.dataSync();return"number"===K.type?en[0]:eD.D5U.toNestedArray(et.shape,en)}let Z=$.attrParams[F];return Z&&Z.value}function getTensor(F,$,V,G){let[H,K]=parseNodeName(F,V);if(null!=G){let F=G.getHashTableHandleByName(H);if(null!=F)return F}let Z=V.currentContextIds.find(F=>!!$[getNodeNameWithContextId(H,F)]);return void 0!==Z?$[getNodeNameWithContextId(H,Z)][K]:void 0}function getTensorsForCurrentContext(F,$,V){return $[getNodeNameWithContextId(F,V.currentContextId)]}function getNodeNameAndIndex(F,$){let[V,G,H]=parseNodeName(F,$);return[getNodeNameWithContextId(V,$&&$.currentContextId),G,H]}function getNodeNameWithContextId(F,$){return $?`${F}-${$}`:F}function parseNodeName(F,$){let V;if(""===F)return["",0,void 0];let G=null!=$&&null!=$.parseNodeNameCache;if(G){let V=$.parseNodeNameCache.get(F);if(null!=V)return V}let H=F.split(":");if(1===H.length)V=[F,0,void 0];else{let F=H[0],$=3===H.length?H[1]:void 0,G=Number(H[H.length-1]);V=[F,G,$]}return G&&$.parseNodeNameCache.set(F,V),V}function getPadding(F,$,V){let G=getParamValue("pad",F,$,V);if("explicit"===G){G=getParamValue("explicitPaddings",F,$,V);let H=[[0,0],[0,0],[0,0],[0,0]];for(let F=0;F<4;F++)H[F][0]=G[2*F],H[F][1]=G[2*F+1];return H}return G}function cloneTensor(F){return F.kept?F:(0,eD.d9v)(F)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iF=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],iO=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],iP=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],iB=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],i$=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],iL=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],iz=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],iV=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],iU=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],iW=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],iG=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],iq=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],iH=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],iX=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],iK=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],iQ=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],iZ=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],iY=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],iJ=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var i1=V(21876).Buffer;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OperationMapper=class OperationMapper{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let F=[es,eu,ec,ep,eh,ef,ed,em,eg,ey,eb,ew,eS,e_,eN,ek,eI,eT,eC],$=[].concat(...F.map(F=>F.json));this.opMappers=$.reduce((F,$)=>(F[$.tfOpName]=$,F),{})}transformGraph(F,$={}){let V=F.node,G=[],H=[],K=[],Z=V.reduce((F,$)=>(F[$.name]=this.mapNode($),$.op.startsWith("Placeholder")?G.push(F[$.name]):"Const"===$.op?H.push(F[$.name]):(null==$.input||0===$.input.length)&&K.push(F[$.name]),F),{}),ee=[],et=[],en={},ea={};null!=$&&(en=this.mapSignatureEntries($.inputs),ea=this.mapSignatureEntries($.outputs));let ei=Object.keys(Z);ei.forEach(F=>{let $=Z[F];$.inputNames.forEach((F,V)=>{let[G,,H]=getNodeNameAndIndex(F),K=Z[G];if(null!=K.outputs){let F=K.outputs.indexOf(H);if(-1!==F){let H=`${G}:${F}`;$.inputNames[V]=H}}$.inputs.push(K),K.children.push($)})}),0===Object.keys(ea).length?ei.forEach(F=>{let $=Z[F];0===$.children.length&&et.push($)}):Object.keys(ea).forEach(F=>{let[$]=getNodeNameAndIndex(F),V=Z[$];null!=V&&(V.signatureKey=ea[F],et.push(V))}),Object.keys(en).length>0?Object.keys(en).forEach(F=>{let[$]=getNodeNameAndIndex(F),V=Z[$];V&&(V.signatureKey=en[F],ee.push(V))}):ee=G;let eo={};null!=F.library&&null!=F.library.function&&(eo=F.library.function.reduce((F,$)=>(F[$.signature.name]=this.mapFunction($),F),{}));let es={nodes:Z,inputs:ee,outputs:et,weights:H,placeholders:G,signature:$,functions:eo};return K.length>0&&(es.initNodes=K),es}mapSignatureEntries(F){return Object.keys(F||{}).reduce(($,V)=>($[F[V].name]=V,$),{})}mapNode(F){let $=getRegisteredOp(F.op)||this.opMappers[F.op]||{};null==F.attr&&(F.attr={});let V={name:F.name,op:F.op,category:$.category,inputNames:(F.input||[]).map(F=>F.startsWith("^")?F.slice(1):F),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:F.attr,outputs:$.outputs};return null!=$.inputs&&(V.inputParams=$.inputs.reduce((F,$)=>(F[$.name]={type:$.type,inputIndexStart:$.start,inputIndexEnd:$.end},F),{})),null!=$.attrs&&(V.attrParams=$.attrs.reduce(($,V)=>{let G;let H=V.type;switch(V.type){case"string":void 0===(G=getStringParam(F.attr,V.tfName,V.defaultValue))&&V.tfDeprecatedName&&(G=getStringParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"string[]":void 0===(G=getStringArrayParam(F.attr,V.tfName,V.defaultValue))&&V.tfDeprecatedName&&(G=getStringArrayParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"number":void 0===(G=getNumberParam(F.attr,V.tfName,V.defaultValue||0))&&V.tfDeprecatedName&&(G=getNumberParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"number[]":void 0===(G=getNumericArrayParam(F.attr,V.tfName,V.defaultValue))&&V.tfDeprecatedName&&(G=getNumericArrayParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"bool":void 0===(G=getBoolParam(F.attr,V.tfName,V.defaultValue))&&V.tfDeprecatedName&&(G=getBoolParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"bool[]":void 0===(G=getBoolArrayParam(F.attr,V.tfName,V.defaultValue))&&V.tfDeprecatedName&&(G=getBoolArrayParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"shape":void 0===(G=getTensorShapeParam(F.attr,V.tfName,V.defaultValue))&&V.tfDeprecatedName&&(G=getTensorShapeParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"shape[]":void 0===(G=getTensorShapeArrayParam(F.attr,V.tfName,V.defaultValue))&&V.tfDeprecatedName&&(G=getTensorShapeArrayParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"dtype":void 0===(G=getDtypeParam(F.attr,V.tfName,V.defaultValue))&&V.tfDeprecatedName&&(G=getDtypeParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"dtype[]":void 0===(G=getDtypeArrayParam(F.attr,V.tfName,V.defaultValue))&&V.tfDeprecatedName&&(G=getDtypeArrayParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"func":void 0===(G=getFuncParam(F.attr,V.tfName,V.defaultValue))&&V.tfDeprecatedName&&(G=getFuncParam(F.attr,V.tfDeprecatedName,V.defaultValue));break;case"tensor":case"tensors":break;default:throw Error(`Unsupported param type: ${V.type} for op: ${F.op}`)}return $[V.name]={value:G,type:H},$},{})),V}mapFunction(F){let $=F.nodeDef,V=[],G=[],H={};null!=$&&(H=$.reduce((F,$)=>(F[$.name]=this.mapNode($),"Const"===$.op&&G.push(F[$.name]),F),{}));let K=[],Z=[];F.signature.inputArg.forEach(F=>{let[$]=getNodeNameAndIndex(F.name),V={name:$,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:parseDtypeParam(F.type),type:"dtype"}},children:[]};V.signatureKey=F.name,K.push(V),H[$]=V});let ee=Object.keys(H);ee.forEach(F=>{let $=H[F];$.inputNames.forEach((F,V)=>{let[G,,K]=getNodeNameAndIndex(F),Z=H[G];if(null!=Z.outputs){let F=Z.outputs.indexOf(K);if(-1!==F){let H=`${G}:${F}`;$.inputNames[V]=H}}$.inputs.push(Z),Z.children.push($)})});let et=F.ret;F.signature.outputArg.forEach(F=>{let[$,V]=getNodeNameAndIndex(et[F.name]),G=H[$];null!=G&&(G.defaultOutput=V,Z.push(G))});let en=this.mapArgsToSignature(F);return{nodes:H,inputs:K,outputs:Z,weights:G,placeholders:V,signature:en}}mapArgsToSignature(F){return{methodName:F.signature.name,inputs:F.signature.inputArg.reduce((F,$)=>(F[$.name]=this.mapArgToTensorInfo($),F),{}),outputs:F.signature.outputArg.reduce(($,V)=>($[V.name]=this.mapArgToTensorInfo(V,F.ret),$),{})}}mapArgToTensorInfo(F,$){let V=F.name;return null!=$&&(V=$[V]),{name:V,dtype:F.type}}};function decodeBase64(F){let $=(0,eD.OBj)().global;if(void 0!==$.atob)return $.atob(F);if(void 0!==i1)return new i1(F,"base64").toString();throw Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function parseStringParam(F,$){let V=Array.isArray(F)?String.fromCharCode.apply(null,F):decodeBase64(F);return $?V:V.toLowerCase()}function getStringParam(F,$,V,G=!1){let H=F[$];return null!=H?parseStringParam(H.s,G):V}function getBoolParam(F,$,V){let G=F[$];return G?G.b:V}function getNumberParam(F,$,V){let G=F[$]||{},H=null!=G.i?G.i:null!=G.f?G.f:V;return"number"==typeof H?H:parseInt(H,10)}function parseDtypeParam(F){switch("string"==typeof F&&(F=H[F]),F){case H.DT_FLOAT:case H.DT_HALF:return"float32";case H.DT_INT32:case H.DT_INT64:case H.DT_INT8:case H.DT_UINT8:return"int32";case H.DT_BOOL:return"bool";case H.DT_DOUBLE:return"float32";case H.DT_STRING:return"string";default:return null}}function getFuncParam(F,$,V){let G=F[$];return G&&G.func?G.func.name:V}function getDtypeParam(F,$,V){let G=F[$];return G&&G.type?parseDtypeParam(G.type):V}function getDtypeArrayParam(F,$,V){let G=F[$];return G&&G.list&&G.list.type?G.list.type.map(F=>parseDtypeParam(F)):V}function parseTensorShapeParam(F){return F.unknownRank?void 0:null!=F.dim?F.dim.map(F=>"number"==typeof F.size?F.size:parseInt(F.size,10)):[]}function getTensorShapeParam(F,$,V){let G=F[$];return G&&G.shape?parseTensorShapeParam(G.shape):V}function getNumericArrayParam(F,$,V){let G=F[$];return G?((G.list.f&&G.list.f.length?G.list.f:G.list.i)||[]).map(F=>"number"==typeof F?F:parseInt(F,10)):V}function getStringArrayParam(F,$,V,G=!1){let H=F[$];return H&&H.list&&H.list.s?H.list.s.map(F=>parseStringParam(F,G)):V}function getTensorShapeArrayParam(F,$,V){let G=F[$];return G&&G.list&&G.list.shape?G.list.shape.map(F=>parseTensorShapeParam(F)):V}function getBoolArrayParam(F,$,V){let G=F[$];return G&&G.list&&G.list.b?G.list.b:V}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let NodeValueImpl=class NodeValueImpl{constructor(F,$,V){this.node=F,this.tensorMap=$,this.context=V,this.inputs=[],this.attrs={},this.inputs=F.inputNames.map(F=>this.getInput(F)),null!=F.rawAttrs&&(this.attrs=Object.keys(F.rawAttrs).reduce((F,$)=>(F[$]=this.getAttr($),F),{}))}getInput(F){return getTensor(F,this.tensorMap,this.context)}getAttr(F,$){let V=this.node.rawAttrs[F];if(null!=V.tensor)return getTensor(F,this.tensorMap,this.context);if(null!=V.i||null!=V.f)return getNumberParam(this.node.rawAttrs,F,$);if(null!=V.s)return getStringParam(this.node.rawAttrs,F,$);if(null!=V.b)return getBoolParam(this.node.rawAttrs,F,$);if(null!=V.shape)return getTensorShapeParam(this.node.rawAttrs,F,$);if(null!=V.type)return getDtypeParam(this.node.rawAttrs,F,$);if(null!=V.list){if(null!=V.list.i||null!=V.list.f)return getNumericArrayParam(this.node.rawAttrs,F,$);if(null!=V.list.s)return getStringArrayParam(this.node.rawAttrs,F,$);if(null!=V.list.shape)return getTensorShapeArrayParam(this.node.rawAttrs,F,$);if(null!=V.list.b)return getBoolArrayParam(this.node.rawAttrs,F,$);if(null!=V.list.type)return getDtypeArrayParam(this.node.rawAttrs,F,$)}return $}};var i2=V(72816);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let executeOp=(F,$,V,G=eE)=>{switch(F.op){case"BiasAdd":case"AddV2":case"Add":return[G.add(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"AddN":return[G.addN(getParamValue("tensors",F,$,V))];case"FloorMod":case"Mod":return[G.mod(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"Mul":return[G.mul(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"RealDiv":case"Div":return[G.div(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"DivNoNan":return[G.divNoNan(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"FloorDiv":return[G.floorDiv(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"Sub":return[G.sub(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"Minimum":return[G.minimum(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"Maximum":return[G.maximum(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"Pow":return[G.pow(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"SquaredDifference":return[G.squaredDifference(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];default:throw TypeError(`Node type ${F.op} is not implemented`)}},basic_math_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"Abs":case"ComplexAbs":return[G.abs(getParamValue("x",F,$,V))];case"Acos":return[G.acos(getParamValue("x",F,$,V))];case"Acosh":return[G.acosh(getParamValue("x",F,$,V))];case"Asin":return[G.asin(getParamValue("x",F,$,V))];case"Asinh":return[G.asinh(getParamValue("x",F,$,V))];case"Atan":return[G.atan(getParamValue("x",F,$,V))];case"Atan2":return[G.atan2(getParamValue("x",F,$,V),getParamValue("y",F,$,V))];case"Atanh":return[G.atanh(getParamValue("x",F,$,V))];case"Ceil":return[G.ceil(getParamValue("x",F,$,V))];case"Complex":return[G.complex(getParamValue("real",F,$,V),getParamValue("imag",F,$,V))];case"Cos":return[G.cos(getParamValue("x",F,$,V))];case"Cosh":return[G.cosh(getParamValue("x",F,$,V))];case"Elu":return[G.elu(getParamValue("x",F,$,V))];case"Erf":return[G.erf(getParamValue("x",F,$,V))];case"Exp":return[G.exp(getParamValue("x",F,$,V))];case"Expm1":return[G.expm1(getParamValue("x",F,$,V))];case"Floor":return[G.floor(getParamValue("x",F,$,V))];case"Log":return[G.log(getParamValue("x",F,$,V))];case"Log1p":return[G.log1p(getParamValue("x",F,$,V))];case"Imag":return[G.imag(getParamValue("x",F,$,V))];case"Neg":return[G.neg(getParamValue("x",F,$,V))];case"Reciprocal":return[G.reciprocal(getParamValue("x",F,$,V))];case"Real":return[G.real(getParamValue("x",F,$,V))];case"Relu":return[G.relu(getParamValue("x",F,$,V))];case"Round":return[G.round(getParamValue("x",F,$,V))];case"Selu":return[G.selu(getParamValue("x",F,$,V))];case"Sigmoid":return[G.sigmoid(getParamValue("x",F,$,V))];case"Sin":return[G.sin(getParamValue("x",F,$,V))];case"Sign":return[G.sign(getParamValue("x",F,$,V))];case"Sinh":return[G.sinh(getParamValue("x",F,$,V))];case"Softplus":return[G.softplus(getParamValue("x",F,$,V))];case"Sqrt":return[G.sqrt(getParamValue("x",F,$,V))];case"Square":return[G.square(getParamValue("x",F,$,V))];case"Tanh":return[G.tanh(getParamValue("x",F,$,V))];case"Tan":return[G.tan(getParamValue("x",F,$,V))];case"ClipByValue":return[G.clipByValue(getParamValue("x",F,$,V),getParamValue("clipValueMin",F,$,V),getParamValue("clipValueMax",F,$,V))];case"Relu6":return[G.relu6(getParamValue("x",F,$,V))];case"Rsqrt":return[G.rsqrt(getTensor(F.inputNames[0],$,V))];case"LeakyRelu":return[G.leakyRelu(getParamValue("x",F,$,V),getParamValue("alpha",F,$,V))];case"Prelu":return[G.prelu(getParamValue("x",F,$,V),getParamValue("alpha",F,$,V))];case"IsNan":return[G.isNaN(getTensor(F.inputNames[0],$,V))];case"IsInf":return[G.isInf(getTensor(F.inputNames[0],$,V))];case"IsFinite":return[G.isFinite(getTensor(F.inputNames[0],$,V))];default:throw TypeError(`Node type ${F.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertShapesMatchAllowUndefinedSize(F,$,V=""){if("number"!=typeof F&&"number"!=typeof $){eD.D5U.assert(F.length===$.length,()=>V+` Shapes ${F} and ${$} must match`);for(let G=0;G<F.length;G++){let H=F[G],K=$[G];eD.D5U.assert(H<0||K<0||H===K,()=>V+` Shapes ${F} and ${$} must match`)}}}function fullDefinedShape(F){return!("number"==typeof F||F.some(F=>F<0))}function inferElementShape(F,$,V){let G=mergeElementShape(F,V),H=!fullDefinedShape(G);if(H&&0===$.length)throw Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${G}`);if(H&&$.forEach(F=>{G=mergeElementShape(F.shape,G)}),!fullDefinedShape(G))throw Error(`Non-fully-defined elementShape: ${G}`);return G}function mergeElementShape(F,$){if("number"==typeof F)return $;if("number"==typeof $)return F;if(F.length!==$.length)throw Error(`Incompatible ranks during merge: ${F} vs. ${$}`);let V=[];for(let G=0;G<F.length;++G){let H=F[G],K=$[G];if(H>=0&&K>=0&&H!==K)throw Error(`Incompatible shape during merge: ${F} vs. ${$}`);V[G]=H>=0?H:K}return V}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TensorArray=class TensorArray{constructor(F,$,V,G,H,K,Z){this.name=F,this.dtype=$,this.maxSize=V,this.elementShape=G,this.identicalElementShapes=H,this.dynamicSize=K,this.clearAfterRead=Z,this.tensors=[],this.closed_=!1,this.idTensor=(0,eD.iD$)(0),(0,eD.CnY)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(F){this.tensors.forEach($=>{null!=F&&F.has($.tensor.id)||$.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(F){if(this.closed_)throw Error(`TensorArray ${this.name} has already been closed.`);if(F<0||F>=this.size())throw Error(`Tried to read from index ${F}, but array size is: ${this.size()}`);let $=this.tensors[F];if($.cleared)throw Error(`TensorArray ${this.name}: Could not read index ${F} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&($.cleared=!0),$.read=!0,$.tensor}readMany(F){return F.map(F=>this.read(F))}write(F,$){if(this.closed_)throw Error(`TensorArray ${this.name} has already been closed.`);if(F<0||!this.dynamicSize&&F>=this.maxSize)throw Error(`Tried to write to index ${F}, but array is not resizeable and size is: ${this.maxSize}`);let V=this.tensors[F]||{};if($.dtype!==this.dtype)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${F},
          because the value dtype is ${$.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=$.shape),assertShapesMatchAllowUndefinedSize(this.elementShape,$.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${F}.`),V.read)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${F}, because it has already been read.`);if(V.written)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${F}, because it has already been written.`);V.tensor=$,(0,eD.CnY)($),V.written=!0,this.tensors[F]=V}writeMany(F,$){if(F.length!==$.length)throw Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${F.length} is not the same as tensors size: ${$.length}.`);F.forEach((F,V)=>this.write(F,$[V]))}gather(F,$){if($&&$!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${$}`);if(F)F=F.slice(0,this.size());else{F=[];for(let $=0;$<this.size();$++)F.push($)}if(0===F.length)return(0,eD.XeE)([],[0].concat(this.elementShape));let V=this.readMany(F);return assertShapesMatchAllowUndefinedSize(this.elementShape,V[0].shape,"TensorArray shape mismatch: "),(0,eD.knu)(V,0)}concat(F){if(F&&F!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${F}`);if(0===this.size())return(0,eD.XeE)([],[0].concat(this.elementShape));let $=[];for(let F=0;F<this.size();F++)$.push(F);let V=this.readMany($);return assertShapesMatchAllowUndefinedSize(this.elementShape,V[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${V[0].shape})`),(0,eD.zoF)(V,0)}scatter(F,$){if($.dtype!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${$.dtype}`);if(F.length!==$.shape[0])throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${F.length} vs. ${$.shape[0]}`);let V=Math.max(...F);if(!this.dynamicSize&&V>=this.maxSize)throw Error(`Max index must be < array size (${V}  vs. ${this.maxSize})`);this.writeMany(F,(0,eD.HHK)($,0))}split(F,$){if($.dtype!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${$.dtype}`);let V=0,G=F.map(F=>V+=F);if(V!==$.shape[0])throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${V}, and tensor's shape is: ${$.shape}`);if(!this.dynamicSize&&F.length!==this.maxSize)throw Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${F.length}), and the TensorArray is not marked as dynamically resizeable`);let H=0===V?0:$.size/V,K=[];(0,eD.lub)(()=>{$=(0,eD.XLQ)($,[1,V,H]);for(let V=0;V<F.length;++V){let Z=0===V?0:G[V-1],ee=[0,Z,0],et=[1,F[V],H];K[V]=(0,eD.XLQ)((0,eD.tPi)($,ee,et),this.elementShape)}return K});let Z=[];for(let $=0;$<F.length;$++)Z[$]=$;this.writeMany(Z,K)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TensorList=class TensorList{get id(){return this.idTensor.id}constructor(F,$,V,G=-1){this.tensors=F,this.elementShape=$,this.elementDtype=V,null!=F&&F.forEach(F=>{if(V!==F.dtype)throw Error(`Invalid data types; op elements ${V}, but list elements ${F.dtype}`);assertShapesMatchAllowUndefinedSize($,F.shape,"TensorList shape mismatch: "),(0,eD.CnY)(F)}),this.idTensor=(0,eD.iD$)(0),this.maxNumElements=G,(0,eD.CnY)(this.idTensor)}copy(){return new TensorList([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(F){this.tensors.forEach($=>{null!=F&&F.has($.id)||$.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(F,$,V=-1){if($!==this.elementDtype)throw Error(`Invalid data types; op elements ${$}, but list elements ${this.elementDtype}`);if(-1!==V&&this.tensors.length!==V)throw Error(`Operation expected a list with ${V} elements but got a list with ${this.tensors.length} elements.`);assertShapesMatchAllowUndefinedSize(F,this.elementShape,"TensorList shape mismatch: ");let G=inferElementShape(this.elementShape,this.tensors,F);return(0,eD.lub)(()=>{let F=this.tensors.map(F=>(0,eD.XLQ)(F,G));return(0,eD.knu)(F,0)})}popBack(F,$){if($!==this.elementDtype)throw Error(`Invalid data types; op elements ${$}, but list elements ${this.elementDtype}`);if(0===this.size())throw Error("Trying to pop from an empty list.");let V=inferElementShape(this.elementShape,this.tensors,F),G=this.tensors.pop();return G.kept=!1,assertShapesMatchAllowUndefinedSize(G.shape,F,"TensorList shape mismatch: "),(0,eD.XLQ)(G,V)}pushBack(F){if(F.dtype!==this.elementDtype)throw Error(`Invalid data types; op elements ${F.dtype}, but list elements ${this.elementDtype}`);if(assertShapesMatchAllowUndefinedSize(F.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw Error("Trying to push element into a full list.");(0,eD.CnY)(F),this.tensors.push(F)}resize(F){if(F<0)throw Error(`TensorListResize expects size to be non-negative. Got: ${F}`);if(-1!==this.maxNumElements&&F>this.maxNumElements)throw Error(`TensorListResize input size ${F} is greater maxNumElement ${this.maxNumElements}.`);let $=new TensorList([],this.elementShape,this.elementDtype,this.maxNumElements);$.tensors.length=F;for(let V=0;V<Math.min(this.tensors.length,F);++V)$.tensors[V]=this.tensors[V];return $}getItem(F,$,V){if(V!==this.elementDtype)throw Error(`Invalid data types; op elements ${V}, but list elements ${this.elementDtype}`);if(F<0||F>this.tensors.length)throw Error(`Trying to access element ${F} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[F])throw Error(`element at index ${F} is null.`);assertShapesMatchAllowUndefinedSize(this.tensors[F].shape,$,"TensorList shape mismatch: ");let G=inferElementShape(this.elementShape,this.tensors,$);return(0,eD.XLQ)(this.tensors[F],G)}setItem(F,$){if($.dtype!==this.elementDtype)throw Error(`Invalid data types; op elements ${$.dtype}, but list elements ${this.elementDtype}`);if(F<0||-1!==this.maxNumElements&&F>=this.maxNumElements)throw Error(`Trying to set element ${F} in a list with max ${this.maxNumElements} elements.`);assertShapesMatchAllowUndefinedSize(this.elementShape,$.shape,"TensorList shape mismatch: "),(0,eD.CnY)($),null!=this.tensors[F]&&(this.tensors[F].kept=!1),this.tensors[F]=$}gather(F,$,V){if($!==this.elementDtype)throw Error(`Invalid data types; op elements ${$}, but list elements ${this.elementDtype}`);assertShapesMatchAllowUndefinedSize(this.elementShape,V,"TensorList shape mismatch: "),F=F.slice(0,this.size());let G=inferElementShape(this.elementShape,this.tensors,V);return 0===F.length?(0,eD.XeE)([],[0].concat(G)):(0,eD.lub)(()=>{let $=F.map(F=>(0,eD.XLQ)(this.tensors[F],G));return(0,eD.knu)($,0)})}concat(F,$){if(F&&F!==this.elementDtype)throw Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${F}`);assertShapesMatchAllowUndefinedSize(this.elementShape,$,"TensorList shape mismatch: ");let V=inferElementShape(this.elementShape,this.tensors,$);return 0===this.size()?(0,eD.XeE)([],[0].concat(V)):(0,eD.lub)(()=>{let F=this.tensors.map(F=>(0,eD.XLQ)(F,V));return(0,eD.zoF)(F,0)})}};function fromTensor(F,$,V){let G=F.dtype;if(F.shape.length<1)throw Error(`Tensor must be at least a vector, but saw shape: ${F.shape}`);if(F.dtype!==V)throw Error(`Invalid data types; op elements ${F.dtype}, but list elements ${V}`);let H=F.shape.slice(1);assertShapesMatchAllowUndefinedSize(H,$,"TensorList shape mismatch: ");let K=(0,eD.HHK)(F);return new TensorList(K,$,G)}function reserve(F,$,V,G){return new TensorList([],F,$,G)}function scatter(F,$,V,G){if($.length!==F.shape[0])throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${$.length} vs. ${F.shape[0]}`);let H=Math.max(...$);if(null!=G&&-1!==G&&H>=G)throw Error(`Max index must be < array size (${H}  vs. ${G})`);let K=new TensorList([],V,F.dtype,G),Z=(0,eD.HHK)(F,0);return $.forEach((F,$)=>{K.setItem(F,Z[$])}),K}function tensor_list_split(F,$,V){let G=0,H=$.map(F=>G+=F);if(G!==F.shape[0])throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${G}, and tensor's shape is: ${F.shape}`);let K=F.shape.slice(1),Z=mergeElementShape(K,V),ee=0===G?0:F.size/G,et=(0,eD.lub)(()=>{let V=[];F=(0,eD.XLQ)(F,[1,G,ee]);for(let G=0;G<$.length;++G){let K=0===G?0:H[G-1],et=[0,K,0],en=[1,$[G],ee];V[G]=(0,eD.XLQ)((0,eD.tPi)(F,et,en),Z)}return F.dispose(),V}),en=new TensorList([],V,F.dtype,$.length);for(let F=0;F<et.length;F++)en.setItem(F,et[F]);return en}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let control_executor_executeOp=async(F,$,V)=>{switch(F.op){case"If":case"StatelessIf":{let G=getParamValue("thenBranch",F,$,V),H=getParamValue("elseBranch",F,$,V),K=getParamValue("cond",F,$,V),Z=getParamValue("args",F,$,V),ee=await K.data();if(ee[0])return V.functionMap[G].executeFunctionAsync(Z,V.tensorArrayMap,V.tensorListMap);return V.functionMap[H].executeFunctionAsync(Z,V.tensorArrayMap,V.tensorListMap)}case"While":case"StatelessWhile":{let G=getParamValue("body",F,$,V),H=getParamValue("cond",F,$,V),K=getParamValue("args",F,$,V),Z=await V.functionMap[H].executeFunctionAsync(K,V.tensorArrayMap,V.tensorListMap),ee=K.map(F=>F.id),et=await Z[0].data();Z.forEach(F=>{F.kept||-1!==ee.indexOf(F.id)||F.dispose()});let en=K;for(;et[0];){let F=en;en=await V.functionMap[G].executeFunctionAsync(en,V.tensorArrayMap,V.tensorListMap);let $=en.map(F=>F.id);F.forEach(F=>{F.kept||-1!==ee.indexOf(F.id)||-1!==$.indexOf(F.id)||F.dispose()});let K=await V.functionMap[H].executeFunctionAsync(en,V.tensorArrayMap,V.tensorListMap);et=await K[0].data(),K.forEach(F=>{F.kept||-1!==ee.indexOf(F.id)||-1!==$.indexOf(F.id)||F.dispose()})}return en}case"LoopCond":{let G=getParamValue("pred",F,$,V);return[cloneTensor(G)]}case"Switch":{let G=getParamValue("pred",F,$,V),H=getParamValue("data",F,$,V);return H.kept||(H=cloneTensor(H)),(await G.data())[0]?[void 0,H]:[H,void 0]}case"Merge":{let G=F.inputNames.find(F=>void 0!==getTensor(F,$,V));if(G){let F=getTensor(G,$,V);return[cloneTensor(F)]}return}case"Enter":{let G=getParamValue("frameName",F,$,V),H=getParamValue("tensor",F,$,V);return V.enterFrame(G),[cloneTensor(H)]}case"Exit":{let G=getParamValue("tensor",F,$,V);return V.exitFrame(),[cloneTensor(G)]}case"NextIteration":{let G=getParamValue("tensor",F,$,V);return V.nextIteration(),[cloneTensor(G)]}case"TensorArrayV3":{let G=getParamValue("size",F,$,V),H=getParamValue("dtype",F,$,V),K=getParamValue("elementShape",F,$,V),Z=getParamValue("dynamicSize",F,$,V),ee=getParamValue("clearAfterRead",F,$,V),et=getParamValue("identicalElementShapes",F,$,V),en=getParamValue("name",F,$,V),ea=new TensorArray(en,H,G,K,et,Z,ee);return V.addTensorArray(ea),[ea.idTensor,(0,eD.iD$)(1)]}case"TensorArrayWriteV3":{let G=getParamValue("tensorArrayId",F,$,V),H=getParamValue("index",F,$,V),K=getParamValue("tensor",F,$,V),Z=V.getTensorArray(G.id);return Z.write(H,K),[Z.idTensor]}case"TensorArrayReadV3":{let G=getParamValue("tensorArrayId",F,$,V),H=getParamValue("index",F,$,V),K=V.getTensorArray(G.id);return[K.read(H)]}case"TensorArrayGatherV3":{let G=getParamValue("tensorArrayId",F,$,V),H=getParamValue("indices",F,$,V),K=getParamValue("dtype",F,$,V),Z=V.getTensorArray(G.id);return[Z.gather(H,K)]}case"TensorArrayScatterV3":{let G=getParamValue("tensorArrayId",F,$,V),H=getParamValue("indices",F,$,V),K=getParamValue("tensor",F,$,V),Z=V.getTensorArray(G.id);return Z.scatter(H,K),[Z.idTensor]}case"TensorArrayConcatV3":{let G=getParamValue("tensorArrayId",F,$,V),H=V.getTensorArray(G.id),K=getParamValue("dtype",F,$,V);return[H.concat(K)]}case"TensorArraySplitV3":{let G=getParamValue("tensorArrayId",F,$,V),H=getParamValue("tensor",F,$,V),K=getParamValue("lengths",F,$,V),Z=V.getTensorArray(G.id);return Z.split(K,H),[Z.idTensor]}case"TensorArraySizeV3":{let G=getParamValue("tensorArrayId",F,$,V),H=V.getTensorArray(G.id);return[(0,eD.iD$)(H.size(),"int32")]}case"TensorArrayCloseV3":{let G=getParamValue("tensorArrayId",F,$,V),H=V.getTensorArray(G.id);return H.clearAndClose(),[H.idTensor]}case"TensorListSetItem":{let G=getParamValue("tensorListId",F,$,V),H=getParamValue("index",F,$,V),K=getParamValue("tensor",F,$,V),Z=V.getTensorList(G.id);return Z.setItem(H,K),[Z.idTensor]}case"TensorListGetItem":{let G=getParamValue("tensorListId",F,$,V),H=getParamValue("index",F,$,V),K=getParamValue("elementShape",F,$,V),Z=getParamValue("elementDType",F,$,V),ee=V.getTensorList(G.id);return[ee.getItem(H,K,Z)]}case"TensorListScatterV2":case"TensorListScatter":{let G=getParamValue("indices",F,$,V),H=getParamValue("tensor",F,$,V),K=getParamValue("elementShape",F,$,V),Z=getParamValue("numElements",F,$,V),ee=scatter(H,G,K,Z);return V.addTensorList(ee),[ee.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let G;let H=getParamValue("elementShape",F,$,V),K=getParamValue("elementDType",F,$,V);G="TensorListReserve"===F.op?"numElements":"maxNumElements";let Z=getParamValue(G,F,$,V),ee="TensorListReserve"===F.op?-1:Z,et=reserve(H,K,Z,ee);return V.addTensorList(et),[et.idTensor]}case"TensorListGather":{let G=getParamValue("tensorListId",F,$,V),H=getParamValue("indices",F,$,V),K=getParamValue("elementShape",F,$,V),Z=getParamValue("elementDType",F,$,V),ee=V.getTensorList(G.id);return[ee.gather(H,Z,K)]}case"TensorListStack":{let G=getParamValue("tensorListId",F,$,V),H=getParamValue("elementShape",F,$,V),K=getParamValue("elementDType",F,$,V),Z=getParamValue("numElements",F,$,V),ee=V.getTensorList(G.id);return[ee.stack(H,K,Z)]}case"TensorListFromTensor":{let G=getParamValue("tensor",F,$,V),H=getParamValue("elementShape",F,$,V),K=getParamValue("elementDType",F,$,V),Z=fromTensor(G,H,K);return V.addTensorList(Z),[Z.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let G=getParamValue("tensorListId",F,$,V),H=V.getTensorList(G.id),K=getParamValue("dtype",F,$,V),Z=getParamValue("elementShape",F,$,V);return[H.concat(K,Z)]}case"TensorListPushBack":{let G=getParamValue("tensorListId",F,$,V),H=getParamValue("tensor",F,$,V),K=V.getTensorList(G.id);return K.pushBack(H),[K.idTensor]}case"TensorListPopBack":{let G=getParamValue("tensorListId",F,$,V),H=getParamValue("elementShape",F,$,V),K=getParamValue("elementDType",F,$,V),Z=V.getTensorList(G.id);return[Z.popBack(H,K)]}case"TensorListSplit":{let G=getParamValue("tensor",F,$,V),H=getParamValue("elementShape",F,$,V),K=getParamValue("lengths",F,$,V),Z=tensor_list_split(G,K,H);return V.addTensorList(Z),[Z.idTensor]}case"TensorListLength":{let G=getParamValue("tensorListId",F,$,V),H=V.getTensorList(G.id);return[(0,eD.iD$)(H.size(),"int32")]}case"TensorListResize":{let G=getParamValue("tensorListId",F,$,V),H=getParamValue("size",F,$,V),K=V.getTensorList(G.id),Z=K.resize(H);return V.addTensorList(Z),[Z.idTensor]}default:throw TypeError(`Node type ${F.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedConvAndDepthWiseParams(F,$,V){let[G,H]=getParamValue("fusedOps",F,$,V),K="biasadd"===G,Z=!K,ee="prelu"===H,et="fusedbatchnorm"===G,en=getParamValue("numArgs",F,$,V);if(K){if(ee&&2!==en)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!ee&&K&&1!==en)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(et)throw Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let ea=getParamValue("strides",F,$,V),ei=getPadding(F,$,V),eo=getParamValue("dataFormat",F,$,V).toUpperCase(),es=getParamValue("dilations",F,$,V),[eu,ec]=getParamValue("args",F,$,V);Z&&(ec=eu,eu=void 0);let ep=getParamValue("leakyreluAlpha",F,$,V);return{stride:ea,pad:ei,dataFormat:eo,dilations:es,biasArg:eu,preluArg:ec,activationFunc:H,leakyreluAlpha:ep}}let convolution_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"Conv1D":{let H=getParamValue("stride",F,$,V),K=getParamValue("pad",F,$,V),Z=getParamValue("dataFormat",F,$,V).toUpperCase(),ee=getParamValue("dilation",F,$,V);return[G.conv1d(getParamValue("x",F,$,V),getParamValue("filter",F,$,V),H,K,Z,ee)]}case"Conv2D":{let H=getParamValue("strides",F,$,V),K=getPadding(F,$,V),Z=getParamValue("dataFormat",F,$,V).toUpperCase(),ee=getParamValue("dilations",F,$,V);return[G.conv2d(getParamValue("x",F,$,V),getParamValue("filter",F,$,V),[H[1],H[2]],K,Z,[ee[1],ee[2]])]}case"_FusedConv2D":{let{stride:H,pad:K,dataFormat:Z,dilations:ee,biasArg:et,preluArg:en,activationFunc:ea,leakyreluAlpha:ei}=fusedConvAndDepthWiseParams(F,$,V);return[G.fused.conv2d({x:getParamValue("x",F,$,V),filter:getParamValue("filter",F,$,V),strides:[H[1],H[2]],pad:K,dataFormat:Z,dilations:[ee[1],ee[2]],bias:et,activation:ea,preluActivationWeights:en,leakyreluAlpha:ei})]}case"FusedDepthwiseConv2dNative":{let{stride:H,pad:K,dataFormat:Z,dilations:ee,biasArg:et,preluArg:en,activationFunc:ea,leakyreluAlpha:ei}=fusedConvAndDepthWiseParams(F,$,V);return[G.fused.depthwiseConv2d({x:getParamValue("x",F,$,V),filter:getParamValue("filter",F,$,V),strides:[H[1],H[2]],pad:K,dataFormat:Z,dilations:[ee[1],ee[2]],bias:et,activation:ea,preluActivationWeights:en,leakyreluAlpha:ei})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let H=getParamValue("outputShape",F,$,V),K=getParamValue("strides",F,$,V),Z=getPadding(F,$,V);return[G.conv2dTranspose(getParamValue("x",F,$,V),getParamValue("filter",F,$,V),H,[K[1],K[2]],Z)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let H=getParamValue("strides",F,$,V),K=getPadding(F,$,V),Z=getParamValue("dilations",F,$,V),ee=getParamValue("dataFormat",F,$,V).toUpperCase();return[G.depthwiseConv2d(getParamValue("input",F,$,V),getParamValue("filter",F,$,V),[H[1],H[2]],K,ee,[Z[1],Z[2]])]}case"Conv3D":{let H=getParamValue("strides",F,$,V),K=getParamValue("pad",F,$,V),Z=getParamValue("dataFormat",F,$,V).toUpperCase(),ee=getParamValue("dilations",F,$,V);return[G.conv3d(getParamValue("x",F,$,V),getParamValue("filter",F,$,V),[H[1],H[2],H[3]],K,Z,[ee[1],ee[2],ee[3]])]}case"AvgPool":{let H=getParamValue("strides",F,$,V),K=getParamValue("pad",F,$,V),Z=getParamValue("kernelSize",F,$,V);return[G.avgPool(getParamValue("x",F,$,V),[Z[1],Z[2]],[H[1],H[2]],K)]}case"MaxPool":{let H=getParamValue("strides",F,$,V),K=getParamValue("pad",F,$,V),Z=getParamValue("kernelSize",F,$,V);return[G.maxPool(getParamValue("x",F,$,V),[Z[1],Z[2]],[H[1],H[2]],K)]}case"MaxPoolWithArgmax":{let H=getParamValue("strides",F,$,V),K=getParamValue("pad",F,$,V),Z=getParamValue("kernelSize",F,$,V),ee=getParamValue("includeBatchInIndex",F,$,V),{result:et,indexes:en}=G.maxPoolWithArgmax(getParamValue("x",F,$,V),[Z[1],Z[2]],[H[1],H[2]],K,ee);return[et,en]}case"AvgPool3D":{let H=getParamValue("strides",F,$,V),K=getParamValue("pad",F,$,V),Z=getParamValue("kernelSize",F,$,V);return[G.avgPool3d(getParamValue("x",F,$,V),[Z[1],Z[2],Z[3]],[H[1],H[2],H[3]],K)]}case"MaxPool3D":{let H=getParamValue("strides",F,$,V),K=getParamValue("pad",F,$,V),Z=getParamValue("kernelSize",F,$,V);return[G.maxPool3d(getParamValue("x",F,$,V),[Z[1],Z[2],Z[3]],[H[1],H[2],H[3]],K)]}case"Dilation2D":{let H=getParamValue("strides",F,$,V),K=getParamValue("pad",F,$,V),Z=getParamValue("dilations",F,$,V),ee=H[1],et=H[2],en=Z[1],ea=Z[2];return[G.dilation2d(getParamValue("x",F,$,V),getParamValue("filter",F,$,V),[ee,et],K,[en,ea],"NHWC")]}default:throw TypeError(`Node type ${F.op} is not implemented`)}},creation_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"Fill":{let H=getParamValue("shape",F,$,V),K=getParamValue("dtype",F,$,V),Z=getParamValue("value",F,$,V);return[G.fill(H,Z,K)]}case"LinSpace":{let H=getParamValue("start",F,$,V),K=getParamValue("stop",F,$,V),Z=getParamValue("num",F,$,V);return[G.linspace(H,K,Z)]}case"Multinomial":{let H=getParamValue("logits",F,$,V),K=getParamValue("numSamples",F,$,V),Z=getParamValue("seed",F,$,V);return[G.multinomial(H,K,Z)]}case"OneHot":{let H=getParamValue("indices",F,$,V),K=getParamValue("depth",F,$,V),Z=getParamValue("onValue",F,$,V),ee=getParamValue("offValue",F,$,V),et=getParamValue("dtype",F,$,V);return[G.oneHot(H,K,Z,ee,et)]}case"Ones":return[G.ones(getParamValue("shape",F,$,V),getParamValue("dtype",F,$,V))];case"OnesLike":return[G.onesLike(getParamValue("x",F,$,V))];case"RandomStandardNormal":return[G.randomStandardNormal(getParamValue("shape",F,$,V),getParamValue("dtype",F,$,V),getParamValue("seed",F,$,V))];case"RandomUniform":return[G.randomUniform(getParamValue("shape",F,$,V),getParamValue("minval",F,$,V),getParamValue("maxval",F,$,V),getParamValue("dtype",F,$,V))];case"RandomUniformInt":return[G.randomUniformInt(getParamValue("shape",F,$,V),getParamValue("minval",F,$,V),getParamValue("maxval",F,$,V),getParamValue("seed",F,$,V))];case"Range":{let H=getParamValue("start",F,$,V),K=getParamValue("stop",F,$,V),Z=getParamValue("step",F,$,V);return[G.range(H,K,Z,getParamValue("dtype",F,$,V))]}case"TruncatedNormal":{let H=getParamValue("shape",F,$,V),K=getParamValue("mean",F,$,V),Z=getParamValue("stdDev",F,$,V),ee=getParamValue("seed",F,$,V);return[G.truncatedNormal(H,K,Z,getParamValue("dtype",F,$,V),ee)]}case"Zeros":return[G.zeros(getParamValue("shape",F,$,V),getParamValue("dtype",F,$,V))];case"ZerosLike":return[G.zerosLike(getParamValue("x",F,$,V))];default:throw TypeError(`Node type ${F.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nmsParams(F,$,V){let G=getParamValue("boxes",F,$,V),H=getParamValue("scores",F,$,V),K=getParamValue("maxOutputSize",F,$,V),Z=getParamValue("iouThreshold",F,$,V),ee=getParamValue("scoreThreshold",F,$,V),et=getParamValue("softNmsSigma",F,$,V);return{boxes:G,scores:H,maxOutputSize:K,iouThreshold:Z,scoreThreshold:ee,softNmsSigma:et}}let dynamic_executor_executeOp=async(F,$,V,G,H=eE)=>{switch(F.op){case"NonMaxSuppressionV5":{let{boxes:G,scores:K,maxOutputSize:Z,iouThreshold:ee,scoreThreshold:et,softNmsSigma:en}=nmsParams(F,$,V),ea=await H.image.nonMaxSuppressionWithScoreAsync(G,K,Z,ee,et,en);return[ea.selectedIndices,ea.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:G,scores:K,maxOutputSize:Z,iouThreshold:ee,scoreThreshold:et}=nmsParams(F,$,V),en=getParamValue("padToMaxOutputSize",F,$,V),ea=await H.image.nonMaxSuppressionPaddedAsync(G,K,Z,ee,et,en);return[ea.selectedIndices,ea.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:G,scores:K,maxOutputSize:Z,iouThreshold:ee,scoreThreshold:et}=nmsParams(F,$,V);return[await H.image.nonMaxSuppressionAsync(G,K,Z,ee,et)]}case"Where":{let G=H.cast(getParamValue("condition",F,$,V),"bool"),K=[await H.whereAsync(G)];return G.dispose(),K}case"ListDiff":return H.setdiff1dAsync(getParamValue("x",F,$,V),getParamValue("y",F,$,V));default:throw TypeError(`Node type ${F.op} is not implemented`)}},evaluation_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"LowerBound":{let H=getParamValue("sortedSequence",F,$,V),K=getParamValue("values",F,$,V);return[G.lowerBound(H,K)]}case"TopKV2":{let H=getParamValue("x",F,$,V),K=getParamValue("k",F,$,V),Z=getParamValue("sorted",F,$,V),ee=G.topk(H,K,Z);return[ee.values,ee.indices]}case"UpperBound":{let H=getParamValue("sortedSequence",F,$,V),K=getParamValue("values",F,$,V);return[G.upperBound(H,K)]}case"Unique":{let H=getParamValue("x",F,$,V),K=G.unique(H);return[K.values,K.indices]}case"UniqueV2":{let H=getParamValue("x",F,$,V),K=getParamValue("axis",F,$,V),Z=G.unique(H,K);return[Z.values,Z.indices]}default:throw TypeError(`Node type ${F.op} is not implemented`)}},graph_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"Const":return $[F.name];case"PlaceholderWithDefault":let H=getParamValue("default",F,$,V);return[getTensor(F.name,$,V)||H];case"Placeholder":return[getTensor(F.name,$,V)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let G=getParamValue("x",F,$,V);return[cloneTensor(G)]}case"IdentityN":return getParamValue("x",F,$,V).map(F=>cloneTensor(F));case"Snapshot":let K=getParamValue("x",F,$,V);return[cloneTensor(K)];case"Shape":return[G.tensor1d(getParamValue("x",F,$,V).shape,"int32")];case"ShapeN":return getParamValue("x",F,$,V).map(F=>G.tensor1d(F.shape));case"Size":return[G.scalar(getParamValue("x",F,$,V).size,"int32")];case"Rank":return[G.scalar(getParamValue("x",F,$,V).rank,"int32")];case"NoOp":return[G.scalar(1)];case"Print":let Z=getParamValue("x",F,$,V),ee=getParamValue("data",F,$,V),et=getParamValue("message",F,$,V),en=getParamValue("summarize",F,$,V);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(et);for(let F=0;F<ee.length;F++)console.log(Array.prototype.slice.call(ee[F].dataSync()).slice(0,en));return[Z];default:throw TypeError(`Node type ${F.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let HashTable=class HashTable{get id(){return this.handle.id}constructor(F,$){this.keyDType=F,this.valueDType=$,this.handle=(0,eD.iD$)(0),this.tensorMap=new Map,(0,eD.CnY)(this.handle)}clearAndClose(){this.tensorMap.forEach(F=>F.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return eL.i(this.size(),"int32")}async import(F,$){this.checkKeyAndValueTensor(F,$);let V=await F.data();return this.tensorMap.forEach(F=>F.dispose()),this.tensorMap.clear(),(0,eD.lub)(()=>{let F=(0,eD.HHK)($),G=V.length,H=F.length;eD.D5U.assert(G===H,()=>`The number of elements doesn't match, keys has ${G} elements, the values has ${H} elements.`);for(let $=0;$<G;$++){let G=V[$],H=F[$];(0,eD.CnY)(H),this.tensorMap.set(G,H)}return this.handle})}async find(F,$){this.checkKeyAndValueTensor(F,$);let V=await F.data();return(0,eD.lub)(()=>{let F=[];for(let G=0;G<V.length;G++){let H=V[G],K=this.findWithDefault(H,$);F.push(K)}return(0,eD.knu)(F)})}findWithDefault(F,$){let V=this.tensorMap.get(F);return null!=V?V:$}checkKeyAndValueTensor(F,$){if(F.dtype!==this.keyDType)throw Error(`Expect key dtype ${this.keyDType}, but got ${F.dtype}`);if($.dtype!==this.valueDType)throw Error(`Expect value dtype ${this.valueDType}, but got ${$.dtype}`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hash_table_executor_executeOp=async(F,$,V,G)=>{switch(F.op){case"HashTable":case"HashTableV2":{let H=G.getHashTableHandleByName(F.name);if(null!=H)return[H];{let H=getParamValue("keyDType",F,$,V),K=getParamValue("valueDType",F,$,V),Z=new HashTable(H,K);return G.addHashTable(F.name,Z),[Z.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let H=getParamValue("tableHandle",F,$,V,G),K=getParamValue("keys",F,$,V),Z=getParamValue("values",F,$,V),ee=G.getHashTableById(H.id);return[await ee.import(K,Z)]}case"LookupTableFind":case"LookupTableFindV2":{let H=getParamValue("tableHandle",F,$,V,G),K=getParamValue("keys",F,$,V),Z=getParamValue("defaultValue",F,$,V),ee=G.getHashTableById(H.id);return[await ee.find(K,Z)]}case"LookupTableSize":case"LookupTableSizeV2":{let H=getParamValue("tableHandle",F,$,V,G),K=G.getHashTableById(H.id);return[K.tensorSize()]}default:throw TypeError(`Node type ${F.op} is not implemented`)}},image_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"ResizeBilinear":{let H=getParamValue("images",F,$,V),K=getParamValue("size",F,$,V),Z=getParamValue("alignCorners",F,$,V),ee=getParamValue("halfPixelCenters",F,$,V);return[G.image.resizeBilinear(H,[K[0],K[1]],Z,ee)]}case"ResizeNearestNeighbor":{let H=getParamValue("images",F,$,V),K=getParamValue("size",F,$,V),Z=getParamValue("alignCorners",F,$,V),ee=getParamValue("halfPixelCenters",F,$,V);return[G.image.resizeNearestNeighbor(H,[K[0],K[1]],Z,ee)]}case"CropAndResize":{let H=getParamValue("image",F,$,V),K=getParamValue("boxes",F,$,V),Z=getParamValue("boxInd",F,$,V),ee=getParamValue("cropSize",F,$,V),et=getParamValue("method",F,$,V),en=getParamValue("extrapolationValue",F,$,V);return[G.image.cropAndResize(H,K,Z,ee,et,en)]}case"ImageProjectiveTransformV3":{let H=getParamValue("images",F,$,V),K=getParamValue("transforms",F,$,V),Z=getParamValue("outputShape",F,$,V),ee=getParamValue("fillValue",F,$,V),et=getParamValue("interpolation",F,$,V),en=getParamValue("fillMode",F,$,V);return[G.image.transform(H,K,et.toLowerCase(),en.toLowerCase(),ee,Z)]}default:throw TypeError(`Node type ${F.op} is not implemented`)}},logical_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"Equal":return[G.equal(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"NotEqual":return[G.notEqual(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"Greater":return[G.greater(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"GreaterEqual":return[G.greaterEqual(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"Less":return[G.less(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"LessEqual":return[G.lessEqual(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"LogicalAnd":return[G.logicalAnd(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"LogicalNot":return[G.logicalNot(getParamValue("a",F,$,V))];case"LogicalOr":return[G.logicalOr(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"Select":case"SelectV2":return[G.where(getParamValue("condition",F,$,V),getParamValue("a",F,$,V),getParamValue("b",F,$,V))];case"BitwiseAnd":return[G.bitwiseAnd(getParamValue("a",F,$,V),getParamValue("b",F,$,V))];default:throw TypeError(`Node type ${F.op} is not implemented`)}},matrices_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[G.matMul(getParamValue("a",F,$,V),getParamValue("b",F,$,V),getParamValue("transposeA",F,$,V),getParamValue("transposeB",F,$,V))];case"Einsum":return[G.einsum(getParamValue("equation",F,$,V),...getParamValue("tensors",F,$,V))];case"Transpose":return[G.transpose(getParamValue("x",F,$,V),getParamValue("perm",F,$,V))];case"_FusedMatMul":let[H,K]=getParamValue("fusedOps",F,$,V),Z="biasadd"===H,ee="prelu"===K,et=getParamValue("numArgs",F,$,V),en=getParamValue("leakyreluAlpha",F,$,V);if(Z){if(ee&&2!==et)throw Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!ee&&1!==et)throw Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[ea,ei]=getParamValue("args",F,$,V);return[G.fused.matMul({a:getParamValue("a",F,$,V),b:getParamValue("b",F,$,V),transposeA:getParamValue("transposeA",F,$,V),transposeB:getParamValue("transposeB",F,$,V),bias:ea,activation:K,preluActivationWeights:ei,leakyreluAlpha:en})];case"MatrixBandPart":return[G.linalg.bandPart(getParamValue("a",F,$,V),getParamValue("numLower",F,$,V),getParamValue("numUpper",F,$,V))];default:throw TypeError(`Node type ${F.op} is not implemented`)}},normalization_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"EuclideanNorm":return[G.euclideanNorm(getParamValue("x",F,$,V),getParamValue("axis",F,$,V),getParamValue("keepDims",F,$,V))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[G.batchNorm(getParamValue("x",F,$,V),getParamValue("mean",F,$,V),getParamValue("variance",F,$,V),getParamValue("offset",F,$,V),getParamValue("scale",F,$,V),getParamValue("epsilon",F,$,V))];case"LRN":return[G.localResponseNormalization(getParamValue("x",F,$,V),getParamValue("radius",F,$,V),getParamValue("bias",F,$,V),getParamValue("alpha",F,$,V),getParamValue("beta",F,$,V))];case"Softmax":return[G.softmax(getParamValue("x",F,$,V))];case"LogSoftmax":return[G.logSoftmax(getParamValue("x",F,$,V))];default:throw TypeError(`Node type ${F.op} is not implemented`)}},ragged_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"RaggedGather":{let{outputNestedSplits:H,outputDenseValues:K}=G.raggedGather(getParamValue("paramsNestedSplits",F,$,V),getParamValue("paramsDenseValues",F,$,V),getParamValue("indices",F,$,V),getParamValue("outputRaggedRank",F,$,V));return H.concat(K)}case"RaggedRange":{let{rtNestedSplits:H,rtDenseValues:K}=G.raggedRange(getParamValue("starts",F,$,V),getParamValue("limits",F,$,V),getParamValue("splits",F,$,V));return[H,K]}case"RaggedTensorToTensor":return[G.raggedTensorToTensor(getParamValue("shape",F,$,V),getParamValue("values",F,$,V),getParamValue("defaultValue",F,$,V),getParamValue("rowPartitionTensors",F,$,V),getParamValue("rowPartitionTypes",F,$,V))];default:throw TypeError(`Node type ${F.op} is not implemented`)}},reduction_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"Max":{let H=getParamValue("axis",F,$,V),K=getParamValue("keepDims",F,$,V);return[G.max(getParamValue("x",F,$,V),H,K)]}case"Mean":{let H=getParamValue("axis",F,$,V),K=getParamValue("keepDims",F,$,V);return[G.mean(getParamValue("x",F,$,V),H,K)]}case"Min":{let H=getParamValue("axis",F,$,V),K=getParamValue("keepDims",F,$,V);return[G.min(getParamValue("x",F,$,V),H,K)]}case"Sum":{let H=getParamValue("axis",F,$,V),K=getParamValue("keepDims",F,$,V);return[G.sum(getParamValue("x",F,$,V),H,K)]}case"All":{let H=getParamValue("axis",F,$,V),K=getParamValue("keepDims",F,$,V);return[G.all(getParamValue("x",F,$,V),H,K)]}case"Any":{let H=getParamValue("axis",F,$,V),K=getParamValue("keepDims",F,$,V);return[G.any(getParamValue("x",F,$,V),H,K)]}case"ArgMax":{let H=getParamValue("axis",F,$,V);return[G.argMax(getParamValue("x",F,$,V),H)]}case"ArgMin":{let H=getParamValue("axis",F,$,V);return[G.argMin(getParamValue("x",F,$,V),H)]}case"Prod":{let H=getParamValue("axis",F,$,V),K=getParamValue("keepDims",F,$,V);return[G.prod(getParamValue("x",F,$,V),H,K)]}case"Cumprod":{let H=getParamValue("axis",F,$,V),K=getParamValue("exclusive",F,$,V),Z=getParamValue("reverse",F,$,V);return[G.cumprod(getParamValue("x",F,$,V),H,K,Z)]}case"Cumsum":{let H=getParamValue("axis",F,$,V),K=getParamValue("exclusive",F,$,V),Z=getParamValue("reverse",F,$,V);return[G.cumsum(getParamValue("x",F,$,V),H,K,Z)]}case"Bincount":let H=getParamValue("x",F,$,V),K=getParamValue("weights",F,$,V),Z=getParamValue("size",F,$,V);return[G.bincount(H,K,Z)];case"DenseBincount":{let H=getParamValue("x",F,$,V),K=getParamValue("weights",F,$,V),Z=getParamValue("size",F,$,V),ee=getParamValue("binaryOutput",F,$,V);return[G.denseBincount(H,K,Z,ee)]}default:throw TypeError(`Node type ${F.op} is not implemented`)}},slice_join_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"ConcatV2":case"Concat":{let H=getParamValue("n",F,$,V),K=getParamValue("axis",F,$,V),Z=getParamValue("tensors",F,$,V);return Z=Z.slice(0,H),[G.concat(Z,K)]}case"Gather":{let H=getParamValue("x",F,$,V),K=getParamValue("indices",F,$,V);return[G.gather(H,G.cast(K,"int32"),0)]}case"GatherV2":{let H=getParamValue("axis",F,$,V),K=getParamValue("batchDims",F,$,V),Z=getParamValue("x",F,$,V),ee=getParamValue("indices",F,$,V);return[G.gather(Z,G.cast(ee,"int32"),H,K)]}case"Reverse":{let H=getParamValue("dims",F,$,V),K=[];for(let F=0;F<H.length;F++)H[F]&&K.push(F);let Z=getParamValue("x",F,$,V);return[G.reverse(Z,K)]}case"ReverseV2":{let H=getParamValue("axis",F,$,V),K=getParamValue("x",F,$,V);return[G.reverse(K,H)]}case"Slice":{let H=getParamValue("begin",F,$,V),K=getParamValue("size",F,$,V);return[G.slice(getParamValue("x",F,$,V),H,K)]}case"StridedSlice":{let H=getParamValue("begin",F,$,V),K=getParamValue("end",F,$,V),Z=getParamValue("strides",F,$,V),ee=getParamValue("beginMask",F,$,V),et=getParamValue("endMask",F,$,V),en=getParamValue("ellipsisMask",F,$,V),ea=getParamValue("newAxisMask",F,$,V),ei=getParamValue("shrinkAxisMask",F,$,V),eo=getParamValue("x",F,$,V);return[G.stridedSlice(eo,H,K,Z,ee,et,en,ea,ei)]}case"Pack":return(0,eD.lub)(()=>{let H=getParamValue("axis",F,$,V),K=getParamValue("tensors",F,$,V),Z=K[0].shape,ee=G.squeeze(K[0]).shape,et=K.map(F=>{let $=eD.D5U.arraysEqual(F.shape,Z);if(!$&&!eD.D5U.arraysEqual(G.squeeze(F).shape,ee))throw Error("the input tensors shape does not match");return $?F:G.reshape(F,Z)});return[G.stack(et,H)]});case"Unpack":{let H=getParamValue("axis",F,$,V),K=getParamValue("tensor",F,$,V);return G.unstack(K,H)}case"Tile":{let H=getParamValue("reps",F,$,V);return[G.tile(getParamValue("x",F,$,V),H)]}case"Split":case"SplitV":{let H=getParamValue("axis",F,$,V),K=getParamValue("numOrSizeSplits",F,$,V),Z=getParamValue("x",F,$,V);return G.split(Z,K,H)}case"ScatterNd":{let H=getParamValue("indices",F,$,V),K=getParamValue("values",F,$,V),Z=getParamValue("shape",F,$,V);return[G.scatterND(H,K,Z)]}case"GatherNd":{let H=getParamValue("x",F,$,V),K=getParamValue("indices",F,$,V);return[G.gatherND(H,K)]}case"SparseToDense":{let H=getParamValue("sparseIndices",F,$,V),K=getParamValue("outputShape",F,$,V),Z=getParamValue("sparseValues",F,$,V),ee=getParamValue("defaultValue",F,$,V);return[G.sparseToDense(H,Z,K,Z.dtype===ee.dtype?ee:G.cast(ee,Z.dtype))]}case"TensorScatterUpdate":{let H=getParamValue("indices",F,$,V),K=getParamValue("values",F,$,V),Z=getParamValue("tensor",F,$,V);return[G.tensorScatterUpdate(Z,H,K)]}default:throw TypeError(`Node type ${F.op} is not implemented`)}},sparse_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"SparseFillEmptyRows":{let{outputIndices:H,outputValues:K,emptyRowIndicator:Z,reverseIndexMap:ee}=G.sparse.sparseFillEmptyRows(getParamValue("indices",F,$,V),getParamValue("values",F,$,V),getParamValue("denseShape",F,$,V),getParamValue("defaultValue",F,$,V));return[H,K,Z,ee]}case"SparseReshape":{let{outputIndices:H,outputShape:K}=G.sparse.sparseReshape(getParamValue("inputIndices",F,$,V),getParamValue("inputShape",F,$,V),getParamValue("newShape",F,$,V));return[H,K]}case"SparseSegmentMean":{let H=G.sparse.sparseSegmentMean(getParamValue("data",F,$,V),getParamValue("indices",F,$,V),getParamValue("segmentIds",F,$,V));return[H]}case"SparseSegmentSum":{let H=G.sparse.sparseSegmentSum(getParamValue("data",F,$,V),getParamValue("indices",F,$,V),getParamValue("segmentIds",F,$,V));return[H]}default:throw TypeError(`Node type ${F.op} is not implemented`)}},spectral_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"FFT":return[G.fft(getParamValue("x",F,$,V))];case"IFFT":return[G.ifft(getParamValue("x",F,$,V))];case"RFFT":return[G.rfft(getParamValue("x",F,$,V))];case"IRFFT":return[G.irfft(getParamValue("x",F,$,V))];default:throw TypeError(`Node type ${F.op} is not implemented`)}},string_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"StaticRegexReplace":return[G.string.staticRegexReplace(getParamValue("input",F,$,V),getParamValue("pattern",F,$,V),getParamValue("rewrite",F,$,V),getParamValue("replaceGlobal",F,$,V))];case"StringNGrams":{let{nGrams:H,nGramsSplits:K}=G.string.stringNGrams(getParamValue("data",F,$,V),getParamValue("dataSplits",F,$,V),getParamValue("separator",F,$,V),getParamValue("nGramWidths",F,$,V),getParamValue("leftPad",F,$,V),getParamValue("rightPad",F,$,V),getParamValue("padWidth",F,$,V),getParamValue("preserveShortSequences",F,$,V));return[H,K]}case"StringSplit":{let{indices:H,values:K,shape:Z}=G.string.stringSplit(getParamValue("input",F,$,V),getParamValue("delimiter",F,$,V),getParamValue("skipEmpty",F,$,V));return[H,K,Z]}case"StringToHashBucketFast":{let H=G.string.stringToHashBucketFast(getParamValue("input",F,$,V),getParamValue("numBuckets",F,$,V));return[H]}default:throw TypeError(`Node type ${F.op} is not implemented`)}},transformation_executor_executeOp=(F,$,V,G=eE)=>{switch(F.op){case"Cast":return[G.cast(getParamValue("x",F,$,V),getParamValue("dtype",F,$,V))];case"ExpandDims":{let H=getParamValue("axis",F,$,V);return[G.expandDims(getParamValue("x",F,$,V),H)]}case"Squeeze":{let H=getParamValue("axis",F,$,V);return[G.squeeze(getParamValue("x",F,$,V),H)]}case"Reshape":return[G.reshape(getParamValue("x",F,$,V),getParamValue("shape",F,$,V))];case"EnsureShape":return[G.ensureShape(getParamValue("x",F,$,V),getParamValue("shape",F,$,V))];case"MirrorPad":return[G.mirrorPad(getParamValue("x",F,$,V),getParamValue("padding",F,$,V),getParamValue("mode",F,$,V))];case"PadV2":case"Pad":return[G.pad(getParamValue("x",F,$,V),getParamValue("padding",F,$,V),getParamValue("constantValue",F,$,V))];case"SpaceToBatchND":{let H=getParamValue("blockShape",F,$,V),K=getParamValue("paddings",F,$,V);return[G.spaceToBatchND(getParamValue("x",F,$,V),H,K)]}case"BatchToSpaceND":{let H=getParamValue("blockShape",F,$,V),K=getParamValue("crops",F,$,V);return[G.batchToSpaceND(getParamValue("x",F,$,V),H,K)]}case"DepthToSpace":{let H=getParamValue("blockSize",F,$,V),K=getParamValue("dataFormat",F,$,V).toUpperCase();return[G.depthToSpace(getParamValue("x",F,$,V),H,K)]}case"BroadcastTo":return[G.broadcastTo(getParamValue("x",F,$,V),getParamValue("shape",F,$,V))];case"BroadcastArgs":return[G.broadcastArgs(getParamValue("s0",F,$,V),getParamValue("s1",F,$,V))];default:throw TypeError(`Node type ${F.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function operation_executor_executeOp(F,$,V,G,H=eD.lub){let K=((F,$,V)=>{switch(F.category){case"arithmetic":return H(()=>executeOp(F,$,V));case"basic_math":return H(()=>basic_math_executor_executeOp(F,$,V));case"control":return control_executor_executeOp(F,$,V);case"convolution":return H(()=>convolution_executor_executeOp(F,$,V));case"creation":return H(()=>creation_executor_executeOp(F,$,V));case"dynamic":return dynamic_executor_executeOp(F,$,V);case"evaluation":return H(()=>evaluation_executor_executeOp(F,$,V));case"image":return H(()=>image_executor_executeOp(F,$,V));case"graph":return H(()=>graph_executor_executeOp(F,$,V));case"logical":return H(()=>logical_executor_executeOp(F,$,V));case"matrices":return H(()=>matrices_executor_executeOp(F,$,V));case"normalization":return H(()=>normalization_executor_executeOp(F,$,V));case"ragged":return H(()=>ragged_executor_executeOp(F,$,V));case"reduction":return H(()=>reduction_executor_executeOp(F,$,V));case"slice_join":return H(()=>slice_join_executor_executeOp(F,$,V));case"sparse":return H(()=>sparse_executor_executeOp(F,$,V));case"spectral":return H(()=>spectral_executor_executeOp(F,$,V));case"string":return H(()=>string_executor_executeOp(F,$,V));case"transformation":return H(()=>transformation_executor_executeOp(F,$,V));case"hash_table":return hash_table_executor_executeOp(F,$,V,G);case"custom":let K=getRegisteredOp(F.op);if(K&&K.customExecutor)return K.customExecutor(new NodeValueImpl(F,$,V));throw TypeError(`Custom op ${F.op} is not registered.`);default:throw TypeError(`Unknown op '${F.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(F,$,V);return eD.D5U.isPromise(K)?K.then(F=>[].concat(F)):[].concat(K)}let ExecutionContext=class ExecutionContext{constructor(F={},$={},V={},G={},H){this.weightMap=F,this.tensorArrayMap=$,this.tensorListMap=V,this.functionMap=G,this.parseNodeNameCache=H,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(F,$){return{id:F,frameName:$,iterationId:0}}set currentContext(F){this.contexts!==F&&(this.contexts=F,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let F=[];for(let $=0;$<this.contexts.length-1;$++){let V=this.contexts.slice(0,this.contexts.length-$);F.push(this.contextIdforContexts(V))}F.push(""),this._currentContextIds=F}contextIdforContexts(F){return F?F.map(F=>0===F.id&&0===F.iterationId?"":`${F.frameName}-${F.iterationId}`).join("/"):""}enterFrame(F){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,F)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let F=Object.assign({},this.contexts[this.contexts.length-1]);F.iterationId+=1,F.id=this.lastId,this.contexts.splice(-1,1,F),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw Error("Cannot increase frame iteration, the context is empty")}getWeight(F){return this.weightMap[F]}addTensorArray(F){this.tensorArrayMap[F.id]=F}getTensorArray(F){return this.tensorArrayMap[F]}addTensorList(F){this.tensorListMap[F.id]=F}getTensorList(F){return this.tensorListMap[F]}dispose(F){for(let $ in this.tensorArrayMap)this.tensorArrayMap[$].clearAndClose(F);for(let $ in this.tensorListMap)this.tensorListMap[$].clearAndClose(F)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getExecutionSubgraph(F,$,V,G){let H=new Set,K=[],Z=null,ee=null,et=new Set,en=new Set(Object.keys(F).map(F=>parseNodeName(F)[0]));G=G||[];let ea=new Set(G.map(F=>parseNodeName(F.name)[0])),ei=[...$];for(;ei.length>0;){let F=ei.pop();if((isControlFlow(F)||isDynamicShape(F)||isHashTable(F))&&null==Z&&(ee=(Z=F).children.map(F=>F.name).filter(F=>H.has(F))),H.add(F.name),!(null!=V[F.name]||en.has(F.name)||ea.has(F.name))){if(0===F.inputs.length){K.push(F.name);continue}F.inputs.forEach(F=>{et.has(F.name)||(et.add(F.name),ei.push(F))})}}return{inputs:F,outputs:$,usedNodes:H,missingInputs:K,dynamicNode:Z,syncInputs:ee}}function getNodesInTopologicalOrder(F,$){let{usedNodes:V,inputs:G}=$,H=Object.keys(G).map(F=>parseNodeName(F)[0]).map($=>F.nodes[$]),K=F.initNodes||[],isUsed=F=>V.has("string"==typeof F?F:F.name);function unique(F){return[...new Map(F.map(F=>[F.name,F])).values()]}let Z=unique([...H,...F.weights,...K]).filter(isUsed),ee=unique([...Z,...Object.values(F.nodes)]).filter(isUsed),et=new Map(ee.map(F=>[F.name,F])),en={};for(let F of ee)for(let $ of(en[F.name]=en[F.name]||0,F.children))isUsed($)||(en[$.name]=Number.POSITIVE_INFINITY),en[$.name]=(en[$.name]||0)+1;let ea=Object.entries(en).filter(([,F])=>0===F).map(([F])=>F),ei=[...ea];for(;ea.length>0;){let F=ea.pop(),$=et.get(F);for(let F of $.children.filter(isUsed))0==--en[F.name]&&(ei.push(F.name),ea.push(F.name))}let eo=ei.map(F=>et.get(F)),es=filterPredefinedReachableNodes(eo,Z);return validateNodesExecutionOrder(es,Z),es}function filterPredefinedReachableNodes(F,$){let V=new Map(F.map(F=>[F.name,F])),G=$.map(F=>F.name),H=new Set(G);for(;G.length>0;){let F=G.pop(),$=V.get(F);for(let F of $.children)!V.has(F.name)||H.has(F.name)||(H.add(F.name),G.push(F.name))}let K=F.filter(F=>H.has(F.name));return K}let NodesExecutionOrderError=class NodesExecutionOrderError extends Error{constructor(F){super(`NodesExecutionOrderError: ${F}`)}};function validateNodesExecutionOrder(F,$){let V=new Map(F.map((F,$)=>[F.name,$])),G=new Set($.map(F=>F.name)),isPredefined=F=>G.has("string"==typeof F?F:F.name),H=new Set(F.map(F=>F.name)),willBeExecuted=F=>H.has("string"==typeof F?F:F.name);for(let $ of F){for(let F of $.children.filter(willBeExecuted)){if(!V.has(F.name))throw new NodesExecutionOrderError(`Child ${F.name} of node ${$.name} is unreachable.`);if(V.get($.name)>V.get(F.name))throw new NodesExecutionOrderError(`Node ${$.name} is scheduled to run after its child ${F.name}.`)}if(!isPredefined($))for(let F of $.inputs){if(!V.has(F.name))throw new NodesExecutionOrderError(`Input ${F.name} of node ${$.name} is unreachable.`);if(V.get(F.name)>V.get($.name))throw new NodesExecutionOrderError(`Node ${$.name} is scheduled to run before its input ${F.name}.`)}}}function getNodeLiveUntilMap(F){let $=new Map(F.map((F,$)=>[F.name,$])),V=Number.MAX_SAFE_INTEGER,G=F.map((F,$)=>isControlFlow(F)?V:$),getSelfLifeSpan=F=>{let V=G[$.get(F.name)];return null==V?-1:V},H=F.map((F,$)=>F.children.map(getSelfLifeSpan).reduce((F,$)=>Math.max(F,$),G[$])),K=new Map;for(let $=0;$<F.length;++$){let G=H[$];if(G===V)continue;let Z=F[$],ee=F[G];K.has(ee.name)||K.set(ee.name,[]),K.get(ee.name).push(Z)}return K}let i3=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),i4=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),i6=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function isControlFlow(F){return i3.has(F.op)}function isDynamicShape(F){return i4.has(F.op)}function isHashTable(F){return i6.has(F.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GraphExecutor=class GraphExecutor{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(F){let $=Object.keys(F).map($=>F[$].map(F=>F.id));this._weightIds=[].concat(...$),this._weightMap=F}set resourceManager(F){this._resourceManager=F}get inputs(){return this._inputs.map(F=>({name:F.name,shape:F.attrParams.shape?F.attrParams.shape.value:void 0,dtype:F.attrParams.dtype?F.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(F=>({name:F.name,shape:F.attrParams.shape?F.attrParams.shape.value:void 0,dtype:F.attrParams.dtype?F.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(F=>F.signatureKey||F.name)}get outputNodes(){return this._outputs.map(F=>{let $=F.signatureKey||F.name;return F.defaultOutput?`${$}:${F.defaultOutput}`:$})}get functions(){return Object.keys(this._functions).reduce((F,$)=>(F[$]=this._functions[$].signature,F),{})}constructor(F,$){this.graph=F,this.parent=$,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=F.outputs,this._inputs=F.inputs,this._initNodes=F.initNodes,this._signature=F.signature,this._functions=F.functions,null!=F.functions&&Object.keys(F.functions).forEach($=>{this._functionExecutorMap[$]=new GraphExecutor(F.functions[$],this)})}getCompilationKey(F,$){let V=F.map(F=>F.name).sort(),G=$.map(F=>F.name).sort();return V.join(this.SEPARATOR)+"--"+G.join(this.SEPARATOR)}compile(F,$){let V=getExecutionSubgraph(F,$,this.weightMap,this._initNodes),{missingInputs:G,dynamicNode:H,syncInputs:K}=V;if(null!=H)throw Error(`This execution contains the node '${H.name}', which has the dynamic op '${H.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${K}]`);if(G.length>0){let V=$.map(F=>F.name),H=Object.keys(F);throw Error(`Cannot compute the outputs [${V}] from the provided inputs [${H}]. Missing the following inputs: [${G}]`)}let Z=getNodesInTopologicalOrder(this.graph,V),ee=getNodeLiveUntilMap(Z);return{orderedNodes:Z,nodeLiveUntilMap:ee}}cloneAndKeepTensor(F){if(null==F)return null;let $=F.clone();return(0,eD.CnY)($),$}cloneTensorList(F){if(!F)return null;let $=F.map(F=>this.cloneAndKeepTensor(F));return $}cloneTensorMap(F){return Object.fromEntries(Object.entries(F).map(([F,$])=>[F,this.cloneTensorList($)]))}execute(F,$){this.disposeIntermediateTensors(),F=this.mapInputs(F);let V=Object.keys(F).sort();this.checkInputs(F),this.checkInputShapeAndType(F),$=this.mapOutputs($),this.checkOutputs($);let G=V.map(F=>this.graph.nodes[parseNodeName(F)[0]]),H=$.map(F=>parseNodeName(F)[0]),K=new Set(H),Z=H.map(F=>this.graph.nodes[F]);0===Z.length&&(Z=this._outputs);let ee=this.getCompilationKey(G,Z),et=this.compiledMap.get(ee);null==et&&(et=this.compile(F,Z),this.compiledMap.set(ee,et));try{this.keepIntermediateTensors=(0,eD.OBj)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(F){this.keepIntermediateTensors=!1,console.warn(F.message)}let en={},ea={};return(0,eD.lub)(()=>{let V=new ExecutionContext(this.weightMap,en,ea,this.functionExecutorMap,this.parseNodeNameCache),G=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(F).forEach($=>{let[H,K]=parseNodeName($,V),Z=[];Z[K]=F[$],G[H]=Z,this.keepIntermediateTensors&&(this.clonedTensorsMap[H]=this.cloneTensorList(Z))});let H=this.getFrozenTensorIds(G),{orderedNodes:Z,nodeLiveUntilMap:ee}=et;for(let F of Z){if(G[F.name])continue;let $=operation_executor_executeOp(F,G,V,this._resourceManager);if(eD.D5U.isPromise($))throw Error(`The execution of the op '${F.op}' returned a promise. Please use model.executeAsync() instead.`);G[F.name]=$,this.keepIntermediateTensors&&(this.clonedTensorsMap[F.name]=this.cloneTensorList($)),this.checkTensorForDisposalWithNodeLiveUntilInfo(F,G,V,H,K,ee.get(F.name))}return null==this.parent&&V.dispose(H),$.map(F=>getTensor(F,G,V))})}getFrozenTensorIds(F){let $=[].concat.apply([],Object.keys(F).map($=>F[$]).map(F=>F.map(F=>F.id)));return new Set($)}checkTensorForDisposal(F,$,V,G,H,K,Z){if(!(isControlFlow($)||K.has(F))){for(let G of V[F])null!=G&&(Z[G.id]=(Z[G.id]||0)+$.children.length);for(let F of $.inputs){if(isControlFlow(F))continue;let $=getTensorsForCurrentContext(F.name,V,G);if(null!=$)for(let F of $){if(!F||F.kept||H.has(F.id))continue;let $=Z[F.id];1===$?(F.dispose(),delete Z[F.id]):null!=$&&Z[F.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(F,$,V,G,H,K){function isNonDisposableNode(F){return isControlFlow(F)||H.has(F.name)}if(!isControlFlow(F)&&null!=K)for(let F of K){if(isNonDisposableNode(F))continue;let H=getTensorsForCurrentContext(F.name,$,V);for(let F of H)!F||F.kept||G.has(F.id)||F.dispose()}}async executeAsync(F,$){return this._executeAsync(F,$)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(F=>{for(let $ of F)$&&!$.isDisposed&&$.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(F,$,V=!1,G={},H={}){this.disposeIntermediateTensors(),V||(F=this.mapInputs(F),this.checkInputs(F),this.checkInputShapeAndType(F),$=this.mapOutputs($),this.checkOutputs($));try{this.keepIntermediateTensors=(0,eD.OBj)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(F){this.keepIntermediateTensors=!1,console.warn(F.message)}let K=new ExecutionContext(this.weightMap,G,H,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let Z=await this.executeWithControlFlow(F,K,$,V),ee=$.map(F=>getTensor(F,Z,K)),et=ee.map(F=>F.id),en=Object.keys(F).map($=>F[$].id),ea=new Set([...et,...en,...this.weightIds]);return Object.values(Z).forEach(F=>{F.forEach(F=>{!F||F.isDisposed||ea.has(F.id)||F.dispose()})}),null==this.parent&&K.dispose(ea),ee}async executeFunctionAsync(F,$,V){let G=F.reduce((F,$,V)=>(F[this.inputs[V].name]=$,F),{});return this._executeAsync(G,this.outputNodes,!0,$,V)}async executeWithControlFlow(F,$,V,G){let H=Object.keys(F),K=H.map(F=>this.graph.nodes[parseNodeName(F)[0]]),Z=V.map(F=>parseNodeName(F)[0]),ee=new Set(Z),et=Z.map(F=>this.graph.nodes[F]);0===et.length&&(et=this._outputs);let{usedNodes:en,missingInputs:ea,dynamicNode:ei,syncInputs:eo}=getExecutionSubgraph(F,et,this.weightMap,this._initNodes),es=[...K,...this.graph.weights,...this._initNodes||[]].map(F=>({node:F,contexts:$.currentContext})),eu=Object.assign({},this.weightMap);Object.keys(F).forEach($=>{let[V,G]=parseNodeName($),H=[];H[G]=F[$],eu[V]=H});let ec={},ep=this.getFrozenTensorIds(eu),eh={};for(;es.length>0;){let F=this.processStack(K,es,$,eu,eh,ep,ee,ec,en);await Promise.all(F)}null!=ei||G||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let ef=et.filter(F=>!isControlFlow(F)&&!getTensor(F.name,eu,$)).map(F=>F.name);if(ef.length>0){let F="";throw null!=ei&&(F=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${eo}]`),Error(`Cannot compute the outputs [${ef}] from the provided inputs [${H}]. Consider providing the following inputs: [${ea}]. ${F}`)}return eu}processStack(F,$,V,G,H,K,Z,ee,et){let en=[];for(;$.length>0;){let F=$.pop();V.currentContext=F.contexts;let ea="";if("Enter"===F.node.op&&getParamValue("isConstant",F.node,G,V)&&([ea]=getNodeNameAndIndex(F.node.name,V)),null==G[F.node.name]){let ei=operation_executor_executeOp(F.node,G,V,this._resourceManager);ea||([ea]=getNodeNameAndIndex(F.node.name,V));let eo=V.currentContext;eD.D5U.isPromise(ei)?en.push(ei.then(en=>(G[ea]=en,this.keepIntermediateTensors&&(this.clonedTensorsMap[ea]=this.cloneTensorList(en)),V.currentContext=eo,this.checkTensorForDisposal(ea,F.node,G,V,K,Z,ee),this.processChildNodes(F.node,$,V,G,H,et),en))):(G[ea]=ei,this.keepIntermediateTensors&&(this.clonedTensorsMap[ea]=this.cloneTensorList(ei)),this.checkTensorForDisposal(ea,F.node,G,V,K,Z,ee),this.processChildNodes(F.node,$,V,G,H,et))}else this.processChildNodes(F.node,$,V,G,H,et)}return en}processChildNodes(F,$,V,G,H,K){F.children.forEach(F=>{let[Z]=getNodeNameAndIndex(F.name,V);!H[Z]&&K.has(F.name)&&("Merge"===F.op?F.inputNames.some(F=>!!getTensor(F,G,V))&&(H[Z]=!0,$.push({contexts:V.currentContext,node:F})):F.inputNames.every(F=>!!getTensor(F,G,V))&&(H[Z]=!0,$.push({contexts:V.currentContext,node:F})))})}dispose(){Object.keys(this.weightMap).forEach(F=>this.weightMap[F].forEach(F=>F.dispose()))}checkInputShapeAndType(F){Object.keys(F).forEach($=>{let V=F[$],[G]=parseNodeName($),H=this.graph.nodes[G];if(H.attrParams.shape&&H.attrParams.shape.value){let F=H.attrParams.shape.value,$=F.length===V.shape.length&&V.shape.every(($,V)=>-1===F[V]||F[V]===$);eD.D5U.assert($,()=>`The shape of dict['${H.name}'] provided in model.execute(dict) must be [${F}], but was [${V.shape}]`)}H.attrParams.dtype&&H.attrParams.dtype.value&&eD.D5U.assert(V.dtype===H.attrParams.dtype.value,()=>`The dtype of dict['${H.name}'] provided in model.execute(dict) must be ${H.attrParams.dtype.value}, but was ${V.dtype}`)})}mapInputs(F){var $,V;let G={};for(let H in F){let K=null===(V=null===($=this._signature)||void 0===$?void 0:$.inputs)||void 0===V?void 0:V[H];null!=K?G[K.name]=F[H]:G[H]=F[H]}return G}checkInputs(F){let $=Object.keys(F).filter(F=>{let[$]=parseNodeName(F);return null==this.graph.nodes[$]});if($.length>0)throw Error(`The dict provided in model.execute(dict) has keys: [${$}] that are not part of graph`)}mapOutputs(F){return F.map(F=>{var $,V;let G=null===(V=null===($=this._signature)||void 0===$?void 0:$.outputs)||void 0===V?void 0:V[F];return null!=G?G.name:F},{})}checkOutputs(F){F.forEach(F=>{let[$]=parseNodeName(F);if(!this.graph.nodes[$])throw Error(`The output '${F}' is not found in the graph`)})}};let ResourceManager=class ResourceManager{constructor(F={},$={}){this.hashTableNameToHandle=F,this.hashTableMap=$}addHashTable(F,$){this.hashTableNameToHandle[F]=$.handle,this.hashTableMap[$.id]=$}getHashTableHandleByName(F){return this.hashTableNameToHandle[F]}getHashTableById(F){return this.hashTableMap[F]}dispose(){for(let F in this.hashTableMap)this.hashTableMap[F].clearAndClose(),delete this.hashTableMap[F];for(let F in this.hashTableNameToHandle)this.hashTableNameToHandle[F].dispose(),delete this.hashTableNameToHandle[F]}};var i5=V(91989);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let i9="?tfjs-format=file",i8="model.json";let GraphModel=class GraphModel{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(F,$={},V=eD.io){this.modelUrl=F,this.loadOptions=$,this.version="n/a",this.io=V,null==$&&(this.loadOptions={}),this.resourceManager=new ResourceManager}findIOHandler(){let F=this.modelUrl;if(null!=F.load)this.handler=F;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(F,this.loadOptions);else{let $=this.io.getLoadHandlers(F,this.loadOptions);if(0===$.length)$.push(this.io.browserHTTPRequest(F,this.loadOptions));else if($.length>1)throw Error(`Found more than one (${$.length}) load handlers for URL '${[F]}'`);this.handler=$[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let F=this.handler.load();return eD.D5U.isPromise(F)?F.then(F=>null==F.getWeightStream?this.loadSync(F):this.loadStreaming(F)):this.loadSync(F)}loadSync(F){let $=this.io.decodeWeights(F.weightData,F.weightSpecs);return this.loadWithWeightMap(F,$)}async loadStreaming(F){if(null==F.getWeightStream)throw Error("Model artifacts missing streamWeights function");let $=await (0,i5.r)(F.getWeightStream(),F.weightSpecs);return this.loadWithWeightMap(F,$)}loadWithWeightMap(F,$){this.artifacts=F;let V=this.artifacts.modelTopology,G=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let F=this.artifacts.userDefinedMetadata;null!=F.signature&&(G=F.signature),null!=F.structuredOutputKeys&&(this.structuredOutputKeys=F.structuredOutputKeys)}if(this.signature=G,this.version=`${V.versions.producer}.${V.versions.minConsumer}`,this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(V,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap($),this.executor.resourceManager=this.resourceManager,null!=F.modelInitializer&&null!=F.modelInitializer.node){let $=OperationMapper.Instance.transformGraph(F.modelInitializer);this.initializer=new GraphExecutor($),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=F.initializerSignature}return!0}async save(F,$){if("string"==typeof F){let $=this.io.getSaveHandlers(F);if(0===$.length)throw Error(`Cannot find any save handlers for URL '${F}'`);if($.length>1)throw Error(`Found more than one (${$.length}) save handlers for URL '${F}'`);F=$[0]}if(null==F.save)throw Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return F.save(this.artifacts)}addStructuredOutputNames(F){if(this.structuredOutputKeys){let $=F instanceof eD.esB?[F]:F,V={};return $.forEach((F,$)=>V[this.structuredOutputKeys[$]]=F),V}return F}predict(F,$){let V=this.execute(F,this.outputNodes);return this.addStructuredOutputNames(V)}async predictAsync(F,$){let V=await this.executeAsync(F,this.outputNodes);return this.addStructuredOutputNames(V)}normalizeInputs(F){var $;if(!(F instanceof eD.esB)&&!Array.isArray(F)){let V=null===($=this.signature)||void 0===$?void 0:$.inputs;if(null!=V)for(let $ in V){let G=V[$];null!=G.resourceId&&(F[$]=this.resourceIdToCapturedInput[G.resourceId])}return F}F=Array.isArray(F)?F:[F];let V=Object.keys(this.resourceIdToCapturedInput).length;if(F.length+V!==this.inputNodes.length)throw Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-V} non-resource placeholders, while there are ${F.length} input tensors provided.`);let G=0;return this.inputNodes.reduce(($,V)=>{var H,K,Z;let ee=null===(Z=null===(K=null===(H=this.signature)||void 0===H?void 0:H.inputs)||void 0===K?void 0:K[V])||void 0===Z?void 0:Z.resourceId;return null!=ee?$[V]=this.resourceIdToCapturedInput[ee]:$[V]=F[G++],$},{})}normalizeOutputs(F){return Array.isArray(F=F||this.outputNodes)?F:[F]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(F){if(this.resourceIdToCapturedInput={},this.initializerSignature){let $=this.initializerSignature.outputs,V=Object.keys($);for(let G=0;G<V.length;G++){let H=V[G],K=$[H];this.resourceIdToCapturedInput[K.resourceId]=F[G]}}}execute(F,$){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),F=this.normalizeInputs(F),$=this.normalizeOutputs($);let V=this.executor.execute(F,$);return V.length>1?V:V[0]}async executeAsync(F,$){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),F=this.normalizeInputs(F),$=this.normalizeOutputs($);let V=await this.executor.executeAsync(F,$);return V.length>1?V:V[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(F){return Object.keys(F).reduce(($,V)=>($[V]=[F[V]],$),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,eD.B90)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function loadGraphModel(F,$={},V=eD.io){if(null==F)throw Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==$&&($={}),$.fromTFHub&&"string"==typeof F&&(F=getTFHubUrl(F));let G=new GraphModel(F,$,V);return await G.load(),G}function loadGraphModelSync(F){let $;if(null==F)throw Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");if(F instanceof Array){let[V,G]=F;if(!V)throw Error("modelJSON must be the first element of the array");if(!G||!(G instanceof ArrayBuffer))throw Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in V))throw Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in V))throw Error("Model JSON is missing 'weightsManifest'");let H=eD.io.getWeightSpecs(V.weightsManifest),K=eD.io.getModelArtifactsForJSONSync(V,H,G);$=eD.io.fromMemorySync(K)}else if("load"in F)$=F;else if("modelTopology"in F&&"weightSpecs"in F&&"weightData"in F)$=eD.io.fromMemorySync(F);else throw Error("Unknown model format");let V=new GraphModel($);return V.load(),V}function getTFHubUrl(F){return F.endsWith("/")||(F+="/"),`${F}${i8}${i9}`}/** @license See the LICENSE file. */let i7="4.15.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var oe=V(36377);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function deepMap(F,$){return deepMapInternal(F,$)}function deepMapInternal(F,$,V=new Map,G=new Set){if(null==F)return null;if("function"==typeof Blob&&F instanceof Blob)return F.slice();if(G.has(F))throw Error("Circular references are not supported.");if(V.has(F))return V.get(F);let H=$(F);if(H.recurse&&null!==H.value)throw Error("A deep map function may not return both a value and recurse=true.");if(!H.recurse)return V.set(F,H.value),H.value;if(isIterable(F)){let H=Array.isArray(F)?[]:{};for(let K in G.add(F),F){let Z=F[K],ee=deepMapInternal(Z,$,V,G);H[K]=ee}return G.delete(F),F.__proto__&&(H.__proto__=F.__proto__),H}throw Error(`Can't recurse into non-iterable type: ${F}`)}function deepZip(F,$=zipToList){return deepZipInternal(F,$)}function deepZipInternal(F,$,V=new Set){let G=F[0];if(V.has(G))throw Error("Circular references are not supported.");let H=$(F);if(H.recurse&&null!==H.value)throw Error("A deep zip function may not return both a value and recurse=true.");if(!H.recurse)return H.value;if(isIterable(G)){let H=Array.isArray(G)?[]:{};for(let K in V.add(G),G){let G=F.map(F=>F[K]),Z=deepZipInternal(G,$,V);H[K]=Z}return V.delete(G),H}throw Error(`Can't recurse into non-iterable type: ${G}`)}function zipToList(F){return null===F?null:isIterable(F[0])?{value:null,recurse:!0}:{value:F,recurse:!1}}async function deepMapAndAwaitAll(F,$){let V=new Map;for(let G of(deepMapInternal(F,$,V),Array.from(V.keys()))){let F=V.get(G);if(eD.D5U.isPromise(F)){let $=await F;V.set(G,$)}}let G=deepMapInternal(F,$,V);return G}function isIterable(F){let $=!1;if(eD.OBj().get("IS_BROWSER"))$=F instanceof TextDecoder;else{let{StringDecoder:G}=V(34977);$=F instanceof G}return null!=F&&!ArrayBuffer.isView(F)&&(Array.isArray(F)||"object"==typeof F&&!(F instanceof eD.esB)&&!(F instanceof Promise)&&!$)}function canTensorify(F){return null==F||isPrimitive(F)||Array.isArray(F)||"object"==typeof F&&F instanceof eD.esB||eD.D5U.isTypedArray(F)}function isPrimitive(F){return null===F||"object"!=typeof F&&"function"!=typeof F}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function deepClone(F){return deepMap(F,cloneIfTensor)}function cloneIfTensor(F){return F instanceof eD.esB?{value:F.clone(),recurse:!1}:isIterable(F)?{value:null,recurse:!0}:{value:F,recurse:!1}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let RingBuffer=class RingBuffer{constructor(F){if(this.capacity=F,this.begin=0,this.end=0,null==F)throw RangeError("Can't create a ring buffer of unknown capacity.");if(F<1)throw RangeError("Can't create ring buffer of capacity < 1.");this.data=Array(F),this.doubledCapacity=2*F}wrap(F){for(;F<0;)F+=this.doubledCapacity;return F%this.doubledCapacity}get(F){if(F<0)throw RangeError("Can't get item at a negative index.");return this.data[F%this.capacity]}set(F,$){if(F<0)throw RangeError("Can't set item at a negative index.");this.data[F%this.capacity]=$}length(){let F=this.end-this.begin;return F<0&&(F=this.doubledCapacity+F),F}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(F){if(this.isFull())throw RangeError("Ring buffer is full.");this.set(this.end,F),this.end=this.wrap(this.end+1)}pushAll(F){for(let $ of F)this.push($)}pop(){if(this.isEmpty())throw RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let F=this.get(this.end);return this.set(this.end,void 0),F}unshift(F){if(this.isFull())throw RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,F)}shift(){if(this.isEmpty())throw RangeError("Ring buffer is empty.");let F=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),F}shuffleExcise(F){if(this.isEmpty())throw RangeError("Ring buffer is empty.");let $=this.wrap(this.begin+F),V=this.get($);return this.set($,this.pop()),V}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let GrowingRingBuffer=class GrowingRingBuffer extends RingBuffer{constructor(){super(GrowingRingBuffer.INITIAL_CAPACITY)}isFull(){return!1}push(F){super.isFull()&&this.expand(),super.push(F)}unshift(F){super.isFull()&&this.expand(),super.unshift(F)}expand(){let F=2*this.capacity,$=Array(F),V=this.length();for(let F=0;F<V;F++)$[F]=this.get(this.wrap(this.begin+F));this.data=$,this.capacity=F,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=V}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function iteratorFromItems(F){return new ArrayIterator(F)}function iteratorFromFunction(F){return new FunctionCallIterator(F)}function iteratorFromConcatenated(F,$){return new ChainedIterator(F,$)}function iteratorFromZipped(F,$=Z.FAIL){return new ZipIterator(F,$)}GrowingRingBuffer.INITIAL_CAPACITY=32;let LazyIterator=class LazyIterator{async toArray(){let F=[],$=await this.next();for(;!$.done;)F.push($.value),$=await this.next();return F}async toArrayForTest(){let F=this.prefetch(100),$=[],V=await F.next();for(;!V.done;)$.push(V.value),V=await F.next();return $}async resolveFully(){let F=await this.next();for(;!F.done;)F=await this.next()}async resolveWhile(F){let $=await this.next(),V=F($.value);for(;!$.done&&V;)V=F(($=await this.next()).value)}handleErrors(F){return new ErrorHandlingLazyIterator(this,F)}filter(F){return new FilterIterator(this,F)}map(F){return new MapIterator(this,F)}mapAsync(F){return new AsyncMapIterator(this,F)}serialMapAsync(F){return new AsyncMapIterator(this,F).serial()}flatmap(F){return new FlatmapIterator(this,F)}async forEachAsync(F){return this.map(F).resolveFully()}async serialForEach(F){return this.serialMapAsync(F).resolveWhile(F=>!0===F)}rowMajorBatch(F,$=!0){return new RowMajorBatchIterator(this,F,$)}columnMajorBatch(F,$=!0,V=zipToList){let G=this.rowMajorBatch(F,$);return G.map(F=>deepZip(F,V))}concatenate(F,$){return new ChainedIterator(iteratorFromItems([this,F]),$)}take(F){return F<0||null==F?this:new TakeIterator(this,F)}skip(F){return F<0||null==F?this:new SkipIterator(this,F)}prefetch(F){return new PrefetchIterator(this,F)}shuffle(F,$){return new ShuffleIterator(this,F,$)}serial(){return new SerialIterator(this)}};let ArrayIterator=class ArrayIterator extends LazyIterator{constructor(F){super(),this.items=F,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let F=this.items[this.trav];return this.trav++,{value:deepClone(F),done:!1}}};let FunctionCallIterator=class FunctionCallIterator extends LazyIterator{constructor(F){super(),this.nextFn=F}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(F){throw F.message=`Error thrown while iterating through a dataset: ${F.message}`,F}}};let SerialIterator=class SerialIterator extends LazyIterator{constructor(F){super(),this.upstream=F,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}};let SkipIterator=class SkipIterator extends LazyIterator{constructor(F,$){super(),this.upstream=F,this.maxCount=$,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let F=await this.upstream.next();if(F.done)return F;eD.B90(F.value)}return this.upstream.next()}};let TakeIterator=class TakeIterator extends LazyIterator{constructor(F,$){super(),this.upstream=F,this.maxCount=$,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}};let RowMajorBatchIterator=class RowMajorBatchIterator extends LazyIterator{constructor(F,$,V=!0){super(),this.upstream=F,this.batchSize=$,this.enableSmallLastBatch=V,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let F=[];for(;F.length<this.batchSize;){let $=await this.upstream.next();if($.done){if(this.enableSmallLastBatch&&F.length>0)return{value:F,done:!1};return{value:null,done:!0}}F.push($.value)}return{value:F,done:!1}}};let FilterIterator=class FilterIterator extends LazyIterator{constructor(F,$){super(),this.upstream=F,this.predicate=$,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let F=await this.upstream.next();if(F.done||this.predicate(F.value))return F;eD.B90(F.value)}}};let MapIterator=class MapIterator extends LazyIterator{constructor(F,$){super(),this.upstream=F,this.transform=$}summary(){return`${this.upstream.summary()} -> Map`}async next(){let F=await this.upstream.next();if(F.done)return{value:null,done:!0};let $=eD.piX.getTensorsInContainer(F.value),V=this.transform(F.value),G=eD.piX.getTensorsInContainer(V);for(let F of $)eD.piX.isTensorInList(F,G)||F.dispose();return{value:V,done:!1}}};let ErrorHandlingLazyIterator=class ErrorHandlingLazyIterator extends LazyIterator{constructor(F,$){super(),this.upstream=F,this.handler=$,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(F){if(!this.handler(F))return{value:null,done:!0}}}};let AsyncMapIterator=class AsyncMapIterator extends LazyIterator{constructor(F,$){super(),this.upstream=F,this.transform=$}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let F=await this.upstream.next();if(F.done)return{value:null,done:!0};let $=eD.piX.getTensorsInContainer(F.value),V=await this.transform(F.value),G=eD.piX.getTensorsInContainer(V);for(let F of $)eD.piX.isTensorInList(F,G)||F.dispose();return{value:V,done:!1}}};let OneToManyIterator=class OneToManyIterator extends LazyIterator{constructor(){super(),this.outputQueue=new GrowingRingBuffer,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}};let FlatmapIterator=class FlatmapIterator extends OneToManyIterator{constructor(F,$){super(),this.upstream=F,this.transform=$}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let F=await this.upstream.next();if(F.done)return!1;let $=eD.piX.getTensorsInContainer(F.value),V=this.transform(F.value),G=eD.piX.getTensorsInContainer(V);for(let F of(this.outputQueue.pushAll(V),$))eD.piX.isTensorInList(F,G)||F.dispose();return!0}};let ChainedIterator=class ChainedIterator extends LazyIterator{constructor(F,$){super(),this.baseErrorHandler=$,this.lastRead=null,this.iterator=null,this.moreIterators=F}summary(){let F="TODO: fill in upstream of chained summaries";return`${F} -> Chained`}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(F){if(await F,null==this.iterator){let F=await this.moreIterators.next();if(F.done)return{value:null,done:!0};this.iterator=F.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let $=await this.iterator.next();return $.done?(this.iterator=null,this.readFromChain(F)):$}};!function(F){F[F.FAIL=0]="FAIL",F[F.SHORTEST=1]="SHORTEST",F[F.LONGEST=2]="LONGEST"}(Z||(Z={}));let ZipIterator=class ZipIterator extends LazyIterator{constructor(F,$=Z.FAIL){super(),this.iterators=F,this.mismatchMode=$,this.count=0,this.currentPromise=null}summary(){let F="TODO: fill in upstream of zip summaries";return`{${F}} -> Zip`}async nextState(F){await F;let $=0,V=0;function getNext(F){if(!(F instanceof LazyIterator))return{value:null,recurse:!0};{let G=F.next();return{value:G.then(F=>($++,F.done&&V++,F.value)),recurse:!1}}}let G=await deepMapAndAwaitAll(this.iterators,getNext);if($===V)return{value:null,done:!0};if(V>0)switch(this.mismatchMode){case Z.FAIL:throw Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Z.SHORTEST:return{value:null,done:!0};case Z.LONGEST:}return this.count++,{value:G,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}};let PrefetchIterator=class PrefetchIterator extends LazyIterator{constructor(F,$){super(),this.upstream=F,this.bufferSize=$,this.buffer=new RingBuffer($)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let F=this.upstream.next();this.buffer.push(F)}}next(){return this.refill(),this.buffer.shift()}};let ShuffleIterator=class ShuffleIterator extends PrefetchIterator{constructor(F,$,V){super(F,$),this.upstream=F,this.windowSize=$,this.upstreamExhausted=!1,this.random=oe.alea(V||eD.D5U.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(F){return Math.floor(this.random()*F)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let F=this.chooseIndex(),$=await this.buffer.shuffleExcise(F);if(!$.done)return this.refill(),$;this.upstreamExhausted=!0}return{value:null,done:!0}}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let Dataset=class Dataset{constructor(){this.size=null}batch(F,$=!0){let V;let G=this;return eD.D5U.assert(F>0,()=>`batchSize needs to be positive, but it is
      ${F}`),datasetFromIteratorFn(async()=>(await G.iterator()).columnMajorBatch(F,$,deepBatchConcat),V=this.size===1/0||null==this.size?this.size:$?Math.ceil(this.size/F):Math.floor(this.size/F))}concatenate(F){let $;let V=this;return datasetFromIteratorFn(async()=>(await V.iterator()).concatenate(await F.iterator()),$=this.size===1/0||F.size===1/0?1/0:null!=this.size&&null!=F.size?this.size+F.size:null)}filter(F){let $;let V=this;return datasetFromIteratorFn(async()=>(await V.iterator()).filter($=>eD.lub(()=>F($))),$=this.size===1/0?1/0:null)}async forEachAsync(F){return(await this.iterator()).forEachAsync(F)}map(F){let $=this;return datasetFromIteratorFn(async()=>(await $.iterator()).map($=>eD.lub(()=>F($))),this.size)}mapAsync(F){let $=this;return datasetFromIteratorFn(async()=>(await $.iterator()).mapAsync(F),this.size)}prefetch(F){if(null==F)throw RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let $=this;return datasetFromIteratorFn(async()=>(await $.iterator()).prefetch(F),this.size)}repeat(F){let $;let V=this;return datasetFromIteratorFn(async()=>{let $=iteratorFromFunction(async()=>({value:await V.iterator(),done:!1}));return iteratorFromConcatenated($.take(F))},$=null!=this.size&&F>0?this.size*F:0===F?0:null!=this.size&&(void 0===F||F<0)?1/0:null)}skip(F){let $;let V=this;return datasetFromIteratorFn(async()=>(await V.iterator()).skip(F),$=null!=this.size&&F>=0&&this.size>=F?this.size-F:null!=this.size&&(this.size<F||void 0===F||F<0)?0:null)}shuffle(F,$,V=!0){if(null==F||F<0){if(null==this.size)throw RangeError("`Dataset.shuffle()` requires bufferSize to be specified.");throw RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`)}let G=this,H=oe.alea($||eD.D5U.now().toString());return datasetFromIteratorFn(async()=>{let $=H.int32();return V&&($+=H.int32()),(await G.iterator()).shuffle(F,$.toString())},this.size)}take(F){let $;let V=this;return datasetFromIteratorFn(async()=>(await V.iterator()).take(F),$=null!=this.size&&this.size>F?F:null!=this.size&&this.size<=F?this.size:null)}async toArray(){if(this.size===1/0)throw Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function datasetFromIteratorFn(F,$=null){return new class extends Dataset{constructor(){super(...arguments),this.size=$}async iterator(){return F()}}}function array(F){return datasetFromIteratorFn(async()=>iteratorFromItems(F),F.length)}function zip(F){let $;if(!isIterable(F))throw Error("The argument to zip() must be an object or array.");if(Array.isArray(F))for(let V=0;V<F.length;V++)$=null==$?F[V].size:Math.min($,F[V].size);else if(F instanceof Object)for(let V in F)$=null==$?F[V].size:Math.min($,F[V].size);return datasetFromIteratorFn(async()=>{let $=await deepMapAndAwaitAll(F,F=>{if(F instanceof Dataset)return{value:F.iterator(),recurse:!1};if(isIterable(F))return{value:null,recurse:!0};throw Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return iteratorFromZipped($,Z.SHORTEST)},$)}function deepBatchConcat(F){if(null===F)return null;let $=F[0];if(canTensorify($)){let $=batchConcat(F);return{value:$,recurse:!1}}return{value:null,recurse:!0}}function batchConcat(F){if(0===F.length)throw Error("Can't make a batch of zero elements.");return F[0]instanceof eD.esB?eD.knu(F):eD.XeE(F)}Dataset.MAX_BUFFER_SIZE=1e4;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let TextLineDataset=class TextLineDataset extends Dataset{constructor(F){super(),this.input=F}async iterator(){let F=await this.input.iterator(),$=F.decodeUTF8(),V=$.split("\n").map(F=>(F.endsWith("\r")&&(F=F.slice(0,-1)),F));return V}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let ot='"',or=Symbol("out"),oa=Symbol("field"),oi=Symbol("quote"),oo=Symbol("quoteafterquote"),os=Symbol("quoteinquote");let CSVDataset=class CSVDataset extends Dataset{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let F=await this.maybeReadHeaderLine();if(this.fullColumnNames||F)this.fullColumnNames&&F&&eD.D5U.assert(F.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+F.length.toString()+").");else throw Error("Column names must be provided if there is no header line.");this.fullColumnNames||(this.fullColumnNames=F);let $=this.fullColumnNames.reduce((F,$)=>(F[$]=F[$]+1||1,F),{}),V=Object.keys($).filter(F=>$[F]>1);if(eD.D5U.assert(0===V.length,()=>"Duplicate column names found: "+V.toString()),this.columnConfigs)for(let F of Object.keys(this.columnConfigs)){let $=this.fullColumnNames.indexOf(F);if(-1===$)throw Error('The key "'+F+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(!this.hasHeader)return null;{let F=await this.base.iterator(),$=await F.next();if($.done)throw Error("No data was found for CSV parsing.");let V=$.value,G=this.parseRow(V,!1);return G}}constructor(F,$){super(),this.input=F,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new TextLineDataset(F),$||($={}),this.hasHeader=!1!==$.hasHeader,this.fullColumnNames=$.columnNames,this.columnConfigs=$.columnConfigs,this.configuredColumnsOnly=$.configuredColumnsOnly,$.delimWhitespace?(eD.D5U.assert(null==$.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=$.delimiter?$.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let F=await this.base.iterator();return this.hasHeader&&(F=F.skip(1)),F.map(F=>this.makeDataElement(F))}makeDataElement(F){let $=this.parseRow(F),V={},G={};for(let H=0;H<this.fullColumnNames.length;H++){let K=this.fullColumnNames[H],Z=this.columnConfigs?this.columnConfigs[K]:null;if(!this.configuredColumnsOnly||Z){let ee=$[H],et=null;if(""===ee){if(Z&&void 0!==Z.default)et=Z.default;else if(Z&&(Z.required||Z.isLabel))throw Error(`Required column ${K} is empty in this line: ${F}`);else et=void 0}else{let F=Number(ee);if(isNaN(F))et=Z&&"bool"===Z.dtype?this.getBoolean(ee):ee;else if(Z&&Z.dtype)switch(Z.dtype){case"float32":default:et=F;break;case"int32":et=Math.floor(F);break;case"bool":et=this.getBoolean(ee)}else et=F}Z&&Z.isLabel?G[K]=et:V[K]=et}}return 0===Object.keys(G).length?V:{xs:V,ys:G}}getBoolean(F){return"1"===F||"true"===F.toLowerCase()?1:0}parseRow(F,$=!0){let V=[],G=0,H=F.length,K=or;for(let $=0;$<H;$++)switch(K){case or:switch(F.charAt($)){case ot:G=$+1,K=oi;break;case this.delimiter:if(G=$+1," "===this.delimiter&&this.delimWhitespace)break;V.push(""),K=or;break;default:K=oa,G=$}break;case oa:F.charAt($)===this.delimiter&&(V.push(F.substring(G,$)),K=or,G=$+1);break;case oi:F.charAt($)===ot&&(K=oo);break;case oo:switch(F.charAt($)){case this.delimiter:V.push(F.substring(G,$-1)),K=or,G=$+1;break;case ot:K=oi;break;default:K=os}break;case os:F.charAt($)===ot&&(K=oi)}if(K===oo?V.push(F.substring(G,H-1)):V.push(F.substring(G)),$&&V.length!==this.fullColumnNames.length)throw Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${V}`);return V}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let MicrophoneIterator=class MicrophoneIterator extends LazyIterator{constructor(F){super(),this.microphoneConfig=F,this.isClosed=!1,this.fftSize=F.fftSize||1024;let $=Math.log2(this.fftSize);if(this.fftSize<0||$<4||$>14||!Number.isInteger($))throw Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=F.numFramesPerSpectrogram||43,this.sampleRateHz=F.sampleRateHz,this.columnTruncateLength=F.columnTruncateLength||this.fftSize,this.audioTrackConstraints=F.audioTrackConstraints,this.smoothingTimeConstant=F.smoothingTimeConstant||0,this.includeSpectrogram=!1!==F.includeSpectrogram,this.includeWaveform=!0===F.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(F={}){if(!(0,eD.OBj)().get("IS_BROWSER"))throw Error("microphone API is only supported in browser environment.");let $=new MicrophoneIterator(F);return await $.start(),$}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(F){throw Error(`Error thrown while initializing video stream: ${F.message}`)}if(!this.stream)throw Error("Could not obtain audio from microphone.");let F=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new F,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let $=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,$.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){let F,$;if(this.isClosed)return{value:null,done:!0};let V=await this.getAudioData();if(this.includeSpectrogram){let $=this.flattenQueue(V.freqDataQueue);F=this.getTensorFromAudioDataArray($,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let F=this.flattenQueue(V.timeDataQueue);$=this.getTensorFromAudioDataArray(F,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:F,waveform:$},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let F=[],$=[],V=0;return new Promise(G=>{let H=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&G({freqDataQueue:F,timeDataQueue:$}),F.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),$.push(this.timeData.slice())),++V===this.numFrames&&(clearInterval(H),G({freqDataQueue:F,timeDataQueue:$}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){!this.isClosed&&(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(F){let $=F[0].length,V=new Float32Array(F.length*$);return F.forEach((F,G)=>V.set(F,G*$)),V}getTensorFromAudioDataArray(F,$){let V=new Float32Array(eD.D5U.sizeFromShape($));return V.set(F,V.length-F.length),(0,eD.XeE)(V,$)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let WebcamIterator=class WebcamIterator extends LazyIterator{constructor(F,$){if(super(),this.webcamVideoElement=F,this.webcamConfig=$,this.isClosed=!0,this.resize=!1,this.needToResize()){if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=(0,eD.RRF)([0],"int32"),this.webcamConfig.centerCrop){let F=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,$=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,V=(1-F)/2,G=(1-$)/2,H=V+F,K=$+G;this.cropBox=(0,eD.odF)([G,V,K,H],[1,4])}else this.cropBox=(0,eD.odF)([0,0,1,1],[1,4])}}summary(){return"webcam"}static async create(F,$={}){if(!(0,eD.OBj)().get("IS_BROWSER"))throw Error("tf.data.webcam is only supported in browser environment.");if(!F){if(F=document.createElement("video"),!$.resizeWidth||!$.resizeHeight)throw Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");F.width=$.resizeWidth,F.height=$.resizeHeight}let V=new WebcamIterator(F,$);return await V.start(),V}async start(){this.webcamConfig.facingMode&&eD.D5U.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(F){throw F.message=`Error thrown while initializing video stream: ${F.message}`,F}if(!this.stream)throw Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(F){console.log(F),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(F=>{this.webcamVideoElement.onloadedmetadata=()=>{F()}})}async next(){let F;if(this.isClosed)return{value:null,done:!0};try{F=eD.Xhn.fromPixels(this.webcamVideoElement)}catch(F){throw Error(`Error thrown converting video to pixels: ${JSON.stringify(F)}`)}if(!this.resize)return{value:F,done:!1};try{return{value:this.cropAndResizeFrame(F),done:!1}}catch(F){throw Error(`Error thrown cropping the video: ${F.message}`)}finally{F.dispose()}}needToResize(){return!!this.webcamConfig.resizeWidth&&!!this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight)}cropAndResizeFrame(F){return(0,eD.lub)(()=>{let $;let V=(0,eD.dt4)((0,eD.pju)(F,"float32"),0);$=eD.image.cropAndResize(V,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let G=$.shape;return(0,eD.XLQ)($,G.slice(1))})}async capture(){return(await this.next()).value}stop(){let F=this.stream.getTracks();F.forEach(F=>F.stop());try{this.webcamVideoElement.srcObject=null}catch(F){console.log(F),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw Error("Can not convert infinite video stream to array.")}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let DataSource=class DataSource{};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let StringIterator=class StringIterator extends LazyIterator{split(F){return new SplitIterator(this,F)}};let SplitIterator=class SplitIterator extends StringIterator{constructor(F,$){super(),this.upstream=F,this.impl=new SplitIteratorImpl(F,$)}summary(){return this.impl.summary()}async next(){return this.impl.next()}};let SplitIteratorImpl=class SplitIteratorImpl extends OneToManyIterator{constructor(F,$){super(),this.upstream=F,this.separator=$,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let F=await this.upstream.next();if(F.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let $=F.value.split(this.separator);for(let F of($[0]=this.carryover+$[0],$.slice(0,-1)))this.outputQueue.push(F);return this.carryover=$[$.length-1],!0}};var ou=V(21876).Buffer;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let ByteChunkIterator=class ByteChunkIterator extends LazyIterator{decodeUTF8(){return new Utf8Iterator(this)}};let Utf8Iterator=class Utf8Iterator extends StringIterator{constructor(F){super(),this.upstream=F,this.impl=new Utf8IteratorImpl(F)}summary(){return this.impl.summary()}async next(){return this.impl.next()}};let Utf8IteratorImpl=class Utf8IteratorImpl extends OneToManyIterator{constructor(F){if(super(),this.upstream=F,(0,eD.OBj)().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:F}=V(31601);this.decoder=new F("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let F,$;let V=await this.upstream.next();return!V.done&&(F=V.value,$=(0,eD.OBj)().get("IS_BROWSER")?this.decoder.decode(F,{stream:!0}):this.decoder.write(ou.from(F.buffer)),this.outputQueue.push($),!0)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let FileChunkIterator=class FileChunkIterator extends ByteChunkIterator{constructor(F,$={}){super(),this.file=F,this.options=$,eD.D5U.assert(F instanceof Uint8Array||!!(0,eD.OBj)().get("IS_BROWSER")&&(F instanceof File||F instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=$.offset||0,this.chunkSize=$.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};let F=new Promise((F,$)=>{let V=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)F(new Uint8Array(this.file.slice(this.offset,V)));else{let G=new FileReader;G.onload=V=>{let H=G.result;if(H instanceof ArrayBuffer&&(H=new Uint8Array(H)),!(H instanceof Uint8Array))return $(TypeError("FileReader returned unknown type."));F(H)},G.onabort=F=>$(Error("Aborted")),G.onerror=F=>$(Error(F.type));let H=this.file.slice(this.offset,V);G.readAsArrayBuffer(H)}this.offset=V});return{value:await F,done:!1}}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */async function urlChunkIterator(F,$={},V){let G,H;"string"==typeof F?G=F:(G=F.url,H=getRequestInitFromRequest(F));let K=await (V||eD.D5U.fetch)(G,H);if(K.ok){let F=new Uint8Array(await K.arrayBuffer());return new FileChunkIterator(F,$)}throw Error(K.statusText)}let getRequestInitFromRequest=F=>{let $={method:F.method,headers:F.headers,body:F.body,mode:F.mode,credentials:F.credentials,cache:F.cache,redirect:F.redirect,referrer:F.referrer,integrity:F.integrity};return $};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function isLocalPath(F){return"string"==typeof F&&"file://"===F.slice(0,7)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let FileDataSource=class FileDataSource extends DataSource{constructor(F,$={}){super(),this.input=F,this.options=$}async iterator(){if(isLocalPath(this.input)&&(0,eD.OBj)().get("IS_NODE")){let F=V(67792);this.input=F.readFileSync(this.input.slice(7))}return new FileChunkIterator(this.input,this.options)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let URLDataSource=class URLDataSource extends DataSource{constructor(F,$={}){super(),this.url=F,this.fileOptions=$}async iterator(){return isLocalPath(this.url)?new FileDataSource(this.url,this.fileOptions).iterator():urlChunkIterator(this.url,this.fileOptions)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function csv(F,$={}){return new CSVDataset(new URLDataSource(F),$)}function func(F){let $=iteratorFromFunction(F);return datasetFromIteratorFn(async()=>$)}function generator(F){return datasetFromIteratorFn(async()=>{let $=await F();return iteratorFromFunction(()=>$.next())})}async function webcam(F,$){return WebcamIterator.create(F,$)}async function microphone(F){return MicrophoneIterator.create(F)}/** @license See the LICENSE file. */let ol="4.15.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var oc=V(18166);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oh=eD.GDt.whereImpl;let MathBackendCPU=class MathBackendCPU extends eD.Zuw{nextDataId(){return MathBackendCPU.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new eD.JLz(this,(0,eD.SRH)())}write(F,$,V){this.firstUse&&(this.firstUse=!1,(0,eD.OBj)().get("IS_NODE")&&eD.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let G={id:this.nextDataId()};return this.data.set(G,{values:F,dtype:V,refCount:1}),G}makeTensorInfo(F,$,V){let G;if("string"===$&&null!=V&&V.length>0&&eD.D5U.isString(V[0])){let H=V.map(F=>eD.D5U.encodeString(F));G=this.write(H,F,$)}else G=this.write(V,F,$);return{dataId:G,shape:F,dtype:$}}refCount(F){if(this.data.has(F)){let $=this.data.get(F);return $.refCount}return 0}incRef(F){let $=this.data.get(F);$.refCount++}decRef(F){if(this.data.has(F)){let $=this.data.get(F);$.refCount--}}move(F,$,V,G,H){this.data.set(F,{values:$,dtype:G,refCount:H})}numDataIds(){return this.data.numDataIds()}async read(F){return this.readSync(F)}readSync(F){let{dtype:$,complexTensorInfos:V}=this.data.get(F);if("complex64"===$){let F=this.readSync(V.real.dataId),$=this.readSync(V.imag.dataId);return eD.backend_util.mergeRealAndImagArrays(F,$)}return eD.D5U.convertBackendValuesAndArrayBuffer(this.data.get(F).values,$)}bufferSync(F){let $=this.readSync(F.dataId);if("string"===F.dtype)try{let V=$.map(F=>eD.D5U.decodeString(F));return(0,eD.f3b)(F.shape,F.dtype,V)}catch(F){throw Error("Failed to decode encoded string bytes into utf-8")}return(0,eD.f3b)(F.shape,F.dtype,$)}makeOutput(F,$,V){return(0,eD.SRH)().makeTensorFromTensorInfo(this.makeTensorInfo($,V,F),this)}disposeData(F,$=!1){if(this.data.has(F)){if(this.data.get(F).refCount--,!$&&this.data.get(F).refCount>0)return!1;let{complexTensorInfos:V}=this.data.get(F);null!=V&&(this.disposeData(V.real.dataId,!0),this.disposeData(V.imag.dataId,!0)),this.data.delete(F)}return!0}disposeIntermediateTensorInfo(F){this.disposeData(F.dataId)}async time(F){let $=eD.D5U.now();F();let V=eD.D5U.now()-$;return{kernelMs:V}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(F){(0,oc.H)([F],"where");let $=this.readSync(F.dataId);return oh(F.shape,$)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};MathBackendCPU.nextDataId=0;var of=V(45226);/** @license See the LICENSE file. */let od="4.15.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(0,eD.jqO)("cpu",()=>new MathBackendCPU,1);var om=V(76738);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let og=(0,om.A)(eD.SX0,F=>F>=0?F:Math.exp(F)-1),oy={kernelName:eD.SX0,backendName:"cpu",kernelFunc:og};var ob=V(41775);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function leakyRelu(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{alpha:K}=G;(0,oc.H)([H],"leakyRelu");let Z=eD.D5U.sizeFromShape(H.shape),ee=V.data.get(H.dataId).values,et=eD.D5U.getTypedArrayFromDType("float32",Z);for(let F=0;F<ee.length;F++)et[F]=ee[F]<0?K*ee[F]:ee[F];return V.makeTensorInfo(H.shape,"float32",et)}let ox={kernelName:eD.J$2,backendName:"cpu",kernelFunc:leakyRelu};var ov=V(33533);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ow=(0,ov.b)((F,$)=>F<0?$*F:F);function Prelu_prelu(F){let{inputs:$,backend:V}=F,{x:G,alpha:H}=$;(0,oc.H)([G,H],"prelu");let K=V.data.get(G.dataId).values,Z=V.data.get(H.dataId).values,[ee,et]=ow(G.shape,H.shape,K,Z,"float32");return V.makeTensorInfo(et,"float32",ee)}let oS={kernelName:eD.o0g,backendName:"cpu",kernelFunc:Prelu_prelu},o_=(0,om.A)(eD.qkr,F=>Math.max(0,F)),oN={kernelName:eD.qkr,backendName:"cpu",kernelFunc:o_},oI=(0,om.A)(eD.SbG,F=>Math.min(Math.max(0,F),6)),oT={kernelName:eD.SbG,backendName:"cpu",kernelFunc:oI};var oC=V(40108);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function applyActivation(F,$,V,G,H){if("linear"===V)return(0,ob.y)({inputs:{x:$},backend:F});if("relu"===V)return o_({inputs:{x:$},backend:F});if("elu"===V)return og({inputs:{x:$},backend:F});if("relu6"===V)return oI({inputs:{x:$},backend:F});if("prelu"===V)return Prelu_prelu({inputs:{x:$,alpha:G},backend:F});if("leakyrelu"===V)return leakyRelu({inputs:{x:$},backend:F,attrs:{alpha:H}});if("sigmoid"===V)return(0,oC.XD)({inputs:{x:$},backend:F});throw Error(`Activation ${V} has not been implemented for the CPU backend.`)}var oE=V(32779);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Reshape_reshape(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{shape:K}=G,Z=eD.D5U.sizeFromShape(H.shape),ee=eD.D5U.inferFromImplicitShape(K,Z),et=eD.D5U.sizeFromShape(ee);eD.D5U.assert(Z===et,()=>`The new shape (${ee}) has ${et} elements and the old shape (${H.shape}) has ${Z} elements. The new shape and old shape must have the same number of elements.`),V.incRef(H.dataId);let en=V.data.get(H.dataId);if(null!=en.complexTensorInfos){let F=en.complexTensorInfos.real,$=en.complexTensorInfos.imag;F.shape=ee,$.shape=ee}return{dataId:H.dataId,shape:ee,dtype:H.dtype}}let oA={kernelName:eD.HZH,backendName:"cpu",kernelFunc:Reshape_reshape};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchMatMul(F){let{inputs:$,backend:V,attrs:G}=F,{a:H,b:K}=$,{transposeA:Z,transposeB:ee}=G;(0,oc.H)([H,K],"matMul");let et=H.shape.length,en=K.shape.length,ea=Z?H.shape[et-2]:H.shape[et-1],ei=ee?K.shape[en-1]:K.shape[en-2],eo=Z?H.shape[et-1]:H.shape[et-2],es=ee?K.shape[en-2]:K.shape[en-1],eu=H.shape.slice(0,-2),ec=K.shape.slice(0,-2),ep=eD.D5U.sizeFromShape(eu),eh=eD.D5U.sizeFromShape(ec),ef=eD.Jyw.assertAndGetBroadcastShape(H.shape.slice(0,-2),K.shape.slice(0,-2)),ed=ef.concat([eo,es]);eD.D5U.assert(ea===ei,()=>`Error in matMul: inner shapes (${ea}) and (${ei}) of Tensors with shapes ${H.shape} and ${K.shape} and transposeA=${Z} and transposeB=${ee} must match.`);let em=Z?[ep,ea,eo]:[ep,eo,ea],eg=ee?[eh,es,ei]:[eh,ei,es],ey=Reshape_reshape({inputs:{x:H},backend:V,attrs:{shape:em}}),eb=Reshape_reshape({inputs:{x:K},backend:V,attrs:{shape:eg}}),ew=Z?ey.shape[1]:ey.shape[2],eS=Z?ey.shape[2]:ey.shape[1],e_=ee?eb.shape[1]:eb.shape[2],eN=Math.max(ep,eh),ek=V.data.get(ey.dataId).values,eI=V.data.get(eb.dataId).values,eT=eD.D5U.computeStrides(ey.shape),eC=eD.D5U.computeStrides(eb.shape),[eE,eA,eM]=Z?[eT[0],1,eT[1]]:[eT[0],eT[1],1],[eR,eF,eO]=ee?[1,eC[1],eC[0]]:[eC[1],1,eC[0]],eP=eS*e_,eB=(0,eD.f3b)([eN,eS,e_],ey.dtype),e$=eB.values,eL=V.blockSize;for(let F=0;F<eN;F++){let $=F%ep,V=F%eh;for(let G=0;G<eS;G+=eL){let H=Math.min(G+eL,eS);for(let K=0;K<e_;K+=eL){let Z=Math.min(K+eL,e_);for(let ee=0;ee<ew;ee+=eL){let et=Math.min(ee+eL,ew);for(let en=G;en<H;en++)for(let G=K;G<Z;G++){let H=0;for(let F=ee;F<et;F++){let K=ek[$*eE+en*eA+F*eM],Z=eI[F*eR+G*eF+V*eO];H+=K*Z}e$[F*eP+(en*e_+G)]+=H}}}}}return V.disposeIntermediateTensorInfo(ey),V.disposeIntermediateTensorInfo(eb),V.makeTensorInfo(ed,eB.dtype,eB.values)}let oD={kernelName:eD.XLW,backendName:"cpu",kernelFunc:batchMatMul};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fusedMatMul(F){let $,V,G;let{inputs:H,backend:K,attrs:Z}=F,{a:ee,b:et,bias:en,preluActivationWeights:ea}=H,{transposeA:ei,transposeB:eo,activation:es,leakyreluAlpha:eu}=Z,ec=[],ep=batchMatMul({inputs:{a:ee,b:et},attrs:{transposeA:ei,transposeB:eo},backend:K});for(let F of($=ep,en&&(V=(0,oE.IH)({inputs:{a:$,b:en},backend:K}),ec.push($),$=V),es&&(G=applyActivation(K,$,es,ea,eu),ec.push($),$=G),ec))K.disposeIntermediateTensorInfo(F);return $}let oM={kernelName:eD.usg,backendName:"cpu",kernelFunc:_fusedMatMul};var oR=V(60224);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oF=(0,om.A)(eD.VGw,F=>Math.acos(F)),oO={kernelName:eD.VGw,backendName:"cpu",kernelFunc:oF},oP=(0,om.A)(eD.SpW,F=>Math.acosh(F)),oB={kernelName:eD.SpW,backendName:"cpu",kernelFunc:oP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function addN(F){let{inputs:$,backend:V}=F,G=$;(0,oc.H)($,"addN");let H=G.map(F=>V.data.get(F.dataId).values),K=(0,eD.f3b)(G[0].shape,G[0].dtype),Z=K.values;for(let F=0;F<G.length;F++){let $=H[F];for(let F=0;F<Z.length;F++)Z[F]+=$[F]}return V.makeTensorInfo(K.shape,K.dtype,K.values)}let o$={kernelName:eD.Xze,backendName:"cpu",kernelFunc:addN};var oL=V(44802);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function All_all(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K,keepDims:Z}=G;(0,oc.H)(H,"all");let ee=eD.D5U.parseAxisParam(K,H.shape),et=ee,en=eD.backend_util.getAxesPermutation(et,H.shape.length),ea=H;null!=en&&(ea=(0,oL.p)({inputs:{x:H},backend:V,attrs:{perm:en}}),et=eD.backend_util.getInnerMostAxes(et.length,H.shape.length)),eD.backend_util.assertAxesAreInnerMostDims("all",et,ea.shape.length);let[ei,eo]=eD.backend_util.computeOutAndReduceShapes(ea.shape,et),es=eD.D5U.sizeFromShape(eo),eu=eD.D5U.makeZerosTypedArray(eD.D5U.sizeFromShape(ei),ea.dtype),ec=V.data.get(ea.dataId).values;for(let F=0;F<eu.length;++F){let $=F*es,V=ec[$];for(let F=0;F<es;++F){let G=ec[$+F];V=V&&G}eu[F]=V}null!=en&&V.disposeIntermediateTensorInfo(ea);let ep=V.makeTensorInfo(ei,ea.dtype,eu);if(Z){let F=eD.backend_util.expandShapeToKeepDim(ei,ee),$=Reshape_reshape({inputs:{x:ep},backend:V,attrs:{shape:F}});return V.disposeIntermediateTensorInfo(ep),$}return ep}let oz={kernelName:eD.oT6,backendName:"cpu",kernelFunc:All_all};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Any_any(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K,keepDims:Z}=G;(0,oc.H)(H,"any");let ee=eD.D5U.parseAxisParam(K,H.shape),et=ee,en=eD.backend_util.getAxesPermutation(et,H.shape.length),ea=H;null!=en&&(ea=(0,oL.p)({inputs:{x:H},backend:V,attrs:{perm:en}}),et=eD.backend_util.getInnerMostAxes(et.length,H.shape.length)),eD.backend_util.assertAxesAreInnerMostDims("any",et,ea.shape.length);let[ei,eo]=eD.backend_util.computeOutAndReduceShapes(ea.shape,et),es=eD.D5U.sizeFromShape(eo),eu=eD.D5U.makeZerosTypedArray(eD.D5U.sizeFromShape(ei),ea.dtype),ec=V.data.get(ea.dataId).values;for(let F=0;F<eu.length;++F){let $=F*es,V=ec[$];for(let F=0;F<es;++F){let G=ec[$+F];V=V||G}eu[F]=V}null!=en&&V.disposeIntermediateTensorInfo(ea);let ep=V.makeTensorInfo(ei,ea.dtype,eu);if(Z){let F=eD.backend_util.expandShapeToKeepDim(ei,ee),$=Reshape_reshape({inputs:{x:ep},backend:V,attrs:{shape:F}});return V.disposeIntermediateTensorInfo(ep),$}return ep}let oV={kernelName:eD.IKK,backendName:"cpu",kernelFunc:Any_any};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMax(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K}=G;(0,oc.H)(H,"argMax");let Z=eD.D5U.parseAxisParam(K,H.shape),ee=eD.backend_util.getAxesPermutation(Z,H.shape.length),et=H,en=[];null!=ee&&(en.push(et=(0,oL.p)({inputs:{x:H},backend:V,attrs:{perm:ee}})),Z=eD.backend_util.getInnerMostAxes(Z.length,et.shape.length)),Z=[Z[0]],eD.backend_util.assertAxesAreInnerMostDims("argMax",Z,et.shape.length);let[ea,ei]=eD.backend_util.computeOutAndReduceShapes(et.shape,Z),eo=eD.D5U.sizeFromShape(ea),es=eD.D5U.makeZerosTypedArray(eo,"int32"),eu=eD.D5U.sizeFromShape(ei),ec=V.data.get(et.dataId).values;for(let F=0;F<es.length;++F){let $=F*eu,V=ec[$],G=0;for(let F=0;F<eu;++F){let H=ec[$+F];H>V&&(V=H,G=F)}es[F]=G}return en.forEach(F=>V.disposeIntermediateTensorInfo(F)),V.makeTensorInfo(ea,"int32",es)}let oU={kernelName:eD.sJF,backendName:"cpu",kernelFunc:argMax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMin(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K}=G;(0,oc.H)(H,"argMin");let Z=eD.D5U.parseAxisParam(K,H.shape),ee=eD.backend_util.getAxesPermutation(Z,H.shape.length),et=H,en=[];null!=ee&&(en.push(et=(0,oL.p)({inputs:{x:H},backend:V,attrs:{perm:ee}})),Z=eD.backend_util.getInnerMostAxes(Z.length,et.shape.length)),Z=[Z[0]],eD.backend_util.assertAxesAreInnerMostDims("argMin",Z,et.shape.length);let[ea,ei]=eD.backend_util.computeOutAndReduceShapes(et.shape,Z),eo=eD.D5U.sizeFromShape(ea),es=eD.D5U.makeZerosTypedArray(eo,"int32"),eu=eD.D5U.sizeFromShape(ei),ec=V.data.get(et.dataId).values;for(let F=0;F<es.length;++F){let $=F*eu,V=ec[$],G=0;for(let F=0;F<eu;++F){let H=ec[$+F];H<V&&(V=H,G=F)}es[F]=G}return en.forEach(F=>V.disposeIntermediateTensorInfo(F)),V.makeTensorInfo(ea,"int32",es)}let oW={kernelName:eD.aJk,backendName:"cpu",kernelFunc:argMin},oj=(0,om.A)(eD.M2y,F=>Math.asin(F)),oG={kernelName:eD.M2y,backendName:"cpu",kernelFunc:oj},oq=(0,om.A)(eD.qw7,F=>Math.asinh(F)),oH={kernelName:eD.qw7,backendName:"cpu",kernelFunc:oq},oX=(0,om.A)(eD.jMg,F=>Math.atan(F)),oK={kernelName:eD.jMg,backendName:"cpu",kernelFunc:oX};var oQ=V(46205);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oZ=(0,ov.b)((F,$)=>Math.atan2(F,$)),oY=(0,oQ.j)(eD.QCc,oZ),oJ={kernelName:eD.QCc,backendName:"cpu",kernelFunc:oY},o0=(0,om.A)(eD.Oyi,F=>Math.atanh(F)),o1={kernelName:eD.Oyi,backendName:"cpu",kernelFunc:o0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pool_utils_pool(F,$,V,G,H,K){let Z=H.strideHeight,ee=H.strideWidth,et=H.dilationHeight,en=H.dilationWidth,ea=H.effectiveFilterHeight,ei=H.effectiveFilterWidth,eo=H.padInfo.top,es=H.padInfo.left,eu="max"===K?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,ec=(0,eD.f3b)(H.outShape,V),ep=ec.values,eh=H.outShape[1]*H.outShape[2]*H.outShape[3],ef=H.outShape[2]*H.outShape[3],ed=H.outShape[3];for(let $=0;$<H.batchSize;++$){let V=$*eh,ec=$*G[0];for(let $=0;$<H.inChannels;++$)for(let eh=0;eh<H.outHeight;++eh){let em=eh*Z-eo,eg=Math.max(0,em),ey=Math.min(H.inHeight,ea+em),eb=V+eh*ef;for(let V=0;V<H.outWidth;++V){let Z=V*ee-es,ea=Math.max(0,Z),eo=Math.min(H.inWidth,ei+Z),eh=eu,ef=0,em=0;for(let V=eg;V<ey;V+=et){let H=ec+V*G[1];for(let V=ea;V<eo;V+=en){let Z=H+V*G[2],ee=F[Z+$];"max"===K&&ee>eh?eh=ee:"avg"===K&&(ef+=ee,em++)}if(isNaN(eh))break}let ew=eb+V*ed+$;ep[ew]="avg"===K?ef/em:eh}}}return ec}function maxPoolPositions(F,$,V,G,H=!1,K=!1){let Z=(0,eD.f3b)(G.outShape,"int32"),ee=G.strideHeight,et=G.strideWidth,en=G.dilationHeight,ea=G.dilationWidth,ei=G.effectiveFilterHeight,eo=G.effectiveFilterWidth,es=G.padInfo.top,eu=G.padInfo.left,ec=(0,eD.f3b)($,V,F);for(let F=0;F<G.batchSize;++F)for(let $=0;$<G.inChannels;++$)for(let V=0;V<G.outHeight;++V){let ep=V*ee-es,eh=ep;for(;eh<0;)eh+=en;let ef=Math.min(G.inHeight,ei+ep);for(let ee=0;ee<G.outWidth;++ee){let ei=ee*et-eu,es=ei;for(;es<0;)es+=ea;let ed=Math.min(G.inWidth,eo+ei),em=Number.NEGATIVE_INFINITY,eg=-1;for(let V=eh;V<ef;V+=en){let Z=V-ep;for(let ee=es;ee<ed;ee+=ea){let et=ee-ei,en=ec.get(F,V,ee,$);en>em&&(em=en,eg=H?K?((F*G.inHeight+V)*G.inWidth+ee)*G.inChannels+$:(V*G.inWidth+ee)*G.inChannels+$:Z*eo+et)}}Z.set(eg,F,V,ee,$)}}return Z}function pool3d(F,$,V,G,H,K){let Z=H.strideDepth,ee=H.strideHeight,et=H.strideWidth,en=H.dilationDepth,ea=H.dilationHeight,ei=H.dilationWidth,eo=H.effectiveFilterDepth,es=H.effectiveFilterHeight,eu=H.effectiveFilterWidth,ec=H.padInfo.front,ep=H.padInfo.top,eh=H.padInfo.left,ef="max"===K?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,ed=(0,eD.f3b)(H.outShape,V),em=ed.values,eg=H.outShape[1]*H.outShape[2]*H.outShape[3]*H.outShape[4],ey=H.outShape[2]*H.outShape[3]*H.outShape[4],eb=H.outShape[3]*H.outShape[4],ew=H.outShape[4];for(let $=0;$<H.batchSize;++$){let V=$*eg,ed=$*G[0];for(let $=0;$<H.inChannels;++$)for(let eg=0;eg<H.outDepth;++eg){let eS=eg*Z-ec,e_=eS;for(;e_<0;)e_+=en;let eN=Math.min(H.inDepth,eo+eS),ek=V+eg*ey;for(let V=0;V<H.outHeight;++V){let Z=V*ee-ep,eo=Z;for(;eo<0;)eo+=ea;let ec=Math.min(H.inHeight,es+Z),eg=ek+V*eb;for(let V=0;V<H.outWidth;++V){let Z=V*et-eh,ee=Z;for(;ee<0;)ee+=ei;let es=Math.min(H.inWidth,eu+Z),ep=eg+V*ew,ey=ef,eb=0,eS=0;for(let V=e_;V<eN;V+=en){let H=ed+V*G[1];for(let V=eo;V<ec;V+=ea){let Z=H+V*G[2];for(let V=ee;V<es;V+=ei){let H=Z+V*G[3],ee=F[H+$];if("max"===K&&ee>ey?ey=ee:"avg"===K&&(eb+=ee,eS++),isNaN(ey))break}if(isNaN(ey))break}if(isNaN(ey))break}let ek=ep+$;em[ek]="avg"===K?eb/Math.max(eS,1):ey}}}}return ed}function maxPool3dPositions(F,$){let V=(0,eD.f3b)($.outShape,"int32"),G=$.strideDepth,H=$.strideHeight,K=$.strideWidth,Z=$.dilationDepth,ee=$.dilationHeight,et=$.dilationWidth,en=$.effectiveFilterDepth,ea=$.effectiveFilterHeight,ei=$.effectiveFilterWidth,eo=$.padInfo.front,es=$.padInfo.top,eu=$.padInfo.left;for(let ec=0;ec<$.batchSize;++ec)for(let ep=0;ep<$.inChannels;++ep)for(let eh=0;eh<$.outDepth;++eh){let ef=eh*G-eo,ed=ef;for(;ed<0;)ed+=Z;let em=Math.min($.inDepth,en+ef);for(let G=0;G<$.outHeight;++G){let en=G*H-es,eo=en;for(;eo<0;)eo+=ee;let eg=Math.min($.inHeight,ea+en);for(let H=0;H<$.outWidth;++H){let es=H*K-eu,ey=es;for(;ey<0;)ey+=et;let eb=Math.min($.inWidth,ei+es),ew=Number.NEGATIVE_INFINITY,eS=-1;for(let $=ed;$<em;$+=Z){let V=$-ef;for(let G=eo;G<eg;G+=ee){let H=G-en;for(let K=ey;K<eb;K+=et){let Z=K-es,ee=F.get(ec,$,G,K,ep);ee>=ew&&(ew=ee,eS=V*ea*ei+H*ea+Z)}}}V.set(eS,ec,eh,G,H,ep)}}}return V}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V;(0,oc.H)(K,"avgPool");let{filterSize:Z,strides:ee,pad:et,dimRoundingMode:en}=H,ea=1;eD.D5U.assert(eD.backend_util.eitherStridesOrDilationsAreOne(ee,ea),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${ee} and dilations '${ea}'`);let ei=eD.backend_util.computePool2DInfo(K.shape,Z,ee,ea,et,en);if(1===ei.filterWidth&&1===ei.filterHeight&&eD.D5U.arraysEqual(ei.inShape,ei.outShape))$=(0,ob.y)({inputs:{x:K},backend:G});else{let F=G.data.get(K.dataId).values,V=eD.D5U.computeStrides(K.shape),H=pool_utils_pool(F,K.shape,K.dtype,V,ei,"avg");$=G.makeTensorInfo(ei.outShape,K.dtype,H.values)}return $}let o2={kernelName:eD.JhU,backendName:"cpu",kernelFunc:avgPool};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3D(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{filterSize:K,strides:Z,pad:ee,dimRoundingMode:et,dataFormat:en}=G;(0,oc.H)(H,"avgPool3d");let ea=eD.backend_util.computePool3DInfo(H.shape,K,Z,1,ee,et,en),ei=V.data.get(H.dataId).values,eo=pool3d(ei,H.shape,H.dtype,eD.D5U.computeStrides(H.shape),ea,"avg");return V.makeTensorInfo(eo.shape,"float32",eo.values)}let o3={kernelName:eD._k9,backendName:"cpu",kernelFunc:avgPool3D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3DGrad(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,input:K}=$,{filterSize:Z,strides:ee,pad:et,dimRoundingMode:en}=G;(0,oc.H)([H,K],"avgPool3DGrad");let ea=eD.backend_util.computePool3DInfo(K.shape,Z,ee,1,et,en),ei=ea.strideDepth,eo=ea.strideHeight,es=ea.strideWidth,eu=ea.filterDepth,ec=ea.filterHeight,ep=ea.filterWidth,eh=ea.dilationDepth,ef=ea.dilationHeight,ed=ea.dilationWidth,em=ea.effectiveFilterDepth,eg=ea.effectiveFilterHeight,ey=ea.effectiveFilterWidth,eb=em-1-ea.padInfo.front,ew=ey-1-ea.padInfo.left,eS=eg-1-ea.padInfo.top,e_=(0,eD.f3b)(K.shape,"float32"),eN=1/(eu*ec*ep),ek=V.bufferSync(H);for(let F=0;F<ea.batchSize;++F)for(let $=0;$<ea.inChannels;++$)for(let V=0;V<ea.inDepth;++V)for(let G=0;G<ea.inHeight;++G)for(let H=0;H<ea.inWidth;++H){let K=V-eb,Z=G-eS,ee=H-ew,et=0;for(let V=0;V<em;V+=eh){let G=(K+V)/ei;if(!(G<0)&&!(G>=ea.outDepth)&&Math.floor(G)===G)for(let V=0;V<eg;V+=ef){let H=(Z+V)/eo;if(!(H<0)&&!(H>=ea.outHeight)&&Math.floor(H)===H)for(let V=0;V<ey;V+=ed){let K=(ee+V)/es;if(K<0||K>=ea.outWidth||Math.floor(K)!==K)continue;let Z=ek.get(F,G,H,K,$);et+=Z}}}e_.set(et*eN,F,V,G,H,$)}return V.makeTensorInfo(e_.shape,e_.dtype,e_.values)}let o4={kernelName:eD.IMb,backendName:"cpu",kernelFunc:avgPool3DGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AvgPoolGrad_avgPoolGrad(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,input:K}=$,Z=K;(0,oc.H)([H,K],"avgPoolGrad");let{filterSize:ee,strides:et,pad:en}=G,ea=eD.backend_util.computePool2DInfo(Z.shape,ee,et,1,en),ei=ea.strideHeight,eo=ea.strideWidth,es=ea.filterHeight,eu=ea.filterWidth,ec=ea.dilationHeight,ep=ea.dilationWidth,eh=ea.effectiveFilterHeight,ef=ea.effectiveFilterWidth,ed=ef-1-ea.padInfo.left,em=eh-1-ea.padInfo.top,eg=(0,eD.f3b)(Z.shape,"float32"),ey=1/(es*eu),eb=V.data.get(H.dataId).values,ew=(0,eD.f3b)(H.shape,"float32",eb);for(let F=0;F<ea.batchSize;++F)for(let $=0;$<ea.inChannels;++$)for(let V=0;V<ea.inHeight;++V)for(let G=0;G<ea.inWidth;++G){let H=V-em,K=G-ed,Z=0;for(let V=0;V<eh;V+=ec){let G=(H+V)/ei;if(!(G<0)&&!(G>=ea.outHeight)&&Math.floor(G)===G)for(let V=0;V<ef;V+=ep){let H=(K+V)/eo;if(H<0||H>=ea.outWidth||Math.floor(H)!==H)continue;let ee=ew.get(F,G,H,$);Z+=ee}}eg.set(Z*ey,F,V,G,$)}return V.makeTensorInfo(eg.shape,eg.dtype,eg.values)}let o6={kernelName:eD.ROF,backendName:"cpu",kernelFunc:AvgPoolGrad_avgPoolGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchNorm(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,scale:K,offset:Z,mean:ee,variance:et}=$;eD.D5U.assert(ee.shape.length===et.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),eD.D5U.assert(null==Z||ee.shape.length===Z.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),eD.D5U.assert(null==K||ee.shape.length===K.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),(0,oc.H)([H,ee,et,K,Z],"batchNorm");let{varianceEpsilon:en}=G;null==en&&(en=.001);let ea=V.data.get(H.dataId).values,ei=V.data.get(ee.dataId).values,eo=V.data.get(et.dataId).values,es=K?V.data.get(K.dataId).values:new Float32Array([1]),eu=Z?V.data.get(Z.dataId).values:new Float32Array([0]),ec=new Float32Array(ea.length),ep=eu.length,eh=es.length,ef=eo.length,ed=ei.length,em=0,eg=0,ey=0,eb=0;for(let F=0;F<ea.length;++F)ec[F]=eu[em++]+(ea[F]-ei[eg++])*es[ey++]/Math.sqrt(eo[eb++]+en),em>=ep&&(em=0),eg>=ed&&(eg=0),ey>=eh&&(ey=0),eb>=ef&&(eb=0);return V.makeTensorInfo(H.shape,H.dtype,ec)}let o5={kernelName:eD.sHE,backendName:"cpu",kernelFunc:batchNorm};var o9=V(82578);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchToSpaceND(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{blockShape:K,crops:Z}=G;(0,oc.H)([H],"batchToSpaceND");let ee=K.reduce((F,$)=>F*$),et=eD.backend_util.getReshaped(H.shape,K,ee),en=eD.backend_util.getPermuted(et.length,K.length),ea=eD.backend_util.getReshapedPermuted(H.shape,K,ee),ei=eD.backend_util.getSliceBeginCoords(Z,K.length),eo=eD.backend_util.getSliceSize(ea,Z,K.length),es=Reshape_reshape({inputs:{x:H},backend:V,attrs:{shape:et}}),eu=(0,oL.p)({inputs:{x:es},backend:V,attrs:{perm:en}}),ec=Reshape_reshape({inputs:{x:eu},backend:V,attrs:{shape:ea}}),ep=(0,o9.tP)({inputs:{x:ec},backend:V,attrs:{begin:ei,size:eo}});return V.disposeIntermediateTensorInfo(es),V.disposeIntermediateTensorInfo(eu),V.disposeIntermediateTensorInfo(ec),ep}let o8={kernelName:eD.zws,backendName:"cpu",kernelFunc:batchToSpaceND};var o7=V(58607);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bincount(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,weights:K}=$,{size:Z}=G,ee=V.data.get(H.dataId).values,et=V.data.get(K.dataId).values,en=(0,o7.W)(ee,et,K.dtype,K.shape,Z);return V.makeTensorInfo([Z],K.dtype,en)}let se={kernelName:eD.zvY,backendName:"cpu",kernelFunc:bincount};var st=V(5003);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function broadcastArgs(F){let{inputs:$,backend:V}=F,{s0:G,s1:H}=$,K=V.data.get(G.dataId).values,Z=V.data.get(H.dataId).values,ee=eD.backend_util.assertAndGetBroadcastShape(Array.from(K),Array.from(Z));return V.makeTensorInfo([ee.length],"int32",Int32Array.from(ee))}let sn={kernelName:eD.eEB,backendName:"cpu",kernelFunc:broadcastArgs};var sa=V(29258),so=V(34769);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ss=(0,om.A)(eD.xnO,(F,$)=>{let V=$;return F>V.clipValueMax?V.clipValueMax:F<V.clipValueMin?V.clipValueMin:F}),su={kernelName:eD.xnO,backendName:"cpu",kernelFunc:ss};var sl=V(26961);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let complexAbs=F=>{let{x:$}=F.inputs,V=F.backend,G=new Float32Array(eD.D5U.sizeFromShape($.shape)),H=V.data.get($.dataId),K=H.complexTensorInfos.real,Z=H.complexTensorInfos.imag,ee=V.data.get(K.dataId).values,et=V.data.get(Z.dataId).values;for(let F=0;F<ee.length;F++){let $=ee[F],V=et[F];G[F]=Math.hypot($,V)}return V.makeOutput(G,$.shape,"float32")},sc={kernelName:eD.yj2,backendName:"cpu",kernelFunc:complexAbs};var sp=V(48926);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag(F){let{inputs:$,backend:V}=F,{input:G}=$,H=V.data.get(G.dataId).complexTensorInfos.imag,K=V.data.get(H.dataId).values;return V.makeTensorInfo(H.shape,H.dtype,K)}let sh={kernelName:eD.J_u,backendName:"cpu",kernelFunc:imag};var sf=V(82186);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Concat_concat(F){let{inputs:$,backend:V,attrs:G}=F,{axis:H}=G,K=eD.D5U.parseAxisParam(H,$[0].shape)[0],Z=$.map(F=>F.shape);eD.backend_util.assertParamsConsistent(Z,K);let ee=eD.backend_util.computeOutShape($.map(F=>F.shape),K);if(0===eD.D5U.sizeFromShape(ee))return V.makeTensorInfo(ee,$[0].dtype,[]);let et=$.filter(F=>eD.D5U.sizeFromShape(F.shape)>0);if(1===et.length)return(0,ob.y)({inputs:{x:et[0]},backend:V});if("complex64"===et[0].dtype){let F=et.map(F=>(0,sf.k)({inputs:{input:F},backend:V})),$=et.map(F=>imag({inputs:{input:F},backend:V})),G=Concat_concat({inputs:F,backend:V,attrs:{axis:K}}),H=Concat_concat({inputs:$,backend:V,attrs:{axis:K}}),Z=(0,sl.P)({inputs:{real:G,imag:H},backend:V});return F.forEach(F=>V.disposeIntermediateTensorInfo(F)),$.forEach(F=>V.disposeIntermediateTensorInfo(F)),V.disposeIntermediateTensorInfo(G),V.disposeIntermediateTensorInfo(H),Z}let en=et.map(F=>{let $=eD.D5U.sizeFromShape(F.shape.slice(K)),G=[-1,$];return Reshape_reshape({inputs:{x:F},backend:V,attrs:{shape:G}})}),ea=en.map(F=>({vals:V.data.get(F.dataId).values,shape:F.shape}));ee=eD.backend_util.computeOutShape(en.map(F=>F.shape),1);let ei=1===en[0].shape[0],eo=(0,sp.j)(ea,ee,$[0].dtype,ei),es=eD.backend_util.computeOutShape(et.map(F=>F.shape),K),eu=V.makeTensorInfo(es,$[0].dtype,eo);return en.forEach(F=>V.disposeIntermediateTensorInfo(F)),eu}let sm={kernelName:eD.Eh3,backendName:"cpu",kernelFunc:Concat_concat};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2D(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,filter:K}=$,{strides:Z,pad:ee,dataFormat:et,dilations:en,dimRoundingMode:ea}=G;(0,oc.H)([H,K],"conv2d");let ei=eD.backend_util.convertConv2DDataFormat(et),eo=eD.backend_util.computeConv2DInfo(H.shape,K.shape,Z,en,ee,ea,!1,ei),es=eo.filterHeight,eu=eo.filterWidth,ec=eo.dilationHeight,ep=eo.dilationWidth,eh=eo.padInfo.left,ef=eo.padInfo.top,ed="channelsLast"===eo.dataFormat,em=new eD.YDk(eo.outShape,H.dtype),eg=eD.D5U.computeStrides(H.shape),ey=eD.D5U.computeStrides(K.shape),eb=eg[0],ew=ed?eg[1]:eg[2],eS=ed?eg[2]:1,e_=ed?1:eg[1],eN=em.strides[0],ek=ed?em.strides[1]:em.strides[2],eI=ed?em.strides[2]:1,eT=ed?1:em.strides[1],eC=V.data.get(H.dataId).values,eE=V.data.get(K.dataId).values,eA=em.values;for(let F=0;F<eo.batchSize;++F){let $=F*eb,V=F*eN;for(let F=0;F<eo.outHeight;++F){let G=V+F*ek,H=F*eo.strideHeight-ef;for(let F=0;F<es;++F){let V=H+F*ec;if(V<0||V>=eo.inHeight)continue;let K=F*ey[0],Z=$+V*ew;for(let F=0;F<eo.outWidth;++F){let $=G+F*eI,V=F*eo.strideWidth-eh;for(let F=0;F<eu;++F){let G=V+F*ep;if(G<0||G>=eo.inWidth)continue;let H=K+F*ey[1],ee=Z+G*eS,et=H;for(let F=0;F<eo.inChannels;++F){let V=eC[ee+F*e_];for(let F=0;F<eo.outChannels;++F)eA[$+F*eT]+=V*eE[et+F];et+=eo.outChannels}}}}}}return V.makeTensorInfo(em.shape,em.dtype,eA)}let sg={kernelName:eD.mhS,backendName:"cpu",kernelFunc:conv2D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropFilter(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,dy:K}=$,{strides:Z,pad:ee,dataFormat:et,dimRoundingMode:en,filterShape:ea}=G;(0,oc.H)([H,K],"conv2dBackpropFilter");let ei=eD.backend_util.convertConv2DDataFormat(et),eo=eD.backend_util.computeConv2DInfo(H.shape,ea,Z,1,ee,en,!1,ei),{strideHeight:es,strideWidth:eu,filterHeight:ec,filterWidth:ep}=eo,eh="channelsLast"===eo.dataFormat,ef=new eD.YDk(eo.filterShape,"float32"),ed=eo.padInfo.left,em=eo.padInfo.top,eg=V.data.get(H.dataId).values,ey=V.data.get(K.dataId).values,eb=new eD.YDk(H.shape,H.dtype,eg),ew=new eD.YDk(K.shape,K.dtype,ey);for(let F=0;F<ec;++F){let $=Math.max(0,Math.ceil((em-F)/es)),V=Math.min(eo.outHeight,(eo.inHeight+em-F)/es);for(let G=0;G<ep;++G){let H=Math.max(0,Math.ceil((ed-G)/eu)),K=Math.min(eo.outWidth,(eo.inWidth+ed-G)/eu);for(let Z=0;Z<eo.inChannels;++Z)for(let ee=0;ee<eo.outChannels;++ee){let et=0;for(let en=0;en<eo.batchSize;++en)for(let ea=$;ea<V;++ea){let $=F+ea*es-em;for(let F=H;F<K;++F){let V=G+F*eu-ed;eh?et+=eb.get(en,$,V,Z)*ew.get(en,ea,F,ee):et+=eb.get(en,Z,$,V)*ew.get(en,ee,ea,F)}}ef.set(et,F,G,Z,ee)}}}return V.makeTensorInfo(ef.shape,ef.dtype,ef.values)}let sy={kernelName:eD.wUP,backendName:"cpu",kernelFunc:conv2DBackpropFilter};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropInput(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,filter:K}=$,{inputShape:Z,strides:ee,pad:et,dataFormat:en,dimRoundingMode:ea}=G;(0,oc.H)([H,K],"conv2dBackpropInput");let ei=eD.D5U.computeStrides(K.shape),eo=eD.D5U.computeStrides(H.shape),es=eD.backend_util.convertConv2DDataFormat(en),eu=eD.backend_util.computeConv2DInfo(Z,K.shape,ee,1,et,ea,!1,es),ec=new eD.YDk(eu.inShape,"float32"),ep=ec.values,eh=V.data.get(H.dataId).values,ef=V.data.get(K.dataId).values,[ed,em,eg]=ei,{batchSize:ey,filterHeight:eb,filterWidth:ew,inChannels:eS,inHeight:e_,inWidth:eN,outChannels:ek,outHeight:eI,outWidth:eT,strideHeight:eC,strideWidth:eE}=eu;es=eu.dataFormat;let eA=eb-1-eu.padInfo.top,eM=ew-1-eu.padInfo.left,eR="channelsLast"===es,eF=ec.strides[0],eO=eR?ec.strides[1]:ec.strides[2],eP=eR?ec.strides[2]:1,eB=eR?1:ec.strides[1],e$=eo[0],eL=eR?eo[1]:eo[2],ez=eR?eo[2]:1,eV=eR?1:eo[1];for(let F=0;F<ey;++F)for(let $=0;$<eS;++$)for(let V=0;V<e_;++V){let G=V-eA,H=Math.max(0,Math.ceil(G/eC)),K=Math.min(eI,(eb+G)/eC);for(let Z=0;Z<eN;++Z){let ee=Z-eM,et=Math.max(0,Math.ceil(ee/eE)),en=Math.min(eT,(ew+ee)/eE),ea=0;for(let V=H;V<K;++V){let H=V*eC-G;for(let G=et;G<en;++G){let K=G*eE-ee,Z=e$*F+eL*V+ez*G,et=ed*(eb-1-H)+em*(ew-1-K)+eg*$;for(let F=0;F<ek;++F){let $=eh[Z+eV*F],V=ef[et+F];ea+=$*V}}}let ei=eF*F+eO*V+eP*Z+eB*$;ep[ei]=ea}}return V.makeTensorInfo(ec.shape,ec.dtype,ec.values)}let sb={kernelName:eD.wm,backendName:"cpu",kernelFunc:conv2DBackpropInput};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3D(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,filter:K}=$,{strides:Z,pad:ee,dilations:et}=G;(0,oc.H)([H,K],"conv3d");let en=eD.backend_util.computeConv3DInfo(H.shape,K.shape,Z,et,ee),{filterDepth:ea,filterHeight:ei,filterWidth:eo,dilationDepth:es,dilationHeight:eu,dilationWidth:ec,padInfo:ep}=en,eh=ep.front,ef=ep.left,ed=ep.top,em=new eD.YDk(en.outShape,H.dtype),eg=V.data.get(H.dataId).values,ey=V.data.get(K.dataId).values,eb=em.values,ew=eD.D5U.computeStrides(H.shape),eS=eD.D5U.computeStrides(K.shape);for(let F=0;F<en.batchSize;++F){let $=F*ew[0],V=F*em.strides[0];for(let F=0;F<en.outDepth;++F){let G=V+F*em.strides[1],H=F*en.strideDepth-eh;for(let F=0;F<ea;++F){let V=H+F*es;if(V<0||V>=en.inDepth)continue;let K=F*eS[0],Z=$+V*ew[1];for(let F=0;F<en.outHeight;++F){let $=G+F*em.strides[2],V=F*en.strideHeight-ed;for(let F=0;F<ei;++F){let G=V+F*eu;if(G<0||G>=en.inHeight)continue;let H=K+F*eS[1],ee=Z+G*ew[2];for(let F=0;F<en.outWidth;++F){let V=$+F*en.outChannels,G=F*en.strideWidth-ef;for(let F=0;F<eo;++F){let $=G+F*ec;if($<0||$>=en.inWidth)continue;let K=H+F*eS[2],Z=ee+$*en.inChannels,et=K;for(let F=0;F<en.inChannels;++F){let $=eg[Z+F];for(let F=0;F<en.outChannels;++F)eb[V+F]+=$*ey[et+F];et+=en.outChannels}}}}}}}}return V.makeTensorInfo(em.shape,em.dtype,em.values)}let sx={kernelName:eD.x12,backendName:"cpu",kernelFunc:conv3D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropFilterV2(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,dy:K}=$,{strides:Z,pad:ee,filterShape:et}=G;(0,oc.H)([H,K],"conv3dBackpropFilterV2");let en=eD.D5U.computeStrides(H.shape),ea=eD.D5U.computeStrides(K.shape),ei=eD.backend_util.computeConv3DInfo(H.shape,et,Z,1,ee),eo=ei.strideDepth,es=ei.strideHeight,eu=ei.strideWidth,ec=ei.filterDepth,ep=ei.filterHeight,eh=ei.filterWidth,ef=new eD.YDk(ei.filterShape,"float32"),ed=ef.values,[em,eg,ey,eb]=ef.strides,ew=V.data.get(K.dataId).values,[eS,e_,eN,ek]=ea,eI=V.data.get(H.dataId).values,[eT,eC,eE,eA]=en,eM=ei.padInfo.front,eR=ei.padInfo.left,eF=ei.padInfo.top;for(let F=0;F<ec;++F){let $=Math.max(0,Math.ceil((eM-F)/eo)),V=Math.min(ei.outDepth,(ei.inDepth+eM-F)/eo),G=F*em;for(let H=0;H<ep;++H){let K=Math.max(0,Math.ceil((eF-H)/es)),Z=Math.min(ei.outHeight,(ei.inHeight+eF-H)/es),ee=H*eg+G;for(let G=0;G<eh;++G){let et=Math.max(0,Math.ceil((eR-G)/eu)),en=Math.min(ei.outWidth,(ei.inWidth+eR-G)/eu),ea=G*ey+ee;for(let ee=0;ee<ei.inChannels;++ee){let ec=ee*eb+ea;for(let ea=0;ea<ei.outChannels;++ea){let ep=0;for(let ec=0;ec<ei.batchSize;++ec){let ei=ec*eT,eh=ec*eS;for(let ec=$;ec<V;++ec){let $=F+ec*eo-eM,V=$*eC+ei,ef=ec*e_+eh;for(let F=K;F<Z;++F){let $=H+F*es-eF,K=$*eE+V,Z=F*eN+ef;for(let F=et;F<en;++F){let $=G+F*eu-eR,V=$*eA+K,H=F*ek+Z;ep+=eI[V+ee]*ew[H+ea]}}}}ed[ec+ea]=ep}}}}}return V.makeTensorInfo(ef.shape,ef.dtype,ef.values)}let sv={kernelName:eD.o2y,backendName:"cpu",kernelFunc:conv3DBackpropFilterV2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropInputV2(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,filter:K}=$,{pad:Z,strides:ee,inputShape:et}=G;(0,oc.H)([H],"conv3dBackpropInputV2");let en=eD.D5U.computeStrides(H.shape),ea=eD.D5U.computeStrides(K.shape),ei=eD.backend_util.computeConv3DInfo(et,K.shape,ee,1,Z),eo=new eD.YDk(ei.inShape,"float32"),es=eo.values,[eu,ec,ep,eh]=eo.strides,ef=V.data.get(H.dataId).values,[ed,em,eg,ey]=en,eb=V.data.get(K.dataId).values,[ew,eS,e_,eN]=ea,{batchSize:ek,filterDepth:eI,filterHeight:eT,filterWidth:eC,inChannels:eE,inDepth:eA,inHeight:eM,inWidth:eR,outChannels:eF,outDepth:eO,outHeight:eP,outWidth:eB,strideDepth:e$,strideHeight:eL,strideWidth:ez}=ei,eV=eI-1-ei.padInfo.front,eU=eT-1-ei.padInfo.top,eW=eC-1-ei.padInfo.left;for(let F=0;F<ek;++F)for(let $=0;$<eE;++$)for(let V=0;V<eA;++V){let G=V-eV,H=Math.max(0,Math.ceil(G/e$)),K=Math.min(eO,(eI+G)/e$);for(let Z=0;Z<eM;++Z){let ee=Z-eU,et=Math.max(0,Math.ceil(ee/eL)),en=Math.min(eP,(eT+ee)/eL);for(let ea=0;ea<eR;++ea){let ei=ea-eW,eo=Math.max(0,Math.ceil(ei/ez)),ek=Math.min(eB,(eC+ei)/ez),eE=0;for(let V=H;V<K;++V){let H=V*e$-G;for(let G=et;G<en;++G){let K=G*eL-ee;for(let Z=eo;Z<ek;++Z){let ee=Z*ez-ei,et=ed*F+em*V+eg*G+ey*Z,en=ew*(eI-1-H)+eS*(eT-1-K)+e_*(eC-1-ee)+eN*$;for(let F=0;F<eF;++F){let $=ef[et+F],V=eb[en+F];eE+=$*V}}}}es[eu*F+ec*V+ep*Z+eh*ea+$]=eE}}}return V.makeTensorInfo(eo.shape,eo.dtype,eo.values)}let sw={kernelName:eD.ik2,backendName:"cpu",kernelFunc:conv3DBackpropInputV2},sS=(0,om.A)(eD.mc4,F=>Math.cos(F)),s_={kernelName:eD.mc4,backendName:"cpu",kernelFunc:sS},sN=(0,om.A)(eD.TR1,F=>Math.cosh(F)),sk={kernelName:eD.TR1,backendName:"cpu",kernelFunc:sN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cropAndResize(F){let{inputs:$,backend:V,attrs:G}=F,{image:H,boxes:K,boxInd:Z}=$,{cropSize:ee,method:et,extrapolationValue:en}=G,[ea,ei,eo,es]=H.shape,eu=K.shape[0],[ec,ep]=ee,eh=(0,eD.f3b)([eu,ec,ep,es],"float32"),ef=V.data.get(K.dataId).values,ed=V.data.get(Z.dataId).values,em=V.data.get(H.dataId).values,eg=eD.D5U.computeStrides(H.shape),ey=eD.D5U.computeStrides(eh.shape);for(let F=0;F<eu;F++){let $=4*F,V=ef[$],G=ef[$+1],H=ef[$+2],K=ef[$+3],Z=ed[F];if(Z>=ea)continue;let ee=ec>1?(H-V)*(ei-1)/(ec-1):0,eu=ep>1?(K-G)*(eo-1)/(ep-1):0;for(let $=0;$<ec;$++){let ea=ec>1?V*(ei-1)+$*ee:.5*(V+H)*(ei-1);if(ea<0||ea>ei-1){for(let V=0;V<ep;V++)for(let G=0;G<es;G++){let H=G+V*ey[2]+$*ey[1]+F*ey[0];eh.values[H]=en}continue}if("bilinear"===et){let V=Math.floor(ea),H=Math.ceil(ea),ee=ea-V;for(let et=0;et<ep;et++){let ea=ep>1?G*(eo-1)+et*eu:.5*(G+K)*(eo-1);if(ea<0||ea>eo-1){for(let V=0;V<es;V++){let G=V+et*ey[2]+$*ey[1]+F*ey[0];eh.values[G]=en}continue}let ei=Math.floor(ea),ec=Math.ceil(ea),ef=ea-ei;for(let G=0;G<es;G++){let K=G+ei*eg[2]+V*eg[1]+Z*eg[0],en=em[K];K=G+ec*eg[2]+V*eg[1]+Z*eg[0];let ea=em[K];K=G+ei*eg[2]+H*eg[1]+Z*eg[0];let eo=em[K];K=G+ec*eg[2]+H*eg[1]+Z*eg[0];let es=em[K],eu=en+(ea-en)*ef,ep=eo+(es-eo)*ef;K=G+et*ey[2]+$*ey[1]+F*ey[0],eh.values[K]=eu+(ep-eu)*ee}}}else for(let V=0;V<ep;++V){let H=ep>1?G*(eo-1)+V*eu:.5*(G+K)*(eo-1);if(H<0||H>eo-1){for(let G=0;G<es;G++){let H=G+V*ey[2]+$*ey[1]+F*ey[0];eh.values[H]=en}continue}let ee=Math.round(H),et=Math.round(ea);for(let G=0;G<es;G++){let H=G+ee*eg[2]+et*eg[1]+Z*eg[0],K=G+V*ey[2]+$*ey[1]+F*ey[0];eh.values[K]=em[H]}}}}return V.makeTensorInfo(eh.shape,eh.dtype,eh.values)}let sI={kernelName:eD.VcC,backendName:"cpu",kernelFunc:cropAndResize};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cumprod_cumprod(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K,exclusive:Z,reverse:ee}=G;(0,oc.H)(H,"cumprod");let et=eD.backend_util.getAxesPermutation([K],H.shape.length),en=H;null!=et&&(en=(0,oL.p)({inputs:{x:H},backend:V,attrs:{perm:et}}));let ea=eD.backend_util.getInnerMostAxes(1,H.shape.length)[0];if(ea!==en.shape.length-1)throw Error(`backend.cumprod in CPU expects an inner-most axis=${en.shape.length-1} but got axis=${ea}`);let ei=(0,eD.x8V)(en.dtype,"int32"),eo=eD.D5U.makeOnesTypedArray(eD.D5U.sizeFromShape(en.shape),ei),es=V.data.get(en.dataId).values,eu=en.shape[en.shape.length-1],ec=ee?(F,$)=>F+eu-$-1:(F,$)=>F+$;for(let F=0;F<es.length;F+=eu)for(let $=0;$<eu;$++){let V=ec(F,$);if(0===$)eo[V]=Z?1:es[V];else{let G=ec(F,$-1);eo[V]=Z?es[G]*eo[G]:es[V]*eo[G]}}let ep=V.makeTensorInfo(en.shape,ei,eo);if(null!=et){let F=eD.backend_util.getUndoAxesPermutation(et),$=(0,oL.p)({inputs:{x:ep},backend:V,attrs:{perm:F}});return V.disposeIntermediateTensorInfo(ep),V.disposeIntermediateTensorInfo(en),$}return ep}let sT={kernelName:eD.Byc,backendName:"cpu",kernelFunc:Cumprod_cumprod};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cumsum_cumsum(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K,exclusive:Z,reverse:ee}=G;(0,oc.H)(H,"cumsum");let et=eD.backend_util.getAxesPermutation([K],H.shape.length),en=H;null!=et&&(en=(0,oL.p)({inputs:{x:H},backend:V,attrs:{perm:et}}));let ea=eD.backend_util.getInnerMostAxes(1,H.shape.length)[0];if(ea!==en.shape.length-1)throw Error(`backend.cumsum in CPU expects an inner-most axis=${en.shape.length-1} but got axis=${ea}`);let ei=(0,eD.x8V)(en.dtype,"int32"),eo=eD.D5U.makeZerosTypedArray(eD.D5U.sizeFromShape(en.shape),ei),es=V.data.get(en.dataId).values,eu=en.shape[en.shape.length-1],ec=ee?(F,$)=>F+eu-$-1:(F,$)=>F+$;for(let F=0;F<es.length;F+=eu)for(let $=0;$<eu;$++){let V=ec(F,$);if(0===$)eo[V]=Z?0:es[V];else{let G=ec(F,$-1);eo[V]=Z?es[G]+eo[G]:es[V]+eo[G]}}let ep=V.makeTensorInfo(en.shape,ei,eo);if(null!=et){let F=eD.backend_util.getUndoAxesPermutation(et),$=(0,oL.p)({inputs:{x:ep},backend:V,attrs:{perm:F}});return V.disposeIntermediateTensorInfo(ep),V.disposeIntermediateTensorInfo(en),$}return ep}let sC={kernelName:eD.iHb,backendName:"cpu",kernelFunc:Cumsum_cumsum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function denseBincount(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,weights:K}=$,{size:Z,binaryOutput:ee}=G;if(1===H.shape.length){let F=V.data.get(H.dataId).values,$=V.data.get(K.dataId).values,G=(0,o7.W)(F,$,K.dtype,K.shape,Z);return V.makeTensorInfo([Z],K.dtype,G)}if(2===H.shape.length){let F=V.bufferSync(H),$=V.bufferSync(K),G=(0,o7.i)(F,$,Z,ee);return V.makeTensorInfo(G.shape,K.dtype,G.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${H.shape.length}.`)}let sE={kernelName:eD.QRR,backendName:"cpu",kernelFunc:denseBincount};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthToSpace(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{blockSize:K,dataFormat:Z}=G;eD.D5U.assert("NHWC"===Z,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${Z}`);let ee=H.shape[0],et=H.shape[1],en=H.shape[2],ea=H.shape[3],ei=et*K,eo=en*K,es=ea/(K*K),eu=V.data.get(H.dataId).values,ec=new Float32Array(ee*ei*eo*es),ep=0;for(let F=0;F<ee;++F)for(let $=0;$<ei;++$){let V=Math.floor($/K),G=$%K;for(let $=0;$<eo;++$){let H=Math.floor($/K),Z=$%K,ee=(G*K+Z)*es;for(let $=0;$<es;++$){let G=$+ee,K=G+ea*(H+en*(V+et*F));ec[ep++]=eu[K]}}}return V.makeTensorInfo([ee,ei,eo,es],H.dtype,ec)}let sA={kernelName:eD.T0n,backendName:"cpu",kernelFunc:depthToSpace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNative(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,filter:K}=$,{strides:Z,pad:ee,dilations:et,dimRoundingMode:en}=G;(0,oc.H)([H,K],"depthwiseConv2DNative");let ea=eD.D5U.computeStrides(H.shape),ei=eD.D5U.computeStrides(K.shape),eo=et;null==eo&&(eo=[1,1]),eD.D5U.assert(eD.backend_util.eitherStridesOrDilationsAreOne(Z,eo),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${Z} and dilations '${eo}'`);let es=eD.backend_util.computeConv2DInfo(H.shape,K.shape,Z,eo,ee,en,!0),{filterHeight:eu,filterWidth:ec,dilationHeight:ep,dilationWidth:eh,padInfo:ef}=es,ed=ef.left,em=ef.top,eg=es.outChannels/es.inChannels,ey=new eD.YDk(es.outShape,H.dtype),eb=V.data.get(H.dataId).values,ew=V.data.get(K.dataId).values,eS=ey.values;for(let F=0;F<es.batchSize;++F){let $=F*ea[0],V=F*ey.strides[0];for(let F=0;F<es.outHeight;++F){let G=V+F*ey.strides[1],H=F*es.strideHeight-em;for(let F=0;F<eu;++F){let V=H+F*ep;if(V<0||V>=es.inHeight)continue;let K=F*ei[0],Z=$+V*ea[1];for(let F=0;F<es.outWidth;++F){let $=G+F*ey.strides[2],V=F*es.strideWidth-ed;for(let F=0;F<ec;++F){let G=V+F*eh;if(G<0||G>=es.inWidth)continue;let H=K+F*ei[1],ee=Z+G*es.inChannels,et=$,en=H;for(let F=0;F<es.inChannels;++F){let $=eb[ee+F];for(let F=0;F<eg;++F)eS[et+F]+=$*ew[en+F];et+=eg,en+=eg}}}}}}return V.makeTensorInfo(ey.shape,ey.dtype,ey.values)}let sD={kernelName:eD.cie,backendName:"cpu",kernelFunc:depthwiseConv2dNative};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropFilter(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,dy:K}=$,{strides:Z,dilations:ee,pad:et,dimRoundingMode:en,filterShape:ea}=G;(0,oc.H)([H,K],"depthwiseConv2dNativeBackpropFilter");let ei=eD.backend_util.computeConv2DInfo(H.shape,ea,Z,ee,et,en,!0),{strideHeight:eo,strideWidth:es,filterHeight:eu,filterWidth:ec}=ei,ep=new eD.YDk(ei.filterShape,"float32"),eh=ei.padInfo.left,ef=ei.padInfo.top,ed=ei.outChannels/ei.inChannels,em=V.data.get(H.dataId).values,eg=new eD.YDk(H.shape,H.dtype,em),ey=V.data.get(K.dataId).values,eb=new eD.YDk(K.shape,K.dtype,ey);for(let F=0;F<eu;++F){let $=Math.max(0,Math.ceil((ef-F)/eo)),V=Math.min(ei.outHeight,(ei.inHeight+ef-F)/eo);for(let G=0;G<ec;++G){let H=Math.max(0,Math.ceil((eh-G)/es)),K=Math.min(ei.outWidth,(ei.inWidth+eh-G)/es);for(let Z=0;Z<ei.outChannels;++Z){let ee=Math.trunc(Z/ed),et=Z%ed,en=0;for(let et=0;et<ei.batchSize;++et)for(let ea=$;ea<V;++ea){let $=F+ea*eo-ef;for(let F=H;F<K;++F){let V=G+F*es-eh;en+=eg.get(et,$,V,ee)*eb.get(et,ea,F,Z)}}ep.set(en,F,G,ee,et)}}}return V.makeTensorInfo(ep.shape,ep.dtype,ep.values)}let sM={kernelName:eD.sL$,backendName:"cpu",kernelFunc:depthwiseConv2dNativeBackpropFilter};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropInput(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,filter:K}=$,{strides:Z,dilations:ee,pad:et,dimRoundingMode:en,inputShape:ea}=G;(0,oc.H)([H,K],"depthwiseConv2DNativeBackpropInput");let ei=eD.D5U.computeStrides(H.shape),eo=eD.D5U.computeStrides(K.shape),es=eD.backend_util.computeConv2DInfo(ea,K.shape,Z,ee,et,en,!0),eu=new eD.YDk(es.inShape,"float32"),ec=eu.values,[ep,eh,ef]=eu.strides,ed=V.data.get(H.dataId).values,[em,eg,ey]=ei,eb=V.data.get(K.dataId).values,[ew,eS,e_]=eo,{batchSize:eN,filterHeight:ek,filterWidth:eI,inChannels:eT,inHeight:eC,inWidth:eE,outChannels:eA,outHeight:eM,outWidth:eR,strideHeight:eF,strideWidth:eO}=es,eP=ek-1-es.padInfo.top,eB=eI-1-es.padInfo.left,e$=eA/eT;for(let F=0;F<eN;++F)for(let $=0;$<eT;++$)for(let V=0;V<eC;++V){let G=V-eP,H=Math.max(0,Math.ceil(G/eF)),K=Math.min(eM,(ek+G)/eF);for(let Z=0;Z<eE;++Z){let ee=Z-eB,et=Math.max(0,Math.ceil(ee/eO)),en=Math.min(eR,(eI+ee)/eO),ea=0;for(let V=H;V<K;++V){let H=V*eF-G;for(let G=et;G<en;++G){let K=G*eO-ee,Z=em*F+eg*V+ey*G,et=ew*(ek-1-H)+eS*(eI-1-K)+e_*$;for(let F=0;F<e$;++F){let V=$*e$+F,G=ed[Z+V],H=eb[et+F];ea+=G*H}}}ec[ep*F+eh*V+ef*Z+$]=ea}}return V.makeTensorInfo(eu.shape,eu.dtype,eu.values)}let sR={kernelName:eD.y7R,backendName:"cpu",kernelFunc:depthwiseConv2dNativeBackpropInput};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function diag(F){let{inputs:$,backend:V}=F,{x:G}=$,H=eD.D5U.sizeFromShape(G.shape),K=V.data.get(G.dataId).values,Z=(0,eD.f3b)([H,H],G.dtype),ee=Z.values;for(let F=0;F<K.length;F++)ee[F*H+F]=K[F];let et=[...G.shape,...G.shape];return V.makeTensorInfo(et,Z.dtype,Z.values)}let sF={kernelName:eD.$w,backendName:"cpu",kernelFunc:diag},sO={kernelName:eD.p4S,backendName:"cpu",kernelFunc:({inputs:F,backend:$,attrs:V})=>{let{x:G,filter:H}=F,{strides:K,pad:Z,dilations:ee}=V,et=$,en=et.data.get(G.dataId).values,ea=G.shape.length,ei=et.data.get(H.dataId).values,eo=H.shape.length,{batchSize:es,inHeight:eu,inWidth:ec,inChannels:ep,outHeight:eh,outWidth:ef,padInfo:ed,strideHeight:em,strideWidth:eg,filterHeight:ey,filterWidth:eb,dilationHeight:ew,dilationWidth:eS,outShape:e_}=eD.backend_util.computeDilation2DInfo(G.shape,H.shape,K,Z,"NHWC",ee),eN=eD.D5U.sizeFromShape(e_),ek=e_.length,eI=eD.D5U.getArrayFromDType(G.dtype,eN);for(let F=0;F<es;++F)for(let $=0;$<eh;++$){let V=$*em-ed.top;for(let K=0;K<ef;++K){let Z=K*eg-ed.left;for(let ee=0;ee<ep;++ee){let et=Number.MIN_SAFE_INTEGER;for(let $=0;$<ey;++$){let K=V+$*ew;if(K>=0&&K<eu)for(let V=0;V<eb;++V){let es=Z+V*eS;if(es>=0&&es<ec){let Z=eD.D5U.locToIndex([F,K,es,ee],ea,eD.D5U.computeStrides(G.shape)),eu=eD.D5U.locToIndex([$,V,ee],eo,eD.D5U.computeStrides(H.shape)),ec=en[Z]+ei[eu];ec>et&&(et=ec)}}}let es=eD.D5U.locToIndex([F,$,K,ee],ek,eD.D5U.computeStrides(e_));eI[es]=et}}}let eT=et.write(eD.D5U.toTypedArray(eI,G.dtype),e_,G.dtype);return{dataId:eT,shape:e_,dtype:G.dtype}}},sP={kernelName:eD.Vn9,backendName:"cpu",kernelFunc:({inputs:F,backend:$,attrs:V})=>{let{x:G,filter:H,dy:K}=F,{strides:Z,pad:ee,dilations:et}=V,en=$,ea=eD.D5U.toNestedArray(G.shape,en.data.get(G.dataId).values),ei=eD.D5U.toNestedArray(H.shape,en.data.get(H.dataId).values),{batchSize:eo,inHeight:es,inWidth:eu,inChannels:ec,outHeight:ep,outWidth:eh,padInfo:ef,strideHeight:ed,strideWidth:em,filterHeight:eg,filterWidth:ey,dilationHeight:eb,dilationWidth:ew,outShape:eS}=eD.backend_util.computeDilation2DInfo(G.shape,H.shape,Z,ee,"NHWC",et);eD.D5U.assert(K.rank===eS.length,()=>`Error in ${eD.Vn9}, dy must have the same rank as output ${eS.length}, but got ${K.rank}`);let e_=eD.D5U.toNestedArray(eS,en.data.get(K.dataId).values),eN=eD.D5U.makeZerosNestedTypedArray(H.shape,H.dtype);for(let F=0;F<eo;++F)for(let $=0;$<ep;++$){let V=$*ed-ef.top;for(let G=0;G<eh;++G){let H=G*em-ef.left;for(let K=0;K<ec;++K){let Z=Number.MIN_SAFE_INTEGER,ee=0,et=0;for(let $=0;$<eg;++$){let G=V+$*eb;if(G>=0&&G<es)for(let V=0;V<ey;++V){let en=H+V*ew;if(en>=0&&en<eu){let H=ea[F][G][en][K]+ei[$][V][K];H>Z&&(Z=H,ee=$,et=V)}}}eN[ee][et][K]+=e_[F][$][G][K]}}}let ek=en.write(eD.D5U.toTypedArray(eN,G.dtype),H.shape,H.dtype);return{dataId:ek,shape:H.shape,dtype:H.dtype}}},sB={kernelName:eD.ekb,backendName:"cpu",kernelFunc:({inputs:F,backend:$,attrs:V})=>{let{x:G,filter:H,dy:K}=F,{strides:Z,pad:ee,dilations:et}=V,en=$,ea=eD.D5U.toNestedArray(G.shape,en.data.get(G.dataId).values),ei=eD.D5U.toNestedArray(H.shape,en.data.get(H.dataId).values),{batchSize:eo,inHeight:es,inWidth:eu,inChannels:ec,outHeight:ep,outWidth:eh,padInfo:ef,strideHeight:ed,strideWidth:em,filterHeight:eg,filterWidth:ey,dilationHeight:eb,dilationWidth:ew,outShape:eS}=eD.backend_util.computeDilation2DInfo(G.shape,H.shape,Z,ee,"NHWC",et);eD.D5U.assert(K.rank===eS.length,()=>`Error in ${eD.ekb}, dy must have the same rank as output ${eS.length}, but got ${K.rank}`);let e_=eD.D5U.toNestedArray(eS,en.data.get(K.dataId).values),eN=eD.D5U.makeZerosNestedTypedArray(G.shape,G.dtype);for(let F=0;F<eo;++F)for(let $=0;$<ep;++$){let V=$*ed-ef.top;for(let G=0;G<eh;++G){let H=G*em-ef.left;for(let K=0;K<ec;++K){let Z=Number.MIN_SAFE_INTEGER,ee=V<0?0:V,et=H<0?0:H;for(let $=0;$<eg;++$){let G=V+$*eb;if(G>=0&&G<es)for(let V=0;V<ey;++V){let en=H+V*ew;if(en>=0&&en<eu){let H=ea[F][G][en][K]+ei[$][V][K];H>Z&&(Z=H,ee=G,et=en)}}}eN[F][ee][et][K]+=e_[F][$][G][K]}}}let ek=en.write(eD.D5U.toTypedArray(eN,G.dtype),G.shape,G.dtype);return{dataId:ek,shape:G.shape,dtype:G.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function draw(F){let{inputs:$,backend:V,attrs:G}=F,{image:H}=$,{canvas:K,options:Z}=G,{contextOptions:ee,imageOptions:et}=Z||{},en=(null==et?void 0:et.alpha)||1,ea=(null==ee?void 0:ee.contextType)||"2d";if("2d"!==ea)throw Error(`Context type ${ee.contextType} is not supported by the CPU backend.`);let ei=K.getContext(ea,(null==ee?void 0:ee.contextAttributes)||{});if(null==ei)throw Error(`Could not get the context with ${ea} type.`);let[eo,es]=H.shape.slice(0,2),eu=2===H.shape.length?1:H.shape[2],ec=V.data.get(H.dataId).values,ep="float32"===H.dtype?255:1,eh=new Uint8ClampedArray(es*eo*4);for(let F=0;F<eo*es;++F){let $=[0,0,0,255*en];for(let V=0;V<eu;V++){let G=ec[F*eu+V];if("float32"===H.dtype){if(G<0||G>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${G}.`)}else if("int32"===H.dtype&&(G<0||G>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${G}.`);1===eu?($[0]=G*ep,$[1]=G*ep,$[2]=G*ep):$[V]=G*ep}let V=4*F;eh[V+0]=Math.round($[0]),eh[V+1]=Math.round($[1]),eh[V+2]=Math.round($[2]),eh[V+3]=Math.round($[3])}K.width=es,K.height=eo;let ef=new ImageData(eh,es,eo);return ei.putImageData(ef,0,0),H}let s$={kernelName:eD.hGc,backendName:"cpu",kernelFunc:draw};var sL=V(1917),sV=V(24391);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sum_sum(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V,{axis:Z,keepDims:ee}=H;(0,oc.H)(K,"sum"),$="bool"===K.dtype?(0,sa.pj)({inputs:{x:K},backend:G,attrs:{dtype:"int32"}}):(0,ob.y)({inputs:{x:K},backend:G});let et=$.shape.length,en=eD.D5U.parseAxisParam(Z,$.shape),ea=eD.backend_util.getAxesPermutation(en,et),ei=en,eo=$;null!=ea&&(eo=(0,oL.p)({inputs:{x:$},backend:G,attrs:{perm:ea}}),ei=eD.backend_util.getInnerMostAxes(ei.length,et)),eD.backend_util.assertAxesAreInnerMostDims("sum",ei,eo.shape.length);let[es,eu]=eD.backend_util.computeOutAndReduceShapes(eo.shape,ei),ec=eD.backend_util.upcastType(eo.dtype,"int32"),ep=(0,sV.l)(G,es,ec),eh=eD.D5U.sizeFromShape(eu),ef=G.data.get(ep.dataId).values,ed=G.data.get(eo.dataId).values;for(let F=0;F<ef.length;++F){let $=F*eh,V=0;for(let F=0;F<eh;++F)V+=ed[$+F];ef[F]=V}if(ee){let F=eD.backend_util.expandShapeToKeepDim(ep.shape,en),$=ep;ep=Reshape_reshape({inputs:{x:ep},backend:G,attrs:{shape:F}}),G.disposeIntermediateTensorInfo($)}return G.disposeIntermediateTensorInfo($),null!=ea&&G.disposeIntermediateTensorInfo(eo),ep}let sU={kernelName:eD.GBy,backendName:"cpu",kernelFunc:Sum_sum};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function einsum(F){let{inputs:$,backend:V,attrs:G}=F,{equation:H}=G,K=$,{allDims:Z,summedDims:ee,idDims:et}=eD.backend_util.decodeEinsumEquation(H,K.length);eD.backend_util.checkEinsumDimSizes(Z.length,et,K);let{path:en,steps:ea}=eD.backend_util.getEinsumComputePath(ee,et),ei=ea.length,eo=null,es=Z.length,eu=[];for(let F=0;F<ei;++F){for(let $ of ea[F]){let F;let{permutationIndices:G,expandDims:H}=eD.backend_util.getEinsumPermutation(es,et[$]);eD.backend_util.isIdentityPermutation(G)?F=K[$]:(F=(0,oL.p)({inputs:{x:K[$]},backend:V,attrs:{perm:G}}),eu.push(F));let Z=F.shape.slice();for(let F=0;F<H.length;++F)Z.splice(H[F],0,1);eD.D5U.arraysEqual(F.shape,Z)||(F=Reshape_reshape({inputs:{x:F},backend:V,attrs:{shape:Z}}),eu.push(F)),null===eo?eo=F:(eo=(0,sL.Jp)({inputs:{a:F,b:eo},backend:V}),eu.push(eo))}F<ei-1&&(en[F]>=0&&(eo=Sum_sum({inputs:{x:eo},backend:V,attrs:{axis:en[F]-(Z.length-es),keepDims:!1}}),eu.push(eo)),es--)}for(let F of eu)F!==eo&&V.disposeIntermediateTensorInfo(F);return eo}let sW={kernelName:eD.$g6,backendName:"cpu",kernelFunc:einsum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eluGrad(F){let{inputs:$,backend:V}=F,{dy:G,y:H}=$;(0,oc.H)([G,H],"eluGrad");let K=new Float32Array(eD.D5U.sizeFromShape(H.shape)),Z=V.data.get(H.dataId).values,ee=V.data.get(G.dataId).values;for(let F=0;F<Z.length;++F){let $=Z[F];$>=0?K[F]=ee[F]:K[F]=ee[F]*($+1)}return V.makeTensorInfo(H.shape,"float32",K)}let sj={kernelName:eD.HEU,backendName:"cpu",kernelFunc:eluGrad};var sG=V(7679);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sq=eD.backend_util.ERF_P,sH=eD.backend_util.ERF_A1,sX=eD.backend_util.ERF_A2,sK=eD.backend_util.ERF_A3,sQ=eD.backend_util.ERF_A4,sZ=eD.backend_util.ERF_A5,sY=(0,om.A)(eD.Omj,F=>{let $=Math.sign(F),V=Math.abs(F),G=1/(1+sq*V);return $*(1-((((sZ*G+sQ)*G+sK)*G+sX)*G+sH)*G*Math.exp(-V*V))}),sJ={kernelName:eD.Omj,backendName:"cpu",kernelFunc:sY};var s3=V(31211);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expandDims(F){let{inputs:$,backend:V,attrs:G}=F,{input:H}=$,{dim:K}=G,Z=H.shape.length,ee=H.shape.slice(),et=K;return K<0&&(eD.D5U.assert(-(Z+1)<=K,()=>`Axis must be in the interval [${-(Z+1)}, ${Z}]`),et=Z+K+1),ee.splice(et,0,1),Reshape_reshape({inputs:{x:H},backend:V,attrs:{shape:ee}})}let s4={kernelName:eD.YFo,backendName:"cpu",kernelFunc:expandDims};var s6=V(30969);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let s5=(0,ov.b)((F,$)=>F/$),s9=(0,oQ.j)(eD.oHH,s5),s8={kernelName:eD.oHH,backendName:"cpu",kernelFunc:s9};var s7=V(71649);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fftBatch(F,$,V){let G=F.shape,H=G[0],K=G[1],Z=V.data.get(F.dataId),ee=Z.complexTensorInfos.real,et=Z.complexTensorInfos.imag,en=[H,K],ea=eD.D5U.sizeFromShape(en),ei=eD.D5U.getTypedArrayFromDType("float32",ea),eo=eD.D5U.getTypedArrayFromDType("float32",ea);for(let F=0;F<H;F++){let G=(0,o9.tP)({inputs:{x:ee},backend:V,attrs:{begin:[F,0],size:[1,K]}}),H=(0,o9.tP)({inputs:{x:et},backend:V,attrs:{begin:[F,0],size:[1,K]}}),Z=(0,sl.P)({inputs:{real:G,imag:H},backend:V}),{real:en,imag:ea}=fftImpl(Z,$,V),es=eD.backend_util.mergeRealAndImagArrays(en,ea);for(let $=0;$<K;$++){let V=eD.backend_util.getComplexWithIndex(es,$);ei[F*K+$]=V.real,eo[F*K+$]=V.imag}V.disposeIntermediateTensorInfo(G),V.disposeIntermediateTensorInfo(H),V.disposeIntermediateTensorInfo(Z)}let es=V.makeTensorInfo(en,"float32",ei),eu=V.makeTensorInfo(en,"float32",eo),ec=(0,sl.P)({inputs:{real:es,imag:eu},backend:V});return V.disposeIntermediateTensorInfo(es),V.disposeIntermediateTensorInfo(eu),ec}function fftImpl(F,$,V){let G=eD.D5U.sizeFromShape(F.shape),H=V.data.get(F.dataId),K=V.data.get(H.complexTensorInfos.real.dataId).values,Z=V.data.get(H.complexTensorInfos.imag.dataId).values;if(isExponentOf2(G)){let H=fftRadix2(K,Z,G,$,V),ee=[F.shape[0],F.shape[1]];if($){let F=V.makeTensorInfo(ee,"float32",H.real),$=V.makeTensorInfo(ee,"float32",H.imag),K=V.makeTensorInfo([],"float32",eD.D5U.createScalarValue(G,"float32")),Z=(0,ob.y)({inputs:{x:K},backend:V}),et=s8.kernelFunc({inputs:{a:F,b:K},backend:V}),en=s8.kernelFunc({inputs:{a:$,b:Z},backend:V}),ea=V.data.get(et.dataId).values,ei=V.data.get(en.dataId).values;return V.disposeIntermediateTensorInfo(F),V.disposeIntermediateTensorInfo($),V.disposeIntermediateTensorInfo(K),V.disposeIntermediateTensorInfo(Z),V.disposeIntermediateTensorInfo(et),V.disposeIntermediateTensorInfo(en),{real:ea,imag:ei}}return H}{let F=eD.backend_util.mergeRealAndImagArrays(K,Z),V=fourierTransformByMatmul(F,G,$);return eD.backend_util.splitRealAndImagArrays(V)}}function isExponentOf2(F){return(F&F-1)==0}function fftRadix2(F,$,V,G,H){if(1===V)return{real:F,imag:$};let K=eD.backend_util.mergeRealAndImagArrays(F,$),Z=V/2,ee=eD.backend_util.complexWithEvenIndex(K),et=ee.real,en=ee.imag,ea=[et.length],ei=H.makeTensorInfo(ea,"float32",et),eo=H.makeTensorInfo(ea,"float32",en),es=(0,sl.P)({inputs:{real:ei,imag:eo},backend:H}),eu=eD.backend_util.complexWithOddIndex(K),ec=eu.real,ep=eu.imag,eh=[ec.length],ef=H.makeTensorInfo(eh,"float32",ec),ed=H.makeTensorInfo(eh,"float32",ep),em=(0,sl.P)({inputs:{real:ef,imag:ed},backend:H}),eg=fftRadix2(et,en,Z,G,H),ey=eg.real,eb=eg.imag,ew=[ey.length],eS=H.makeTensorInfo(ew,"float32",ey),e_=H.makeTensorInfo(ew,"float32",eb),eN=(0,sl.P)({inputs:{real:eS,imag:e_},backend:H}),ek=fftRadix2(ec,ep,Z,G,H),eI=ek.real,eT=ek.imag,eC=[eI.length],eE=H.makeTensorInfo(eC,"float32",eI),eA=H.makeTensorInfo(eC,"float32",eT),eM=(0,sl.P)({inputs:{real:eE,imag:eA},backend:H}),eR=eD.backend_util.exponents(V,G),eF=[eR.real.length],eO=H.makeTensorInfo(eF,"float32",eR.real),eP=H.makeTensorInfo(eF,"float32",eR.imag),eB=(0,sl.P)({inputs:{real:eO,imag:eP},backend:H}),e$=(0,sL.Jp)({inputs:{a:eB,b:eM},backend:H}),eL=(0,oE.IH)({inputs:{a:eN,b:e$},backend:H}),ez=(0,s7.lu)({inputs:{a:eN,b:e$},backend:H}),eV=(0,sf.k)({inputs:{input:eL},backend:H}),eU=(0,sf.k)({inputs:{input:ez},backend:H}),eW=imag({inputs:{input:eL},backend:H}),ej=imag({inputs:{input:ez},backend:H}),eG=Concat_concat({inputs:[eV,eU],backend:H,attrs:{axis:0}}),eH=Concat_concat({inputs:[eW,ej],backend:H,attrs:{axis:0}}),eX=H.data.get(eG.dataId).values,eK=H.data.get(eH.dataId).values;return H.disposeIntermediateTensorInfo(ei),H.disposeIntermediateTensorInfo(eo),H.disposeIntermediateTensorInfo(es),H.disposeIntermediateTensorInfo(ef),H.disposeIntermediateTensorInfo(ed),H.disposeIntermediateTensorInfo(em),H.disposeIntermediateTensorInfo(eS),H.disposeIntermediateTensorInfo(e_),H.disposeIntermediateTensorInfo(eN),H.disposeIntermediateTensorInfo(eE),H.disposeIntermediateTensorInfo(eA),H.disposeIntermediateTensorInfo(eM),H.disposeIntermediateTensorInfo(eO),H.disposeIntermediateTensorInfo(eP),H.disposeIntermediateTensorInfo(eB),H.disposeIntermediateTensorInfo(e$),H.disposeIntermediateTensorInfo(eL),H.disposeIntermediateTensorInfo(ez),H.disposeIntermediateTensorInfo(eV),H.disposeIntermediateTensorInfo(eW),H.disposeIntermediateTensorInfo(eU),H.disposeIntermediateTensorInfo(ej),H.disposeIntermediateTensorInfo(eG),H.disposeIntermediateTensorInfo(eH),{real:eX,imag:eK}}function fourierTransformByMatmul(F,$,V){let G=new Float32Array(2*$);for(let H=0;H<$;H++){let K=0,Z=0;for(let G=0;G<$;G++){let ee=eD.backend_util.exponent(H*G,$,V),et=eD.backend_util.getComplexWithIndex(F,G);K+=et.real*ee.real-et.imag*ee.imag,Z+=et.real*ee.imag+et.imag*ee.real}V&&(K/=$,Z/=$),eD.backend_util.assignToTypedArray(G,K,Z,H)}return G}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FFT_fft(F){let{inputs:$,backend:V}=F,{input:G}=$,H=eD.D5U.sizeFromShape(G.shape),K=G.shape[G.shape.length-1],Z=H/K,ee=Reshape_reshape({inputs:{x:G},backend:V,attrs:{shape:[Z,K]}}),et=fftBatch(ee,!1,V),en=Reshape_reshape({inputs:{x:et},backend:V,attrs:{shape:G.shape}});return V.disposeIntermediateTensorInfo(ee),V.disposeIntermediateTensorInfo(et),en}let ue={kernelName:eD.vwp,backendName:"cpu",kernelFunc:FFT_fft};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill(F){let{backend:$,attrs:V}=F,{shape:G,value:H,dtype:K}=V,Z=K||eD.D5U.inferDtype(H),ee=eD.D5U.getArrayFromDType(Z,eD.D5U.sizeFromShape(G));return fillValues(ee,H,Z),$.makeTensorInfo(G,Z,ee)}let ut={kernelName:eD.deh,backendName:"cpu",kernelFunc:fill};function fillValues(F,$,V){F.fill($)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ur={kernelName:eD.Uyb,backendName:"cpu",kernelFunc:({inputs:F,attrs:$,backend:V})=>{let{image:G}=F,H=V,K=eD.D5U.getTypedArrayFromDType(G.dtype,eD.D5U.sizeFromShape(G.shape)),[Z,ee,et,en]=G.shape,ea=H.data.get(G.dataId).values;for(let F=0;F<Z;F++){let $=F*et*ee*en;for(let F=0;F<ee;F++){let V=F*(et*en);for(let F=0;F<et;F++){let G=F*en;for(let H=0;H<en;H++){let Z=Math.round(et-F-1),ee=$+V+G+H,ei=ea[ee];if(Z>=0&&Z<et){let F=Z*en,G=$+V+F+H;ei=ea[G]}K[ee]=ei}}}}let ei=H.write(K,G.shape,G.dtype);return{dataId:ei,shape:G.shape,dtype:G.dtype}}};var un=V(76574),ua=V(44892);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedConv2D(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,filter:K,bias:Z,preluActivationWeights:ee}=$,{strides:et,pad:en,dataFormat:ea,dilations:ei,dimRoundingMode:eo,activation:es,leakyreluAlpha:eu}=G,ec=conv2D({inputs:{x:H,filter:K},backend:V,attrs:{strides:et,pad:en,dataFormat:ea,dilations:ei,dimRoundingMode:eo}});if(Z){let F=ec;if("NCHW"===ea&&1===Z.shape.length&&1!==Z.shape[0]){let F=Reshape_reshape({inputs:{x:Z},backend:V,attrs:{shape:[Z.shape[0],1,1]}});ec=(0,oE.IH)({inputs:{a:ec,b:F},backend:V}),V.disposeIntermediateTensorInfo(F)}else ec=(0,oE.IH)({inputs:{a:ec,b:Z},backend:V});V.disposeIntermediateTensorInfo(F)}if(es){let F=ec;if("NCHW"===ea&&"prelu"===es&&1===ee.shape.length&&1!==ee.shape[0]){let F=Reshape_reshape({inputs:{x:ee},backend:V,attrs:{shape:[ee.shape[0],1,1]}});ec=applyActivation(V,ec,es,F,eu),V.disposeIntermediateTensorInfo(F)}else ec=applyActivation(V,ec,es,ee,eu);V.disposeIntermediateTensorInfo(F)}return ec}let ui={kernelName:eD._V0,backendName:"cpu",kernelFunc:fusedConv2D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedDepthwiseConv2D(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,filter:K,bias:Z,preluActivationWeights:ee}=$,{strides:et,pad:en,dataFormat:ea,dilations:ei,dimRoundingMode:eo,activation:es,leakyreluAlpha:eu}=G,ec=depthwiseConv2dNative({inputs:{x:H,filter:K},backend:V,attrs:{strides:et,pad:en,dataFormat:ea,dilations:ei,dimRoundingMode:eo}});if(Z){let F=ec;ec=(0,oE.IH)({inputs:{a:ec,b:Z},backend:V}),V.disposeIntermediateTensorInfo(F)}if(es){let F=ec;ec=applyActivation(V,ec,es,ee,eu),V.disposeIntermediateTensorInfo(F)}return ec}let uo={kernelName:eD.luS,backendName:"cpu",kernelFunc:fusedDepthwiseConv2D};var us=V(31820);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherNd(F){let{inputs:$,backend:V}=F,{params:G,indices:H}=$,K=eD.D5U.sizeFromShape(G.shape),Z=H.shape,ee=Z[Z.length-1],[et,en,ea,ei]=eD.backend_util.prepareAndValidate(G,H);if(0===en)return V.makeTensorInfo(et,G.dtype,[]);let eo=V.data.get(H.dataId).values,es=V.bufferSync(G),eu=(0,us.m)(eo,es,G.dtype,en,ee,ea,ei,G.shape,K);return V.makeTensorInfo(et,G.dtype,eu.values)}let uu={kernelName:eD.q1x,backendName:"cpu",kernelFunc:gatherNd};var ul=V(54468);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,indices:K}=$,{axis:Z,batchDims:ee}=G;(0,oc.H)([H,K],"gatherV2");let et=eD.D5U.parseAxisParam(Z,H.shape)[0],en=V.data.get(K.dataId).values,ea=H.shape[et];for(let F=0;F<en.length;++F){let $=en[F];eD.D5U.assert($<=ea-1&&$>=0,()=>`GatherV2: the index value ${$} is not in [0, ${ea-1}]`)}let ei=ee;null==ee&&(ei=0);let eo=eD.D5U.sizeFromShape(K.shape),es=eD.backend_util.segment_util.collectGatherOpShapeInfo(H,K,et,ei),eu=Reshape_reshape({inputs:{x:H},backend:V,attrs:{shape:[es.batchSize,es.outerSize,es.dimSize,es.sliceSize]}}),ec=Reshape_reshape({inputs:{x:K},backend:V,attrs:{shape:[es.batchSize,eo/es.batchSize]}}),ep=[es.batchSize,es.outerSize,eo/es.batchSize,es.sliceSize],eh=V.bufferSync(ec),ef=V.bufferSync(eu),ed=(0,ul.i)(ef,eh,ep);return V.disposeIntermediateTensorInfo(eu),V.disposeIntermediateTensorInfo(ec),V.makeTensorInfo(es.outputShape,ed.dtype,ed.values)}let uc={kernelName:eD.qi_,backendName:"cpu",kernelFunc:gatherV2};var up=V(36272),uh=V(26259);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IFFT_ifft(F){let{inputs:$,backend:V}=F,{input:G}=$,H=eD.D5U.sizeFromShape(G.shape),K=G.shape[G.shape.length-1],Z=H/K,ee=Reshape_reshape({inputs:{x:G},backend:V,attrs:{shape:[Z,K]}}),et=fftBatch(ee,!0,V),en=Reshape_reshape({inputs:{x:et},backend:V,attrs:{shape:G.shape}});return V.disposeIntermediateTensorInfo(ee),V.disposeIntermediateTensorInfo(et),en}let uf={kernelName:eD.Qg5,backendName:"cpu",kernelFunc:IFFT_ifft},ud=(0,om.A)(eD.avt,F=>Number.isFinite(F)?1:0,"bool"),um={kernelName:eD.avt,backendName:"cpu",kernelFunc:ud},ug=(0,om.A)(eD.iWB,F=>Math.abs(F)===1/0?1:0,"bool"),uy={kernelName:eD.iWB,backendName:"cpu",kernelFunc:ug},ub=(0,om.A)(eD.r7n,F=>Number.isNaN(F)?1:0,"bool"),ux={kernelName:eD.r7n,backendName:"cpu",kernelFunc:ub};var uv=V(88405),uw=V(40635),uS=V(61325);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function linSpace(F){let{backend:$,attrs:V}=F,{start:G,stop:H,num:K}=V,Z=(0,uS.b)(G,H,K);return $.makeTensorInfo([Z.length],"float32",Z)}let u_={kernelName:eD.e7N,backendName:"cpu",kernelFunc:linSpace};var uN=V(55223);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uk=(0,om.A)(eD.kU,F=>Math.log1p(F)),uI={kernelName:eD.kU,backendName:"cpu",kernelFunc:uk},uT=(0,ov.b)((F,$)=>F&&$),uC=(0,oQ.j)(eD.PYm,uT,null,"bool"),uE={kernelName:eD.PYm,backendName:"cpu",kernelFunc:uC},uA=(0,om.A)(eD.VfG,F=>F?0:1,"bool"),uD={kernelName:eD.VfG,backendName:"cpu",kernelFunc:uA},uM=(0,ov.b)((F,$)=>F||$),uR=(0,oQ.j)(eD.MZg,uM,null,"bool"),uF={kernelName:eD.MZg,backendName:"cpu",kernelFunc:uR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lRN(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{depthRadius:K,bias:Z,alpha:ee,beta:et}=G;(0,oc.H)(H,"LRN");let en=H.shape[3],ea=en-1,ei=V.data.get(H.dataId).values,eo=eD.D5U.sizeFromShape(H.shape),es=new Float32Array(eo);function sumAcrossChannels(F){let $=F%en,V=F-$+Math.max(0,$-K),G=F-$+Math.min($+K,ea),H=0;for(;V<=G;V++){let F=ei[V];H+=F*F}return H}for(let F=0;F<eo;F++){let $=sumAcrossChannels(F),V=ei[F]*Math.pow(Z+ee*$,-et);es[F]=V}return V.makeTensorInfo(H.shape,H.dtype,es)}let uO={kernelName:eD.eZ0,backendName:"cpu",kernelFunc:lRN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lRNGrad(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,y:K,dy:Z}=$,{depthRadius:ee,bias:et,alpha:en,beta:ea}=G;(0,oc.H)(Z,"LRNGrad");let ei=eD.D5U.sizeFromShape(Z.shape),eo=Z.shape[3],es=V.data.get(Z.dataId).values,eu=V.data.get(H.dataId).values,ec=V.data.get(K.dataId).values,ep=new Float32Array(ei),eh=ei;for(let F=0;F<eh;F++){let $=F%eo,V=F-$+Math.max(0,$-ee),G=F-$+Math.min(eo,$+ee+1),H=0;for(let F=V;F<G;F++)H+=Math.pow(eu[F],2);H=en*H+et;for(let $=V;$<G;$++){let V=-2*en*ea*eu[$]*ec[F]/H;F===$&&(V+=Math.pow(H,-ea)),V*=es[F],ep[$]+=V}}return V.makeTensorInfo(Z.shape,H.dtype,ep)}let uP={kernelName:eD.Hhh,backendName:"cpu",kernelFunc:lRNGrad};var uB=V(55126),u$=V(77107);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Max_max(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{reductionIndices:K,keepDims:Z}=G,ee=V,et=H.shape,en=et.length,ea=eD.D5U.parseAxisParam(K,et),ei=ea,eo=eD.backend_util.getAxesPermutation(ei,en),es=ee.data.get(H.dataId).values;if(null!=eo){let F=Array(en);for(let $=0;$<F.length;$++)F[$]=et[eo[$]];es=(0,u$.H)(es,et,H.dtype,eo,F),ei=eD.backend_util.getInnerMostAxes(ei.length,en),et=F}(0,oc.H)(H,"max"),eD.backend_util.assertAxesAreInnerMostDims("max",ei,en);let[eu,ec]=eD.backend_util.computeOutAndReduceShapes(et,ei),ep=eD.D5U.sizeFromShape(ec),eh=(0,uB.B)(es,ep,eu,H.dtype),ef=ee.write(eh,eu,H.dtype),ed=eu;if(Z){let F=eD.backend_util.expandShapeToKeepDim(eu,ea);ed=F}return{dataId:ef,shape:ed,dtype:H.dtype}}let uL={kernelName:eD.YoZ,backendName:"cpu",kernelFunc:Max_max};var uz=V(71717);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V;(0,oc.H)(K,"maxPool");let{filterSize:Z,strides:ee,pad:et,dimRoundingMode:en}=H,ea=1;eD.D5U.assert(eD.backend_util.eitherStridesOrDilationsAreOne(ee,ea),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${ee} and dilations '${ea}'`);let ei=eD.backend_util.computePool2DInfo(K.shape,Z,ee,ea,et,en);if(1===ei.filterWidth&&1===ei.filterHeight&&eD.D5U.arraysEqual(ei.inShape,ei.outShape))$=(0,ob.y)({inputs:{x:K},backend:G});else{let F=G.data.get(K.dataId).values,V=eD.D5U.computeStrides(K.shape),H=pool_utils_pool(F,K.shape,K.dtype,V,ei,"max");$=G.makeTensorInfo(ei.outShape,K.dtype,H.values)}return $}let uV={kernelName:eD.mTV,backendName:"cpu",kernelFunc:maxPool};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3D(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{filterSize:K,strides:Z,pad:ee,dimRoundingMode:et,dataFormat:en}=G;(0,oc.H)(H,"maxPool3d");let ea=eD.backend_util.computePool3DInfo(H.shape,K,Z,1,ee,et,en),ei=V.data.get(H.dataId).values,eo=pool3d(ei,H.shape,H.dtype,eD.D5U.computeStrides(H.shape),ea,"max");return V.makeTensorInfo(eo.shape,"float32",eo.values)}let uU={kernelName:eD.OAf,backendName:"cpu",kernelFunc:maxPool3D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3DGrad(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,input:K}=$,{filterSize:Z,strides:ee,pad:et,dimRoundingMode:en}=G;(0,oc.H)([H,K],"maxPool3DGrad");let ea=eD.backend_util.computePool3DInfo(K.shape,Z,ee,1,et,en),ei=V.bufferSync(K),eo=maxPool3dPositions(ei,ea),es=ea.strideDepth,eu=ea.strideHeight,ec=ea.strideWidth,ep=ea.dilationDepth,eh=ea.dilationHeight,ef=ea.dilationWidth,ed=ea.effectiveFilterDepth,em=ea.effectiveFilterHeight,eg=ea.effectiveFilterWidth,ey=ed-1-ea.padInfo.front,eb=eg-1-ea.padInfo.left,ew=em-1-ea.padInfo.top,eS=(0,eD.f3b)(K.shape,"float32"),e_=V.bufferSync(H);for(let F=0;F<ea.batchSize;++F)for(let $=0;$<ea.inChannels;++$)for(let V=0;V<ea.inDepth;++V)for(let G=0;G<ea.inHeight;++G)for(let H=0;H<ea.inWidth;++H){let K=V-ey,Z=G-ew,ee=H-eb,et=0;for(let V=0;V<ed;V+=ep){let G=(K+V)/es;if(!(G<0)&&!(G>=ea.outDepth)&&Math.floor(G)===G)for(let H=0;H<em;H+=eh){let K=(Z+H)/eu;if(!(K<0)&&!(K>=ea.outHeight)&&Math.floor(K)===K)for(let Z=0;Z<eg;Z+=ef){let en=(ee+Z)/ec;if(en<0||en>=ea.outWidth||Math.floor(en)!==en)continue;let ei=ed*em*eg-1-eo.get(F,G,K,en,$),es=V*em*eg+H*eg+Z,eu=ei===es?1:0;if(0===eu)continue;let ep=e_.get(F,G,K,en,$);et+=ep*eu}}}eS.set(et,F,V,G,H,$)}return V.makeTensorInfo(eS.shape,eS.dtype,eS.values)}let uW={kernelName:eD.OU7,backendName:"cpu",kernelFunc:maxPool3DGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MaxPoolGrad_maxPoolGrad(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,input:K,output:Z}=$,ee=K;(0,oc.H)([K,Z],"maxPoolGrad");let{filterSize:et,strides:en,pad:ea,dimRoundingMode:ei}=G,eo=eD.backend_util.computePool2DInfo(ee.shape,et,en,1,ea,ei),es=V.data.get(ee.dataId).values,eu=(0,eD.f3b)(eo.outShape,ee.dtype,maxPoolPositions(es,ee.shape,ee.dtype,eo).values),ec=eo.strideHeight,ep=eo.strideWidth,eh=eo.dilationHeight,ef=eo.dilationWidth,ed=eo.effectiveFilterHeight,em=eo.effectiveFilterWidth,eg=em-1-eo.padInfo.left,ey=ed-1-eo.padInfo.top,eb=(0,eD.f3b)(ee.shape,"float32"),ew=V.data.get(H.dataId).values,eS=(0,eD.f3b)(H.shape,"float32",ew);for(let F=0;F<eo.batchSize;++F)for(let $=0;$<eo.inChannels;++$)for(let V=0;V<eo.inHeight;++V)for(let G=0;G<eo.inWidth;++G){let H=V-ey,K=G-eg,Z=0;for(let V=0;V<ed;V+=eh){let G=(H+V)/ec;if(!(G<0)&&!(G>=eo.outHeight)&&Math.floor(G)===G)for(let H=0;H<em;H+=ef){let ee=(K+H)/ep;if(ee<0||ee>=eo.outWidth||Math.floor(ee)!==ee)continue;let et=ed*em-1-eu.get(F,G,ee,$),en=V*em+H,ea=et===en?1:0;if(0===ea)continue;let ei=eS.get(F,G,ee,$);Z+=ei*ea}}eb.set(Z,F,V,G,$)}return V.makeTensorInfo(eb.shape,eb.dtype,eb.values)}let uj={kernelName:eD.OV7,backendName:"cpu",kernelFunc:MaxPoolGrad_maxPoolGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolWithArgmaxImpl(F,$,V,G,H){let K=eD.D5U.computeStrides($),Z=pool_utils_pool(F,$,V,K,H,"max"),ee=maxPoolPositions(F,$,V,H,!0,G);return[Z.values,ee.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uG={kernelName:eD.vFR,backendName:"cpu",kernelFunc:({inputs:F,attrs:$,backend:V})=>{let{x:G}=F,{filterSize:H,strides:K,pad:Z,includeBatchInIndex:ee}=$,et=V;(0,oc.H)(G,"MaxPoolWithArgmax");let en=et.data.get(G.dataId).values,ea=eD.backend_util.computePool2DInfo(G.shape,H,K,[1,1],Z),[ei,eo]=maxPoolWithArgmaxImpl(en,G.shape,G.dtype,ee,ea),es=et.write(ei,ea.outShape,G.dtype),eu=et.write(eo,ea.outShape,G.dtype);return[{dataId:es,shape:ea.outShape,dtype:G.dtype},{dataId:eu,shape:ea.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mean_mean(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K,keepDims:Z}=G,ee=eD.D5U.parseAxisParam(K,H.shape),et=eD.backend_util.computeOutAndReduceShapes(H.shape,ee),en=et[1],ea=eD.D5U.sizeFromShape(en),ei=[],eo=V.makeTensorInfo([],"float32",new Float32Array([ea]));ei.push(eo);let es=(0,sa.pj)({inputs:{x:H},backend:V,attrs:{dtype:"float32"}});ei.push(es);let eu=s9({inputs:{a:es,b:eo},backend:V});ei.push(eu);let ec=Sum_sum({inputs:{x:eu},backend:V,attrs:{axis:K,keepDims:Z}});return ei.forEach(F=>V.disposeIntermediateTensorInfo(F)),ec}let uq={kernelName:eD.q2K,backendName:"cpu",kernelFunc:Mean_mean};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Min_min(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K,keepDims:Z}=G;(0,oc.H)(H,"min");let ee=eD.D5U.parseAxisParam(K,H.shape),et=ee,en=eD.backend_util.getAxesPermutation(et,H.shape.length),ea=H;null!=en&&(ea=(0,oL.p)({inputs:{x:H},backend:V,attrs:{perm:en}}),et=eD.backend_util.getInnerMostAxes(et.length,H.shape.length)),eD.backend_util.assertAxesAreInnerMostDims("min",et,ea.shape.length);let[ei,eo]=eD.backend_util.computeOutAndReduceShapes(ea.shape,et),es=eD.D5U.sizeFromShape(eo),eu=eD.D5U.makeZerosTypedArray(eD.D5U.sizeFromShape(ei),ea.dtype),ec=V.data.get(ea.dataId).values;for(let F=0;F<eu.length;++F){let $=F*es,V=ec[$];for(let F=0;F<es;++F){let G=ec[$+F];(Number.isNaN(G)||G<V)&&(V=G)}eu[F]=V}null!=en&&V.disposeIntermediateTensorInfo(ea);let ep=V.makeTensorInfo(ei,ea.dtype,eu);if(Z){let F=eD.backend_util.expandShapeToKeepDim(ei,ee),$=Reshape_reshape({inputs:{x:ep},backend:V,attrs:{shape:F}});return V.disposeIntermediateTensorInfo(ep),$}return ep}let uH={kernelName:eD.c17,backendName:"cpu",kernelFunc:Min_min};var uX=V(612);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mirrorPad(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{paddings:K,mode:Z}=G;(0,oc.H)(H,"mirrorPad");let ee=K.map((F,$)=>F[0]+H.shape[$]+F[1]),et=K.map(F=>F[0]),en=K.map((F,$)=>F[0]+H.shape[$]),ea="reflect"===Z?0:1,ei=V.data.get(H.dataId).values,eo=H.shape.length,es=eD.D5U.computeStrides(H.shape),eu=eD.D5U.sizeFromShape(ee),ec=ee.length,ep=eD.D5U.computeStrides(ee),eh=eD.D5U.getTypedArrayFromDType(H.dtype,eu);for(let F=0;F<eu;F++){let $=eD.D5U.indexToLoc(F,ec,ep);for(let F=0;F<ec;F++)$[F]<et[F]?$[F]=2*et[F]-$[F]-ea:$[F]>=en[F]&&($[F]=(en[F]-1)*2-$[F]+ea);$=$.map((F,$)=>F-et[$]);let V=eD.D5U.locToIndex($,eo,es);eh[F]=ei[V]}let ef=V.write(eh,ee,H.dtype);return{dataId:ef,shape:ee,dtype:H.dtype}}let uK={kernelName:eD.jQs,backendName:"cpu",kernelFunc:mirrorPad},uQ=(0,ov.b)((F,$)=>{let V=F%$;return F<0&&$<0||F>=0&&$>=0?V:(V+$)%$}),uZ=(0,oQ.j)(eD.Vbg,uQ),uY={kernelName:eD.Vbg,backendName:"cpu",kernelFunc:uZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Softmax_softmax(F){let{inputs:$,backend:V,attrs:G}=F,{logits:H}=$,{dim:K}=G,Z=H.shape.length,ee=K;if(-1===ee&&(ee=Z-1),ee!==Z-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${Z} and dim was ${ee}`);let et=eD.D5U.parseAxisParam([ee],H.shape),en=Max_max({inputs:{x:H},backend:V,attrs:{reductionIndices:et,keepDims:!1}}),ea=eD.backend_util.expandShapeToKeepDim(en.shape,et),ei=Reshape_reshape({inputs:{x:en},backend:V,attrs:{shape:ea}}),eo=(0,s7.lu)({inputs:{a:H,b:ei},backend:V}),es=(0,s3.Qq)({inputs:{x:eo},backend:V}),eu=Sum_sum({inputs:{x:es},backend:V,attrs:{axis:et,keepDims:!1}}),ec=Reshape_reshape({inputs:{x:eu},backend:V,attrs:{shape:ea}}),ep=s9({inputs:{a:es,b:ec},backend:V});return V.disposeIntermediateTensorInfo(en),V.disposeIntermediateTensorInfo(ei),V.disposeIntermediateTensorInfo(eo),V.disposeIntermediateTensorInfo(es),V.disposeIntermediateTensorInfo(eu),V.disposeIntermediateTensorInfo(ec),ep}let uJ={kernelName:eD.Gcp,backendName:"cpu",kernelFunc:Softmax_softmax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function multinomial(F){let{inputs:$,backend:V,attrs:G}=F,{logits:H}=$,{numSamples:K,seed:Z,normalized:ee}=G;(0,oc.H)(H,"multinomial");let et=ee?H:Softmax_softmax({inputs:{logits:H},backend:V,attrs:{dim:-1}}),en=et.shape[0],ea=et.shape[1],ei=V.data.get(et.dataId).values,eo=[en,K],es=eD.D5U.makeZerosTypedArray(eD.D5U.sizeFromShape(eo),"int32");for(let F=0;F<en;++F){let $=F*ea,V=new Float32Array(ea-1);V[0]=ei[$];for(let F=1;F<V.length;++F)V[F]=V[F-1]+ei[$+F];let G=oe.alea(Z.toString()),H=F*K;for(let F=0;F<K;++F){let $=G();es[H+F]=V.length;for(let G=0;G<V.length;G++)if($<V[G]){es[H+F]=G;break}}}return ee||V.disposeIntermediateTensorInfo(et),V.makeTensorInfo(eo,"int32",es)}let u0={kernelName:eD.NZg,backendName:"cpu",kernelFunc:multinomial};var u2=V(70854);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let u3=eD.GDt.nonMaxSuppressionV3Impl;function nonMaxSuppressionV3(F){let{inputs:$,backend:V,attrs:G}=F,{boxes:H,scores:K}=$,{maxOutputSize:Z,iouThreshold:ee,scoreThreshold:et}=G;(0,oc.H)(H,"NonMaxSuppression");let en=V.data.get(H.dataId).values,ea=V.data.get(K.dataId).values,{selectedIndices:ei}=u3(en,ea,Z,ee,et);return V.makeTensorInfo([ei.length],"int32",new Int32Array(ei))}let u4={kernelName:eD.uv1,backendName:"cpu",kernelFunc:nonMaxSuppressionV3},u6=eD.GDt.nonMaxSuppressionV4Impl;function nonMaxSuppressionV4(F){let{inputs:$,backend:V,attrs:G}=F,{boxes:H,scores:K}=$,{maxOutputSize:Z,iouThreshold:ee,scoreThreshold:et,padToMaxOutputSize:en}=G;(0,oc.H)(H,"NonMaxSuppressionPadded");let ea=V.data.get(H.dataId).values,ei=V.data.get(K.dataId).values,{selectedIndices:eo,validOutputs:es}=u6(ea,ei,Z,ee,et,en);return[V.makeTensorInfo([eo.length],"int32",new Int32Array(eo)),V.makeTensorInfo([],"int32",new Int32Array([es]))]}let u5={kernelName:eD.cye,backendName:"cpu",kernelFunc:nonMaxSuppressionV4},u9=eD.GDt.nonMaxSuppressionV5Impl;function nonMaxSuppressionV5(F){let{inputs:$,backend:V,attrs:G}=F,{boxes:H,scores:K}=$,{maxOutputSize:Z,iouThreshold:ee,scoreThreshold:et,softNmsSigma:en}=G;(0,oc.H)(H,"NonMaxSuppressionWithScore");let ea=V.data.get(H.dataId).values,ei=V.data.get(K.dataId).values,eo=Z,es=ee,eu=et,ec=en,{selectedIndices:ep,selectedScores:eh}=u9(ea,ei,eo,es,eu,ec);return[V.makeTensorInfo([ep.length],"int32",new Int32Array(ep)),V.makeTensorInfo([eh.length],"float32",new Float32Array(eh))]}let u8={kernelName:eD.W0H,backendName:"cpu",kernelFunc:nonMaxSuppressionV5};var u7=V(98584);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oneHot(F){let{inputs:$,backend:V,attrs:G}=F,{indices:H}=$,{dtype:K,depth:Z,onValue:ee,offValue:et}=G;(0,oc.H)(H,"oneHot");let en=eD.D5U.sizeFromShape(H.shape),ea=new Float32Array(en*Z);ea.fill(et);let ei=V.data.get(H.dataId).values;for(let F=0;F<en;++F)ei[F]>=0&&ei[F]<Z&&(ea[F*Z+ei[F]]=ee);return V.makeTensorInfo([...H.shape,Z],K,ea)}let lt={kernelName:eD.we_,backendName:"cpu",kernelFunc:oneHot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike(F){let{inputs:$,backend:V}=F,{x:G}=$;if("string"===G.dtype)throw Error("zerosLike is not supported for string tensors");if("complex64"!==G.dtype)return fill({backend:V,attrs:{shape:G.shape,value:0,dtype:G.dtype}});{let F=(0,sf.k)({inputs:{input:G},backend:V}),$=zerosLike({inputs:{x:F},backend:V}),H=imag({inputs:{input:G},backend:V}),K=zerosLike({inputs:{x:H},backend:V}),Z=(0,sl.P)({inputs:{real:$,imag:K},backend:V});return V.disposeIntermediateTensorInfo(F),V.disposeIntermediateTensorInfo($),V.disposeIntermediateTensorInfo(H),V.disposeIntermediateTensorInfo(K),Z}}let la={kernelName:eD.RuY,backendName:"cpu",kernelFunc:zerosLike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function onesLike(F){let{inputs:$,backend:V}=F,{x:G}=$;if("string"===G.dtype)throw Error("onesLike is not supported for string tensors");if("complex64"!==G.dtype)return fill({backend:V,attrs:{shape:G.shape,value:1,dtype:G.dtype}});{let F=(0,sf.k)({inputs:{input:G},backend:V}),$=onesLike({inputs:{x:F},backend:V}),H=imag({inputs:{input:G},backend:V}),K=zerosLike({inputs:{x:H},backend:V}),Z=(0,sl.P)({inputs:{real:$,imag:K},backend:V});return V.disposeIntermediateTensorInfo(F),V.disposeIntermediateTensorInfo($),V.disposeIntermediateTensorInfo(H),V.disposeIntermediateTensorInfo(K),Z}}let li={kernelName:eD.qWM,backendName:"cpu",kernelFunc:onesLike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pack(F){let{inputs:$,backend:V,attrs:G}=F,{axis:H}=G;if(1===$.length)return expandDims({inputs:{input:$[0]},backend:V,attrs:{dim:H}});let K=$[0].shape,Z=$[0].dtype;$.forEach(F=>{eD.D5U.assertShapesMatch(K,F.shape,"All tensors passed to stack must have matching shapes"),eD.D5U.assert(Z===F.dtype,()=>"All tensors passed to stack must have matching dtypes")});let ee=[],et=$.map(F=>{let $=expandDims({inputs:{input:F},backend:V,attrs:{dim:H}});return ee.push($),$}),en=Concat_concat({inputs:et,backend:V,attrs:{axis:H}});return ee.forEach(F=>V.disposeIntermediateTensorInfo(F)),en}let ls={kernelName:eD.QiL,backendName:"cpu",kernelFunc:pack};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function padV2(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{paddings:K,constantValue:Z}=G;(0,oc.H)(H,"pad");let ee=K.map((F,$)=>F[0]+H.shape[$]+F[1]),et=K.map(F=>F[0]),en=V.data.get(H.dataId).values,ea=eD.D5U.sizeFromShape(H.shape),ei=H.shape.length,eo=eD.D5U.computeStrides(H.shape),es=eD.D5U.sizeFromShape(ee),eu=ee.length,ec=eD.D5U.computeStrides(ee),ep=eD.D5U.getTypedArrayFromDType(H.dtype,es);0!==Z&&ep.fill(Z);for(let F=0;F<ea;F++){let $=eD.D5U.indexToLoc(F,ei,eo),V=$.map((F,$)=>F+et[$]),G=eD.D5U.locToIndex(V,eu,ec);ep[G]=en[F]}let eh=V.write(ep,ee,H.dtype);return{dataId:eh,shape:ee,dtype:H.dtype}}let lu={kernelName:eD.lyA,backendName:"cpu",kernelFunc:padV2},lc=(0,ov.b)((F,$)=>Math.pow(F,$)),lp=(0,oQ.j)(eD.pe_,lc),lh={kernelName:eD.pe_,backendName:"cpu",kernelFunc:lp};var lf=V(29560),ld=V(59885);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function raggedGather(F){let{inputs:$,backend:V,attrs:G}=F,{paramsNestedSplits:H,paramsDenseValues:K,indices:Z}=$,{outputRaggedRank:ee}=G,et=H.map(F=>V.data.get(F.dataId).values),en=H.map(F=>F.shape),ea=V.data.get(K.dataId).values,ei=V.data.get(Z.dataId).values,[eo,es,eu]=(0,ld.c)(et,en,ea,K.shape,K.dtype,ei,Z.shape,ee),ec=eo.map(F=>V.makeTensorInfo([F.length],"int32",F)),ep=V.makeTensorInfo(eu,K.dtype,es);return ec.concat([ep])}let lm={kernelName:eD.dDz,backendName:"cpu",kernelFunc:raggedGather};var lg=V(36486);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function raggedRange(F){let{inputs:$,backend:V}=F,{starts:G,limits:H,deltas:K}=$,Z=V.data.get(G.dataId).values,ee=V.data.get(H.dataId).values,et=V.data.get(K.dataId).values,[en,ea]=(0,lg.S)(Z,G.shape,G.dtype,ee,H.shape,et,K.shape),ei=V.makeTensorInfo([en.length],"int32",en),eo=V.makeTensorInfo([ea.length],G.dtype,ea);return[ei,eo]}let ly={kernelName:eD.CQl,backendName:"cpu",kernelFunc:raggedRange};var lb=V(8306);/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function raggedTensorToTensor(F){let{inputs:$,backend:V,attrs:G}=F,{shape:H,values:K,defaultValue:Z,rowPartitionTensors:ee}=$,{rowPartitionTypes:et}=G,en=V.data.get(H.dataId).values,ea=V.data.get(K.dataId).values,ei=V.data.get(Z.dataId).values,eo=ee.map(F=>V.data.get(F.dataId).values),es=ee.map(F=>F.shape),[eu,ec]=(0,lb.p)(en,H.shape,ea,K.shape,K.dtype,ei,Z.shape,eo,es,et);return V.makeTensorInfo(eu,K.dtype,ec)}let lx={kernelName:eD.BiW,backendName:"cpu",kernelFunc:raggedTensorToTensor};var lv=V(99230);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function range(F){let{backend:$,attrs:V}=F,{start:G,stop:H,dtype:K,step:Z}=V,ee=(0,lv.b)(G,H,Z,K);return $.makeTensorInfo([ee.length],K,ee)}let lw={kernelName:eD.e6w,backendName:"cpu",kernelFunc:range},lS=(0,om.A)(eD.$HU,F=>1/F),l_={kernelName:eD.$HU,backendName:"cpu",kernelFunc:lS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeBilinear(F){let{inputs:$,backend:V,attrs:G}=F,{images:H}=$,{alignCorners:K,halfPixelCenters:Z,size:ee}=G;(0,oc.H)(H,"resizeBilinear");let et=eD.D5U.computeStrides(H.shape),[en,ea]=ee,[ei,eo,es,eu]=H.shape,ec=V.data.get(H.dataId).values,ep=new Float32Array(eD.D5U.sizeFromShape([ei,en,ea,eu])),eh=[K&&en>1?eo-1:eo,K&&ea>1?es-1:es],ef=[K&&en>1?en-1:en,K&&ea>1?ea-1:ea],ed=0,em=eh[0]/ef[0],eg=eh[1]/ef[1];for(let F=0;F<ei;F++)for(let $=0;$<en;$++){let V;V=Z?em*($+.5)-.5:em*$;let G=Math.max(0,Math.floor(V)),H=V-G,K=Math.min(eo-1,Math.ceil(V)),ee=F*et[0]+G*et[1],en=F*et[0]+K*et[1];for(let F=0;F<ea;F++){let $;$=Z?eg*(F+.5)-.5:eg*F;let V=Math.max(0,Math.floor($)),G=$-V,K=Math.min(es-1,Math.ceil($)),ea=ee+V*et[2],ei=en+V*et[2],eo=ee+K*et[2],eh=en+K*et[2];for(let F=0;F<eu;F++){let $=ec[ea+F],V=ec[ei+F],K=ec[eo+F],Z=ec[eh+F],ee=$+(K-$)*G,et=V+(Z-V)*G,en=ee+(et-ee)*H;ep[ed++]=en}}}return V.makeTensorInfo([ei,en,ea,eu],"float32",ep)}let lN={kernelName:eD._Yw,backendName:"cpu",kernelFunc:resizeBilinear};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeBilinearGrad(F){let{inputs:$,backend:V,attrs:G}=F,{images:H,dy:K}=$,{alignCorners:Z}=G;(0,oc.H)([K,H],"resizeBilinearGrad");let ee=eD.D5U.computeStrides(H.shape),[et,en,ea,ei]=H.shape,[,eo,es]=K.shape,eu=new Float32Array(et*en*ea*ei),ec=[Z&&eo>1?en-1:en,Z&&es>1?ea-1:ea],ep=[Z&&eo>1?eo-1:eo,Z&&es>1?es-1:es],eh=ec[0]/ep[0],ef=ec[1]/ep[1],ed=V.data.get(K.dataId).values,em=0;for(let F=0;F<et;F++){let $=F*ee[0];for(let F=0;F<eo;F++){let V=F*eh,G=Math.floor(V),H=Math.min(Math.ceil(V),en-1),K=$+G*ee[1],Z=$+H*ee[1],et=V-G,eo=1-et;for(let F=0;F<es;F++){let $=F*ef,V=Math.floor($),G=Math.min(Math.ceil($),ea-1),H=$-V,en=1-H,es=K+V*ee[2],ec=K+G*ee[2],ep=Z+V*ee[2],eh=Z+G*ee[2],eg=eo*en,ey=eo*H,eb=et*en,ew=et*H;for(let F=0;F<ei;F++){let $=ed[em++];eu[es+F]+=$*eg,eu[ec+F]+=$*ey,eu[ep+F]+=$*eb,eu[eh+F]+=$*ew}}}}return V.makeTensorInfo([et,ea,en,ei],"float32",eu)}let lk={kernelName:eD.zbQ,backendName:"cpu",kernelFunc:resizeBilinearGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeNearestNeighbor(F){let{inputs:$,backend:V,attrs:G}=F,{images:H}=$,{alignCorners:K,halfPixelCenters:Z,size:ee}=G;(0,oc.H)(H,"resizeNearestNeighbor");let et=eD.D5U.computeStrides(H.shape),[en,ea]=ee,[ei,eo,es,eu]=H.shape,ec=V.data.get(H.dataId).values,ep=new Float32Array(ei*en*ea*eu),eh=[K&&en>1?eo-1:eo,K&&ea>1?es-1:es],ef=[K&&en>1?en-1:en,K&&ea>1?ea-1:ea],ed=eh[0]/ef[0],em=eh[1]/ef[1],eg=0;for(let F=0;F<ei;F++){let $=F*et[0];for(let F=0;F<en;F++){let V=Z?ed*(F+.5):ed*F,G=Math.min(eo-1,K?Math.round(V):Math.floor(V));Z&&(G=Math.max(0,G));let H=$+G*et[1];for(let F=0;F<ea;F++){let $=Z?em*(F+.5):em*F,V=Math.min(es-1,K?Math.round($):Math.floor($));Z&&(V=Math.max(0,V));let G=H+V*et[2];for(let F=0;F<eu;F++){let $=ec[G+F];ep[eg++]=$}}}}return V.makeTensorInfo([ei,en,ea,eu],H.dtype,ep)}let lI={kernelName:eD.dpD,backendName:"cpu",kernelFunc:resizeNearestNeighbor};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeNearestNeighborGrad(F){let{inputs:$,backend:V,attrs:G}=F,{images:H,dy:K}=$,{alignCorners:Z}=G;(0,oc.H)([K,H],"resizeNearestNeighborGrad");let ee=eD.D5U.computeStrides(H.shape),et=eD.D5U.computeStrides(K.shape),[en,ea,ei,eo]=H.shape,[,es,eu]=K.shape,ec=new Float32Array(en*ea*ei*eo),ep=V.data.get(K.dataId).values,eh=[Z&&es>1?ea-1:ea,Z&&eu>1?ei-1:ei],ef=[Z&&es>1?es-1:es,Z&&eu>1?eu-1:eu],ed=eh[0]/ef[0],em=eh[1]/ef[1],eg=1/ed,ey=1/em,eb=2*Math.ceil(eg)+2,ew=2*Math.ceil(ey)+2;for(let F=0;F<en;F++){let $=F*ee[0];for(let F=0;F<ea;F++){let V=$+F*ee[1],G=Math.floor(F*eg),H=Math.floor(G-eb/2);for(let G=0;G<ei;G++){let K=V+G*ee[2],en=Math.floor(G*ey),eh=Math.floor(en-ew/2);for(let V=0;V<eo;V++){let ee=0;for(let K=0;K<eb;K++){let en=K+H;if(en<0||en>=es)continue;let eo=$+en*et[1],ec=en*ed,ef=Math.min(ea-1,Z?Math.round(ec):Math.floor(ec));if(F===ef)for(let F=0;F<ew;F++){let $=F+eh;if($<0||$>=eu)continue;let H=eo+$*et[2],K=$*em,en=Math.min(ei-1,Z?Math.round(K):Math.floor(K));G===en&&(ee+=ep[H+V])}}ec[K+V]=ee}}}}return V.makeTensorInfo(H.shape,H.dtype,ec)}let lT={kernelName:eD.Hmb,backendName:"cpu",kernelFunc:resizeNearestNeighborGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Reverse_reverse(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{dims:K}=G;(0,oc.H)(H,"reverse");let Z=H.shape.length,ee=eD.D5U.parseAxisParam(K,H.shape);if(0===Z)return(0,ob.y)({inputs:{x:H},backend:V});let et=new eD.YDk(H.shape,H.dtype),en=V.bufferSync(H);for(let F=0;F<et.size;F++){let $=et.indexToLoc(F),V=$.slice();ee.forEach(F=>V[F]=H.shape[F]-1-V[F]),et.set(en.get(...V),...$)}return V.makeTensorInfo(et.shape,et.dtype,et.values)}let lC={kernelName:eD.mKl,backendName:"cpu",kernelFunc:Reverse_reverse},lE={kernelName:eD.b9H,backendName:"cpu",kernelFunc:({inputs:F,attrs:$,backend:V})=>{let{image:G}=F,{radians:H,fillValue:K,center:Z}=$,ee=V,et=eD.D5U.getTypedArrayFromDType(G.dtype,eD.D5U.sizeFromShape(G.shape)),[en,ea,ei,eo]=G.shape,[es,eu]=eD.backend_util.getImageCenter(Z,ea,ei),ec=255,ep=Math.sin(H),eh=Math.cos(H),ef=ee.data.get(G.dataId).values;for(let F=0;F<en;F++){let $=F*ei*ea*eo;for(let F=0;F<ea;F++){let V=F*(ei*eo);for(let G=0;G<ei;G++){let H=G*eo;for(let Z=0;Z<eo;Z++){let ee=[en,F,G,Z],ed=ee[2],em=ee[1],eg=(ed-es)*eh-(em-eu)*ep,ey=(ed-es)*ep+(em-eu)*eh;eg=Math.round(eg+es),ey=Math.round(ey+eu);let eb=K;if("number"!=typeof K&&(eb=3===Z?ec:K[Z]),eg>=0&&eg<ei&&ey>=0&&ey<ea){let F=ey*(ei*eo),V=eg*eo,G=$+F+V+Z;eb=ef[G]}let ew=$+V+H+Z;et[ew]=eb}}}}let ed=ee.write(et,G.shape,G.dtype);return{dataId:ed,shape:G.shape,dtype:G.dtype}}},lA=(0,om.A)(eD.e07,F=>{let $=Math.floor(F);return F-$<.5?Math.floor(F):F-$>.5?Math.ceil(F):$%2==0?$:$+1}),lD={kernelName:eD.e07,backendName:"cpu",kernelFunc:lA};var lM=V(7742),lR=V(60001);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scatterNd(F){let{inputs:$,backend:V,attrs:G}=F,{indices:H,updates:K}=$,{shape:Z}=G,{sliceRank:ee,numUpdates:et,sliceSize:en,strides:ea,outputSize:ei}=eD.backend_util.calculateShapes(K,H,Z),eo=!0,es=V.bufferSync(H),eu=V.bufferSync(K),ec=(0,lR.N)(es,eu,Z,ei,en,et,ee,ea,0,eo);return V.makeTensorInfo(Z,ec.dtype,ec.values)}let lF={kernelName:eD.xQA,backendName:"cpu",kernelFunc:scatterNd};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lowerBound(F,$){let V=0,G=F.length,H=0;for(;V<G;)F[H=Math.floor((V+G)/2)]<$?V=H+1:G=H;return G}function upperBound(F,$){let V=0,G=F.length,H=0;for(;V<G;)F[H=Math.floor((V+G)/2)]<=$?V=H+1:G=H;return G}function searchSortedImpl(F,$,V,G,H,K){let Z=eD.D5U.getArrayFromDType("int32",V*H);for(let ee=0;ee<V;++ee){let V=F.slice(ee*G,(ee+1)*G),et=ee*H;for(let F=0;F<H;++F)Z[et+F]="left"===K?lowerBound(V,$[F+et]):upperBound(V,$[F+et])}return Z}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function searchSorted(F){let{inputs:$,backend:V,attrs:G}=F,{sortedSequence:H,values:K}=$,{side:Z}=G,ee=V.data.get(H.dataId).values,et=V.data.get(K.dataId).values,en=searchSortedImpl(ee,et,H.shape[0],H.shape[1],K.shape[1],Z);return V.makeTensorInfo(K.shape,"int32",en)}let lO={kernelName:eD.nr8,backendName:"cpu",kernelFunc:searchSorted};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Select_select(F){let{inputs:$,backend:V}=F,{condition:G,t:H,e:K}=$;(0,oc.H)([G,H,K],"select");let Z=G.shape.length,ee=V.data.get(G.dataId).values,et=V.data.get(H.dataId).values,en=V.data.get(K.dataId).values,ea=(0,eD.x8V)(H.dtype,K.dtype),ei=eD.D5U.makeZerosTypedArray(eD.D5U.sizeFromShape(H.shape),ea),eo=0,es=0===Z||Z>1||1===H.shape.length?1:eD.D5U.sizeFromShape(H.shape.slice(1));for(let F=0;F<ee.length;F++)for(let $=0;$<es;$++)1===ee[F]?ei[eo++]=et[F]:ei[eo++]=en[F];return V.makeTensorInfo(H.shape,ea,ei)}let lP={kernelName:eD.PhF,backendName:"cpu",kernelFunc:Select_select},lB=eD.backend_util.SELU_SCALEALPHA,l$=eD.backend_util.SELU_SCALE,lL=(0,om.A)(eD.oFR,F=>F>=0?l$*F:lB*(Math.exp(F)-1)),lz={kernelName:eD.oFR,backendName:"cpu",kernelFunc:lL},lV=(0,om.A)(eD.i5y,F=>F<0?-1:F>0?1:0),lU={kernelName:eD.i5y,backendName:"cpu",kernelFunc:lV},lW=(0,om.A)(eD.RQH,F=>Math.sin(F)),lj={kernelName:eD.RQH,backendName:"cpu",kernelFunc:lW},lG=(0,om.A)(eD.wYB,F=>Math.sinh(F)),lq={kernelName:eD.wYB,backendName:"cpu",kernelFunc:lG},lH=11920928955078125e-23,lX=Math.log(lH)+2,lK=(0,om.A)(eD.MRv,F=>{let $=F>-lX,V=F<lX,G=Math.exp(F);return V?G:$?F:Math.log(1+G)}),lQ={kernelName:eD.MRv,backendName:"cpu",kernelFunc:lK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function spaceToBatchND(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{blockShape:K,paddings:Z}=G;(0,oc.H)([H],"spaceToBatchND");let ee=eD.D5U.sizeFromShape(K),et=[[0,0]];et.push(...Z);for(let F=1+K.length;F<H.shape.length;++F)et.push([0,0]);let en=lu.kernelFunc({inputs:{x:H},backend:V,attrs:{paddings:et,constantValue:0}}),ea=eD.backend_util.getReshaped(en.shape,K,ee,!1),ei=eD.backend_util.getPermuted(ea.length,K.length,!1),eo=eD.backend_util.getReshapedPermuted(en.shape,K,ee,!1),es={x:en},eu={shape:ea},ec=Reshape_reshape({inputs:es,backend:V,attrs:eu}),ep={x:ec},eh={perm:ei},ef=(0,oL.p)({inputs:ep,backend:V,attrs:eh}),ed={x:ef},em={shape:eo},eg=Reshape_reshape({inputs:ed,backend:V,attrs:em});return V.disposeIntermediateTensorInfo(en),V.disposeIntermediateTensorInfo(ec),V.disposeIntermediateTensorInfo(ef),eg}let lZ={kernelName:eD.TQc,backendName:"cpu",kernelFunc:spaceToBatchND};var lY=V(42123);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseFillEmptyRows(F){let{inputs:$,backend:V}=F,{indices:G,values:H,denseShape:K,defaultValue:Z}=$;if(1!==K.shape.length)throw Error(`Dense shape must be a vector, saw:
        ${K.shape}`);if(2!==G.shape.length)throw Error(`Indices must be a matrix, saw:
        ${G.shape}`);if(1!==H.shape.length)throw Error(`Values must be a vector, saw:
        ${H.shape}`);if(0!==Z.shape.length)throw Error(`Default value must be a scalar, saw:
        ${Z.shape}`);let ee=V.data.get(G.dataId).values,et=V.data.get(H.dataId).values,en=V.data.get(K.dataId).values,ea=V.data.get(Z.dataId).values[0],[ei,eo,es,eu,ec]=(0,lY.c)(ee,G.shape,G.dtype,et,H.dtype,en,ea);return[V.makeTensorInfo(eo,G.dtype,ei),V.makeTensorInfo([eo[0]],H.dtype,es),V.makeTensorInfo([eu.length],"bool",new Uint8Array(eu.map(F=>Number(F)))),V.makeTensorInfo([ec.length],G.dtype,new Int32Array(ec))]}let lJ={kernelName:eD.O3z,backendName:"cpu",kernelFunc:sparseFillEmptyRows};var l0=V(3849);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseReshape(F){let{inputs:$,backend:V}=F,{inputIndices:G,inputShape:H,newShape:K}=$;if(2!==G.shape.length)throw Error(`Input indices should be a matrix but received shape
        ${G.shape}`);if(1!==H.shape.length)throw Error(`Input shape should be a vector but received shape
        ${H.shape}`);if(1!==K.shape.length)throw Error(`Target shape should be a vector but received shape ${K.shape}`);let Z=Array.from(V.data.get(H.dataId).values),ee=V.data.get(G.dataId).values,et=Array.from(V.data.get(K.dataId).values),[en,ea,ei]=(0,l0.U)(ee,G.shape,G.dtype,Z,et);return[V.makeTensorInfo(ea,G.dtype,en),V.makeTensorInfo([ei.length],K.dtype,new Int32Array(ei))]}let l3={kernelName:eD.nhH,backendName:"cpu",kernelFunc:sparseReshape};var l4=V(13989);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentMean(F){let{inputs:$,backend:V}=F,{data:G,indices:H,segmentIds:K}=$;if(G.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==H.shape.length)throw Error(`Indices should be a vector but received shape
          ${H.shape}`);if(1!==K.shape.length)throw Error(`Segment ids should be a vector but received shape
          ${K.shape}`);if(H.shape[0]!==K.shape[0])throw Error("segmentIds and indices should have same size.");let Z=V.data.get(G.dataId).values,ee=V.data.get(H.dataId).values,et=V.data.get(K.dataId).values,[en,ea]=(0,l4.V)(Z,G.shape,G.dtype,ee,et,!0);return V.makeTensorInfo(ea,G.dtype,en)}let l6={kernelName:eD.w3H,backendName:"cpu",kernelFunc:sparseSegmentMean};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentSum(F){let{inputs:$,backend:V}=F,{data:G,indices:H,segmentIds:K}=$;if(G.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==H.shape.length)throw Error(`Indices should be a vector but received shape
         ${H.shape}`);if(1!==K.shape.length)throw Error(`Segment ids should be a vector but received shape
         ${K.shape}`);if(H.shape[0]!==K.shape[0])throw Error("segmentIds and indices should have same size.");let Z=V.data.get(G.dataId).values,ee=V.data.get(H.dataId).values,et=V.data.get(K.dataId).values,[en,ea]=(0,l4.V)(Z,G.shape,G.dtype,ee,et);return V.makeTensorInfo(ea,G.dtype,en)}let l5={kernelName:eD.ZjV,backendName:"cpu",kernelFunc:sparseSegmentSum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseToDense(F){let $;let{inputs:V,backend:G,attrs:H}=F,{sparseIndices:K,sparseValues:Z,defaultValue:ee}=V,{outputShape:et}=H,{sliceRank:en,numUpdates:ea,sliceSize:ei,strides:eo,outputSize:es}=eD.backend_util.calculateShapes(Z,K,et),eu=!1,ec=G.bufferSync(K);switch(Z.dtype){case"bool":{let F=G.bufferSync(Z),V=!!G.data.get(ee.dataId).values[0];$=(0,lR.N)(ec,F,et,es,ei,ea,en,eo,V,eu);break}case"float32":{let F=G.bufferSync(Z),V=G.data.get(ee.dataId).values[0];$=(0,lR.N)(ec,F,et,es,ei,ea,en,eo,V,eu);break}case"int32":{let F=G.bufferSync(Z),V=G.data.get(ee.dataId).values[0];$=(0,lR.N)(ec,F,et,es,ei,ea,en,eo,V,eu);break}case"string":{let F=G.bufferSync(Z),V=eD.D5U.decodeString(G.data.get(ee.dataId).values[0]);$=(0,lR.N)(ec,F,et,es,ei,ea,en,eo,V,eu);break}default:throw Error(`Unsupported type ${Z.dtype}`)}return G.makeTensorInfo(et,$.dtype,$.values)}let l9={kernelName:eD.D2d,backendName:"cpu",kernelFunc:sparseToDense};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function splitV(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{numOrSizeSplits:K,axis:Z}=G,ee=eD.D5U.parseAxisParam(Z,H.shape)[0],et=eD.backend_util.prepareSplitSize(H,K,ee),en=Array(H.shape.length).fill(0),ea=H.shape.slice();return et.map(F=>{let $=[...ea];$[ee]=F;let G=(0,o9.tP)({inputs:{x:H},backend:V,attrs:{begin:en,size:$}});return en[ee]+=F,G})}let l8={kernelName:eD.L8s,backendName:"cpu",kernelFunc:splitV};var l7=V(10440);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ce={kernelName:eD.bK0,backendName:"cpu",kernelFunc:({inputs:F,backend:$})=>{let{x:V}=F,G=$;(0,oc.H)(V,"square");let H=G.data.get(V.dataId).values,K=new Float32Array(H.length);for(let F=0;F<H.length;++F){let $=H[F];K[F]=$*$}let Z=G.write(K,V.shape,V.dtype);return{dataId:Z,shape:V.shape,dtype:V.dtype}}};var ct=V(40212),cr=V(27693);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cn=(0,om.A)(eD.h8e,(F,$)=>{let V=$;return isNaN(F)?NaN:F>0?1:V.alpha}),ca={kernelName:eD.h8e,backendName:"cpu",kernelFunc:cn};var ci=V(62210);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stridedSlice(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V,{begin:Z,end:ee,strides:et,beginMask:en,endMask:ea,ellipsisMask:ei,newAxisMask:eo,shrinkAxisMask:es}=H;(0,oc.H)(K,"stridedSlice");let{finalShapeSparse:eu,finalShape:ec,isIdentity:ep,sliceDim0:eh,isSimpleSlice:ef,begin:ed,end:em,strides:eg}=eD.kuN.sliceInfo(K.shape,Z,ee,et,en,ea,ei,eo,es);if(ep)$=Reshape_reshape({inputs:{x:K},backend:G,attrs:{shape:ec}});else if(eh||ef){eD.D5U.assert(K.shape.length>=1,()=>`Input must have rank at least 1, got: ${K.shape.length}`);let F=eD.kuN.computeOutShape(ed,em,eg),V=(0,o9.tP)({inputs:{x:K},backend:G,attrs:{begin:ed,size:F}});$=Reshape_reshape({inputs:{x:V},backend:G,attrs:{shape:ec}}),G.disposeIntermediateTensorInfo(V)}else{let F=G.bufferSync(K),V=(0,ci.t)(eu,F,eg,ed);$=G.makeTensorInfo(ec,V.dtype,V.values)}return $}let co={kernelName:eD.jQk,backendName:"cpu",kernelFunc:stridedSlice};var cs=V(66841);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringNGrams(F){let{inputs:$,backend:V,attrs:G}=F,{separator:H,nGramWidths:K,leftPad:Z,rightPad:ee,padWidth:et,preserveShortSequences:en}=G,{data:ea,dataSplits:ei}=$,eo=V.data.get(ea.dataId).values,es=V.data.get(ei.dataId).values,[eu,ec]=(0,cs.A)(eo,es,H,K,Z,ee,et,en);return[V.makeTensorInfo([eu.length],"string",eu),V.makeTensorInfo(ei.shape,"int32",ec)]}let cu={kernelName:eD._JP,backendName:"cpu",kernelFunc:stringNGrams};var cl=V(38639);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringSplit(F){let{inputs:$,backend:V,attrs:G}=F,{skipEmpty:H}=G,{input:K,delimiter:Z}=$;if("string"!==K.dtype)throw Error("Input must be of datatype string");if(1!==K.shape.length)throw Error(`Input must be a vector, got shape: ${K.shape}`);if(0!==Z.shape.length)throw Error(`Delimiter must be a scalar, got shape: ${Z.shape}`);let ee=V.data.get(K.dataId).values,et=V.data.get(Z.dataId).values[0],[en,ea,ei]=(0,cl.Q)(ee,et,H),eo=ea.length;return[V.makeTensorInfo([eo,2],"int32",en),V.makeTensorInfo([eo],"string",ea),V.makeTensorInfo([2],"int32",new Int32Array(ei))]}let cc={kernelName:eD.s1s,backendName:"cpu",kernelFunc:stringSplit};var cp=V(26626);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringToHashBucketFast(F){let{inputs:$,backend:V,attrs:G}=F,{numBuckets:H}=G,{input:K}=$;if("string"!==K.dtype)throw Error("Input must be of datatype string");if(H<=0)throw Error("Number of buckets must be at least 1");let Z=V.data.get(K.dataId).values,ee=(0,cp.h)(Z,H);return V.makeTensorInfo(K.shape,"int32",ee)}let ch={kernelName:eD.XkS,backendName:"cpu",kernelFunc:stringToHashBucketFast},cd=(0,om.A)(eD.sEM,F=>Math.tan(F)),cg={kernelName:eD.sEM,backendName:"cpu",kernelFunc:cd},cy=(0,om.A)(eD.MIZ,F=>Math.tanh(F)),cx={kernelName:eD.MIZ,backendName:"cpu",kernelFunc:cy};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensorScatterUpdate(F){let{inputs:$,backend:V}=F,{tensor:G,indices:H,updates:K}=$,{sliceRank:Z,numUpdates:ee,sliceSize:et,strides:en,outputSize:ea}=eD.backend_util.calculateShapes(K,H,G.shape),ei=!1,eo=V.bufferSync(H),es=V.bufferSync(K),eu=V.bufferSync(G),ec=(0,lR.N)(eo,es,G.shape,ea,et,ee,Z,en,eu,ei);return V.makeTensorInfo(G.shape,ec.dtype,ec.values)}let cw={kernelName:eD.SIB,backendName:"cpu",kernelFunc:tensorScatterUpdate};var cS=V(27723);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tile_tile(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{reps:K}=G;(0,oc.H)(H,"tile");let Z=(0,cS.R)(V.bufferSync(H),K);return V.makeTensorInfo(Z.shape,Z.dtype,Z.values)}let c_={kernelName:eD.n9L,backendName:"cpu",kernelFunc:Tile_tile};var cN=V(69556);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function topK(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{k:K,sorted:Z}=G;(0,oc.H)(H,"topk");let ee=V.data.get(H.dataId).values,[et,en]=(0,cN.W)(ee,H.shape,H.dtype,K,Z);return[V.makeTensorInfo(et.shape,et.dtype,et.values),V.makeTensorInfo(en.shape,en.dtype,en.values)]}let ck={kernelName:eD.cWu,backendName:"cpu",kernelFunc:topK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transform(F){let{inputs:$,attrs:V,backend:G}=F,{image:H,transforms:K}=$,{interpolation:Z,fillMode:ee,fillValue:et,outputShape:en}=V,[ea,ei,eo,es]=H.shape,[eu,ec]=null!=en?en:[ei,eo],ep=[ea,eu,ec,es],eh=eD.D5U.computeStrides(H.shape),ef=eh[0],ed=eh[1],em=eh[2],eg=eD.D5U.computeStrides(ep),ey=eg[0],eb=eg[1],ew=eg[2],eS=eD.D5U.getTypedArrayFromDType(H.dtype,eD.D5U.sizeFromShape(ep));eS.fill(et);let e_=G.data.get(H.dataId).values,eN=G.data.get(K.dataId).values;for(let F=0;F<ea;++F){let $=1===K.shape[0]?eN:eN.subarray(8*F,8*F+8);for(let V=0;V<eu;++V)for(let G=0;G<ec;++G)for(let H=0;H<es;++H){let K;let en=$[6]*G+$[7]*V+1;if(0===en)continue;let ea=($[0]*G+$[1]*V+$[2])/en,es=($[3]*G+$[4]*V+$[5])/en,eu=mapCoord(ea,eo,ee),ec=mapCoord(es,ei,ee);switch(Z){case"nearest":K=nearestInterpolation(e_,ei,eo,ef,ed,em,F,ec,eu,H,et);break;case"bilinear":K=bilinearInterpolation(e_,ei,eo,ef,ed,em,F,ec,eu,H,et);break;default:throw Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${Z}`)}let ep=F*ey+V*eb+G*ew+H;eS[ep]=K}return G.makeTensorInfo(ep,H.dtype,eS)}let ek=G.write(eS,ep,H.dtype);return{dataId:ek,shape:H.shape,dtype:H.dtype}}let cI={kernelName:eD.wx7,backendName:"cpu",kernelFunc:transform};function mapCoord(F,$,V){switch(V){case"reflect":return mapCoordReflect(F,$);case"wrap":return mapCoordWrap(F,$);case"nearest":return mapCoordNearest(F,$);default:return mapCoordConstant(F,$)}}function mapCoordReflect(F,$){let V=F;if(V<0){if($<=1)V=0;else{let F=2*$;V<F&&(V=F*Math.trunc(-V/F)+V),V=V<-$?V+F:-V-1}}else if(V>$-1){if($<=1)V=0;else{let F=2*$;(V-=F*Math.trunc(V/F))>=$&&(V=F-V-1)}}return eD.D5U.clamp(0,V,$-1)}function mapCoordWrap(F,$){let V=F;if(V<0){if($<=1)V=0;else{let F=$-1;V+=$*(Math.trunc(-V/F)+1)}}else if(V>$-1){if($<=1)V=0;else{let F=$-1;V-=$*Math.trunc(V/F)}}return eD.D5U.clamp(0,V,$-1)}function mapCoordConstant(F,$){return F}function mapCoordNearest(F,$){return eD.D5U.clamp(0,F,$-1)}function readWithFillValue(F,$,V,G,H,K,Z,ee,et,en,ea){let ei=Z*G+ee*H+et*K+en;return 0<=ee&&ee<$&&0<=et&&et<V?F[ei]:ea}function nearestInterpolation(F,$,V,G,H,K,Z,ee,et,en,ea){let ei=Math.round(ee),eo=Math.round(et);return readWithFillValue(F,$,V,G,H,K,Z,ei,eo,en,ea)}function bilinearInterpolation(F,$,V,G,H,K,Z,ee,et,en,ea){let ei=Math.floor(ee),eo=Math.floor(et),es=ei+1,eu=eo+1,ec=(eu-et)*readWithFillValue(F,$,V,G,H,K,Z,ei,eo,en,ea)+(et-eo)*readWithFillValue(F,$,V,G,H,K,Z,ei,eu,en,ea),ep=(eu-et)*readWithFillValue(F,$,V,G,H,K,Z,es,eo,en,ea)+(et-eo)*readWithFillValue(F,$,V,G,H,K,Z,es,eu,en,ea);return(es-ee)*ec+(ee-ei)*ep}var cT=V(75638);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Unique_unique(F){let{inputs:$,attrs:V,backend:G}=F,{axis:H}=V,{x:K}=$;(0,oc.H)(K,"unique");let Z=G.data.get(K.dataId).values,{outputValues:ee,outputShape:et,indices:en}=(0,cT.S)(Z,H,K.shape,K.dtype);return[G.makeTensorInfo(et,K.dtype,ee),G.makeTensorInfo([en.length],"int32",en)]}let cC={kernelName:eD.kpP,backendName:"cpu",kernelFunc:Unique_unique};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unpack(F){let{inputs:$,backend:V,attrs:G}=F,{value:H}=$,{axis:K}=G;K<0&&(K+=H.shape.length);let Z=H.shape.length,ee=H.shape[K],et=Array(Z-1),en=0;for(let F=0;F<Z;F++)F!==K&&(et[en++]=H.shape[F]);let ea=Array(Z).fill(0),ei=H.shape.slice();ei[K]=1;let eo=Array(ee);for(let F=0;F<eo.length;F++){ea[K]=F;let $=(0,o9.tP)({inputs:{x:H},backend:V,attrs:{begin:ea,size:ei}});eo[F]=Reshape_reshape({inputs:{x:$},backend:V,attrs:{shape:et}}),V.disposeIntermediateTensorInfo($)}return eo}let cE={kernelName:eD.ToN,backendName:"cpu",kernelFunc:unpack};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unsortedSegmentSum(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,segmentIds:K}=$,{numSegments:Z}=G;(0,oc.H)(H,"unsortedSegmentSum");let ee=H.shape.length,et=K.shape.length,en=[],ea=[],ei=ee-et,eo=K;for(let F=0;F<ei;++F){let $=expandDims({inputs:{input:eo},backend:V,attrs:{dim:F+1}});eo=$,ea.push($)}for(let F=0;F<Z;++F){let $=eD.D5U.createScalarValue(F,"int32"),G=V.makeTensorInfo([],"int32",$),K=(0,sG.Dg)({inputs:{a:G,b:eo},backend:V}),Z=(0,sa.pj)({inputs:{x:K},backend:V,attrs:{dtype:"float32"}}),ee=(0,sL.Jp)({inputs:{a:Z,b:H},backend:V}),et=Sum_sum({inputs:{x:ee},backend:V,attrs:{axis:0,keepDims:!1}});en.push(et),ea.push(G),ea.push(K),ea.push(Z),ea.push(ee),ea.push(et)}let es=pack({inputs:en,backend:V,attrs:{axis:0}});return ea.forEach(F=>V.disposeIntermediateTensorInfo(F)),es}let cA={kernelName:eD.Qvg,backendName:"cpu",kernelFunc:unsortedSegmentSum},cD=[oM,oR.fC,oO,oB,oE.j4,o$,oz,oV,oU,oW,oG,oH,oK,oJ,o1,o2,o3,o4,o6,oD,o5,o8,se,st.T0,sn,sa.Mq,so.y2,su,sl.z,sc,sm,sg,sy,sb,sx,sv,sw,s_,sk,sI,sT,sC,sE,sA,sD,sM,sR,sF,sO,sP,sB,s$,sW,oy,sj,sG.Kx,sJ,s3.SX,s4,s6.Vu,ue,ut,ur,un.Ao,ua.EE,ui,uo,uu,uc,up.Ce,uh.V,ob.I,uf,sh,um,uy,ux,ox,uv.zh,uw.m3,u_,uN.xM,uI,uE,uD,uF,uO,uP,uL,uz.eJ,uV,uU,uW,uj,uG,uq,uH,uX.u0,uK,uY,u0,sL.f$,u2.AF,u4,u5,u8,u7.nP,lt,li,ls,lu,lh,oS,lf.Iz,lm,ly,lx,lw,sf.O,s8,l_,oN,oT,oA,lN,lk,lI,lT,lC,lE,lD,lM.FY,lF,lO,lP,lz,oC.BP,lU,lj,lq,o9.C6,uJ,lQ,lZ,lJ,l3,l6,l5,l9,l8,l7.cz,ce,ct.MS,cr.j,ca,co,cu,cc,ch,s7.GR,sU,cg,cx,cw,c_,ck,cI,oL.b,cC,cE,cA,la];for(let F of cD)(0,eD.wCN)(F);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var cM=V(94739);/** @license See the LICENSE file. */let cR="4.15.0";var cF=V(4328),cO=V(91906),cP=V(90740),cB=V(95489);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function forceHalfFloat(){(0,eD.OBj)().set("WEBGL_FORCE_F16_TEXTURES",!0)}eD.C2$.isBrowser()&&(0,eD.jqO)("webgl",()=>new cM.QC,2);let c$={forceHalfFloat:forceHalfFloat};var cL=V(16697);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cz=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let BinaryOpProgram=class BinaryOpProgram{constructor(F,$,V){this.variableNames=["A","B"],this.outputShape=eD.backend_util.assertAndGetBroadcastShape($,V),this.enableShapeUniforms=(0,cL.C9)(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${F}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var cV=V(21034),cU=V(55156);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cW=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;let BinaryOpPackedProgram=class BinaryOpPackedProgram{constructor(F,$,V,G=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=eD.backend_util.assertAndGetBroadcastShape($,V);let H=this.outputShape.length;this.enableShapeUniforms=(0,cL.C9)(H);let K="";if(G){if(0===H||1===eD.D5U.sizeFromShape(this.outputShape))K=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else{let F=(0,cU.kW)(H);if(K=`
          ${F} coords = getOutputCoords();
        `,1===H)this.enableShapeUniforms?K+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:K+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let F=(0,cV.Ky)("coords",H);this.enableShapeUniforms?K+=`
            bool nextRowOutOfBounds =
              (${F[H-2]} + 1) >= outShape[${H} - 2];
            bool nextColOutOfBounds =
              (${F[H-1]} + 1) >= outShape[${H} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:K+=`
            bool nextRowOutOfBounds =
              (${F[H-2]} + 1) >= ${this.outputShape[H-2]};
            bool nextColOutOfBounds =
              (${F[H-1]} + 1) >= ${this.outputShape[H-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}}}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${F}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${K}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Identity_identity(F){let{inputs:$,backend:V}=F,{x:G}=$;return V.incRef(G.dataId),{dataId:G.dataId,shape:G.shape,dtype:G.dtype}}let cG={kernelName:eD.iJz,backendName:"webgl",kernelFunc:Identity_identity};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex(F){let{inputs:$,backend:V}=F,{real:G,imag:H}=$,K=V.makeTensorInfo(G.shape,"complex64"),Z=V.texData.get(K.dataId),ee=Identity_identity({inputs:{x:G},backend:V}),et=Identity_identity({inputs:{x:H},backend:V});return Z.complexTensorInfos={real:ee,imag:et},K}let cq={kernelName:eD.Zz9,backendName:"webgl",kernelFunc:complex},cH="return (a < 0.) ? b * a : a;",cX=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function LeakyRelu_leakyRelu(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{alpha:K}=G,Z=V.makeTensorInfo([],"float32",eD.D5U.createScalarValue(K,"float32")),ee=(0,eD.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(cX,H.shape,Z.shape):new BinaryOpProgram(cH,H.shape,Z.shape),et=V.runWebGLProgram(ee,[H,Z],"float32");return V.disposeIntermediateTensorInfo(Z),et}let cK={kernelName:eD.J$2,backendName:"webgl",kernelFunc:LeakyRelu_leakyRelu},cQ="return (a < 0.) ? b * a : a;",cZ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function kernels_Prelu_prelu(F){let{inputs:$,backend:V}=F,{x:G,alpha:H}=$,K=(0,eD.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(cZ,G.shape,H.shape):new BinaryOpProgram(cQ,G.shape,H.shape);return V.runWebGLProgram(K,[G,H],"float32")}let cY={kernelName:eD.o0g,backendName:"webgl",kernelFunc:kernels_Prelu_prelu};var cJ=V(84518),c3=V(29365);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let c4="if (isnan(x)) return x;";function unaryKernelFunc({opSnippet:F,packedOpSnippet:$,cpuKernelImpl:V,dtype:G}){return({inputs:H,backend:K})=>{let Z;let{x:ee}=H,et=K,en=G||ee.dtype;if(et.shouldExecuteOnCPU([ee])&&null!=V){let F=et.texData.get(ee.dataId),$=V(F.values,en);return et.makeTensorInfo(ee.shape,en,$)}let ea=(0,eD.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=$;return Z=ea?new c3.cc(ee.shape,$):new cJ.l(ee.shape,F),et.runWebGLProgram(Z,[ee],en)}}function binaryKernelFunc({opSnippet:F,packedOpSnippet:$,checkOutOfBounds:V=!1,supportsComplex:G=!1,cpuKernelImpl:H,dtype:K}){return({inputs:Z,backend:ee})=>{let et;let{a:en,b:ea}=Z,ei=ee;if(G&&"complex64"===en.dtype){let $=ei.texData.get(en.dataId),V=ei.texData.get(ea.dataId),[G,H]=[[$.complexTensorInfos.real,V.complexTensorInfos.real],[$.complexTensorInfos.imag,V.complexTensorInfos.imag]].map($=>{let[V,G]=$,H={dataId:V.dataId,dtype:V.dtype,shape:en.shape},K={dataId:G.dataId,dtype:G.dtype,shape:ea.shape},Z=new BinaryOpProgram(F,en.shape,ea.shape);return ei.runWebGLProgram(Z,[H,K],(0,eD.x8V)(V.dtype,G.dtype))}),K=complex({inputs:{real:G,imag:H},backend:ei});return ei.disposeIntermediateTensorInfo(G),ei.disposeIntermediateTensorInfo(H),K}let eo=K||(0,eD.x8V)(en.dtype,ea.dtype);if(("string"===en.dtype||"string"===ea.dtype||ei.shouldExecuteOnCPU([en,ea]))&&null!=H){let F=ei.texData.get(en.dataId).values,$=ei.texData.get(ea.dataId).values,V="string"===en.dtype?eD.backend_util.fromUint8ToStringArray(F):F,G="string"===en.dtype?eD.backend_util.fromUint8ToStringArray($):$,[K,Z]=H(en.shape,ea.shape,V,G,eo),ee=ei.makeTensorInfo(Z,eo),et=ei.texData.get(ee.dataId);return et.values=K,ee}let es=(0,eD.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=$;return et=es?new BinaryOpPackedProgram($,en.shape,ea.shape,V):new BinaryOpProgram(F,en.shape,ea.shape),ei.runWebGLProgram(et,[en,ea],eo)}}function mapActivationToShaderProgram(F,$=!1){if("linear"===F)return $?c3.t$:cJ.t$;if("relu"===F)return $?c3.RX:cJ.RX;if("elu"===F)return $?c3.Cv:cJ.Cv;if("relu6"===F)return $?c3.eW:cJ.eW;if("prelu"===F)return $?cZ:cQ;if("leakyrelu"===F)return $?cX:cH;if("sigmoid"===F)return $?c3.Tq:cJ.Tq;throw Error(`Activation ${F} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MatMulPackedProgram=class MatMulPackedProgram{constructor(F,$,V,G=!1,H=!1,K=!1,Z=null,ee=!1,et=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=V,this.enableShapeUniforms=(0,cL.C9)(this.outputShape.length);let en=G?F[1]:F[2],ea=Math.ceil(en/2),ei=G?"i * 2, rc.y":"rc.y, i * 2",eo=H?"rc.z, i * 2":"i * 2, rc.z",es=G?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],eu=H?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],ec="",ep="";Z&&(ec=ee?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${Z}
        }`:et?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${Z}
        }`:`vec4 activation(vec4 x) {
          ${Z}
        }`,ep="result = activation(result);");let eh=K?"result += getBiasAtOutCoords();":"";K&&this.variableNames.push("bias"),ee&&this.variableNames.push("preluActivationWeights"),et&&this.variableNames.push("leakyreluAlpha");let ef="rc.x",ed="rc.x";F[0]<$[0]?ef=`imod(rc.x, ${F[0]})`:$[0]<F[0]&&(ed=`imod(rc.x, ${$[0]})`),this.userCode=`
      ${ec}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${ea}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${ef};
        int batchB = ${ed};
        for (int i = 0; i < ${ea}; i++) {
          vec4 a = getMatrixA(batchA, ${ei});
          vec4 b = getMatrixB(batchB, ${eo});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${es[0]} * ${eu[0]});
          result += (${es[1]} * ${eu[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${eh}

        ${ep}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let c6={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let BinaryOpComplexProgram=class BinaryOpComplexProgram{constructor(F,$,V){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=eD.backend_util.assertAndGetBroadcastShape($,V),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${F}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var c5=V(64272);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let c9="return a * b;";function multiply(F){let $;let{inputs:V,backend:G}=F,{a:H,b:K}=V,Z=eD.backend_util.upcastType(H.dtype,K.dtype);if("complex64"===H.dtype){let F=G.texData.get(H.dataId),$=G.texData.get(K.dataId),V=new BinaryOpComplexProgram(c6.REAL,H.shape,K.shape),Z=new BinaryOpComplexProgram(c6.IMAG,H.shape,K.shape),ee=[{dataId:F.complexTensorInfos.real.dataId,dtype:F.complexTensorInfos.real.dtype,shape:H.shape},{dataId:F.complexTensorInfos.imag.dataId,dtype:F.complexTensorInfos.imag.dtype,shape:H.shape},{dataId:$.complexTensorInfos.real.dataId,dtype:$.complexTensorInfos.real.dtype,shape:K.shape},{dataId:$.complexTensorInfos.imag.dataId,dtype:$.complexTensorInfos.imag.dtype,shape:K.shape}],et=G.runWebGLProgram(V,ee,"float32"),en=G.runWebGLProgram(Z,ee,"float32"),ea=complex({inputs:{real:et,imag:en},backend:G});return G.disposeIntermediateTensorInfo(et),G.disposeIntermediateTensorInfo(en),ea}if(G.shouldExecuteOnCPU([H,K])){let F=G.texData.get(H.dataId),$=G.texData.get(K.dataId),[V,ee]=(0,c5.Th)(H.shape,K.shape,F.values,$.values,Z),et=G.makeTensorInfo(ee,Z),en=G.texData.get(et.dataId);return en.values=V,et}return $=(0,eD.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(c9,H.shape,K.shape):new BinaryOpProgram(c9,H.shape,K.shape),G.runWebGLProgram($,[H,K],Z)}let c8={kernelName:eD.wYn,backendName:"webgl",kernelFunc:multiply};var c7=V(28831);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function packedReshape(F,$,V){let G=[(0,cO.getBatchDim)(F.shape),...(0,cO.getRowsCols)(F.shape)],H={dtype:F.dtype,shape:G,dataId:F.dataId},K=[(0,cO.getBatchDim)($),...(0,cO.getRowsCols)($)],Z=new c7.v(K,G),ee=!0,et=[G],en=V.runWebGLProgram(Z,[H],F.dtype,et,ee);return{dataId:en.dataId,shape:$,dtype:en.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Reshape_reshape(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{shape:K}=G,Z=V,ee=eD.D5U.sizeFromShape(H.shape),et=eD.D5U.inferFromImplicitShape(K,ee),en=eD.D5U.sizeFromShape(et);eD.D5U.assert(ee===en,()=>`The new shape (${et}) has ${en} elements and the old shape (${H.shape}) has ${ee} elements. The new shape and old shape must have the same number of elements.`);let ea=Z.texData.get(H.dataId);return!ea.isPacked||(0,cO.isReshapeFree)(H.shape,et)||null!==ea.texture&&(0,cO.isReshapeFree)(ea.shape,et)?(Z.incRef(H.dataId),{dataId:H.dataId,shape:et,dtype:H.dtype}):packedReshape(H,et,Z)}let pe={kernelName:eD.HZH,backendName:"webgl",kernelFunc:kernels_Reshape_reshape};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MeanProgram=class MeanProgram{constructor(F,$){this.variableNames=["x"];let{windowSize:V,batchSize:G,inSize:H,outSize:K}=F;this.outputShape=[G,K];let Z=4*Math.floor(V/4),ee=V%4,et="sumValue += dot(values, ones);";if(null!=$){let F=1/$;et=`sumValue += dot(values * ${eD.D5U.isInt(F)?F.toPrecision(2):F}, ones);`}let en="";H%V>0&&(en=`
        if (inIdx < 0 || inIdx >= ${H}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${en}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${V};

        float sumValue = 0.0;

        for (int i = 0; i < ${Z}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${et}
        }

        int inIdx = inOffset + ${Z};
        if (${1===ee}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${et}
        } else if (${2===ee}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${et}
        } else if (${3===ee}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${et}
        }
        setOutput(sumValue);
      }
    `}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ReduceProgram=class ReduceProgram{constructor(F,$){this.variableNames=["x"];let{windowSize:V,batchSize:G,inSize:H,outSize:K}=F;this.outputShape=[G,K];let Z="0.0",ee="";"prod"===$?Z="1.0":"min"===$?(Z="1.0 / 1e-20",ee="min"):"max"===$&&(Z="-1.0 / 1e-20",ee="max");let et=`${$}(${$}(${$}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===$?et="sumValue":"prod"===$?et="prodValue":"all"===$?et="allValue":"any"===$&&(et="anyValue");let en=4*Math.floor(V/4),ea=V%4,ei=`
      if (${"sum"===$}) {
        sumValue += dot(values, ones);
      } else if (${"prod"===$}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${ee}(values, minMaxValue);
        if (${"min"===$} || ${"max"===$}) {
          minMaxValue = ${ee}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,eo="vec4";"all"===$?(Z="1.0",ei=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,eo="bvec4"):"any"===$&&(Z="0.0",ei=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,eo="bvec4");let es="";H%V>0&&(es=`
        if (inIdx < 0 || inIdx >= ${H}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${Z};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${es}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${V};

        vec4 minMaxValue = vec4(${Z});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${en}; i += 4) {
          int inIdx = inOffset + i;
          ${eo} values = ${eo}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${ei}
        }

        int inIdx = inOffset + ${en};
        if (${1===ea}) {
          ${eo} values = ${eo}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${ei}
        } else if (${2===ea}) {
          ${eo} values = ${eo}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${ei}
        } else if (${3===ea}) {
          ${eo} values = ${eo}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${ei}
        }
        setOutput(${et});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getReductionStages(F){let $=[];for(;0===$.length||1!==$[$.length-1].outSize;){let V=$.length?$[$.length-1].outSize:F[1],G=eD.backend_util.computeOptimalWindowSize(V);$.push({inSize:V,windowSize:G,outSize:Math.ceil(V/G)})}return $}function reduce(F,$,V,G){let H=getReductionStages(F.shape),K=F;for(let Z=0;Z<H.length;Z++){let ee,et;let{inSize:en,windowSize:ea,outSize:ei}=H[Z];ee="mean"===V?0===Z?new MeanProgram({windowSize:ea,inSize:en,batchSize:F.shape[0],outSize:ei},en):new MeanProgram({windowSize:ea,inSize:en,batchSize:F.shape[0],outSize:ei}):new ReduceProgram({windowSize:ea,inSize:en,batchSize:F.shape[0],outSize:ei},V),et=K,K=G.runWebGLProgram(ee,[K],$),et.dataId!==F.dataId&&G.disposeIntermediateTensorInfo(et)}return K}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TransposeProgram=class TransposeProgram{constructor(F,$){this.variableNames=["A"];let V=Array(F.length);for(let G=0;G<V.length;G++)V[G]=F[$[G]];this.outputShape=V,this.rank=V.length;let G=(0,cU.kW)(this.rank),H=getSwitchedCoords($);this.userCode=`
    void main() {
      ${G} resRC = getOutputCoords();
      setOutput(getA(${H}));
    }
    `}};function getSwitchedCoords(F){let $=F.length;if($>6)throw Error(`Transpose for rank ${$} is not yet supported`);let V=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],G=Array($);for(let $=0;$<F.length;$++)G[F[$]]=V[$];return G.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TransposePackedProgram=class TransposePackedProgram{constructor(F,$){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let V=Array(F.length);for(let G=0;G<V.length;G++)V[G]=F[$[G]];if(this.outputShape=V,this.rank=V.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let G=(0,cU.kW)(this.rank),H=(0,cV.k6)("rc",this.rank),K=Array(this.rank);for(let F=0;F<$.length;F++)K[$[F]]=H[F];let Z=`vec2(${K.slice(-2).join()})`,ee=`++${H[this.rank-1]} < ${V[this.rank-1]}`,et=`getChannel(getA(${K.join()}), ${Z})`;this.userCode=`
    void main() {
      ${G} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${et};
      if(${ee}) {
        result[1] = ${et};
      }
      --${H[this.rank-1]};
      if(++${H[this.rank-2]} < ${V[this.rank-2]}) {
        result[2] = ${et};
        if(${ee}) {
          result[3] = ${et};
        }
      }
      setOutput(result);
    }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transposeImpl(F,$,V){let G=(0,eD.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TransposePackedProgram(F.shape,$):new TransposeProgram(F.shape,$);return V.runWebGLProgram(G,[F],F.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sumImpl(F,$,V,G){let H=$,K=F.shape.length,Z=eD.D5U.parseAxisParam(H,F.shape),ee=Z,et=eD.backend_util.getAxesPermutation(ee,K),en=null!=et,ea=F;en&&(ea=transposeImpl(F,et,G),ee=eD.backend_util.getInnerMostAxes(ee.length,K)),eD.backend_util.assertAxesAreInnerMostDims("sum",ee,K);let[ei,eo]=eD.backend_util.computeOutAndReduceShapes(ea.shape,ee),es=ei;V&&(es=eD.backend_util.expandShapeToKeepDim(ei,Z));let eu=eD.D5U.sizeFromShape(eo),ec=eD.D5U.sizeFromShape(F.shape),ep=ec/eu,eh=kernels_Reshape_reshape({inputs:{x:ea},attrs:{shape:[ep,eu]},backend:G}),ef=(0,eD.z4k)(F.dtype),ed=reduce(eh,ef,"sum",G),em=kernels_Reshape_reshape({inputs:{x:ed},attrs:{shape:es},backend:G});return G.disposeIntermediateTensorInfo(eh),G.disposeIntermediateTensorInfo(ed),en&&G.disposeIntermediateTensorInfo(ea),em}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Sum_sum(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K,keepDims:Z}=G;return sumImpl(H,K,Z,V)}let po={kernelName:eD.GBy,backendName:"webgl",kernelFunc:kernels_Sum_sum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Transpose_transpose(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V,{perm:Z}=H,ee=G,et=K.shape.length,en=Array(et);for(let F=0;F<en.length;F++)en[F]=K.shape[Z[F]];if(ee.shouldExecuteOnCPU([K])){let F=ee.texData.get(K.dataId),V=F.values,G=(0,c5.Fv)(V,K.shape,K.dtype,Z,en);$=ee.makeTensorInfo(en,K.dtype);let H=ee.texData.get($.dataId);H.values=G}else $=transposeImpl(K,Z,ee);return $}let pu={kernelName:eD.G3Y,backendName:"webgl",kernelFunc:Transpose_transpose},pl=1e3;function batchMatMulImpl({a:F,b:$,transposeA:V,transposeB:G,backend:H,bias:K=null,preluActivationWeights:Z=null,leakyreluAlpha:ee=0,activation:et=null}){let en;let ea=F.shape.length,ei=$.shape.length,eo=V?F.shape[ea-2]:F.shape[ea-1],es=G?$.shape[ei-1]:$.shape[ei-2],eu=V?F.shape[ea-1]:F.shape[ea-2],ec=G?$.shape[ei-2]:$.shape[ei-1],ep=F.shape.slice(0,-2),eh=$.shape.slice(0,-2),ef=eD.D5U.sizeFromShape(ep),ed=eD.D5U.sizeFromShape(eh),em=eD.Jyw.assertAndGetBroadcastShape(F.shape.slice(0,-2),$.shape.slice(0,-2)),eg=em.concat([eu,ec]);eD.D5U.assert(eo===es,()=>`Error in matMul: inner shapes (${eo}) and (${es}) of Tensors with shapes ${F.shape} and ${$.shape} and transposeA=${V} and transposeB=${G} must match.`);let ey=V?[ef,eo,eu]:[ef,eu,eo],eb=G?[ed,ec,es]:[ed,es,ec],ew=kernels_Reshape_reshape({inputs:{x:F},backend:H,attrs:{shape:ey}}),eS=kernels_Reshape_reshape({inputs:{x:$},backend:H,attrs:{shape:eb}}),e_=[ew,eS],eN=Math.max(ef,ed),ek=V?ew.shape[1]:ew.shape[2],eI=null!=K,eT=null!=Z,eC="leakyrelu"===et,eE=null!=et?mapActivationToShaderProgram(et,!0):null,eA=eI||eT||eC||null!=eE;if((1===eu||1===ec)&&ek>pl&&!1===eA){let F=ew,$=eS;V&&(F=Transpose_transpose({inputs:{x:ew},backend:H,attrs:{perm:[0,2,1]}}),e_.push(F)),G&&($=Transpose_transpose({inputs:{x:eS},backend:H,attrs:{perm:[0,2,1]}}),e_.push($));let K=1!==ec,Z=1===ec,ee=F;K&&(ee=kernels_Reshape_reshape({inputs:{x:F},backend:H,attrs:{shape:[eN,ek,1]}}),e_.push(ee));let et=1===ec?2:1,ea=$;Z&&(ea=kernels_Reshape_reshape({inputs:{x:$},backend:H,attrs:{shape:[eN,1,ek]}}),e_.push(ea));let ei=multiply({inputs:{a:ee,b:ea},backend:H});en=kernels_Sum_sum({inputs:{x:ei},backend:H,attrs:{axis:et,keepDims:!0}}),e_.push(ei)}else{let et=(0,eD.x8V)(F.dtype,$.dtype),ea=new MatMulPackedProgram(ey,eb,[eN,eu,ec],V,G,eI,eE,eT,eC),ei=[ew,eS];if(null!=K&&ei.push(K),eT&&ei.push(Z),eC){let F=H.makeTensorInfo([],"float32",eD.D5U.createScalarValue(ee,"float32"));ei.push(F),e_.push(F)}en=H.runWebGLProgram(ea,ei,et)}let eM=kernels_Reshape_reshape({inputs:{x:en},backend:H,attrs:{shape:eg}});for(let F of(e_.push(en),e_))H.disposeIntermediateTensorInfo(F);return eM}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _FusedMatMul_fusedMatMul(F){let{inputs:$,backend:V,attrs:G}=F,{a:H,b:K,bias:Z,preluActivationWeights:ee}=$,{transposeA:et,transposeB:en,activation:ea,leakyreluAlpha:ei}=G;return batchMatMulImpl({a:H,b:K,transposeA:et,transposeB:en,backend:V,bias:Z,preluActivationWeights:ee,leakyreluAlpha:ei,activation:ea})}let pc={kernelName:eD.usg,backendName:"webgl",kernelFunc:_FusedMatMul_fusedMatMul},ph="return abs(x);";function Abs_abs(F){let $;let{inputs:V,backend:G}=F,{x:H}=V;if(G.shouldExecuteOnCPU([H])&&"complex64"!==H.dtype){let F=G.texData.get(H.dataId),$=(0,c5.CJ)(F.values);return G.makeTensorInfo(H.shape,H.dtype,$)}return $=(0,eD.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new c3.cc(H.shape,ph):new cJ.l(H.shape,ph),G.runWebGLProgram($,[H],H.dtype)}let pf={kernelName:eD.SYM,backendName:"webgl",kernelFunc:Abs_abs},pd=cJ.D1+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,pm=unaryKernelFunc({opSnippet:pd}),pg={kernelName:eD.VGw,backendName:"webgl",kernelFunc:pm},py=cJ.D1+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,pb=unaryKernelFunc({opSnippet:py}),pw={kernelName:eD.SpW,backendName:"webgl",kernelFunc:pb},pS="return a + b;",p_=binaryKernelFunc({opSnippet:pS,packedOpSnippet:pS,supportsComplex:!0,cpuKernelImpl:c5.cK}),pN={kernelName:eD.mm_,backendName:"webgl",kernelFunc:p_};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AddNProgram=class AddNProgram{constructor(F,$){this.outputShape=[],this.outputShape=F,this.variableNames=$.map((F,$)=>`T${$}`);let V=[];this.variableNames.forEach(F=>{V.push(`float v${F} = get${F}AtOutCoords();`)});let G=this.variableNames.map(F=>`v${F}`).join(" + ");this.userCode=`
      void main() {
        ${V.join("\n        ")}

        float result = ${G};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AddNPackedProgram=class AddNPackedProgram{constructor(F,$){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=F,this.variableNames=$.map((F,$)=>`T${$}`);let V=[];this.variableNames.forEach(F=>{V.push(`vec4 v${F} = get${F}AtOutCoords();`)});let G=this.variableNames.map(F=>`v${F}`).join(" + ");this.userCode=`
      void main() {
        ${V.join("\n        ")}

        vec4 result = ${G};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AddN_addN(F){let{inputs:$,backend:V}=F,G=$;if(1===G.length)return Identity_identity({inputs:{x:G[0]},backend:V});if(G.length>(0,eD.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let F=Math.floor(G.length/2),$=AddN_addN({inputs:G.slice(0,F),backend:V}),H=AddN_addN({inputs:G.slice(F),backend:V});return AddN_addN({inputs:[$,H],backend:V})}let H=G.map(F=>F.dtype).reduce((F,$)=>(0,eD.x8V)(F,$)),K=G.map(F=>F.shape),Z=(0,eD.OBj)().getBool("WEBGL_PACK"),ee=Z?new AddNPackedProgram(G[0].shape,K):new AddNProgram(G[0].shape,K);return V.runWebGLProgram(ee,G,H)}let pI={kernelName:eD.Xze,backendName:"webgl",kernelFunc:AddN_addN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_All_all(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V,{axis:Z,keepDims:ee}=H,et=K.shape.length,en=eD.D5U.parseAxisParam(Z,K.shape),ea=en,ei=eD.backend_util.getAxesPermutation(ea,et),eo=K;null!=ei&&(eo=Transpose_transpose({inputs:{x:K},backend:G,attrs:{perm:ei}}),ea=eD.backend_util.getInnerMostAxes(ea.length,et)),eD.backend_util.assertAxesAreInnerMostDims("all",ea,et);let[es,eu]=eD.backend_util.computeOutAndReduceShapes(eo.shape,ea),ec=eD.D5U.sizeFromShape(eu),ep=kernels_Reshape_reshape({inputs:{x:eo},backend:G,attrs:{shape:[-1,ec]}}),eh=reduce(ep,ep.dtype,"all",G);if(ee){let F=eD.backend_util.expandShapeToKeepDim(es,en);$=kernels_Reshape_reshape({inputs:{x:eh},backend:G,attrs:{shape:F}})}else $=kernels_Reshape_reshape({inputs:{x:eh},backend:G,attrs:{shape:es}});return G.disposeIntermediateTensorInfo(ep),G.disposeIntermediateTensorInfo(eh),null!=ei&&G.disposeIntermediateTensorInfo(eo),$}let pT={kernelName:eD.oT6,backendName:"webgl",kernelFunc:kernels_All_all};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Any_any(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V,{axis:Z,keepDims:ee}=H,et=K.shape.length,en=eD.D5U.parseAxisParam(Z,K.shape),ea=en,ei=eD.backend_util.getAxesPermutation(ea,et),eo=K;null!=ei&&(eo=Transpose_transpose({inputs:{x:K},backend:G,attrs:{perm:ei}}),ea=eD.backend_util.getInnerMostAxes(ea.length,et)),eD.backend_util.assertAxesAreInnerMostDims("any",ea,et);let[es,eu]=eD.backend_util.computeOutAndReduceShapes(eo.shape,ea),ec=eD.D5U.sizeFromShape(eu),ep=kernels_Reshape_reshape({inputs:{x:eo},backend:G,attrs:{shape:[-1,ec]}}),eh=reduce(ep,ep.dtype,"any",G);if(ee){let F=eD.backend_util.expandShapeToKeepDim(es,en);$=kernels_Reshape_reshape({inputs:{x:eh},backend:G,attrs:{shape:F}})}else $=kernels_Reshape_reshape({inputs:{x:eh},backend:G,attrs:{shape:es}});return G.disposeIntermediateTensorInfo(ep),G.disposeIntermediateTensorInfo(eh),null!=ei&&G.disposeIntermediateTensorInfo(eo),$}let pC={kernelName:eD.IKK,backendName:"webgl",kernelFunc:kernels_Any_any};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ArgMinMaxProgram=class ArgMinMaxProgram{constructor(F,$,V){this.variableNames=["A"];let{windowSize:G,batchSize:H,outSize:K}=F;V||this.variableNames.push("bestIndicesA"),this.outputShape=[H,K];let Z="max"===$?">":"<",ee=V?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${G};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${G}; i++) {
          int inIdx = ${ee};
          float candidate = getA(batch, inIdx);
          if (candidate ${Z} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ArgMinMaxPackedProgram=class ArgMinMaxPackedProgram{constructor(F,$,V,G){let H,K;this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,eD.D5U.assert(F.length>2,()=>`Packed arg${V.charAt(0).toUpperCase()+V.slice(1)} supports only inputs with rank above 2.`);let Z=F[F.length-1],ee=Math.ceil(Z/$);this.outputShape=F.slice(0,-1),ee>1&&this.outputShape.push(ee),G||this.variableNames.push("bestIndicesA");let et=this.outputShape,en=et.length,ea=(0,cU.kW)(en),ei=(0,cV.Ky)("coords",en);if(1===ee){K=en+1;let F=(0,cU.kW)(K);H=`
        ${F} sourceLocR = ${F}(${ei.join()}, 0);
        ++${ei[en-1]};
        ${F} sourceLocG = ${F}(${ei.join()}, 0);
        ++${ei[en-2]};
        ${F} sourceLocA = ${F}(${ei.join()}, 0);
        --${ei[en-1]};
        ${F} sourceLocB = ${F}(${ei.join()}, 0);
        --${ei[en-2]};`}else K=en,H=`
        ${ea} sourceLocR = coords;
        ++${ei[en-1]};
        ${ea} sourceLocG = coords;
        ++${ei[en-2]};
        ${ea} sourceLocA = coords;
        --${ei[en-1]};
        ${ea} sourceLocB = coords;
        --${ei[en-2]};`;let eo=["x","y","z","w","u","v"].slice(0,K),es="."+eo[K-1],eu=eo.map(F=>"int "+F),ec=(0,cV.Ky)("sourceLocR",K-1).concat("inIdx.r"),ep=(0,cV.Ky)("sourceLocG",K-1).concat("inIdx.g"),eh=(0,cV.Ky)("sourceLocB",K-1).concat("inIdx.b"),ef=(0,cV.Ky)("sourceLocA",K-1).concat("inIdx.a"),ed="max"===V?"greaterThan":"lessThan",em=G?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${ec.join()}),
                             getBestIndicesAChannel(${ep.join()}),
                             getBestIndicesAChannel(${eh.join()}),
                             getBestIndicesAChannel(${ef.join()})));`,eg=`vec4(
            getAChannel(${ec.join()}),
            hasNextCol ? getAChannel(${ep.join()}) : 0.,
            hasNextRow ? getAChannel(${eh.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${ef.join()}) : 0.)`,ey=G?"":`
      float getBestIndicesAChannel(${eu.join()}) {
        return getChannel(getBestIndicesA(${eo.join()}),
                                          vec2(${eo.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${eu.join()}) {
        return getChannel(getA(${eo.join()}),
                               vec2(${eo.slice(-2).join()}));
      }
      ${ey}
      void main() {
        ${ea} coords = getOutputCoords();
        bool hasNextCol = ${ei[en-1]} < ${et[en-1]-1};
        bool hasNextRow = ${ei[en-2]} < ${et[en-2]-1};
        ${H}
        ivec4 srcIdx = ivec4(sourceLocR${es}, sourceLocG${es},
          sourceLocB${es}, sourceLocA${es}) * ${$};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${eg};

        for (int i = 0; i < ${$}; i++) {
          inIdx = srcIdx;
          ${em}
          vec4 candidate = ${eg};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${ed}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argReduce(F,$,V,G=null){let H=$.shape[0],K=$.shape[1];null!=G&&(H=G.shape[0],K=G.shape[1]);let Z=eD.backend_util.computeOptimalWindowSize(K),ee={windowSize:Z,inSize:K,batchSize:H,outSize:Math.ceil(K/Z)},et=new ArgMinMaxProgram(ee,V,null==G),en=[$];null!=G&&en.push(G);let ea=F.runWebGLProgram(et,en,"int32");if(1===ea.shape[1])return ea;let ei=argReduce(F,$,V,ea);return F.disposeIntermediateTensorInfo(ea),ei}function argReducePacked(F,$,V,G=null){let H=null!=G?G.shape:$.shape,K=H[H.length-1],Z=eD.backend_util.computeOptimalWindowSize(K),ee=new ArgMinMaxPackedProgram(H,Z,V,null==G),et=null==G?[$]:[$,G],en=F.runWebGLProgram(ee,et,"int32");if(en.shape.length===$.shape.length){let G=argReducePacked(F,$,V,en);return F.disposeIntermediateTensorInfo(en),G}return en}function argMinMaxReduce(F,$,V,G){let H=[V];if(eD.backend_util.assertAxesAreInnerMostDims("arg"+G.charAt(0).toUpperCase()+G.slice(1),H,$.shape.length),!(0,eD.OBj)().getBool("WEBGL_PACK_REDUCE")||$.shape.length<=2){let V=[],K=F.texData.get($.dataId),Z=null!==K&&K.isPacked,ee=$;Z&&V.push(ee=F.unpackTensor($));let[et,en]=eD.backend_util.computeOutAndReduceShapes(ee.shape,H),ea=eD.D5U.sizeFromShape(en),ei=kernels_Reshape_reshape({inputs:{x:ee},backend:F,attrs:{shape:[-1,ea]}});V.push(ei);let eo=argReduce(F,ei,G);V.push(eo);let es=kernels_Reshape_reshape({inputs:{x:eo},backend:F,attrs:{shape:et}});return V.forEach($=>F.disposeIntermediateTensorInfo($)),es}return argReducePacked(F,$,G)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ArgMax_argMax(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K}=G,Z=eD.D5U.parseAxisParam(K,H.shape),ee=eD.backend_util.getAxesPermutation(Z,H.shape.length),et=H,en=[];null!=ee&&(en.push(et=Transpose_transpose({inputs:{x:H},backend:V,attrs:{perm:ee}})),Z=eD.backend_util.getInnerMostAxes(Z.length,et.shape.length)),eD.backend_util.assertAxesAreInnerMostDims("argMax",[Z[0]],et.shape.length);let ea=argMinMaxReduce(V,et,Z[0],"max");return en.forEach(F=>V.disposeIntermediateTensorInfo(F)),ea}let pE={kernelName:eD.sJF,backendName:"webgl",kernelFunc:ArgMax_argMax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ArgMin_argMin(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K}=G,Z=eD.D5U.parseAxisParam(K,H.shape),ee=eD.backend_util.getAxesPermutation(Z,H.shape.length),et=H,en=[];null!=ee&&(en.push(et=Transpose_transpose({inputs:{x:H},backend:V,attrs:{perm:ee}})),Z=eD.backend_util.getInnerMostAxes(Z.length,et.shape.length)),eD.backend_util.assertAxesAreInnerMostDims("argMin",[Z[0]],et.shape.length);let ea=argMinMaxReduce(V,et,Z[0],"min");return en.forEach(F=>V.disposeIntermediateTensorInfo(F)),ea}let pA={kernelName:eD.aJk,backendName:"webgl",kernelFunc:ArgMin_argMin},pD=cJ.D1+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,pM=unaryKernelFunc({opSnippet:pD}),pR={kernelName:eD.M2y,backendName:"webgl",kernelFunc:pM},pF=cJ.D1+"return log(x + sqrt(x * x + 1.0));",pO=unaryKernelFunc({opSnippet:pF}),pP={kernelName:eD.qw7,backendName:"webgl",kernelFunc:pO},pB=cJ.D1+`
  return atan(x);
`,p$=unaryKernelFunc({opSnippet:pB}),pL={kernelName:eD.jMg,backendName:"webgl",kernelFunc:p$},pz=cz+`
  return atan(a, b);
`,pV=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+cW+`
  return result;
`,pU=binaryKernelFunc({opSnippet:pz,packedOpSnippet:pV}),pW={kernelName:eD.QCc,backendName:"webgl",kernelFunc:pU},pG=cJ.D1+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,pq=unaryKernelFunc({opSnippet:pG}),pH={kernelName:eD.Oyi,backendName:"webgl",kernelFunc:pq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pool2DProgram=class Pool2DProgram{constructor(F,$,V,G=!1,H=!1){if(this.variableNames=["x"],"avg"===$&&V)throw Error("Cannot compute positions for average pool.");let K=F.filterWidth,Z=F.strideHeight,ee=F.strideWidth,et=F.dilationHeight,en=F.dilationWidth,ea=F.effectiveFilterHeight,ei=F.effectiveFilterWidth,eo=F.padInfo.top,es=F.padInfo.left;this.outputShape=F.outShape;let eu="avg"===$,ec=`((batch  * ${F.inHeight} + xR) * ${F.inWidth} + xC) * ${F.inChannels} + d`,ep=`(xR * ${F.inWidth} + xC) * ${F.inChannels} + d`,eh="0.0";if(eu||(eh="-1.0 / 1e-20"),V){let $=">=";this.userCode=`
        const ivec2 strides = ivec2(${Z}, ${ee});
        const ivec2 pads = ivec2(${eo}, ${es});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${ea};
              wR += ${et}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${F.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${ei};
                wC += ${en}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${F.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${$} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${G?H?ec:ep:`wR * ${ei} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let ef="max",ed=`${$}(${$}(${$}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===$&&(ed="avgValue / max(count, 1.0)");let em=4*Math.floor(K/4),eg=K%4,ey=`
      if (${eu}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${ef}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${Z}, ${ee});
      const ivec2 pads = ivec2(${eo}, ${es});
      const float initializationValue = ${eh};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${F.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${eh});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${ea};
            wR += ${et}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${F.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${em}; wC += 4) {
            int xC = xCCorner + wC * ${en};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${en}, d),
              getValue(batch, xR, xC + 2 * ${en}, d),
              getValue(batch, xR, xC + 3 * ${en}, d)
            );

            ${ey}
          }

          int xC = xCCorner + ${em};
          if (${1===eg}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${ey}
          } else if (${2===eg}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${en}, d),
              initializationValue,
              initializationValue
            );

            ${ey}
          } else if (${3===eg}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${en}, d),
              getValue(batch, xR, xC + 2 * ${en}, d),
              initializationValue
            );

            ${ey}
          }
        }
        setOutput(${ed});
      }
    `}};let Pool3DProgram=class Pool3DProgram{constructor(F,$,V,G=!1,H=!1){if(this.variableNames=["x"],"avg"===$&&V)throw Error("Cannot compute positions for average pool.");let K=F.filterWidth,Z=F.strideDepth,ee=F.strideHeight,et=F.strideWidth,en=F.dilationDepth,ea=F.dilationHeight,ei=F.dilationWidth,eo=F.effectiveFilterDepth,es=F.effectiveFilterHeight,eu=F.effectiveFilterWidth,ec=F.padInfo.front,ep=F.padInfo.top,eh=F.padInfo.left;this.outputShape=F.outShape;let ef="avg"===$,ed="0.0";if(ef||(ed="-1.0 / 1e-20"),V){let $=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${Z}, ${ee}, ${et});
        const ivec3 pads = ivec3(${ec}, ${ep}, ${eh});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${eo};
              wD += ${en}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${F.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${es};
                wR += ${ea}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${F.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${eu};
                  wC += ${ei}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${F.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${$} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${G?H?`(((batch * ${F.inDepth} + xD) * ${F.inHeight} + xR) * ${F.inWidth} + xC) * ${F.inChannels} + ch`:`((xD * ${F.inHeight} + xR) * ${F.inWidth} + xC) * ${F.inChannels} + ch`:`wD * ${es} * ${eu} +
                      wR * ${eu} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let em="max",eg=`${$}(${$}(${$}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===$&&(eg="avgValue / max(count, 1.0)");let ey=4*Math.floor(K/4),eb=K%4,ew=`
      if (${ef}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${em}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${Z}, ${ee}, ${et});
      const ivec3 pads = ivec3(${ec}, ${ep}, ${eh});
      const float initializationValue = ${ed};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${F.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${ed});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${eo};
            wD += ${en}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${F.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${es};
            wR += ${ea}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${F.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${ey}; wC += 4) {
              int xC = xCCorner + wC * ${ei};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${ei}, ch),
                getValue(batch, xD, xR, xC + 2 * ${ei}, ch),
                getValue(batch, xD, xR, xC + 3 * ${ei}, ch)
              );

              ${ew}
            }

            int xC = xCCorner + ${ey};
            if (${1===eb}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${ew}
            } else if (${2===eb}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${ei}, ch),
                initializationValue,
                initializationValue
              );

              ${ew}
            } else if (${3===eb}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${ei}, ch),
                getValue(batch, xD, xR, xC + 2 * ${ei}, ch),
                initializationValue
              );

              ${ew}
            }
          }
        }
        setOutput(${eg});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AvgPool_avgPool(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$;(0,cO.assertNotComplex)(H,"avgPool");let{filterSize:K,strides:Z,pad:ee,dimRoundingMode:et}=G,en=1;eD.D5U.assert(eD.backend_util.eitherStridesOrDilationsAreOne(Z,en),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${Z} and dilations '${en}'`);let ea=eD.backend_util.computePool2DInfo(H.shape,K,Z,en,ee,et);if(1===ea.filterWidth&&1===ea.filterHeight&&eD.D5U.arraysEqual(ea.inShape,ea.outShape))return Identity_identity({inputs:{x:H},backend:V});let ei=new Pool2DProgram(ea,"avg",!1);return V.runWebGLProgram(ei,[H],"float32")}let pX={kernelName:eD.JhU,backendName:"webgl",kernelFunc:AvgPool_avgPool};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AvgPool3D_avgPool3D(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{filterSize:K,strides:Z,pad:ee,dimRoundingMode:et,dataFormat:en}=G,ea=[1,1,1],ei=eD.backend_util.computePool3DInfo(H.shape,K,Z,ea,ee,et,en),eo=new Pool3DProgram(ei,"avg",!1);return V.runWebGLProgram(eo,[H],"float32")}let pK={kernelName:eD._k9,backendName:"webgl",kernelFunc:AvgPool3D_avgPool3D};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AvgPool2DBackpropProgram=class AvgPool2DBackpropProgram{constructor(F){this.variableNames=["dy"],this.outputShape=F.inShape;let $=F.filterHeight,V=F.filterWidth,G=F.strideHeight,H=F.strideWidth,K=F.dilationHeight,Z=F.dilationWidth,ee=F.effectiveFilterHeight,et=F.effectiveFilterWidth,en=ee-1-F.padInfo.top,ea=et-1-F.padInfo.left,ei=1/($*V);this.userCode=`
      const ivec2 pads = ivec2(${en}, ${ea});
      const float avgMultiplier = float(${ei});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${ee};
            wR += ${K}) {
          float dyR = float(dyRCorner + wR) / ${G}.0;

          if (dyR < 0.0 || dyR >= ${F.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${et};
            wC+= ${Z}) {
            float dyC = float(dyCCorner + wC) / ${H}.0;

            if (dyC < 0.0 || dyC >= ${F.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}};let AvgPool3DBackpropProgram=class AvgPool3DBackpropProgram{constructor(F){this.variableNames=["dy"],this.outputShape=F.inShape;let $=F.filterDepth,V=F.filterHeight,G=F.filterWidth,H=F.strideDepth,K=F.strideHeight,Z=F.strideWidth,ee=F.dilationDepth,et=F.dilationHeight,en=F.dilationWidth,ea=F.effectiveFilterDepth,ei=F.effectiveFilterHeight,eo=F.effectiveFilterWidth,es=ea-1-F.padInfo.front,eu=ei-1-F.padInfo.top,ec=eo-1-F.padInfo.left,ep=1/($*V*G);this.userCode=`
      const ivec3 pads = ivec3(${es}, ${eu}, ${ec});
      const float avgMultiplier = float(${ep});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${ea};
            wD += ${ee}) {
          float dyD = float(dyDCorner + wD) / ${H}.0;

          if (dyD < 0.0 || dyD >= ${F.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${ei};
              wR += ${et}) {
            float dyR = float(dyRCorner + wR) / ${K}.0;

            if (dyR < 0.0 || dyR >= ${F.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${eo};
                wC += ${en}) {
              float dyC = float(dyCCorner + wC) / ${Z}.0;

              if (dyC < 0.0 || dyC >= ${F.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AvgPool3DGrad_avgPool3DGrad(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,input:K}=$,Z=K,{filterSize:ee,strides:et,pad:en,dimRoundingMode:ea}=G,ei=[1,1,1],eo=eD.backend_util.computePool3DInfo(Z.shape,ee,et,ei,en,ea),es=new AvgPool3DBackpropProgram(eo);return V.runWebGLProgram(es,[H],Z.dtype)}let pQ={kernelName:eD.IMb,backendName:"webgl",kernelFunc:AvgPool3DGrad_avgPool3DGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_AvgPoolGrad_avgPoolGrad(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,input:K}=$,Z=K;(0,cO.assertNotComplex)([H,K],"avgPoolGrad");let{filterSize:ee,strides:et,pad:en}=G,ea=eD.backend_util.computePool2DInfo(Z.shape,ee,et,1,en),ei=new AvgPool2DBackpropProgram(ea);return V.runWebGLProgram(ei,[H],Z.dtype)}let pZ={kernelName:eD.ROF,backendName:"webgl",kernelFunc:kernels_AvgPoolGrad_avgPoolGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BatchMatMul_batchMatMul(F){let{inputs:$,backend:V,attrs:G}=F,{a:H,b:K}=$,{transposeA:Z,transposeB:ee}=G;return batchMatMulImpl({a:H,b:K,transposeA:Z,transposeB:ee,backend:V})}let pY={kernelName:eD.XLW,backendName:"webgl",kernelFunc:BatchMatMul_batchMatMul};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BatchNormProgram=class BatchNormProgram{constructor(F,$,V,G,H,K){this.outputShape=[],this.variableNames=["x","mean","variance"],eD.backend_util.assertAndGetBroadcastShape(F,$),eD.backend_util.assertAndGetBroadcastShape(F,V);let Z="0.0";null!=G&&(eD.backend_util.assertAndGetBroadcastShape(F,G),this.variableNames.push("offset"),Z="getOffsetAtOutCoords()");let ee="1.0";null!=H&&(eD.backend_util.assertAndGetBroadcastShape(F,H),this.variableNames.push("scale"),ee="getScaleAtOutCoords()"),this.outputShape=F,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${Z};
        float scale = ${ee};
        float inv = scale * inversesqrt(variance + float(${K}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BatchNormPackedProgram=class BatchNormPackedProgram{constructor(F,$,V,G,H,K){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],eD.backend_util.assertAndGetBroadcastShape(F,$),eD.backend_util.assertAndGetBroadcastShape(F,V);let Z="vec4(0.0)";null!=G&&(eD.backend_util.assertAndGetBroadcastShape(F,G),this.variableNames.push("offset"),Z="getOffsetAtOutCoords()");let ee="vec4(1.0)";null!=H&&(eD.backend_util.assertAndGetBroadcastShape(F,H),this.variableNames.push("scale"),ee="getScaleAtOutCoords()"),this.outputShape=F,this.userCode=`
      void main() {
        vec4 offset = ${Z};
        vec4 scale = ${ee};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${K}));

        setOutput((x - mean) * inv + offset);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BatchNorm_batchNorm=({inputs:F,backend:$,attrs:V})=>{let{x:G,mean:H,variance:K,offset:Z,scale:ee}=F;eD.D5U.assert(H.shape.length===K.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),eD.D5U.assert(null==Z||H.shape.length===Z.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),eD.D5U.assert(null==ee||H.shape.length===ee.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:et}=V;null==et&&(et=.001);let en=[G,H,K],ea=null;null!=Z&&(ea=Z.shape,en.push(Z));let ei=null;null!=ee&&(ei=ee.shape,en.push(ee));let eo=(0,eD.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new BatchNormPackedProgram(G.shape,H.shape,K.shape,ea,ei,et):new BatchNormProgram(G.shape,H.shape,K.shape,ea,ei,et),es=$.runWebGLProgram(eo,en,en[0].dtype);return es},pJ={kernelName:eD.sHE,backendName:"webgl",kernelFunc:BatchNorm_batchNorm};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SliceProgram=class SliceProgram{constructor(F){let $;this.variableNames=["source"],this.outputShape=F,this.rank=F.length;let V=(0,cU.kW)(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let G=getCoords(this.rank),H=F.map((F,$)=>`sourceLoc.${p6[$]} = start[${$}] + coords.${p6[$]};`);$=`
        ${V} sourceLoc;
        ${V} coords = getOutputCoords();
        ${H.join("\n")}
      `,this.userCode=`
      void main() {
        ${$}
        setOutput(getSource(${G}));
      }
    `}};let p6=["x","y","z","w","u","v"];function getCoords(F){if(1===F)return"sourceLoc";if(F<=6)return p6.slice(0,F).map(F=>"sourceLoc."+F).join(",");throw Error(`Slicing for rank ${F} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SlicePackedProgram=class SlicePackedProgram{constructor(F){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=F,this.rank=F.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let $=(0,cU.kW)(this.rank),V=(0,cV.Ky)("coords",this.rank),G=(0,cV.Ky)("sourceLoc",this.rank),H=1===this.rank?"sourceLoc":`vec2(${G.slice(-2).join()})`,K=`getChannel(getSource(${G.join()}), ${H})`,Z=`
      result.x = ${K};
      if (++${V[this.rank-1]} < ${F[this.rank-1]}) {
        ++${G[this.rank-1]};
        result.y = ${K};
        --${G[this.rank-1]};
      }
    `,ee=1===this.rank?"":`
      --${V[this.rank-1]};
      if (++${V[this.rank-2]} < ${F[this.rank-2]}) {
        ++${G[this.rank-2]};
        result.z = ${K};
        if (++${V[this.rank-1]} < ${F[this.rank-1]}) {
          ++${G[this.rank-1]};
          result.w = ${K};
        }
      }
    `,et=this.rank<=4?`sourceLoc = coords +
            ${$}(${F.map((F,$)=>`start[${$}]`).join()});`:F.map((F,$)=>`${G[$]} = ${V[$]} + start[${$}];`).join("\n");this.userCode=`
      void main() {
        ${$} coords = getOutputCoords();
        ${$} sourceLoc;
        ${et}
        vec4 result = vec4(0.);
        ${Z}
        ${ee}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function shallowSlice(F,$,V,G){let H=G.texData.get(F.dataId),K=G.makeTensorInfo(V,F.dtype),Z=G.texData.get(K.dataId);Object.assign(Z,H),Z.refCount=1,Z.shape=V,Z.dtype=F.dtype;let ee=eD.kuN.computeFlatOffset($,eD.D5U.computeStrides(F.shape));H.slice&&(ee+=H.slice.flatOffset),Z.slice={flatOffset:ee,origDataId:H.slice&&H.slice.origDataId||F.dataId};let et=G.dataRefCount.get(Z.slice.origDataId)||1;return G.dataRefCount.set(Z.slice.origDataId,et+1),K}function Slice_slice(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{begin:K,size:Z}=G,[ee,et]=eD.kuN.parseSliceParams(H,K,Z);if(eD.kuN.assertParamsValid(H,ee,et),0===eD.D5U.sizeFromShape(et))return V.makeTensorInfo(et,H.dtype,[]);if(V.shouldExecuteOnCPU([H])||"string"===H.dtype){let F=V.texData.get(H.dataId),$=(0,c5.nT)(F.values,ee,et,H.shape,H.dtype);return V.makeTensorInfo(et,H.dtype,$)}let{isPacked:en}=V.texData.get(H.dataId),ea=eD.kuN.isSliceContinous(H.shape,ee,et);if(en||!ea){let F=(0,eD.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SlicePackedProgram(et):new SliceProgram(et),$=[ee];return V.runWebGLProgram(F,[H],H.dtype,$)}return V.uploadToGPU(H.dataId),shallowSlice(H,ee,et,V)}let p5={kernelName:eD.p2w,backendName:"webgl",kernelFunc:Slice_slice},BatchToSpaceND_batchToSpaceND=F=>{let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{blockShape:K,crops:Z}=G;eD.D5U.assert(H.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let ee=K.reduce((F,$)=>F*$),et=eD.backend_util.getReshaped(H.shape,K,ee),en=eD.backend_util.getPermuted(et.length,K.length),ea=eD.backend_util.getReshapedPermuted(H.shape,K,ee),ei=eD.backend_util.getSliceBeginCoords(Z,K.length),eo=eD.backend_util.getSliceSize(ea,Z,K.length),es=[],eu=kernels_Reshape_reshape({inputs:{x:H},backend:V,attrs:{shape:et}}),ec=Transpose_transpose({inputs:{x:eu},backend:V,attrs:{perm:en}}),ep=kernels_Reshape_reshape({inputs:{x:ec},backend:V,attrs:{shape:ea}}),eh=Slice_slice({inputs:{x:ep},backend:V,attrs:{begin:ei,size:eo}});return es.push(eu),es.push(ec),es.push(ep),es.forEach(F=>V.disposeIntermediateTensorInfo(F)),eh},p9={kernelName:eD.zws,backendName:"webgl",kernelFunc:BatchToSpaceND_batchToSpaceND};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bincount_bincount(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,weights:K}=$,{size:Z}=G,ee=V.readSync(H.dataId),et=V.readSync(K.dataId),en=(0,c5.qO)(ee,et,K.dtype,K.shape,Z);return V.makeTensorInfo([Z],K.dtype,en)}let p8={kernelName:eD.zvY,backendName:"webgl",kernelFunc:Bincount_bincount},p7=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,he=`
  return float(int(a.r) & int(b.r));
`;function bitwiseAnd(F){let $;let{inputs:V,backend:G}=F,{a:H,b:K}=V,Z=(0,eD.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),ee=(0,eD.OBj)().getNumber("WEBGL_VERSION");if(G.shouldExecuteOnCPU([H,K])||1===ee){let F=G.texData.get(H.dataId).values,$=G.texData.get(K.dataId).values,[V,Z]=(0,c5.XM)(H.shape,K.shape,F,$,H.dtype),ee=G.makeTensorInfo(Z,H.dtype),et=G.texData.get(ee.dataId);return et.values=V,ee}return $=Z?new BinaryOpPackedProgram(p7,H.shape,K.shape,!1):new BinaryOpProgram(he,H.shape,K.shape),G.runWebGLProgram($,[H,K],H.dtype)}let ht={kernelName:eD.hCO,backendName:"webgl",kernelFunc:bitwiseAnd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BroadcastArgs_broadcastArgs(F){let{inputs:$,backend:V}=F,{s0:G,s1:H}=$,K=V.readSync(G.dataId),Z=V.readSync(H.dataId),ee=eD.backend_util.assertAndGetBroadcastShape(Array.from(K),Array.from(Z));return V.makeTensorInfo([ee.length],"int32",Int32Array.from(ee))}let hr={kernelName:eD.eEB,backendName:"webgl",kernelFunc:BroadcastArgs_broadcastArgs},hn="return float(a != b);",ha=binaryKernelFunc({opSnippet:hn,cpuKernelImpl:c5.cZ,dtype:"bool"}),ho={kernelName:eD.yQU,backendName:"webgl",kernelFunc:ha};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real(F){let{inputs:$,backend:V}=F,{input:G}=$,H=V.texData.get(G.dataId);return Identity_identity({inputs:{x:H.complexTensorInfos.real},backend:V})}let hs={kernelName:eD.xJR,backendName:"webgl",kernelFunc:real},hu="return float(int(x));";function int_int(F,$){let V=new cJ.l(F.shape,hu),G=$.runWebGLProgram(V,[F],"int32");return{dataId:G.dataId,shape:G.shape,dtype:G.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cast_cast(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{dtype:K}=G;if("complex64"===K){if("complex64"===H.dtype)return Identity_identity({inputs:{x:H},backend:V});let F=eD.lls(H.shape),$=Cast_cast({inputs:{x:H},backend:V,attrs:{dtype:"float32"}}),G=complex({inputs:{real:$,imag:F},backend:V});return F.dispose(),V.disposeIntermediateTensorInfo($),G}if("complex64"===H.dtype){let F=real({inputs:{input:H},backend:V}),$=Cast_cast({inputs:{x:F},backend:V,attrs:{dtype:K}});return V.disposeIntermediateTensorInfo(F),$}if(!eD.D5U.hasEncodingLoss(H.dtype,K)){let F=Identity_identity({inputs:{x:H},backend:V});return{dataId:F.dataId,shape:F.shape,dtype:K}}if(V.shouldExecuteOnCPU([H])){let F=V.texData.get(H.dataId).values,[$,G,Z]=(0,c5.cm)(F,H.shape,H.dtype,K);return V.makeTensorInfo($,G,Z)}if("int32"===K)return int_int(H,V);if("bool"===K){let F=V.makeTensorInfo([],"bool",eD.D5U.getTypedArrayFromDType("bool",1)),$={a:H,b:F},G=ha({inputs:$,backend:V});return V.disposeIntermediateTensorInfo(F),G}throw Error(`Error in Cast: failed to cast ${H.dtype} to ${K}`)}let hl={kernelName:eD.RFZ,backendName:"webgl",kernelFunc:Cast_cast},hc="return ceil(x);",hp=unaryKernelFunc({opSnippet:hc,packedOpSnippet:hc,cpuKernelImpl:c5.pk}),hh={kernelName:eD.gJX,backendName:"webgl",kernelFunc:hp};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ClipProgram=class ClipProgram{constructor(F){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=F,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ClipPackedProgram=class ClipPackedProgram{constructor(F){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=F,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ClipByValue_clipByValue(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V,{clipValueMin:Z,clipValueMax:ee}=H;$=(0,eD.OBj)().getBool("WEBGL_PACK_CLIP")?new ClipPackedProgram(K.shape):new ClipProgram(K.shape);let et=[[Z],[ee]];return G.runWebGLProgram($,[K],K.dtype,et)}let hf={kernelName:eD.xnO,backendName:"webgl",kernelFunc:ClipByValue_clipByValue};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ComplexAbsProgram=class ComplexAbsProgram{constructor(F){this.variableNames=["real","imag"],this.outputShape=F,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeComplexComponentTensorInfo(F,$){return{dataId:$.dataId,dtype:$.dtype,shape:F.shape}}function ComplexAbs_complexAbs(F){let{inputs:$,backend:V}=F,{x:G}=$,H=V.texData.get(G.dataId),K=new ComplexAbsProgram(G.shape),Z=[makeComplexComponentTensorInfo(G,H.complexTensorInfos.real),makeComplexComponentTensorInfo(G,H.complexTensorInfos.imag)];return V.runWebGLProgram(K,Z,Z[0].dtype)}let hd={kernelName:eD.yj2,backendName:"webgl",kernelFunc:ComplexAbs_complexAbs};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ConcatProgram=class ConcatProgram{constructor(F){this.outputShape=[],this.outputShape=eD.backend_util.computeOutShape(F,1),this.variableNames=F.map((F,$)=>`T${$}`);let $=Array(F.length-1);$[0]=F[0][1];for(let V=1;V<$.length;V++)$[V]=$[V-1]+F[V][1];let V=[`if (yC < ${$[0]}) setOutput(getT0(yR, yC));`];for(let F=1;F<$.length;F++){let G=$[F-1];V.push(`else if (yC < ${$[F]}) setOutput(getT${F}(yR, yC-${G}));`)}let G=$.length,H=$[$.length-1];V.push(`else setOutput(getT${G}(yR, yC-${H}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${V.join("\n        ")}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ConcatPackedProgram=class ConcatPackedProgram{constructor(F,$){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=eD.backend_util.computeOutShape(F,$);let V=this.outputShape,G=V.length,H=(0,cU.kW)(G),K=(0,cV.Ky)("coords",G),Z=["x","y","z","w","u","v"].slice(0,G);this.variableNames=F.map((F,$)=>`T${$}`);let ee=Array(F.length-1);ee[0]=F[0][$];for(let V=1;V<ee.length;V++)ee[V]=ee[V-1]+F[V][$];let et=Z[$],en=Z.slice(-2),ea=Z.join(),ei=`if (${et} < ${ee[0]}) {
        return getChannel(
            getT0(${ea}), vec2(${en.join()}));
        }`;for(let F=1;F<ee.length;F++){let $=ee[F-1];ei+=`
        if (${et} < ${ee[F]}  && ${et} >= ${ee[F-1]}) {
          return getChannel(
            getT${F}(${shiftedChannels(Z,et,$)}),
            vec2(${shiftedChannels(en,et,$)}));
        }`}let eo=ee.length,es=ee[ee.length-1];ei+=`
        return getChannel(
          getT${eo}(${shiftedChannels(Z,et,es)}),
          vec2(${shiftedChannels(en,et,es)}));`,this.userCode=`
      float getValue(${Z.map(F=>"int "+F)}) {
        ${ei}
      }

      void main() {
        ${H} coords = getOutputCoords();
        vec4 result = vec4(getValue(${K}), 0., 0., 0.);

        ${K[G-1]} = ${K[G-1]} + 1;
        if (${K[G-1]} < ${V[G-1]}) {
          result.g = getValue(${K});
        }

        ${K[G-2]} = ${K[G-2]} + 1;
        if (${K[G-2]} < ${V[G-2]}) {
          result.a = getValue(${K});
        }

        ${K[G-1]} = ${K[G-1]} - 1;
        if (${K[G-2]} < ${V[G-2]} &&
            ${K[G-1]} < ${V[G-1]}) {
          result.b = getValue(${K});
        }
        setOutput(result);
      }
    `}};function shiftedChannels(F,$,V){let G=F.indexOf($),H=F.map((F,$)=>$===G?`${F} - ${V}`:F);return H.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Imag_imag(F){let{inputs:$,backend:V}=F,{input:G}=$,H=V.texData.get(G.dataId);return Identity_identity({inputs:{x:H.complexTensorInfos.imag},backend:V})}let hm={kernelName:eD.J_u,backendName:"webgl",kernelFunc:Imag_imag};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concatImpl(F,$,V){let G=F[0].dtype;if("complex64"===G){let G=F.map(F=>real({inputs:{input:F},backend:V})),H=F.map(F=>Imag_imag({inputs:{input:F},backend:V})),K=concatImpl(G,$,V),Z=concatImpl(H,$,V),ee=complex({inputs:{real:K,imag:Z},backend:V});return G.forEach(F=>V.disposeIntermediateTensorInfo(F)),H.forEach(F=>V.disposeIntermediateTensorInfo(F)),V.disposeIntermediateTensorInfo(K),V.disposeIntermediateTensorInfo(Z),ee}let H=V.shouldExecuteOnCPU(F);if("string"===G&&(H=!0),H){let H=F.map(F=>{let G=eD.D5U.sizeFromShape(F.shape.slice($)),H=[-1,G];return kernels_Reshape_reshape({inputs:{x:F},backend:V,attrs:{shape:H}})}),K=H.map(F=>({vals:V.readSync(F.dataId),shape:F.shape})),Z=eD.backend_util.computeOutShape(H.map(F=>F.shape),1),ee=1===H[0].shape[0],et=(0,c5.n7)(K,Z,G,ee),en=eD.backend_util.computeOutShape(F.map(F=>F.shape),$),ea=V.makeTensorInfo(en,G,et);return H.forEach(F=>V.disposeIntermediateTensorInfo(F)),ea}let K=F.filter(F=>eD.D5U.sizeFromShape(F.shape)>0),Z=(0,eD.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&K[0].shape.length>1;if(1===K.length){let $=Z?new cJ.l(F[0].shape,cJ.bl):new c3.cc(F[0].shape,cJ.bl);return V.runWebGLProgram($,F,G)}let ee=(0,eD.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(K.length>ee){let F=[];for(let G=0;G<K.length;G+=ee){let H=K.slice(G,G+ee);F.push(concatImpl(H,$,V))}let G=concatImpl(F,$,V);for(let $ of F)V.disposeIntermediateTensorInfo($);return G}if(Z){let F=new ConcatPackedProgram(K.map(F=>F.shape),$);return V.runWebGLProgram(F,K,G)}let{tensors2D:et,outShape:en}=computeTensors2D(K,$,V),ea=new ConcatProgram(et.map(F=>F.shape)),ei=V.runWebGLProgram(ea,et,G);et.forEach(F=>V.disposeIntermediateTensorInfo(F));let eo=kernels_Reshape_reshape({inputs:{x:ei},attrs:{shape:en},backend:V});return V.disposeIntermediateTensorInfo(ei),eo}function computeTensors2D(F,$,V){let G=eD.backend_util.computeOutShape(F.map(F=>F.shape),$),H=F.map(F=>kernels_Reshape_reshape({inputs:{x:F},attrs:{shape:[-1,eD.D5U.sizeFromShape(F.shape.slice($))]},backend:V}));return{tensors2D:H,outShape:G}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Concat_concat(F){let{inputs:$,backend:V,attrs:G}=F,{axis:H}=G,K=eD.D5U.parseAxisParam(H,$[0].shape)[0],Z=$.map(F=>F.shape);eD.backend_util.assertParamsConsistent(Z,K);let ee=eD.backend_util.computeOutShape($.map(F=>F.shape),K);if(0===eD.D5U.sizeFromShape(ee))return V.makeTensorInfo(ee,$[0].dtype,[]);let et=$.filter(F=>eD.D5U.sizeFromShape(F.shape)>0);return 1===et.length?Identity_identity({inputs:{x:et[0]},backend:V}):concatImpl(et,K,V)}let hg={kernelName:eD.Eh3,backendName:"webgl",kernelFunc:kernels_Concat_concat};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv2DProgram=class Conv2DProgram{constructor(F,$=!1,V=null,G=!1,H=!1){this.variableNames=["x","W"],this.outputShape=F.outShape;let K=F.padInfo.top,Z=F.padInfo.left,ee=F.strideHeight,et=F.strideWidth,en=F.dilationHeight,ea=F.dilationWidth,ei=F.filterHeight,eo=F.filterWidth,es=4*Math.floor(F.inChannels/4),eu=F.inChannels%4,ec="channelsLast"===F.dataFormat,ep=ec?1:2,eh=ec?2:3,ef=ec?3:1,ed="",em="";V&&(ed=G?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${V}
        }`:H?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${V}
        }`:`
          float activation(float x) {
            ${V}
          }
        `,em="result = activation(result);");let eg=$?"result += getBiasAtOutCoords();":"";$&&this.variableNames.push("bias"),G&&this.variableNames.push("preluActivationWeights"),H&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${ed}

      const ivec2 strides = ivec2(${ee}, ${et});
      const ivec2 pads = ivec2(${K}, ${Z});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${ef}];

        ivec2 xRCCorner =
            ivec2(coords[${ep}], coords[${eh}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${ei}; wR++) {
          int xR = xRCorner + wR * ${en};

          if (xR < 0 || xR >= ${F.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${eo}; wC++) {
            int xC = xCCorner + wC * ${ea};

            if (xC < 0 || xC >= ${F.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${es}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${ec}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${1===eu}) {

              if (${ec}) {
                dotProd +=
                    getX(batch, xR, xC, ${es}) *
                    getW(wR, wC, ${es}, d2);
              } else {
                dotProd +=
                    getX(batch, ${es}, xR, xC) *
                    getW(wR, wC, ${es}, d2);
              }

            } else if (${2===eu}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${es}, d2),
                getW(wR, wC, ${es} + 1, d2)
              );

              if (${ec}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${es}),
                  getX(batch, xR, xC, ${es} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${es}, xR, xC),
                  getX(batch, ${es} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${3===eu}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${es}, d2),
                getW(wR, wC, ${es} + 1, d2),
                getW(wR, wC, ${es} + 2, d2)
              );

              if (${ec}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${es}),
                  getX(batch, xR, xC, ${es} + 1),
                  getX(batch, xR, xC, ${es} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${es}, xR, xC),
                  getX(batch, ${es} + 1, xR, xC),
                  getX(batch, ${es} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${eg}
        ${em}
        setOutput(result);
      }
    `}};let Conv3DProgram=class Conv3DProgram{constructor(F){this.variableNames=["x","W"],this.outputShape=F.outShape;let $=F.padInfo.front,V=F.padInfo.top,G=F.padInfo.left,H=F.strideDepth,K=F.strideHeight,Z=F.strideWidth,ee=F.dilationDepth,et=F.dilationHeight,en=F.dilationWidth,ea=F.filterDepth,ei=F.filterHeight,eo=F.filterWidth,es=4*Math.floor(F.inChannels/4),eu=F.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${H}, ${K}, ${Z});
      const ivec3 pads = ivec3(${$}, ${V}, ${G});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${ea}; wF++) {
          int xF = xFCorner + wF * ${ee};

          if (xF < 0 || xF >= ${F.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${ei}; wR++) {
            int xR = xRCorner + wR * ${et};

            if (xR < 0 || xR >= ${F.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${eo}; wC++) {
              int xC = xCCorner + wC * ${en};

              if (xC < 0 || xC >= ${F.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${es}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${1===eu}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${es}) *
                  getW(wF, wR, wC, ${es}, d2);
              } else if (${2===eu}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${es}),
                  getX(batch, xF, xR, xC, ${es} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${es}, d2),
                  getW(wF, wR, wC, ${es} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${3===eu}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${es}),
                  getX(batch, xF, xR, xC, ${es} + 1),
                  getX(batch, xF, xR, xC, ${es} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${es}, d2),
                  getW(wF, wR, wC, ${es} + 1, d2),
                  getW(wF, wR, wC, ${es} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv2DPackedProgram=class Conv2DPackedProgram{constructor(F,$=!1,V=null,G=!1,H=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=F.outShape,this.enableShapeUniforms=(0,cL.C9)(this.outputShape.length);let K=F.padInfo.left,Z=F.strideWidth,ee=F.dilationWidth,et=F.filterHeight,en=F.filterWidth,ea=en,ei=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let F=0;F<en;F++)ei+=`
           vec4 xTexelC${2*F};
           int xTexelC${2*F}Ready;
           vec4 xTexelC${2*F+1};
           int xTexelC${2*F+1}Ready;
           vec4 xC${F};`;ei+=`
     for (int r = 0; r < ${et}; r++) {
      for (int d1 = 0; d1 < ${F.inChannels}; d1 += 2) {
       `;for(let F=0;F<en;F++)ei+=`
           xTexelC${2*F} = vec4(0.0);
           xTexelC${2*F}Ready = 0;
           xTexelC${2*F+1} = vec4(0.0);
           xTexelC${2*F+1}Ready = 0;
           xC${F} = vec4(0.0);`;ei+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let $=0;$<(ea+1)/2;$++){let V=2*$;if(ei+=`
           xC = xCCorner + ${V*ee};
           `,1===Z){if(V<en&&(K%2==1?(ei+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${V}Ready == 0) {
                   xTexelC${V} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${V}.zw = vec2(0.0);
                   }
                   xTexelC${V}Ready = 1;
                 }
               `,1===ee&&V>0?ei+=`
                 xC${V} = vec4(xTexelC${V-2}.zw, xTexelC${V}.xy);
                 `:ei+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${V} = vec4(previous.zw, xTexelC${V}.xy);
                   } else {
                     xC${V} = vec4(0.0, 0.0, xTexelC${V}.xy);
                   }
                   `):ei+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${V}Ready == 0) {
                   xTexelC${V} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${V}.zw = vec2(0.0);
                   }
                   xTexelC${V}Ready = 1;
                 }

                 xC${V} = xTexelC${V};
                 `,V+1<en)){let F=K%2==0?eD.D5U.nearestLargerEven(ee):ee;ee%2==0&&K%2==1||ee%2!=0&&K%2!=1?(ei+=`
                   xCOffset = xC + imod(pads[1], 2) + ${F};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${V+1}Ready == 0) {
                     xTexelC${V+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${V+1}.zw = vec2(0.0);
                     }
                     xTexelC${V+1}Ready = 1;
                   }
                   `,ee>1?ei+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${V+1} = vec4(previous.zw, xTexelC${V+1}.xy);
                     } else {
                      xC${V+1} = vec4(0.0, 0.0, xTexelC${V+1}.xy);
                     }
                     `:ei+=`
                     xC${V+1} = vec4(xTexelC${V}.zw, xTexelC${V+1}.xy);
                     `):1===F?ei+=`
                     xC${V+1} = xTexelC${V};
                     `:ei+=`
                     xCOffset = xC + ${F};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${V+1}Ready == 0) {
                       xTexelC${V+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${V+1}.zw = vec2(0.0);
                       }
                       xTexelC${V+1}Ready = 1;
                     }

                     xC${V+1} = xTexelC${V+1};
                     `}}else V<en&&(K%2==1?(ei+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${V}Ready == 0) {
                   xTexelC${V} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${V}.zw = vec2(0.0);
                   }
                   xTexelC${V}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${V+1}Ready == 0) {
                   xTexelC${V+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${V+1}.zw = vec2(0.0);
                   }
                   xTexelC${V+1}Ready = 1;
                 }

                 xC${V} = vec4(xTexelC${V}.zw, xTexelC${V+1}.zw);
               `,V+1<en&&(ei+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${V+1} = vec4(xTexelC${V+1}.xy, final.xy);
                 `)):(ei+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${V}Ready == 0) {
                   xTexelC${V} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${V}.zw = vec2(0.0);
                   }
                   xTexelC${V}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${V+1}Ready == 0) {
                   xTexelC${V+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${V+1}.zw = vec2(0.);
                   }
                   xTexelC${V+1}Ready = 1;
                 }

                 xC${V} = vec4(
                   xTexelC${V}.xy, xTexelC${V+1}.xy);
               `,V+1<en&&(ei+=`
                   xC${V+1} = vec4(xTexelC${V}.zw, xTexelC${V+1}.zw);
                 `)));V<en&&(ei+=`
             wTexel = getW(r, ${V}, d1, d2);
             dotProd += xC${V}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${F.inChannels}) {
               dotProd += xC${V}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,V+1<en&&(ei+=`
               wTexel = getW(r, ${V+1}, d1, d2);
               dotProd += xC${V+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${F.inChannels}) {
                 dotProd += xC${V+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}ei+=`
     }
   
     }
   
     }
   `;let eo="",es="";V&&(eo=G?`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${V}
         }`:H?`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${V}
         }`:`vec4 activation(vec4 x) {
           ${V}
         }`,es="result = activation(result);");let eu=$?"result += getBiasAtOutCoords();":"";$&&this.variableNames.push("bias"),G&&this.variableNames.push("preluActivationWeights"),H&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${eo}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${ei}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${eu}
         ${es}
         setOutput(result);
       }
     `}};var hy=V(29610);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Im2ColPackedProgram=class Im2ColPackedProgram{constructor(F,$){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=F,this.enableShapeUniforms=(0,cL.C9)(this.outputShape.length);let{dataFormat:V}=$,G=(0,hy.A)(),H="channelsLast"===V,K=H?1:2,Z=H?2:3,ee=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${F[2]} && pos < ${F[1]}) {`,et="";for(let F=0;F<=1;F++)for(let $=0;$<=1;$++)et+=`
          blockIndex = rc.z + ${$};
          pos = rc.y + ${F};

          ${ee}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${K}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${Z}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${H}) {
                  innerDims = vec2(d1, ch);
                  result[${2*F+$}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${2*F+$}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${et}

        ${G.output} = result;
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getShapeForBatchMatMul(F,$){let V=F.length;return V>=3?$?[...F.slice(0,-3),F[V-3]*F[V-2],F[V-1]]:[...F.slice(0,-3),F[V-3],F[V-2]*F[V-1]]:!$&&1===V&&F[0]>1?[F[0],1]:null}function conv2dByMatMul({x:F,filter:$,convInfo:V,backend:G,bias:H=null,preluActivationWeights:K=null,leakyreluAlpha:Z=0,activation:ee=null}){let et;let en=F.shape,ea=G.texData.get(F.dataId),ei=V.inChannels,eo=en[0]*en[1]*en[2],es=V.outChannels,eu="channelsLast"===V.dataFormat,ec=!1,ep=!1,eh=[];if(null!=K){let F=getShapeForBatchMatMul(K.shape,eu);null!=F&&(K=kernels_Reshape_reshape({inputs:{x:K},backend:G,attrs:{shape:F}}),eh.push(K))}if(null!=H){let F=getShapeForBatchMatMul(H.shape,eu);null!=F&&(H=kernels_Reshape_reshape({inputs:{x:H},backend:G,attrs:{shape:F}}),eh.push(H))}let ef=(1===eo||1===es)&&ei>pl,ed=!ef&&ea.isPacked&&eu&&null!=ea.texture&&en[2]%2!=0&&eD.D5U.arraysEqual(ea.shape.slice(-3),en.slice(-3));if(ed){let ei=en[0]*en[1]*(en[2]+1),eo={dataId:F.dataId,shape:[1,ei,V.inChannels],dtype:F.dtype},es=ea.shape;ea.shape=ea.shape.slice(),ea.shape[ea.shape.length-2]++,eD.D5U.assert(cO.isReshapeFree(ea.shape,eo.shape),()=>`packed reshape ${ea.shape} to ${eo.shape} isn't free`);let eu=kernels_Reshape_reshape({inputs:{x:$},backend:G,attrs:{shape:[1,V.inChannels,V.outChannels]}});eh.push(eu);let ef=batchMatMulImpl({a:eo,b:eu,backend:G,transposeA:ec,transposeB:ep,bias:H,activation:ee,preluActivationWeights:K,leakyreluAlpha:Z}),ed=G.texData.get(ef.dataId);eD.D5U.assert(ed.isPacked,()=>"batchMatMul result is expected to be packed"),ea.shape=es,ed.shape=V.outShape,(et=Identity_identity({inputs:{x:ef},backend:G})).shape=V.outShape,eh.push(ef)}else{let en=V.outHeight*V.outWidth,ea=kernels_Reshape_reshape({inputs:{x:F},backend:G,attrs:{shape:eu?[V.batchSize,en,V.inChannels]:[V.batchSize,V.inChannels,en]}}),ei=kernels_Reshape_reshape({inputs:{x:$},backend:G,attrs:{shape:[1,V.inChannels,V.outChannels]}}),eo=batchMatMulImpl({a:eu?ea:ei,b:eu?ei:ea,transposeA:!eu,transposeB:ep,backend:G,bias:H,activation:ee,preluActivationWeights:K,leakyreluAlpha:Z});et=kernels_Reshape_reshape({inputs:{x:eo},backend:G,attrs:{shape:V.outShape}}),eh.push(ea),eh.push(ei),eh.push(eo)}for(let F of eh)G.disposeIntermediateTensorInfo(F);return et}function conv2dWithIm2Row({x:F,filter:$,convInfo:V,backend:G,bias:H=null,preluActivationWeights:K=null,leakyreluAlpha:Z=0,activation:ee=null}){let{filterWidth:et,filterHeight:en,inChannels:ea,outWidth:ei,outHeight:eo,dataFormat:es}=V,eu="channelsLast"===es,ec=et*en*ea,ep=eo*ei,eh=[V.batchSize,ec,ep],ef=!0,ed=!1,em=[];if(null!=K){let F=getShapeForBatchMatMul(K.shape,eu);null!=F&&(K=kernels_Reshape_reshape({inputs:{x:K},backend:G,attrs:{shape:F}}),em.push(K))}if(null!=H){let F=getShapeForBatchMatMul(H.shape,eu);null!=F&&(H=kernels_Reshape_reshape({inputs:{x:H},backend:G,attrs:{shape:F}}),em.push(H))}let eg=kernels_Reshape_reshape({inputs:{x:$},backend:G,attrs:{shape:[1,ec,eD.D5U.sizeFromShape($.shape)/ec]}});em.push(eg);let ey=new Im2ColPackedProgram(eh,V),eb=[F.shape,[V.padInfo.top,V.padInfo.left],[V.strideHeight,V.strideWidth],[V.dilationHeight,V.dilationWidth],[V.inChannels],[V.filterWidth*V.inChannels],[V.outWidth]],ew=G.runWebGLProgram(ey,[F],"float32",eb),eS=kernels_Reshape_reshape({inputs:{x:ew},backend:G,attrs:{shape:eh}});em.push(ew),em.push(eS);let e_=null!=H,eN=null!=K,ek="leakyrelu"===ee,eI=ee?mapActivationToShaderProgram(ee,!0):null,eT=new MatMulPackedProgram(eu?eS.shape:eg.shape,eu?eg.shape:eS.shape,eu?[V.batchSize,ep,V.outChannels]:[V.batchSize,V.outChannels,ep],ef,ed,e_,eI,eN,ek),eC=eu?[eS,eg]:[eg,eS];if(H&&eC.push(H),eN&&eC.push(K),ek){let F=G.makeTensorInfo([],"float32",eD.D5U.createScalarValue(Z,"float32"));eC.push(F),em.push(F)}let eE=G.runWebGLProgram(eT,eC,"float32"),eA=kernels_Reshape_reshape({inputs:{x:eE},backend:G,attrs:{shape:V.outShape}});for(let F of(em.push(eE),em))G.disposeIntermediateTensorInfo(F);return eA}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Conv2D_conv2d(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K,filter:Z}=V,{strides:ee,pad:et,dataFormat:en,dilations:ea,dimRoundingMode:ei}=H,eo=eD.backend_util.convertConv2DDataFormat(en),es=eD.backend_util.computeConv2DInfo(K.shape,Z.shape,ee,ea,et,ei,!1,eo);if(1===es.filterHeight&&1===es.filterWidth&&1===es.dilationHeight&&1===es.dilationWidth&&1===es.strideHeight&&1===es.strideWidth&&("SAME"===es.padInfo.type||"VALID"===es.padInfo.type))$=conv2dByMatMul({x:K,filter:Z,convInfo:es,backend:G});else if(es.strideWidth<=2&&"channelsLast"===eo&&(0,eD.OBj)().getBool("WEBGL_EXP_CONV")){let F=new Conv2DPackedProgram(es),V=[[es.padInfo.top,es.padInfo.left],[es.strideHeight,es.strideWidth],[es.dilationHeight,es.dilationWidth],[es.inHeight,es.inWidth]];$=G.runWebGLProgram(F,[K,Z],"float32",V)}else if((0,eD.OBj)().getBool("WEBGL_CONV_IM2COL"))$=conv2dWithIm2Row({x:K,filter:Z,convInfo:es,backend:G});else{let F=new Conv2DProgram(es);$=G.runWebGLProgram(F,[K,Z],"float32")}let eu=kernels_Reshape_reshape({inputs:{x:$},backend:G,attrs:{shape:es.outShape}});return G.disposeIntermediateTensorInfo($),eu}let hb={kernelName:eD.mhS,backendName:"webgl",kernelFunc:Conv2D_conv2d};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv2DDerFilterProgram=class Conv2DDerFilterProgram{constructor(F){this.variableNames=["x","dy"],this.outputShape=F.filterShape;let $=F.strideHeight,V=F.strideWidth,G=F.padInfo.top,H=F.padInfo.left,K="channelsLast"===F.dataFormat;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${F.batchSize}; b++) {
          for (int yR = 0; yR < ${F.outHeight}; yR++) {
            int xR = wR + yR * ${$} - ${G};

            if (xR < 0 || xR >= ${F.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${F.outWidth}; yC++) {
              int xC = wC + yC * ${V} - ${H};

              if (xC < 0 || xC >= ${F.inWidth}) {
                continue;
              }

              ${K?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}};let Conv2DDerInputProgram=class Conv2DDerInputProgram{constructor(F){this.variableNames=["dy","W"],this.outputShape=F.inShape;let $=F.filterHeight,V=F.filterWidth,G=F.strideHeight,H=F.strideWidth,K="channelsLast"===F.dataFormat,Z=$-1-F.padInfo.top,ee=V-1-F.padInfo.left,et=K?1:2,en=K?2:3,ea=K?3:1;this.userCode=`
      const ivec2 pads = ivec2(${Z}, ${ee});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${ea}];

        ivec2 dyCorner = ivec2(coords[${et}], coords[${en}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${$}; wR++) {
          float dyR = float(dyRCorner + wR) / ${G}.0;

          if (dyR < 0.0 || dyR >= ${F.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${$} - 1 - wR;

          for (int wC = 0; wC < ${V}; wC++) {
            float dyC = float(dyCCorner + wC) / ${H}.0;

            if (dyC < 0.0 || dyC >= ${F.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${V} - 1 - wC;

            for (int d2 = 0; d2 < ${F.outChannels}; d2++) {

              if (${K}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}};let Conv3DDerFilterProgram=class Conv3DDerFilterProgram{constructor(F){this.variableNames=["x","dy"],this.outputShape=F.filterShape;let $=F.strideDepth,V=F.strideHeight,G=F.strideWidth,H=F.padInfo.front,K=F.padInfo.top,Z=F.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${F.batchSize}; b++) {
          for (int yF = 0; yF < ${F.outDepth}; yF++) {
            int xF = wF + yF * ${$} - ${H};

            if (xF < 0 || xF >= ${F.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${F.outHeight}; yR++) {
              int xR = wR + yR * ${V} - ${K};

              if (xR < 0 || xR >= ${F.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${F.outWidth}; yC++) {
                int xC = wC + yC * ${G} - ${Z};

                if (xC < 0 || xC >= ${F.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};let Conv3DDerInputProgram=class Conv3DDerInputProgram{constructor(F){this.variableNames=["dy","W"],this.outputShape=F.inShape;let $=F.filterDepth,V=F.filterHeight,G=F.filterWidth,H=F.strideDepth,K=F.strideHeight,Z=F.strideWidth,ee=$-1-F.padInfo.front,et=V-1-F.padInfo.top,en=G-1-F.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${ee}, ${et}, ${en});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${$}; wF++) {
          float dyF = float(dyFCorner + wF) / ${H}.0;

          if (dyF < 0.0 || dyF >= ${F.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${$} - 1 - wF;

          for (int wR = 0; wR < ${V}; wR++) {
            float dyR = float(dyRCorner + wR) / ${K}.0;

            if (dyR < 0.0 || dyR >= ${F.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${V} - 1 - wR;

            for (int wC = 0; wC < ${G}; wC++) {
              float dyC = float(dyCCorner + wC) / ${Z}.0;

              if (dyC < 0.0 || dyC >= ${F.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${G} - 1 - wC;

              for (int d2 = 0; d2 < ${F.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Conv2DBackpropFilter_conv2DBackpropFilter(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,dy:K}=$,{strides:Z,pad:ee,dataFormat:et,dimRoundingMode:en,filterShape:ea}=G,ei=eD.backend_util.convertConv2DDataFormat(et),eo=eD.backend_util.computeConv2DInfo(H.shape,ea,Z,1,ee,en,!1,ei),es=new Conv2DDerFilterProgram(eo);return V.runWebGLProgram(es,[H,K],"float32")}let hx={kernelName:eD.wUP,backendName:"webgl",kernelFunc:Conv2DBackpropFilter_conv2DBackpropFilter};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv2DDerInputPackedProgram=class Conv2DDerInputPackedProgram{constructor(F){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=F.inShape,this.enableShapeUniforms=(0,cL.C9)(this.outputShape.length);let $=F.filterHeight,V=F.filterWidth,G=$-1-F.padInfo.top,H=V-1-F.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${G}, ${H});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${$}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${F.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${$} - 1 - wR;

          for (int wC = 0; wC < ${V}; wC++) {
            int wCPerm = ${V} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${F.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${F.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${F.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${F.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${F.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Conv2DBackpropInput_conv2DBackpropInput(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,filter:K}=$,{inputShape:Z,strides:ee,pad:et,dataFormat:en,dimRoundingMode:ea}=G,ei=eD.backend_util.convertConv2DDataFormat(en),eo=eD.backend_util.computeConv2DInfo(Z,K.shape,ee,1,et,ea,!1,ei);if((0,eD.OBj)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===ei){let F=[[eo.strideHeight,eo.strideWidth]],$=new Conv2DDerInputPackedProgram(eo);return V.runWebGLProgram($,[H,K],"float32",F)}{let F=new Conv2DDerInputProgram(eo);return V.runWebGLProgram(F,[H,K],"float32")}}let hv={kernelName:eD.wm,backendName:"webgl",kernelFunc:Conv2DBackpropInput_conv2DBackpropInput};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Conv3D_conv3D(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,filter:K}=$,{strides:Z,pad:ee,dilations:et}=G,en=eD.backend_util.computeConv3DInfo(H.shape,K.shape,Z,et,ee),ea=new Conv3DProgram(en);return V.runWebGLProgram(ea,[H,K],"float32")}let hw={kernelName:eD.x12,backendName:"webgl",kernelFunc:Conv3D_conv3D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Conv3DBackpropFilterV2_conv3DBackpropFilterV2(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,dy:K}=$,{strides:Z,pad:ee,filterShape:et}=G,en=eD.backend_util.computeConv3DInfo(H.shape,et,Z,1,ee),ea=new Conv3DDerFilterProgram(en);return V.runWebGLProgram(ea,[H,K],"float32")}let hS={kernelName:eD.o2y,backendName:"webgl",kernelFunc:Conv3DBackpropFilterV2_conv3DBackpropFilterV2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropInput(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,filter:K}=$,{pad:Z,strides:ee,inputShape:et}=G,en=eD.backend_util.computeConv3DInfo(et,K.shape,ee,1,Z),ea=new Conv3DDerInputProgram(en);return V.runWebGLProgram(ea,[H,K],"float32")}let h_={kernelName:eD.ik2,backendName:"webgl",kernelFunc:conv3DBackpropInput},hN=c4+`
  return cos(x);
`,hk=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${cW}
  return result;
`,hT=unaryKernelFunc({opSnippet:hN,packedOpSnippet:hk}),hE={kernelName:eD.mc4,backendName:"webgl",kernelFunc:hT},hA=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,hD=unaryKernelFunc({opSnippet:hA}),hM={kernelName:eD.TR1,backendName:"webgl",kernelFunc:hD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let CropAndResizeProgram=class CropAndResizeProgram{constructor(F,$,V,G,H){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[K,Z,ee,et]=F,[en]=$,[ea,ei]=V;this.outputShape=[en,ea,ei,et];let eo="bilinear"===G?1:0,[es,eu]=[`${Z-1}.0`,`${ee-1}.0`],[ec,ep,eh]=ea>1?[`${(Z-1)/(ea-1)}`,"(y2-y1) * height_ratio",`y1*${es} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${es}`],[ef,ed,em]=ei>1?[`${(ee-1)/(ei-1)}`,"(x2-x1) * width_ratio",`x1*${eu} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${eu}`];this.userCode=`
      const float height_ratio = float(${ec});
      const float width_ratio = float(${ef});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${K}) {
          return;
        }

        float height_scale = ${ep};
        float width_scale = ${ed};

        float in_y = ${eh};
        if( in_y < 0.0 || in_y > ${es} ) {
          setOutput(float(${H}));
          return;
        }
        float in_x = ${em};
        if( in_x < 0.0 || in_x > ${eu} ) {
          setOutput(float(${H}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${eo} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let CropAndResize_cropAndResize=F=>{let{inputs:$,backend:V,attrs:G}=F,{image:H,boxes:K,boxInd:Z}=$,{cropSize:ee,method:et,extrapolationValue:en}=G,ea=new CropAndResizeProgram(H.shape,K.shape,ee,et,en);return V.runWebGLProgram(ea,[H,K,Z],"float32")},hR={kernelName:eD.VcC,backendName:"webgl",kernelFunc:CropAndResize_cropAndResize};!function(F){F.Prod="*",F.Sum="+"}(ee||(ee={}));let CumProgram=class CumProgram{constructor(F,$,V,G){this.op=F,this.outputShape=$,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let H=this.outputShape.length,K=this.op===ee.Prod?"1.0":"0.0",Z=V?K:`getX(${cum_gpu_getCoords(H,"coords",this.op)})`,et=this.outputShape[this.outputShape.length-1],en="",ea="";V?(en=G?`end != ${et-1}`:"end != 0",ea=G?"end + 1":"end - 1"):(en=G?`end + pow2 < ${et}`:"end >= pow2",ea=G?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${(0,cU.kW)(H)} coords = getOutputCoords();
        int end = ${getFinalCoord(H,"coords",this.op)};
        float val = ${Z};
        int pow2 = int(pow(2.0, index));
        if (${en}) {
          int idx = ${ea};
          ${getFinalCoord(H,"coords",this.op)} = idx;
          val ${this.op}= getX(${cum_gpu_getCoords(H,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function cum_gpu_getCoords(F,$,V){if(1===F)return`${$}`;if(2===F)return`${$}.x, ${$}.y`;if(3===F)return`${$}.x, ${$}.y, ${$}.z`;if(4===F)return`${$}.x, ${$}.y, ${$}.z, ${$}.w`;throw Error(`Cumulative ${V} for rank ${F} is not yet supported`)}function getFinalCoord(F,$,V){if(1===F)return`${$}`;if(2===F)return`${$}.y`;if(3===F)return`${$}.z`;if(4===F)return`${$}.w`;throw Error(`Cumulative ${V} for rank ${F} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumImpl(F,$,V,G,H,K){let Z=$.shape.length,ee=eD.backend_util.getAxesPermutation([G],Z),et=$;null!=ee&&(et=Transpose_transpose({inputs:{x:$},backend:V,attrs:{perm:ee}}));let en=eD.backend_util.getInnerMostAxes(1,Z)[0];if(en!==Z-1)throw Error(`WebGL cumprod shader expects an inner-most axis=${$.shape.length-1} but got axis=${G}`);let ea=et.shape[en],ei=Identity_identity({inputs:{x:et},backend:V});for(let $=0;$<=Math.ceil(Math.log2(ea))-1;$++){let G=new CumProgram(F,et.shape,!1,K),H=[[$]],Z=ei;ei=V.runWebGLProgram(G,[ei],ei.dtype,H),V.disposeIntermediateTensorInfo(Z)}if(H){let $=new CumProgram(F,et.shape,H,K),G=ei;ei=V.runWebGLProgram($,[ei],ei.dtype),V.disposeIntermediateTensorInfo(G)}if(null!=ee){let F=eD.backend_util.getUndoAxesPermutation(ee),$=Transpose_transpose({inputs:{x:ei},backend:V,attrs:{perm:F}});return V.disposeIntermediateTensorInfo(ei),V.disposeIntermediateTensorInfo(et),$}return ei}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Cumprod_cumprod(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K,exclusive:Z,reverse:et}=G;return cumImpl(ee.Prod,H,V,K,Z,et)}let hP={kernelName:eD.Byc,backendName:"webgl",kernelFunc:kernels_Cumprod_cumprod};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Cumsum_cumsum(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{axis:K,exclusive:Z,reverse:et}=G;return cumImpl(ee.Sum,H,V,K,Z,et)}let hB={kernelName:eD.iHb,backendName:"webgl",kernelFunc:kernels_Cumsum_cumsum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DenseBincount_denseBincount(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,weights:K}=$,{size:Z,binaryOutput:ee}=G;if(1===H.shape.length){let F=V.readSync(H.dataId),$=V.readSync(K.dataId),G=(0,c5.qO)(F,$,K.dtype,K.shape,Z);return V.makeTensorInfo([Z],K.dtype,G)}if(2===H.shape.length){let F=V.bufferSync(H),$=V.bufferSync(K),G=(0,c5.cx)(F,$,Z,ee);return V.makeTensorInfo(G.shape,K.dtype,G.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${H.shape.length}.`)}let h$={kernelName:eD.QRR,backendName:"webgl",kernelFunc:DenseBincount_denseBincount};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthToSpaceProgram=class DepthToSpaceProgram{constructor(F,$,V){this.variableNames=["x"],this.outputShape=[],this.outputShape=F,this.blockSize=$,this.dataFormat=V,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${$};
      int offset_h = imod(h, ${$});
      int in_w = w / ${$};
      int offset_w = imod(w, ${$});
      int offset_d = (offset_h * ${$} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DepthToSpace_depthToSpace(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{blockSize:K,dataFormat:Z}=G,ee=H.shape[0],et="NHWC"===Z?H.shape[1]:H.shape[2],en="NHWC"===Z?H.shape[2]:H.shape[3],ea="NHWC"===Z?H.shape[3]:H.shape[1],ei=et*K,eo=en*K,es=ea/(K*K),eu="NHWC"===Z?[ee,ei,eo,es]:[ee,es,ei,eo],ec=new DepthToSpaceProgram(eu,K,Z);return V.runWebGLProgram(ec,[H],H.dtype)}let hL={kernelName:eD.T0n,backendName:"webgl",kernelFunc:DepthToSpace_depthToSpace};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthwiseConv2DProgram=class DepthwiseConv2DProgram{constructor(F,$=!1,V=null,G=!1,H=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=F.outShape,this.enableShapeUniforms=(0,cL.C9)(this.outputShape.length);let K=F.filterHeight,Z=F.filterWidth,ee=F.outChannels/F.inChannels,et="",en="";V&&(et=G?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${V}
        }`:H?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${V}
        }`:`
          float activation(float x) {
            ${V}
          }
        `,en="result = activation(result);");let ea=$?"result += getBiasAtOutCoords();":"";$&&this.variableNames.push("bias"),G&&this.variableNames.push("preluActivationWeights"),H&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${et}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${ee};
        int q = d2 - d1 * ${ee};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${K}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${Z}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${ea}
        ${en}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthwiseConvPacked2DProgram=class DepthwiseConvPacked2DProgram{constructor(F,$=!1,V=null,G=!1,H=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=F.outShape,this.enableShapeUniforms=(0,cL.C9)(this.outputShape.length);let K=F.outChannels/F.inChannels,Z=F.padInfo.left,ee=F.strideWidth,et=F.dilationWidth,en=F.filterHeight,ea=F.filterWidth,ei=ea,eo=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let F=0;F<ea;F++)eo+=`
          vec4 xTexelC${2*F};
          int xTexelC${2*F}Ready;
          vec4 xTexelC${2*F+1};
          int xTexelC${2*F+1}Ready;
          vec4 xC${F};`;eo+=`
    for (int r = 0; r < ${en}; r++) {
      `;for(let F=0;F<ea;F++)eo+=`
          xTexelC${2*F} = vec4(0.0);
          xTexelC${2*F}Ready = 0;
          xTexelC${2*F+1} = vec4(0.0);
          xTexelC${2*F+1}Ready = 0;
          xC${F} = vec4(0.0);`;eo+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let F=0;F<(ei+1)/2;F++){let $=2*F;if(eo+=`
          xC = xCCorner + ${$*et};
          `,1===ee){if($<ea&&(Z%2==1?(eo+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }
              `,1===et&&$>0?eo+=`
                xC${$} = vec4(xTexelC${$-2}.zw, xTexelC${$}.xy);
                `:eo+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${$} = vec4(previous.zw, xTexelC${$}.xy);
                  } else {
                    xC${$} = vec4(0.0, 0.0, xTexelC${$}.xy);
                  }
                  `):eo+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xC${$} = xTexelC${$};
                `,$+1<ea)){let F=Z%2==0?eD.D5U.nearestLargerEven(et):et;et%2==0&&Z%2==1||et%2!=0&&Z%2!=1?(eo+=`
                  xCOffset = xC + imod(pads[1], 2) + ${F};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                    xTexelC${$+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${$+1}.zw = vec2(0.0);
                    }
                    xTexelC${$+1}Ready = 1;
                  }
                  `,et>1?eo+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${$+1} = vec4(previous.zw, xTexelC${$+1}.xy);
                    } else {
                     xC${$+1} = vec4(0.0, 0.0, xTexelC${$+1}.xy);
                    }
                    `:eo+=`
                    xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.xy);
                    `):1===F?eo+=`
                    xC${$+1} = xTexelC${$};
                    `:eo+=`
                    xCOffset = xC + ${F};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                      xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${$+1}.zw = vec2(0.0);
                      }
                      xTexelC${$+1}Ready = 1;
                    }

                    xC${$+1} = xTexelC${$+1};
                    `}}else $<ea&&(Z%2==1?(eo+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.0);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
              `,$+1<ea&&(eo+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${$+1} = vec4(xTexelC${$+1}.xy, final.xy);
                `)):(eo+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(
                  xTexelC${$}.xy, xTexelC${$+1}.xy);
              `,$+1<ea&&(eo+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
                `)));$<ea&&(eo+=`
            wTexel = getW(r, ${$}, d1, q);
            dotProd += xC${$} * vec4(wTexel.xz, wTexel.xz);
          `,$+1<ea&&(eo+=`
              wTexel = getW(r, ${$+1}, d1, q);
              dotProd += xC${$+1} * vec4(wTexel.xz, wTexel.xz);
            `))}eo+=`
    }
  
      }
    `;let es="",eu="";V&&(es=G?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${V}
        }`:H?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${V}
        }`:`vec4 activation(vec4 x) {
          ${V}
        }`,eu="result = activation(result);");let ec=$?"result += getBiasAtOutCoords();":"";$&&this.variableNames.push("bias"),G&&this.variableNames.push("preluActivationWeights"),H&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${es}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${K};
        int q = d2 - d1 * ${K};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${eo}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${ec}
        ${eu}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DepthwiseConv2dNative_depthwiseConv2dNative(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K,filter:Z}=V,{strides:ee,pad:et,dilations:en,dimRoundingMode:ea}=H,ei=en;null==ei&&(ei=[1,1]),eD.D5U.assert(eD.backend_util.eitherStridesOrDilationsAreOne(ee,ei),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${ee} and dilations '${ei}'`);let eo=eD.backend_util.computeConv2DInfo(K.shape,Z.shape,ee,ei,et,ea,!0);$=(0,eD.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&eo.strideWidth<=2&&eo.outChannels/eo.inChannels==1?new DepthwiseConvPacked2DProgram(eo):new DepthwiseConv2DProgram(eo);let es=[[eo.padInfo.top,eo.padInfo.left],[eo.strideHeight,eo.strideWidth],[eo.dilationHeight,eo.dilationWidth],[eo.inHeight,eo.inWidth]];return G.runWebGLProgram($,[K,Z],"float32",es)}let hz={kernelName:eD.cie,backendName:"webgl",kernelFunc:DepthwiseConv2dNative_depthwiseConv2dNative};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthwiseConv2DDerFilterProgram=class DepthwiseConv2DDerFilterProgram{constructor(F){this.variableNames=["x","dy"],this.outputShape=F.filterShape;let $=F.strideHeight,V=F.strideWidth,G=F.padInfo.top,H=F.padInfo.left,K=F.outChannels/F.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${K} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${F.batchSize}; b++) {
          for (int yR = 0; yR < ${F.outHeight}; yR++) {
            int xR = wR + yR * ${$} - ${G};

            if (xR < 0 || xR >= ${F.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${F.outWidth}; yC++) {
              int xC = wC + yC * ${V} - ${H};

              if (xC < 0 || xC >= ${F.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}};let DepthwiseConv2DDerInputProgram=class DepthwiseConv2DDerInputProgram{constructor(F){this.variableNames=["dy","W"],this.outputShape=F.inShape;let $=F.filterHeight,V=F.filterWidth,G=F.strideHeight,H=F.strideWidth,K=$-1-F.padInfo.top,Z=V-1-F.padInfo.left,ee=F.outChannels/F.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${K}, ${Z});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${$}; wR++) {
          float dyR = float(dyRCorner + wR) / ${G}.0;

          if (dyR < 0.0 || dyR >= ${F.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${$} - 1 - wR;

          for (int wC = 0; wC < ${V}; wC++) {
            float dyC = float(dyCCorner + wC) / ${H}.0;

            if (dyC < 0.0 || dyC >= ${F.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${V} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${ee}; dm++) {
              int d2 = d1 * ${ee} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DepthwiseConv2dNativeBackpropFilter_depthwiseConv2dNativeBackpropFilter(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,dy:K}=$,{strides:Z,dilations:ee,pad:et,dimRoundingMode:en,filterShape:ea}=G,ei=eD.backend_util.computeConv2DInfo(H.shape,ea,Z,ee,et,en,!0),eo=new DepthwiseConv2DDerFilterProgram(ei);return V.runWebGLProgram(eo,[H,K],"float32")}let hV={kernelName:eD.sL$,backendName:"webgl",kernelFunc:DepthwiseConv2dNativeBackpropFilter_depthwiseConv2dNativeBackpropFilter};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DepthwiseConv2dNativeBackpropInput_depthwiseConv2dNativeBackpropInput(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,filter:K}=$,{strides:Z,dilations:ee,pad:et,dimRoundingMode:en,inputShape:ea}=G,ei=eD.backend_util.computeConv2DInfo(ea,K.shape,Z,ee,et,en,!0),eo=new DepthwiseConv2DDerInputProgram(ei);return V.runWebGLProgram(eo,[H,K],"float32")}let hU={kernelName:eD.y7R,backendName:"webgl",kernelFunc:DepthwiseConv2dNativeBackpropInput_depthwiseConv2dNativeBackpropInput};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DiagProgram=class DiagProgram{constructor(F){this.variableNames=["X"],this.outputShape=[F,F],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Diag_diag(F){let{inputs:$,backend:V}=F,{x:G}=$,H=[...G.shape,...G.shape],K=eD.D5U.sizeFromShape(G.shape),Z=kernels_Reshape_reshape({inputs:{x:G},backend:V,attrs:{shape:[K]}}),ee=new DiagProgram(K),et=V.runWebGLProgram(ee,[Z],Z.dtype),en=kernels_Reshape_reshape({inputs:{x:et},backend:V,attrs:{shape:H}});return V.disposeIntermediateTensorInfo(Z),V.disposeIntermediateTensorInfo(et),en}let hW={kernelName:eD.$w,backendName:"webgl",kernelFunc:Diag_diag};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Dilation2DProgram=class Dilation2DProgram{constructor(F){this.variableNames=["x","W"],this.outputShape=F.outShape;let{inHeight:$,inWidth:V,padInfo:G,strideHeight:H,strideWidth:K,filterHeight:Z,filterWidth:ee,dilationHeight:et,dilationWidth:en}=F,{top:ea,left:ei}=G;this.userCode=`
      const ivec2 strides = ivec2(${H}, ${K});
      const ivec2 pads = ivec2(${ea}, ${ei});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${Z}; h++) {
          int hIn = hBeg + h * ${et};

          if (hIn >= 0 && hIn < ${$}) {
            for (int w = 0; w < ${ee}; w++) {
              int wIn = wBeg + w * ${en};

              if (wIn >= 0 && wIn < ${V}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dilation2D(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K,filter:Z}=V,{strides:ee,pad:et,dilations:en}=H,ea=eD.backend_util.computeDilation2DInfo(K.shape,Z.shape,ee,et,"NHWC",en),ei=new Dilation2DProgram(ea);$=G.runWebGLProgram(ei,[K,Z],"float32");let eo=kernels_Reshape_reshape({inputs:{x:$},backend:G,attrs:{shape:ea.outShape}});return G.disposeIntermediateTensorInfo($),eo}let hj={kernelName:eD.p4S,backendName:"webgl",kernelFunc:dilation2D};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Einsum_einsum(F){let{inputs:$,backend:V,attrs:G}=F,{equation:H}=G,K=$,{allDims:Z,summedDims:ee,idDims:et}=eD.backend_util.decodeEinsumEquation(H,K.length);eD.backend_util.checkEinsumDimSizes(Z.length,et,K);let{path:en,steps:ea}=eD.backend_util.getEinsumComputePath(ee,et),ei=ea.length,eo=null,es=Z.length,eu=[];for(let F=0;F<ei;++F){for(let $ of ea[F]){let F;let{permutationIndices:G,expandDims:H}=eD.backend_util.getEinsumPermutation(es,et[$]);eD.backend_util.isIdentityPermutation(G)?F=K[$]:(F=Transpose_transpose({inputs:{x:K[$]},backend:V,attrs:{perm:G}}),eu.push(F));let Z=F.shape.slice();for(let F=0;F<H.length;++F)Z.splice(H[F],0,1);eD.D5U.arraysEqual(F.shape,Z)||(F=kernels_Reshape_reshape({inputs:{x:F},backend:V,attrs:{shape:Z}}),eu.push(F)),null===eo?eo=F:(eo=multiply({inputs:{a:F,b:eo},backend:V}),eu.push(eo))}F<ei-1&&(en[F]>=0&&(eo=kernels_Sum_sum({inputs:{x:eo},backend:V,attrs:{axis:en[F]-(Z.length-es),keepDims:!1}}),eu.push(eo)),es--)}for(let F of eu)F!==eo&&V.disposeIntermediateTensorInfo(F);return eo}let hG={kernelName:eD.$g6,backendName:"webgl",kernelFunc:Einsum_einsum},hq="return (x >= 0.0) ? x : (exp(x) - 1.0);",hH=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,hX=unaryKernelFunc({opSnippet:hq,packedOpSnippet:hH}),hK={kernelName:eD.SX0,backendName:"webgl",kernelFunc:hX},hQ="return (b >= 0.0) ? a : a * (b + 1.0);",hZ=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,EluGrad_eluGrad=F=>{let{inputs:$,backend:V}=F,{dy:G,y:H}=$,K=(0,eD.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(hZ,G.shape,H.shape):new BinaryOpProgram(hQ,G.shape,H.shape);return V.runWebGLProgram(K,[G,H],G.dtype)},hY={kernelName:eD.HEU,backendName:"webgl",kernelFunc:EluGrad_eluGrad},hJ=`
  return vec4(equal(a, b));
`,h0="return float(a == b);",h1=binaryKernelFunc({opSnippet:h0,packedOpSnippet:hJ,dtype:"bool",cpuKernelImpl:c5.gv}),h2={kernelName:eD.hdR,backendName:"webgl",kernelFunc:h1},h3=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${eD.backend_util.ERF_P};
  float a1 = ${eD.backend_util.ERF_A1};
  float a2 = ${eD.backend_util.ERF_A2};
  float a3 = ${eD.backend_util.ERF_A3};
  float a4 = ${eD.backend_util.ERF_A4};
  float a5 = ${eD.backend_util.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,h4=unaryKernelFunc({opSnippet:h3}),h6={kernelName:eD.Omj,backendName:"webgl",kernelFunc:h4},h5=c4+`
  return exp(x);
`,h9=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,h8=unaryKernelFunc({opSnippet:h5,packedOpSnippet:h9,cpuKernelImpl:c5.aX,dtype:"float32"}),h7={kernelName:eD.NEP,backendName:"webgl",kernelFunc:h8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ExpandDims_expandDims(F){let{inputs:$,attrs:V,backend:G}=F,{dim:H}=V,{input:K}=$,Z=K.shape.length,ee=K.shape.slice(),et=H;return H<0&&(eD.D5U.assert(-(Z+1)<=H,()=>`Axis must be in the interval [${-(Z+1)}, ${Z}]`),et=Z+H+1),ee.splice(et,0,1),kernels_Reshape_reshape({inputs:{x:K},backend:G,attrs:{shape:ee}})}let fe={kernelName:eD.YFo,backendName:"webgl",kernelFunc:ExpandDims_expandDims},ft="return exp(x) - 1.0;",fr=unaryKernelFunc({opSnippet:ft,packedOpSnippet:ft,cpuKernelImpl:c5.tx}),fa={kernelName:eD.Y0y,backendName:"webgl",kernelFunc:fr};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FFTProgram=class FFTProgram{constructor(F,$,V){let G;this.variableNames=["real","imag"];let H=$[1];this.outputShape=$;let K=V?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,Z=V?`${H}.0`:"1.0";if("real"===F)G="return real * expR - imag * expI;";else if("imag"===F)G="return real * expI + imag * expR;";else throw Error(`FFT component must be either "real" or "imag", got ${F}.`);this.userCode=`
      const float exponentMultiplier = ${K};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${G}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${H});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${H}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${Z};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FFT_impl_fftImpl(F,$,V){let G=V.texData.get(F.dataId),H=eD.D5U.sizeFromShape(F.shape),K=F.shape[F.shape.length-1],Z=H/K,ee=kernels_Reshape_reshape({inputs:{x:F},backend:V,attrs:{shape:[Z,K]}}),et=ee.shape,en=new FFTProgram("real",et,$),ea=new FFTProgram("imag",et,$),ei=[{dataId:G.complexTensorInfos.real.dataId,dtype:G.complexTensorInfos.real.dtype,shape:et},{dataId:G.complexTensorInfos.imag.dataId,dtype:G.complexTensorInfos.imag.dtype,shape:et}],eo=V.runWebGLProgram(en,ei,"float32"),es=V.runWebGLProgram(ea,ei,"float32"),eu=complex({inputs:{real:eo,imag:es},backend:V});V.disposeIntermediateTensorInfo(eo),V.disposeIntermediateTensorInfo(es);let ec=kernels_Reshape_reshape({inputs:{x:eu},backend:V,attrs:{shape:F.shape}});return V.disposeIntermediateTensorInfo(ee),V.disposeIntermediateTensorInfo(eu),ec}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_FFT_fft(F){let{inputs:$,backend:V}=F,{input:G}=$;return FFT_impl_fftImpl(G,!1,V)}let fi={kernelName:eD.vwp,backendName:"webgl",kernelFunc:kernels_FFT_fft};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FillProgram=class FillProgram{constructor(F,$){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=F,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fill_fill(F){let{backend:$,attrs:V}=F,{shape:G,value:H}=V,{dtype:K}=V;if("string"===(K=K||eD.D5U.inferDtype(H))){let F=eD.D5U.getArrayFromDType(K,eD.D5U.sizeFromShape(G));return F.fill(H),$.makeTensorInfo(G,K,F)}{let F=new FillProgram(G,H),V=[[H]];return $.runWebGLProgram(F,[],K,V)}}let fo={kernelName:eD.deh,backendName:"webgl",kernelFunc:Fill_fill};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FlipLeftRightProgram=class FlipLeftRightProgram{constructor(F){this.variableNames=["Image"],this.outputShape=[];let $=F[2];this.outputShape=F,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${$} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${$}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fu={kernelName:eD.Uyb,backendName:"webgl",kernelFunc:({inputs:F,backend:$})=>{let{image:V}=F,G=$,H=new FlipLeftRightProgram(V.shape),K=G.runWebGLProgram(H,[V],V.dtype);return K}},fl="return floor(x);",fc=unaryKernelFunc({opSnippet:fl,packedOpSnippet:fl,cpuKernelImpl:c5.MZ}),fh={kernelName:eD.OR,backendName:"webgl",kernelFunc:fc},ff=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,fd=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,fm=binaryKernelFunc({opSnippet:ff,packedOpSnippet:fd,dtype:"int32"}),fg={kernelName:eD.jeX,backendName:"webgl",kernelFunc:fm};var fy=V(18378);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FromPixelsProgram=class FromPixelsProgram{constructor(F){this.variableNames=["A"];let $=(0,hy.A)(),[V,G]=F;this.outputShape=F,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${G}.0, ${V}.0);

        vec4 values = ${$.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FromPixelsPackedProgram=class FromPixelsPackedProgram{constructor(F){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let $=(0,hy.A)(),[V,G]=F;this.outputShape=F,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${G}.0, ${V}.0);
            vec4 values = ${$.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${$.output} = result;
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fb={kernelName:eD.eBW,backendName:"webgl",kernelFunc:fromPixels},fx=(0,eD.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function fromPixels(F){let{inputs:$,backend:V,attrs:H}=F,{pixels:K}=$,{numChannels:Z}=H,ee="undefined"!=typeof HTMLVideoElement&&K instanceof HTMLVideoElement,et="undefined"!=typeof HTMLImageElement&&K instanceof HTMLImageElement,[en,ea]=ee?[K.videoWidth,K.videoHeight]:[K.width,K.height],ei=[ea,en],eo=[ea,en,Z];if(et||ee){let F=(0,eD.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==G||F!==fx)&&(fx=F,G=document.createElement("canvas").getContext("2d",{willReadFrequently:fx})),G.canvas.width=en,G.canvas.height=ea,G.drawImage(K,0,0,en,ea),K=G.canvas}let es=V.makeTensorInfo(ei,"int32");V.texData.get(es.dataId).usage=fy.v2.PIXELS,V.gpgpu.uploadPixelDataToTexture(V.getTexture(es.dataId),K);let eu=(0,eD.OBj)().getBool("WEBGL_PACK")?new FromPixelsPackedProgram(eo):new FromPixelsProgram(eo),ec=V.runWebGLProgram(eu,[es],"int32");return V.disposeData(es.dataId),ec}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedConv2d(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K,filter:Z,bias:ee,preluActivationWeights:et}=V,{strides:en,pad:ea,dataFormat:ei,dilations:eo,dimRoundingMode:es,activation:eu,leakyreluAlpha:ec}=H,ep=eD.backend_util.convertConv2DDataFormat(ei),eh=eD.backend_util.computeConv2DInfo(K.shape,Z.shape,en,eo,ea,es,!1,ep),ef=[],ed=null!=ee,em=null!=et,eg="leakyrelu"===eu,prepareInputs=()=>{let F=[K,Z],alignInputWithDataFormat=(F,$)=>{if("NCHW"===$&&1===F.shape.length&&1!==F.shape[0]){let $=kernels_Reshape_reshape({inputs:{x:F},backend:G,attrs:{shape:[F.shape[0],1,1]}});return ef.push($),$}return F};if(ed&&F.push(alignInputWithDataFormat(ee,ei)),em&&F.push(alignInputWithDataFormat(et,ei)),eg){let $=G.makeTensorInfo([],"float32",eD.D5U.createScalarValue(ec,"float32"));F.push($),ef.push($)}return F};if(1===eh.filterHeight&&1===eh.filterWidth&&1===eh.dilationHeight&&1===eh.dilationWidth&&1===eh.strideHeight&&1===eh.strideWidth&&("SAME"===eh.padInfo.type||"VALID"===eh.padInfo.type))$=conv2dByMatMul({x:K,filter:Z,convInfo:eh,backend:G,bias:ee,activation:eu,preluActivationWeights:et,leakyreluAlpha:ec});else if(eh.strideWidth<=2&&"channelsLast"===ep&&(0,eD.OBj)().getBool("WEBGL_EXP_CONV")){let F=eu?mapActivationToShaderProgram(eu,!0):null,V=new Conv2DPackedProgram(eh,ed,F,em,eg),H=[[eh.padInfo.top,eh.padInfo.left],[eh.strideHeight,eh.strideWidth],[eh.dilationHeight,eh.dilationWidth],[eh.inHeight,eh.inWidth]],K=prepareInputs();$=G.runWebGLProgram(V,K,"float32",H)}else if((0,eD.OBj)().getBool("WEBGL_CONV_IM2COL"))$=conv2dWithIm2Row({x:K,filter:Z,convInfo:eh,backend:G,bias:ee,activation:eu,preluActivationWeights:et,leakyreluAlpha:ec});else{let F=eu?mapActivationToShaderProgram(eu,!1):null,V=new Conv2DProgram(eh,ed,F,em,eg),H=prepareInputs();$=G.runWebGLProgram(V,H,"float32")}let ey=kernels_Reshape_reshape({inputs:{x:$},backend:G,attrs:{shape:eh.outShape}});return ef.push($),ef.forEach(F=>G.disposeIntermediateTensorInfo(F)),ey}let fv={kernelName:eD._V0,backendName:"webgl",kernelFunc:fusedConv2d};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FusedDepthwiseConv2D_fusedDepthwiseConv2D(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K,filter:Z,bias:ee,preluActivationWeights:et}=V,{strides:en,pad:ea,dilations:ei,dimRoundingMode:eo,activation:es,leakyreluAlpha:eu}=H,ec=[],ep=ei;null==ep&&(ep=[1,1]),eD.D5U.assert(eD.backend_util.eitherStridesOrDilationsAreOne(en,ep),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${en} and dilations '${ep}'`);let eh=eD.backend_util.computeConv2DInfo(K.shape,Z.shape,en,ep,ea,eo,!0),ef=(0,eD.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&eh.strideWidth<=2&&eh.outChannels/eh.inChannels==1,ed=es?mapActivationToShaderProgram(es,ef):null,em=[K,Z],eg=null!=ee,ey=null!=et,eb="leakyrelu"===es;if(eg&&em.push(ee),ey&&em.push(et),eb){let F=G.makeTensorInfo([],"float32",eD.D5U.createScalarValue(eu,"float32"));em.push(F),ec.push(F)}$=ef?new DepthwiseConvPacked2DProgram(eh,eg,ed,ey,eb):new DepthwiseConv2DProgram(eh,eg,ed,ey,eb);let ew=[[eh.padInfo.top,eh.padInfo.left],[eh.strideHeight,eh.strideWidth],[eh.dilationHeight,eh.dilationWidth],[eh.inHeight,eh.inWidth]],eS=G.runWebGLProgram($,em,"float32",ew);return ec.forEach(F=>G.disposeIntermediateTensorInfo(F)),eS}let fw={kernelName:eD.luS,backendName:"webgl",kernelFunc:FusedDepthwiseConv2D_fusedDepthwiseConv2D};let GatherNDProgram=class GatherNDProgram{constructor(F,$,V,G){this.sliceDim=F,this.strides=$,this.paramsShape=G,this.variableNames=["x","indices"],this.outputShape=V;let H=(0,cU.kW)(V.length),K=`
    int index;`;for(let F=0;F<this.sliceDim;F++)K+=`
          index = round(getIndices(coords[0], ${F}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[F]};
          flattenIndex += index * ${this.strides[F]};`;this.userCode=`
         void main() {
          ${H} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${K}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GatherNd_gatherNd(F){let{inputs:$,backend:V}=F,{params:G,indices:H}=$,K=H.shape,Z=K[K.length-1],ee=eD.D5U.sizeFromShape(G.shape),[et,en,ea,ei]=eD.backend_util.prepareAndValidate(G,H),eo=kernels_Reshape_reshape({inputs:{x:H},backend:V,attrs:{shape:[en,Z]}}),es=kernels_Reshape_reshape({inputs:{x:G},backend:V,attrs:{shape:[eD.D5U.sizeFromShape(G.shape)/ea,ea]}});if(V.shouldExecuteOnCPU([G,H])||"string"===G.dtype){let F=V.readSync(H.dataId),$=V.bufferSync(G),K=(0,c5.TD)(F,$,G.dtype,en,Z,ea,ei,G.shape,ee);return V.makeTensorInfo(et,G.dtype,K.values)}let eu=new GatherNDProgram(Z,ei,[en,ea],G.shape),ec=V.runWebGLProgram(eu,[es,eo],es.dtype),ep=kernels_Reshape_reshape({inputs:{x:ec},backend:V,attrs:{shape:et}});return V.disposeIntermediateTensorInfo(eo),V.disposeIntermediateTensorInfo(es),V.disposeIntermediateTensorInfo(ec),ep}let fS={kernelName:eD.q1x,backendName:"webgl",kernelFunc:GatherNd_gatherNd};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GatherProgram=class GatherProgram{constructor(F,$){this.variableNames=["A","indices"],this.outputShape=$,this.rank=$.length;let V=(0,cU.kW)(this.rank),G=getSourceCoords(F,2);this.userCode=`
      void main() {
        ${V} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${F[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${G}));
      }
    `}};function getSourceCoords(F,$){let V=["resRC.x","resRC.y","resRC.z","resRC.w"],G=[];for(let $=0;$<F.length;$++)2===$?G.push("index"):G.push(`${V[$]}`);return G.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GatherV2_gatherV2(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,indices:K}=$,{axis:Z,batchDims:ee}=G,et=eD.D5U.parseAxisParam(Z,H.shape)[0];if((0,eD.OBj)().get("DEBUG")){let F=V.readSync(K.dataId),$=H.shape[et];for(let V=0;V<F.length;++V){let G=F[V];eD.D5U.assert(G<=$-1&&G>=0,()=>`GatherV2: the index value ${G} is not in [0, ${$-1}]`)}}let en=eD.backend_util.segment_util.collectGatherOpShapeInfo(H,K,et,ee),ea=eD.D5U.sizeFromShape(K.shape),ei=[],eo=kernels_Reshape_reshape({inputs:{x:H},backend:V,attrs:{shape:[en.batchSize,en.outerSize,en.dimSize,en.sliceSize]}}),es=kernels_Reshape_reshape({inputs:{x:K},backend:V,attrs:{shape:[en.batchSize,ea/en.batchSize]}});ei.push(eo),ei.push(es);let eu=[en.batchSize,en.outerSize,ea/en.batchSize,en.sliceSize];if(V.shouldExecuteOnCPU([H,K])||"string"===H.dtype){let F=V.bufferSync(es),$=V.bufferSync(eo),G=(0,c5.m$)($,F,eu);return ei.forEach(F=>V.disposeIntermediateTensorInfo(F)),V.makeTensorInfo(en.outputShape,G.dtype,G.values)}let ec=new GatherProgram(eo.shape,eu),ep=V.runWebGLProgram(ec,[eo,es],eo.dtype);ei.push(ep);let eh=kernels_Reshape_reshape({inputs:{x:ep},backend:V,attrs:{shape:en.outputShape}});return ei.forEach(F=>V.disposeIntermediateTensorInfo(F)),eh}let f_={kernelName:eD.qi_,backendName:"webgl",kernelFunc:GatherV2_gatherV2},fN="return float(a > b);",fk=`
  return vec4(greaterThan(a, b));
`,fI=binaryKernelFunc({opSnippet:fN,packedOpSnippet:fk,cpuKernelImpl:c5.B_,dtype:"bool"}),fT={kernelName:eD.iZT,backendName:"webgl",kernelFunc:fI},fC="return float(a >= b);",fE=`
  return vec4(greaterThanEqual(a, b));
`,fA=binaryKernelFunc({opSnippet:fC,packedOpSnippet:fE,dtype:"bool",cpuKernelImpl:c5.ji}),fD={kernelName:eD.Acj,backendName:"webgl",kernelFunc:fA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_IFFT_ifft(F){let{inputs:$,backend:V}=F,{input:G}=$;return FFT_impl_fftImpl(G,!0,V)}let fM={kernelName:eD.Qg5,backendName:"webgl",kernelFunc:kernels_IFFT_ifft},fR="return float(!isnan(x) && !isinf(x));",fF=unaryKernelFunc({opSnippet:fR,dtype:"bool"}),fO={kernelName:eD.avt,backendName:"webgl",kernelFunc:fF},fP="return float(isinf(x));",fB=unaryKernelFunc({opSnippet:fP,dtype:"bool"}),f$={kernelName:eD.iWB,backendName:"webgl",kernelFunc:fB},fL="return float(isnan(x));",fz=unaryKernelFunc({opSnippet:fL,dtype:"bool"}),fV={kernelName:eD.r7n,backendName:"webgl",kernelFunc:fz},fU="return float(a < b);",fW=`
  return vec4(lessThan(a, b));
`,fj=binaryKernelFunc({opSnippet:fU,packedOpSnippet:fW,cpuKernelImpl:c5.kY,dtype:"bool"}),fG={kernelName:eD.vtC,backendName:"webgl",kernelFunc:fj},fq="return float(a <= b);",fH=`
  return vec4(lessThanEqual(a, b));
`,fX=binaryKernelFunc({opSnippet:fq,packedOpSnippet:fH,cpuKernelImpl:c5.Rn,dtype:"bool"}),fK={kernelName:eD.CAk,backendName:"webgl",kernelFunc:fX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LinSpace_linSpace(F){let{backend:$,attrs:V}=F,{start:G,stop:H,num:K}=V,Z=(0,c5.PQ)(G,H,K);return $.makeTensorInfo([Z.length],"float32",Z)}let fQ={kernelName:eD.e7N,backendName:"webgl",kernelFunc:LinSpace_linSpace},fZ=c4+`
  return x < 0.0 ? 0./0. : log(x);
`,fY=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,fJ=unaryKernelFunc({opSnippet:fZ,packedOpSnippet:fY,cpuKernelImpl:c5.Sd}),f0={kernelName:eD.ZbH,backendName:"webgl",kernelFunc:fJ},f1=c4+`
  return log(1.0 + x);
`,f3=unaryKernelFunc({opSnippet:f1}),f4={kernelName:eD.kU,backendName:"webgl",kernelFunc:f3},f6="return float(a >= 1.0 && b >= 1.0);",f5=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,f9=binaryKernelFunc({opSnippet:f6,packedOpSnippet:f5,dtype:"bool"}),f8={kernelName:eD.PYm,backendName:"webgl",kernelFunc:f9},f7="return float(!(x >= 1.0));",de=unaryKernelFunc({opSnippet:f7}),dr={kernelName:eD.VfG,backendName:"webgl",kernelFunc:de},dn="return float(a >= 1.0 || b >= 1.0);",da=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,du=binaryKernelFunc({opSnippet:dn,packedOpSnippet:da,dtype:"bool"}),dl={kernelName:eD.MZg,backendName:"webgl",kernelFunc:du};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LRNProgram=class LRNProgram{constructor(F,$,V,G,H){let K;this.variableNames=["x"],this.outputShape=[];let Z=$,ee=F[3]-1;this.outputShape=F;let et=`float(${V}) + float(${G}) * sum`;K=.5===H?`inversesqrt(${et})`:1===H?`1.0/(${et})`:`exp(log(${et}) * float(-${H}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${Z}; j <= ${Z}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${ee}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${K};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LRNPackedProgram=class LRNPackedProgram{constructor(F,$,V,G,H){let K;this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let Z=$,ee=F[3]-1;this.outputShape=F;let et=`float(${V}) + float(${G}) * sum`;K=.5===H?`inversesqrt(${et})`:1===H?`1.0/(${et})`:`exp(log(${et}) * float(-${H}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${Z};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${Z}; j <= ${Z}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${ee}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${K};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lrn=F=>{let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{depthRadius:K,bias:Z,alpha:ee,beta:et}=G,en=(0,eD.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new LRNPackedProgram(H.shape,K,Z,ee,et):new LRNProgram(H.shape,K,Z,ee,et);return V.runWebGLProgram(en,[H],H.dtype)},dc={kernelName:eD.eZ0,backendName:"webgl",kernelFunc:lrn};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LRNGradProgram=class LRNGradProgram{constructor(F,$,V,G,H){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=F,this.depth=F[3],this.depthRadius=$,this.bias=V,this.alpha=G,this.beta=H,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${$})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${$} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${G}) * norm + float(${V});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${G})
                * float(${H})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${H});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lrnGrad=F=>{let{inputs:$,backend:V,attrs:G}=F,{x:H,y:K,dy:Z}=$,{depthRadius:ee,bias:et,alpha:en,beta:ea}=G,ei=new LRNGradProgram(H.shape,ee,et,en,ea);return V.runWebGLProgram(ei,[H,K,Z],H.dtype)},dh={kernelName:eD.Hhh,backendName:"webgl",kernelFunc:lrnGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxImpl(F,$,V,G){let H=eD.D5U.sizeFromShape($),K=eD.D5U.sizeFromShape(F.shape),Z=K/H,ee=kernels_Reshape_reshape({inputs:{x:F},attrs:{shape:[Z,H]},backend:G}),et=reduce(ee,F.dtype,"max",G),en=kernels_Reshape_reshape({inputs:{x:et},attrs:{shape:V},backend:G});return G.disposeIntermediateTensorInfo(ee),G.disposeIntermediateTensorInfo(et),en}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Max_max(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V,{reductionIndices:Z,keepDims:ee}=H,et=K.shape.length,en=eD.D5U.parseAxisParam(Z,K.shape),ea=en,ei=eD.backend_util.getAxesPermutation(ea,et),eo=null!=ei,es=G.shouldExecuteOnCPU([K]),eu=K;if(eo){if(es){let F=G.texData.get(eu.dataId),$=F.values,V=Array(et);for(let F=0;F<V.length;F++)V[F]=K.shape[ei[F]];let H=(0,c5.Fv)($,K.shape,K.dtype,ei,V);eu=G.makeTensorInfo(V,K.dtype);let Z=G.texData.get(eu.dataId);Z.values=H}else eu=transposeImpl(K,ei,G);ea=eD.backend_util.getInnerMostAxes(ea.length,et)}eD.backend_util.assertAxesAreInnerMostDims("max",ea,et);let[ec,ep]=eD.backend_util.computeOutAndReduceShapes(eu.shape,ea),eh=ec;if(ee&&(eh=eD.backend_util.expandShapeToKeepDim(ec,en)),es){let F=G.texData.get(eu.dataId),V=F.values,H=(0,c5.$O)(V,eD.D5U.sizeFromShape(ep),eh,K.dtype);$=G.makeTensorInfo(eh,K.dtype);let Z=G.texData.get($.dataId);Z.values=H}else $=maxImpl(eu,ep,eh,G);return eo&&G.disposeIntermediateTensorInfo(eu),$}let df={kernelName:eD.YoZ,backendName:"webgl",kernelFunc:kernels_Max_max},dd=cz+`
  return max(a, b);
`,dg=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+cW+`
  return result;
`,dv=binaryKernelFunc({opSnippet:dd,packedOpSnippet:dg,cpuKernelImpl:c5.nL}),dS={kernelName:eD.BMI,backendName:"webgl",kernelFunc:dv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MaxPool_maxPool(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$;(0,cO.assertNotComplex)(H,"maxPool");let{filterSize:K,strides:Z,pad:ee,dimRoundingMode:et}=G,en=1;eD.D5U.assert(eD.backend_util.eitherStridesOrDilationsAreOne(Z,en),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${Z} and dilations '${en}'`);let ea=eD.backend_util.computePool2DInfo(H.shape,K,Z,en,ee,et);if(1===ea.filterWidth&&1===ea.filterHeight&&eD.D5U.arraysEqual(ea.inShape,ea.outShape))return Identity_identity({inputs:{x:H},backend:V});let ei=new Pool2DProgram(ea,"max",!1);return V.runWebGLProgram(ei,[H],H.dtype)}let d_={kernelName:eD.mTV,backendName:"webgl",kernelFunc:MaxPool_maxPool};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3d(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{filterSize:K,strides:Z,pad:ee,dataFormat:et,dimRoundingMode:en}=G,ea=[1,1,1],ei=eD.backend_util.computePool3DInfo(H.shape,K,Z,ea,ee,en,et),eo=new Pool3DProgram(ei,"max",!1);return V.runWebGLProgram(eo,[H],H.dtype)}let dN={kernelName:eD.OAf,backendName:"webgl",kernelFunc:maxPool3d};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MaxPool2DBackpropProgram=class MaxPool2DBackpropProgram{constructor(F){this.variableNames=["dy","maxPos"],this.outputShape=F.inShape;let $=F.strideHeight,V=F.strideWidth,G=F.dilationHeight,H=F.effectiveFilterHeight,K=F.effectiveFilterWidth,Z=H-1-F.padInfo.top,ee=K-1-F.padInfo.left,et=H*K-1;this.userCode=`
      const ivec2 pads = ivec2(${Z}, ${ee});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${H};
          wR += ${G}) {
          float dyR = float(dyRCorner + wR) / ${$}.0;

          if (dyR < 0.0 || dyR >= ${F.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${K}; wC++) {
            float dyC = float(dyCCorner + wC) / ${V}.0;

            if (dyC < 0.0 || dyC >= ${F.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${et} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${K} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}};let MaxPool3DBackpropProgram=class MaxPool3DBackpropProgram{constructor(F){this.variableNames=["dy","maxPos"],this.outputShape=F.inShape;let $=F.strideDepth,V=F.strideHeight,G=F.strideWidth,H=F.dilationDepth,K=F.dilationHeight,Z=F.dilationWidth,ee=F.effectiveFilterDepth,et=F.effectiveFilterHeight,en=F.effectiveFilterWidth,ea=ee-1-F.padInfo.front,ei=et-1-F.padInfo.top,eo=en-1-F.padInfo.left,es=ee*et*en-1;this.userCode=`
      const ivec3 pads = ivec3(${ea}, ${ei}, ${eo});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${ee};
           wD += ${H}) {
          float dyD = float(dyDCorner + wD) / ${$}.0;

          if (dyD < 0.0 || dyD >= ${F.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${et};
              wR += ${K}) {
            float dyR = float(dyRCorner + wR) / ${V}.0;

            if (dyR < 0.0 || dyR >= ${F.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${en};
                wC += ${Z}) {
              float dyC = float(dyCCorner + wC) / ${G}.0;

              if (dyC < 0.0 || dyC >= ${F.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${es} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${et} * ${en} +
                  wR * ${en} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MaxPool3DGrad_maxPool3DGrad(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,input:K}=$,Z=K,{filterSize:ee,strides:et,pad:en,dimRoundingMode:ea}=G,ei=[1,1,1],eo=eD.backend_util.computePool3DInfo(Z.shape,ee,et,ei,en,ea),es=new Pool3DProgram(eo,"max",!0),eu=V.runWebGLProgram(es,[Z],Z.dtype),ec=new MaxPool3DBackpropProgram(eo),ep=V.runWebGLProgram(ec,[H,eu],Z.dtype);return V.disposeIntermediateTensorInfo(eu),ep}let dI={kernelName:eD.OU7,backendName:"webgl",kernelFunc:MaxPool3DGrad_maxPool3DGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_MaxPoolGrad_maxPoolGrad(F){let{inputs:$,backend:V,attrs:G}=F,{dy:H,input:K,output:Z}=$,ee=K;(0,cO.assertNotComplex)([K,Z],"maxPoolGrad");let{filterSize:et,strides:en,pad:ea,dimRoundingMode:ei}=G,eo=eD.backend_util.computePool2DInfo(ee.shape,et,en,1,ea,ei),es=!0,eu=new Pool2DProgram(eo,"max",es),ec=V.runWebGLProgram(eu,[ee],ee.dtype),ep=new MaxPool2DBackpropProgram(eo),eh=V.runWebGLProgram(ep,[H,ec],ee.dtype);return V.disposeIntermediateTensorInfo(ec),eh}let dT={kernelName:eD.OV7,backendName:"webgl",kernelFunc:kernels_MaxPoolGrad_maxPoolGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MaxPoolWithArgmax_impl_maxPoolWithArgmaxImpl(F,$,V,G){let H=new Pool2DProgram(V,"max",!1),K=G.runWebGLProgram(H,[F],"float32");H=new Pool2DProgram(V,"max",!0,!0,$);let Z=G.runWebGLProgram(H,[F],"float32");return[K,Z]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dC={kernelName:eD.vFR,backendName:"webgl",kernelFunc:({inputs:F,attrs:$,backend:V})=>{let{x:G}=F,{filterSize:H,strides:K,pad:Z,includeBatchInIndex:ee}=$,et=V;eD.D5U.assert(4===G.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${G.shape.length}.`);let en=[1,1];eD.D5U.assert(eD.backend_util.eitherStridesOrDilationsAreOne(K,en),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${K} and dilations '${en}'`);let ea=eD.backend_util.computePool2DInfo(G.shape,H,K,en,Z),[ei,eo]=MaxPoolWithArgmax_impl_maxPoolWithArgmaxImpl(G,ee,ea,et);return[ei,eo]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function meanImpl(F,$,V,G){let H=eD.D5U.sizeFromShape($),K=eD.D5U.sizeFromShape(F.shape),Z=K/H,ee=kernels_Reshape_reshape({inputs:{x:F},attrs:{shape:[Z,H]},backend:G}),et=reduce(ee,"float32","mean",G),en=kernels_Reshape_reshape({inputs:{x:et},attrs:{shape:V},backend:G});return G.disposeIntermediateTensorInfo(ee),G.disposeIntermediateTensorInfo(et),en}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dE={kernelName:eD.q2K,backendName:"webgl",kernelFunc:({inputs:F,attrs:$,backend:V})=>{let{x:G}=F,{keepDims:H,axis:K}=$,Z=V,ee=G.shape.length,et=eD.D5U.parseAxisParam(K,G.shape),en=et,ea=eD.backend_util.getAxesPermutation(en,ee),ei=null!=ea,eo=Z.shouldExecuteOnCPU([G]),es=[],eu=G;if(ei){if(eo){let F=Z.texData.get(eu.dataId),$=F.values,V=Array(ee);for(let F=0;F<V.length;F++)V[F]=G.shape[ea[F]];let H=(0,c5.Fv)($,G.shape,G.dtype,ea,V);eu=Z.makeTensorInfo(V,G.dtype);let K=Z.texData.get(eu.dataId);K.values=H}else eu=transposeImpl(G,ea,Z);es.push(eu),en=eD.backend_util.getInnerMostAxes(en.length,ee)}eD.backend_util.assertAxesAreInnerMostDims("sum",en,ee);let[ec,ep]=eD.backend_util.computeOutAndReduceShapes(eu.shape,en),eh=ec;H&&(eh=eD.backend_util.expandShapeToKeepDim(ec,et));let ef=meanImpl(eu,ep,eh,Z);for(let F of es)Z.disposeIntermediateTensorInfo(F);return ef}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Min_min(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V,{axis:Z,keepDims:ee}=H,et=K.shape.length,en=eD.D5U.parseAxisParam(Z,K.shape),ea=en,ei=eD.backend_util.getAxesPermutation(ea,et),eo=K;null!=ei&&(eo=Transpose_transpose({inputs:{x:K},backend:G,attrs:{perm:ei}}),ea=eD.backend_util.getInnerMostAxes(ea.length,K.shape.length)),eD.backend_util.assertAxesAreInnerMostDims("min",ea,et);let[es,eu]=eD.backend_util.computeOutAndReduceShapes(eo.shape,ea),ec=eD.D5U.sizeFromShape(eu),ep=kernels_Reshape_reshape({inputs:{x:eo},backend:G,attrs:{shape:[-1,ec]}}),eh=reduce(ep,ep.dtype,"min",G);if(ee){let F=eD.backend_util.expandShapeToKeepDim(es,en);$=kernels_Reshape_reshape({inputs:{x:eh},backend:G,attrs:{shape:F}})}else $=kernels_Reshape_reshape({inputs:{x:eh},backend:G,attrs:{shape:es}});return G.disposeIntermediateTensorInfo(ep),G.disposeIntermediateTensorInfo(eh),null!=ei&&G.disposeIntermediateTensorInfo(eo),$}let dA={kernelName:eD.c17,backendName:"webgl",kernelFunc:kernels_Min_min},dD=cz+`
  return min(a, b);
`,dM=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+cW+`
  return result;
`,dR=binaryKernelFunc({opSnippet:dD,packedOpSnippet:dM,cpuKernelImpl:c5.r}),dF={kernelName:eD.q8u,backendName:"webgl",kernelFunc:dR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MirrorPadProgram=class MirrorPadProgram{constructor(F,$,V){this.variableNames=["x"],this.outputShape=$.map(($,V)=>$[0]+F[V]+$[1]);let G=F.length,H=(0,cU.kW)(G),K=$.map(F=>F[0]).join(","),Z=$.map(($,V)=>$[0]+F[V]).join(","),ee=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,G),et="reflect"===V?0:1;if(1===G){this.userCode=`
        int start = ${K};
        int end = ${Z};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${et};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${et};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${H} start = ${H}(${K});
      ${H} end = ${H}(${Z});

      void main() {
        ${H} outC = getOutputCoords();
        for (int i = 0; i < ${G}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${et};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${et};
          }
        }
        ${H} coords = outC - start;
        setOutput(getX(${ee}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MirrorPadPackedProgram=class MirrorPadPackedProgram{constructor(F,$,V){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=$.map(($,V)=>$[0]+F[V]+$[1]);let G=F.length,H=(0,cU.kW)(G),K=$.map(F=>F[0]).join(","),Z=$.map(($,V)=>$[0]+F[V]).join(","),ee=(0,cV.Ky)("rc",G),et=(0,cV.Ky)("source",G),en=`${ee[G-1]} < ${this.outputShape[G-1]}`,ea=1===G?"source":`vec2(${et.slice(-2).join()})`,ei="reflect"===V?0:1,eo="";if(1===G){let F=`
        ${H} source = rc;
        if (source < start) {
          source = start * 2 - source - ${ei};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${ei};
        }
        source -= start;
      `;eo=`
        ${H} rc = outputLoc;
        ${F}
        result[0] = getChannel(getX(${et.join()}), ${ea});
        ${ee[G-1]} += 1;
        if(${en}) {
          ${F}
          result[1] = getChannel(getX(${et.join()}), ${ea});
        }
      `}else{let F=`
        ${H} source = rc;
        ${H} lt = ${H}(lessThan(source, start));
        ${H} gte = ${H}(greaterThanEqual(source, end));
        ${H} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${ei}) +
                gte * ((end - 1) * 2 - source + ${ei});
        source -= start;
      `;eo=`
        ${H} rc = outputLoc;
        ${F}
        result[0] = getChannel(getX(${et.join()}), ${ea});
        ${ee[G-1]} += 1;
        if(${en}) {
          ${F}
          result[1] = getChannel(getX(${et.join()}), ${ea});
        }
        rc = outputLoc;
        ${ee[G-2]} += 1;
        if(${ee[G-2]} < ${this.outputShape[G-2]}) {
          ${F}
          result[2] = getChannel(getX(${et.join()}), ${ea});
          ${ee[G-1]} += 1;
          if(${en}) {
            ${F}
            result[3] = getChannel(getX(${et.join()}), ${ea});
          }
        }
      `}this.userCode=`
      const ${H} start = ${H}(${K});
      const ${H} end = ${H}(${Z});

      void main() {
        ${H} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${eo}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mirrorPadKernelFunc=({inputs:F,backend:$,attrs:V})=>{let{x:G}=F,{paddings:H,mode:K}=V,Z=(0,eD.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new MirrorPadPackedProgram(G.shape,H,K):new MirrorPadProgram(G.shape,H,K),ee=$.runWebGLProgram(Z,[G],G.dtype);return ee},dO={kernelName:eD.jQs,backendName:"webgl",kernelFunc:mirrorPadKernelFunc},dP=`if (b == 0.0) return NAN;
  return mod(a, b);`,dB=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+cW+`
  return result;
`,d$=binaryKernelFunc({opSnippet:dP,packedOpSnippet:dB}),dL={kernelName:eD.Vbg,backendName:"webgl",kernelFunc:d$};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MultinomialProgram=class MultinomialProgram{constructor(F,$,V){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[F,V],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${$-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${$-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dz=`
if (a == b) {
  return 1.0;
};
return a / b;`,dV=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,dU=binaryKernelFunc({opSnippet:dz,packedOpSnippet:dV,checkOutOfBounds:!0}),dj={kernelName:eD.oHH,backendName:"webgl",kernelFunc:dU},dG="return a - b;",dq=binaryKernelFunc({opSnippet:dG,packedOpSnippet:dG,supportsComplex:!0,cpuKernelImpl:c5.kI}),dH={kernelName:eD.Tr8,backendName:"webgl",kernelFunc:dq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Softmax_softmax(F){let{inputs:$,backend:V,attrs:G}=F,{logits:H}=$,{dim:K}=G,Z=eD.D5U.parseAxisParam([K],H.shape),ee=kernels_Max_max({inputs:{x:H},backend:V,attrs:{reductionIndices:Z,keepDims:!1}}),et=eD.backend_util.expandShapeToKeepDim(ee.shape,Z),en=kernels_Reshape_reshape({inputs:{x:ee},backend:V,attrs:{shape:et}}),ea=dq({inputs:{a:H,b:en},backend:V}),ei=h8({inputs:{x:ea},backend:V}),eo=kernels_Sum_sum({inputs:{x:ei},backend:V,attrs:{axis:Z,keepDims:!1}}),es=kernels_Reshape_reshape({inputs:{x:eo},backend:V,attrs:{shape:et}}),eu=dU({inputs:{a:ei,b:es},backend:V});return V.disposeIntermediateTensorInfo(ee),V.disposeIntermediateTensorInfo(en),V.disposeIntermediateTensorInfo(ea),V.disposeIntermediateTensorInfo(ei),V.disposeIntermediateTensorInfo(eo),V.disposeIntermediateTensorInfo(es),eu}let dX={kernelName:eD.Gcp,backendName:"webgl",kernelFunc:kernels_Softmax_softmax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Multinomial_multinomial(F){let{inputs:$,backend:V,attrs:G}=F,{logits:H}=$,{numSamples:K,seed:Z,normalized:ee}=G,et=ee?H:kernels_Softmax_softmax({inputs:{logits:H},backend:V,attrs:{dim:H.shape.length-1}}),en=et.shape[0],ea=et.shape[1],ei=new MultinomialProgram(en,ea,K),eo=[[Z]],es=V.runWebGLProgram(ei,[et],"int32",eo);return ee||V.disposeIntermediateTensorInfo(et),es}let dK={kernelName:eD.NZg,backendName:"webgl",kernelFunc:Multinomial_multinomial},dQ=cJ.D1+`
  return -x;
`,dZ=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Neg_neg(F){let $;let{inputs:V,backend:G}=F,{x:H}=V;if(G.shouldExecuteOnCPU([H])){let F=G.texData.get(H.dataId),[$,V]=(0,c5.Bo)(F.values,H.shape,H.dtype);return G.makeTensorInfo(V,H.dtype,$)}return $=(0,eD.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new c3.cc(H.shape,dZ):new cJ.l(H.shape,dQ),G.runWebGLProgram($,[H],H.dtype)}let dY={kernelName:eD.kuV,backendName:"webgl",kernelFunc:Neg_neg},dJ=eD.GDt.nonMaxSuppressionV3Impl;function NonMaxSuppressionV3_nonMaxSuppressionV3(F){eD.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:$,backend:V,attrs:G}=F,{boxes:H,scores:K}=$,{maxOutputSize:Z,iouThreshold:ee,scoreThreshold:et}=G,en=V.readSync(H.dataId),ea=V.readSync(K.dataId),{selectedIndices:ei}=dJ(en,ea,Z,ee,et);return V.makeTensorInfo([ei.length],"int32",new Int32Array(ei))}let d3={kernelName:eD.uv1,backendName:"webgl",kernelFunc:NonMaxSuppressionV3_nonMaxSuppressionV3},d4=eD.GDt.nonMaxSuppressionV4Impl;function NonMaxSuppressionV4_nonMaxSuppressionV4(F){eD.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:$,backend:V,attrs:G}=F,{boxes:H,scores:K}=$,{maxOutputSize:Z,iouThreshold:ee,scoreThreshold:et,padToMaxOutputSize:en}=G,ea=V.readSync(H.dataId),ei=V.readSync(K.dataId),{selectedIndices:eo,validOutputs:es}=d4(ea,ei,Z,ee,et,en);return[V.makeTensorInfo([eo.length],"int32",new Int32Array(eo)),V.makeTensorInfo([],"int32",new Int32Array([es]))]}let d6={kernelName:eD.cye,backendName:"webgl",kernelFunc:NonMaxSuppressionV4_nonMaxSuppressionV4},d9=eD.GDt.nonMaxSuppressionV5Impl;function NonMaxSuppressionV5_nonMaxSuppressionV5(F){eD.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:$,backend:V,attrs:G}=F,{boxes:H,scores:K}=$,{maxOutputSize:Z,iouThreshold:ee,scoreThreshold:et,softNmsSigma:en}=G,ea=V.readSync(H.dataId),ei=V.readSync(K.dataId),eo=Z,es=ee,eu=et,ec=en,{selectedIndices:ep,selectedScores:eh}=d9(ea,ei,eo,es,eu,ec);return[V.makeTensorInfo([ep.length],"int32",new Int32Array(ep)),V.makeTensorInfo([eh.length],"float32",new Float32Array(eh))]}let d7={kernelName:eD.W0H,backendName:"webgl",kernelFunc:NonMaxSuppressionV5_nonMaxSuppressionV5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OneHotProgram=class OneHotProgram{constructor(F,$,V,G){this.variableNames=["indices"],this.outputShape=[F,$],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${G}), float(${V}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OneHot_oneHot=F=>{let{inputs:$,backend:V,attrs:G}=F,{indices:H}=$,{dtype:K,depth:Z,onValue:ee,offValue:et}=G,en=eD.D5U.sizeFromShape(H.shape),ea=new OneHotProgram(en,Z,ee,et),ei=kernels_Reshape_reshape({inputs:{x:H},backend:V,attrs:{shape:[en]}}),eo=V.runWebGLProgram(ea,[ei],K);V.disposeIntermediateTensorInfo(ei);let es=[...H.shape,Z],eu=kernels_Reshape_reshape({inputs:{x:eo},backend:V,attrs:{shape:es}});return V.disposeIntermediateTensorInfo(eo),eu},mt={kernelName:eD.we_,backendName:"webgl",kernelFunc:OneHot_oneHot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZerosLike_zerosLike(F){let{inputs:$,backend:V}=F,{x:G}=$;if("complex64"!==G.dtype)return Fill_fill({attrs:{shape:G.shape,dtype:G.dtype,value:"string"===G.dtype?"":0},backend:V});{let F=real({inputs:{input:G},backend:V}),$=ZerosLike_zerosLike({inputs:{x:F},backend:V}),H=Imag_imag({inputs:{input:G},backend:V}),K=ZerosLike_zerosLike({inputs:{x:H},backend:V}),Z=complex({inputs:{real:$,imag:K},backend:V});return V.disposeIntermediateTensorInfo(F),V.disposeIntermediateTensorInfo($),V.disposeIntermediateTensorInfo(H),V.disposeIntermediateTensorInfo(K),Z}}let mr={kernelName:eD.RuY,backendName:"webgl",kernelFunc:ZerosLike_zerosLike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OnesLike_onesLike(F){let{inputs:$,backend:V}=F,{x:G}=$;if("string"===G.dtype)throw Error("onesLike is not supported under string dtype");if("complex64"!==G.dtype)return Fill_fill({attrs:{shape:G.shape,dtype:G.dtype,value:1},backend:V});{let F=real({inputs:{input:G},backend:V}),$=OnesLike_onesLike({inputs:{x:F},backend:V}),H=Imag_imag({inputs:{input:G},backend:V}),K=ZerosLike_zerosLike({inputs:{x:H},backend:V}),Z=complex({inputs:{real:$,imag:K},backend:V});return V.disposeIntermediateTensorInfo(F),V.disposeIntermediateTensorInfo($),V.disposeIntermediateTensorInfo(H),V.disposeIntermediateTensorInfo(K),Z}}let mn={kernelName:eD.qWM,backendName:"webgl",kernelFunc:OnesLike_onesLike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pack_pack(F){let{inputs:$,backend:V,attrs:G}=F,{axis:H}=G;if(1===$.length)return ExpandDims_expandDims({inputs:{input:$[0]},backend:V,attrs:{dim:H}});let K=$[0].shape,Z=$[0].dtype;$.forEach(F=>{eD.D5U.assertShapesMatch(K,F.shape,"All tensors passed to stack must have matching shapes"),eD.D5U.assert(Z===F.dtype,()=>"All tensors passed to stack must have matching dtypes")});let ee=[],et=$.map(F=>{let $=ExpandDims_expandDims({inputs:{input:F},backend:V,attrs:{dim:H}});return ee.push($),$}),en=kernels_Concat_concat({inputs:et,backend:V,attrs:{axis:H}});return ee.forEach(F=>V.disposeIntermediateTensorInfo(F)),en}let ma={kernelName:eD.QiL,backendName:"webgl",kernelFunc:Pack_pack};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PadProgram=class PadProgram{constructor(F,$,V){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=$.map(($,V)=>$[0]+F[V]+$[1]);let G=F.length,H=(0,cU.kW)(G),K=$.map(F=>F[0]).join(","),Z=$.map(($,V)=>$[0]+F[V]).join(","),ee=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,G);if(1===G){this.userCode=`
        int start = ${K};
        int end = ${Z};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${H} start = ${H}(${K});
      ${H} end = ${H}(${Z});

      void main() {
        ${H} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${H} coords = outC - start;
          setOutput(getX(${ee}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PadPackedProgram=class PadPackedProgram{constructor(F,$,V){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=$.map(($,V)=>$[0]+F[V]+$[1]);let G=F.length,H=(0,cU.kW)(G),K=$.map(F=>F[0]).join(","),Z=$.map(($,V)=>$[0]+F[V]).join(","),ee=(0,cV.Ky)("rc",G),et=(0,cV.Ky)("source",G),en=`${ee[G-1]} < ${this.outputShape[G-1]}`,ea=1===G?"source":`vec2(${et.slice(-2).join()})`,ei=[`${H} rc = outputLoc;`,`${ee[G-1]} += 1;
       if(${en}) {
      `,1===G?"":`}
       rc = outputLoc;
       ${ee[G-2]} += 1;
       if(${ee[G-2]} < ${this.outputShape[G-2]}) {`,1===G?"":`  ${ee[G-1]} += 1;
         if(${en}) {`],eo=1===G?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",es="";for(let F=0,$=1===G?2:4;F<$;F++)es+=`
        ${ei[F]}
        if (${eo}) {
          result[${F}] = float(value);
        } else {
          ${H} source = rc - start;
          result[${F}] = getChannel(getX(${et.join()}), ${ea});
        }
      `;es+=1===G?"} ":"}}",this.userCode=`
      const ${H} start = ${H}(${K});
      const ${H} end = ${H}(${Z});

      void main() {
        ${H} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${es}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PadV2_padV2=F=>{let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{paddings:K,constantValue:Z}=G;if(0===eD.D5U.sizeFromShape(H.shape)){let F=K.map((F,$)=>F[0]+H.shape[$]+F[1]);return Fill_fill({backend:V,attrs:{shape:F,value:Z,dtype:H.dtype}})}let ee=(0,eD.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PadPackedProgram(H.shape,K,Z):new PadProgram(H.shape,K,Z),et=[[Z]];return V.runWebGLProgram(ee,[H],H.dtype,et)},mo={kernelName:eD.lyA,backendName:"webgl",kernelFunc:PadV2_padV2},mu=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,ml=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+cW+`
  return result;
`,mc=binaryKernelFunc({opSnippet:mu,packedOpSnippet:ml}),mp={kernelName:eD.pe_,backendName:"webgl",kernelFunc:mc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Prod_prod(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V,{axis:Z,keepDims:ee}=H,et=K.shape.length,en=[],ea=eD.D5U.parseAxisParam(Z,K.shape),ei=ea,eo=eD.backend_util.getAxesPermutation(ei,et),es=K;if(null!=eo&&(es=Transpose_transpose({inputs:{x:K},backend:G,attrs:{perm:eo}}),ei=eD.backend_util.getInnerMostAxes(ei.length,et),en.push(es)),eD.backend_util.assertAxesAreInnerMostDims("prod",ei,et),G.shouldExecuteOnCPU([es])){let F=G.texData.get(es.dataId).values,{outVals:V,outShape:H,outDtype:K}=(0,c5.Tg)(es.shape,es.dtype,F,ei);$=G.makeTensorInfo(H,K,V)}else{let[F,V]=eD.backend_util.computeOutAndReduceShapes(es.shape,ei),H=eD.D5U.sizeFromShape(V),Z=kernels_Reshape_reshape({inputs:{x:es},backend:G,attrs:{shape:[-1,H]}}),ee=(0,eD.z4k)(K.dtype),et=reduce(Z,ee,"prod",G);$=kernels_Reshape_reshape({inputs:{x:et},backend:G,attrs:{shape:F}}),en.push(Z),en.push(et)}if(ee){en.push($);let F=eD.backend_util.expandShapeToKeepDim($.shape,ea);$=kernels_Reshape_reshape({inputs:{x:$},backend:G,attrs:{shape:F}})}return en.forEach(F=>G.disposeIntermediateTensorInfo(F)),$}let mh={kernelName:eD.DlI,backendName:"webgl",kernelFunc:Prod_prod};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RaggedGather_raggedGather(F){let{inputs:$,backend:V,attrs:G}=F,{paramsNestedSplits:H,paramsDenseValues:K,indices:Z}=$,{outputRaggedRank:ee}=G,et=H.map(F=>V.readSync(F.dataId)),en=H.map(F=>F.shape),ea=V.readSync(K.dataId),ei=V.readSync(Z.dataId),[eo,es,eu]=(0,c5.Qs)(et,en,ea,K.shape,K.dtype,ei,Z.shape,ee),ec=eo.map(F=>V.makeTensorInfo([F.length],"int32",F)),ep=V.makeTensorInfo(eu,K.dtype,es);return ec.concat([ep])}let md={kernelName:eD.dDz,backendName:"webgl",kernelFunc:RaggedGather_raggedGather};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RaggedRange_raggedRange(F){let{inputs:$,backend:V}=F,{starts:G,limits:H,deltas:K}=$,Z=V.readSync(G.dataId),ee=V.readSync(H.dataId),et=V.readSync(K.dataId),[en,ea]=(0,c5.M8)(Z,G.shape,G.dtype,ee,H.shape,et,K.shape),ei=V.makeTensorInfo([en.length],"int32",en),eo=V.makeTensorInfo([ea.length],G.dtype,ea);return[ei,eo]}let mm={kernelName:eD.CQl,backendName:"webgl",kernelFunc:RaggedRange_raggedRange};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RaggedTensorToTensor_raggedTensorToTensor(F){let{inputs:$,backend:V,attrs:G}=F,{shape:H,values:K,defaultValue:Z,rowPartitionTensors:ee}=$,{rowPartitionTypes:et}=G,en=V.readSync(H.dataId),ea=V.readSync(K.dataId),ei=V.readSync(Z.dataId),eo=ee.map(F=>V.readSync(F.dataId)),es=ee.map(F=>F.shape),[eu,ec]=(0,c5.fy)(en,H.shape,ea,K.shape,K.dtype,ei,Z.shape,eo,es,et);return V.makeTensorInfo(eu,K.dtype,ec)}let mg={kernelName:eD.BiW,backendName:"webgl",kernelFunc:RaggedTensorToTensor_raggedTensorToTensor},Range_range=F=>{let{backend:$,attrs:V}=F,{start:G,stop:H,step:K,dtype:Z}=V,ee=(0,c5.hO)(G,H,K,Z);return $.makeTensorInfo([ee.length],Z,ee)},my={kernelName:eD.e6w,backendName:"webgl",kernelFunc:Range_range},mb="return 1.0 / x;",mx=unaryKernelFunc({opSnippet:mb}),mv={kernelName:eD.$HU,backendName:"webgl",kernelFunc:mx},mw=cJ.D1+`
  return (x < 0.0) ? 0.0 : x;
`,mS=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,m_=unaryKernelFunc({opSnippet:mw,packedOpSnippet:mS}),mN={kernelName:eD.qkr,backendName:"webgl",kernelFunc:m_},mk=cJ.D1+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,mI=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mT=unaryKernelFunc({opSnippet:mk,packedOpSnippet:mI}),mC={kernelName:eD.SbG,backendName:"webgl",kernelFunc:mT};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeBilinearProgram=class ResizeBilinearProgram{constructor(F,$,V,G,H){let K;this.variableNames=["A"],this.outputShape=[];let[Z,ee,et,en]=F;this.outputShape=[Z,$,V,en];let ea=[G&&$>1?ee-1:ee,G&&V>1?et-1:et],ei=[G&&$>1?$-1:$,G&&V>1?V-1:V];K=H?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${ea[0]/ei[0]},
          ${ea[1]/ei[1]});
      const vec2 inputShapeRC = vec2(${ee}.0, ${et}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${K};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeBilinearPackedProgram=class ResizeBilinearPackedProgram{constructor(F,$,V,G,H){let K;this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[Z,ee,et,en]=F;this.outputShape=[Z,$,V,en];let ea=[G&&$>1?ee-1:ee,G&&V>1?et-1:et],ei=[G&&$>1?$-1:$,G&&V>1?V-1:V];K=H?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${ea[0]/ei[0]},
          ${ea[1]/ei[1]},
          ${ea[1]/ei[1]});
      const vec3 inputShapeRC = vec3(${ee}.0, ${et}.0,
                                     ${et}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${K};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${en-1};
        bool hasNextRow = coords.z < ${V-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ResizeBilinear_resizeBilinear(F){let{inputs:$,backend:V,attrs:G}=F,{images:H}=$,{alignCorners:K,halfPixelCenters:Z,size:ee}=G,[et,en]=ee,ea=(0,eD.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeBilinearPackedProgram(H.shape,et,en,K,Z):new ResizeBilinearProgram(H.shape,et,en,K,Z);return V.runWebGLProgram(ea,[H],"float32")}let mE={kernelName:eD._Yw,backendName:"webgl",kernelFunc:ResizeBilinear_resizeBilinear};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeBilinearBackpropProgram=class ResizeBilinearBackpropProgram{constructor(F,$,V){this.variableNames=["dy"],this.outputShape=[],this.outputShape=$;let[,G,H]=$,[,K,Z]=F,ee=[V&&K>1?G-1:G,V&&Z>1?H-1:H],et=[V&&K>1?K-1:K,V&&Z>1?Z-1:Z],en=ee[0]/et[0],ea=ee[1]/et[1],ei=1/en,eo=1/ea,es=2*Math.ceil(ei)+2,eu=2*Math.ceil(eo)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${en});
        const float widthScale = float(${ea});

        const float invHeightScale = float(${ei});
        const float invWidthScale = float(${eo});

        const int winHeight = int(${es});
        const int winWidth = int(${eu});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${K}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${Z}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${G-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${H-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ResizeBilinearGrad_resizeBilinearGrad(F){let{inputs:$,backend:V,attrs:G}=F,{images:H,dy:K}=$,{alignCorners:Z}=G,ee=new ResizeBilinearBackpropProgram(K.shape,H.shape,Z);return V.runWebGLProgram(ee,[K],K.dtype)}let mA={kernelName:eD.zbQ,backendName:"webgl",kernelFunc:ResizeBilinearGrad_resizeBilinearGrad};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeNearestNeighborProgram=class ResizeNearestNeighborProgram{constructor(F,$,V,G,H){let K;this.variableNames=["A"],this.outputShape=[];let[Z,ee,et,en]=F;this.outputShape=[Z,$,V,en];let ea=[G&&$>1?ee-1:ee,G&&V>1?et-1:et],ei=[G&&$>1?$-1:$,G&&V>1?V-1:V],eo=G?"0.5":"0.0";K=H?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${ea[0]/ei[0]},
          ${ea[1]/ei[1]});
      const vec2 inputShapeRC = vec2(${ee}.0, ${et}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${K};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${eo})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeNearestNeighborPackedProgram=class ResizeNearestNeighborPackedProgram{constructor(F,$,V,G,H){let K;this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[Z,ee,et,en]=F;this.outputShape=[Z,$,V,en];let ea=[G&&$>1?ee-1:ee,G&&V>1?et-1:et],ei=[G&&$>1?$-1:$,G&&V>1?V-1:V],eo=G?"0.5":"0.0";K=H?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${ea[0]/ei[0]},
          ${ea[1]/ei[1]},
          ${ea[1]/ei[1]});
      const vec3 inputShapeRC = vec3(${ee}.0, ${et}.0,
                                     ${et}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${K};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${eo})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${en-1};
        bool hasNextRow = coords.z < ${V-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ResizeNearestNeighbor_resizeNearestNeighbor(F){let{inputs:$,backend:V,attrs:G}=F,{images:H}=$,{alignCorners:K,halfPixelCenters:Z,size:ee}=G,[et,en]=ee,ea=(0,eD.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeNearestNeighborPackedProgram(H.shape,et,en,K,Z):new ResizeNearestNeighborProgram(H.shape,et,en,K,Z);return V.runWebGLProgram(ea,[H],H.dtype)}let mD={kernelName:eD.dpD,backendName:"webgl",kernelFunc:ResizeNearestNeighbor_resizeNearestNeighbor};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeNearestNeigborBackpropProgram=class ResizeNearestNeigborBackpropProgram{constructor(F,$,V){this.variableNames=["dy"],this.outputShape=[],this.outputShape=$;let[,G,H]=$,[,K,Z]=F,ee=[V&&K>1?G-1:G,V&&Z>1?H-1:H],et=[V&&K>1?K-1:K,V&&Z>1?Z-1:Z],en=ee[0]/et[0],ea=ee[1]/et[1],ei=1/en,eo=1/ea,es=2*Math.ceil(ei)+2,eu=2*Math.ceil(eo)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${en});
        const float widthScale = float(${ea});

        const float invHeightScale = float(${ei});
        const float invWidthScale = float(${eo});

        const int winHeight = int(${es});
        const int winWidth = int(${eu});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${K}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${Z}) {
              continue;
            }

            float sourceFracRow =
              float(${ee[0]}) *
                (float(dyR) / float(${et[0]}));

            float sourceFracCol =
                float(${ee[1]}) *
                  (float(dyC) / float(${et[1]}));

            int sourceNearestRow = int(min(
                float(int(${G}) - 1),
                ${V} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${H}) - 1),
                ${V} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ResizeNearestNeighborGrad_resizeNearestNeighborGrad(F){let{inputs:$,backend:V,attrs:G}=F,{images:H,dy:K}=$,{alignCorners:Z}=G,ee=new ResizeNearestNeigborBackpropProgram(K.shape,H.shape,Z);return V.runWebGLProgram(ee,[K],K.dtype)}let mM={kernelName:eD.Hmb,backendName:"webgl",kernelFunc:ResizeNearestNeighborGrad_resizeNearestNeighborGrad};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ReverseProgram=class ReverseProgram{constructor(F,$){this.variableNames=["x"];let V=F.length;if(V>4)throw Error(`WebGL backend: Reverse of rank-${V} tensor is not yet supported`);if(this.outputShape=F,1===V){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${F[0]} - coord - 1));
        }
      `;return}let getInCoord=V=>-1!==$.indexOf(V)&&1!==F[V]?`${F[V]} - coords[${V}] - 1`:`coords[${V}]`,G=F.map((F,$)=>getInCoord($)).join(","),H=(0,cU.kW)(V);this.userCode=`
      void main() {
        ${H} coords = getOutputCoords();
        setOutput(getX(${G}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ReversePackedProgram=class ReversePackedProgram{constructor(F,$){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let V=F.length;if(V>4)throw Error(`WebGL backend: Reverse of rank-${V} tensor is not yet supported`);this.outputShape=F;let G=(0,cV.Ky)("rc",V),H=`${G[V-1]} + 1 < ${this.outputShape[V-1]}`,K=`${G[V-2]} + 1 < ${this.outputShape[V-2]}`,Z=(0,cU.kW)(V);function getR(F){return getChannel(F)}function getG(F){return F[V-1]="("+F[V-1]+" + 1)",getChannel(F)}function getB(F){return F[V-2]="("+F[V-2]+" + 1)",getChannel(F)}function getA(F){return F[V-1]="("+F[V-1]+" + 1)",F[V-2]="("+F[V-2]+" + 1)",getChannel(F)}function getChannel($){let V=F.map((F,V)=>getInCoord(V,$)),G=V.join(","),H=V.slice(-2).join(",");return`getChannel(getX(${G}), vec2(${H}))`}function getInCoord(V,G){return -1!==$.indexOf(V)&&1!==F[V]?`${F[V]} - ${G[V]} - 1`:`${G[V]}`}1===V?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${F[0]} - rc - 1),
            ${F[0]} - rc - 1);
          if(${H}){
              result.g = getChannel(getX(${F[0]} - (rc  + 1) - 1),
                ${F[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${Z} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getR(G.slice())};
          if(${H}){
            result.g = ${getG(G.slice())};
          }
          if(${K}) {
            result.b = ${getB(G.slice())};
            if(${H}) {
              result.a = ${getA(G.slice())};
            }
          }
          setOutput(result);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Reverse_reverse(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{dims:K}=G,Z=H.shape.length,ee=eD.D5U.parseAxisParam(K,H.shape);if(0===Z)return Identity_identity({inputs:{x:H},backend:V});let et=(0,eD.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ReversePackedProgram(H.shape,ee):new ReverseProgram(H.shape,ee);return V.runWebGLProgram(et,[H],H.dtype)}let mR={kernelName:eD.mKl,backendName:"webgl",kernelFunc:kernels_Reverse_reverse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let RotateProgram=class RotateProgram{constructor(F,$){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let V=F[1],G=F[2];this.outputShape=F;let H="";H="number"==typeof $?`float outputValue = ${$.toFixed(2)};`:`
        vec3 fill = vec3(${$.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${H}
          if(coordX >= 0 && coordX < ${G} && coordY >= 0 && coordY < ${V}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mF={kernelName:eD.b9H,backendName:"webgl",kernelFunc:({inputs:F,attrs:$,backend:V})=>{let{image:G}=F,{radians:H,fillValue:K,center:Z}=$,ee=V,et=new RotateProgram(G.shape,K),[en,ea]=eD.backend_util.getImageCenter(Z,G.shape[1],G.shape[2]),ei=[[en,ea,Math.sin(H),Math.cos(H)]],eo=ee.runWebGLProgram(et,[G],G.dtype,ei);return eo}},mO=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,mP=unaryKernelFunc({opSnippet:mO}),mB={kernelName:eD.e07,backendName:"webgl",kernelFunc:mP},m$="return inversesqrt(x);",mL=unaryKernelFunc({opSnippet:m$,cpuKernelImpl:c5.St}),mz={kernelName:eD.bV0,backendName:"webgl",kernelFunc:mL};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ScatterProgram=class ScatterProgram{constructor(F,$,V,G,H,K,Z=!0,ee=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=K;let et=(0,cU.kW)(H.length),en=(0,cU.kW)(K.length),ea="";1===V?ea="i":2===V&&(ea="i, j");let ei=`getIndices(${ea})`,eo="";1===G?eo="i":2===G&&(eo="i, coords[1]");let es=`getUpdates(${eo})`,eu="";ee&&(eu="coords[0], coords[1]");let ec=`getDefaultValue(${eu})`,ep=$>1?"strides[j]":"strides";this.userCode=`
        ${et} strides = ${et}(${H});

        void main() {
          ${en} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${F}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${$}; j++) {
              int index = round(${ei});
              flattenedIndex += index * ${ep};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${es};
              found = true;
            }
          }
          setOutput(mix(${ec}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ScatterPackedProgram=class ScatterPackedProgram{constructor(F,$,V,G,H,K,Z=!0,ee=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=K;let et=(0,cU.kW)(H.length),en=(0,cU.kW)(K.length),ea="";1===V?ea="i":2===V&&(ea="i, j");let ei=`getIndices(${ea})`,eo="";1===G?eo="i":2===G&&(eo="i, coords[1]");let es=`getUpdates(${eo})`,eu="";ee&&(eu="coords[0], coords[1]");let ec=`getDefaultValue(${eu})`,ep=$>1?"strides[j]":"strides",eh=$>1?"strides[j + 1]":"strides";this.userCode=`
        ${et} strides = ${et}(${H});

        void main() {
          ${en} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${F}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${$}; j+=2) {
              ivec4 index = round(${ei});
              flattenedIndex += index.xz * ${ep};
              if (j + 1 < ${$}) {
                flattenedIndex += index.yw * ${eh};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${es};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${ec}, sum, found));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ScatterNd_scatterNd(F){let $;let{inputs:V,backend:G,attrs:H}=F,{indices:K,updates:Z}=V,{shape:ee}=H,{sliceRank:et,numUpdates:en,sliceSize:ea,strides:ei,outputSize:eo}=eD.backend_util.calculateShapes(Z,K,ee),es=[eo/ea,ea];if(0===eo)return G.makeTensorInfo(ee,K.dtype);let eu=kernels_Reshape_reshape({inputs:{x:K},backend:G,attrs:{shape:[en,et]}}),ec=kernels_Reshape_reshape({inputs:{x:Z},backend:G,attrs:{shape:[en,ea]}}),ep=G.makeTensorInfo([],"float32",new Float32Array([0]));$=(0,eD.OBj)().getBool("WEBGL_PACK")?new ScatterPackedProgram(en,et,eu.shape.length,ec.shape.length,ei,es):new ScatterProgram(en,et,eu.shape.length,ec.shape.length,ei,es);let eh=G.runWebGLProgram($,[ec,eu,ep],ec.dtype),ef=kernels_Reshape_reshape({inputs:{x:eh},backend:G,attrs:{shape:ee}});return G.disposeIntermediateTensorInfo(eu),G.disposeIntermediateTensorInfo(ec),G.disposeIntermediateTensorInfo(eh),G.disposeIntermediateTensorInfo(ep),ef}let mV={kernelName:eD.xQA,backendName:"webgl",kernelFunc:ScatterNd_scatterNd};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SearchSortedProgram=class SearchSortedProgram{constructor(F,$,V,G){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[F,V];let H="while (left < right) {",K=`for (int i = 0; i < ${Math.ceil(Math.log2($+1))}; ++i) { if (left >= right) break;`,Z=2===(0,eD.OBj)().getNumber("WEBGL_VERSION")?H:K,ee="left"===G?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${Z}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${ee} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SearchSorted_searchSorted(F){let{inputs:$,backend:V,attrs:G}=F,{sortedSequence:H,values:K}=$,{side:Z}=G,ee=new SearchSortedProgram(H.shape[0],H.shape[1],K.shape[1],Z),et=[[H.shape[1]]];return V.runWebGLProgram(ee,[H,K],"int32",et)}let mU={kernelName:eD.nr8,backendName:"webgl",kernelFunc:SearchSorted_searchSorted};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SelectProgram=class SelectProgram{constructor(F,$,V){let G,H;if(this.variableNames=["c","a","b"],this.outputShape=$,V>4)throw Error(`Where for rank ${V} is not yet supported`);if(1===V)H="resRC",G="resRC";else{let V=["resRC.x","resRC.y","resRC.z","resRC.w"],K=[],Z=[];for(let G=0;G<$.length;G++)Z.push(`${V[G]}`),G<F&&K.push(`${V[G]}`);G=K.join(),H=Z.join()}let K=(0,cU.kW)(V);this.userCode=`
      void main() {
        ${K} resRC = getOutputCoords();
        float cVal = getC(${G});
        if (cVal >= 1.0) {
          setOutput(getA(${H}));
        } else {
          setOutput(getB(${H}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Select_select(F){let{inputs:$,backend:V}=F,{condition:G,t:H,e:K}=$,Z=new SelectProgram(G.shape.length,H.shape,H.shape.length);return V.runWebGLProgram(Z,[G,H,K],(0,eD.x8V)(H.dtype,K.dtype))}let mW={kernelName:eD.PhF,backendName:"webgl",kernelFunc:kernels_Select_select},mj=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${eD.backend_util.SELU_SCALEALPHA};
  float scale = ${eD.backend_util.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,mG=unaryKernelFunc({opSnippet:mj}),mq={kernelName:eD.oFR,backendName:"webgl",kernelFunc:mG},mH=c4+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,mX=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mK=unaryKernelFunc({opSnippet:mH,packedOpSnippet:mX,cpuKernelImpl:c5.UN}),mQ={kernelName:eD.a5O,backendName:"webgl",kernelFunc:mK},mZ=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,mY=unaryKernelFunc({opSnippet:mZ}),mJ={kernelName:eD.i5y,backendName:"webgl",kernelFunc:mY},m0=c4+`
  return sin(x);
`,m1=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${cW}
  return result;
`,m2=unaryKernelFunc({opSnippet:m0,packedOpSnippet:m1}),m3={kernelName:eD.RQH,backendName:"webgl",kernelFunc:m2},m4=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,m6=unaryKernelFunc({opSnippet:m4}),m5={kernelName:eD.wYB,backendName:"webgl",kernelFunc:m6},m9=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,m8=unaryKernelFunc({opSnippet:m9}),m7={kernelName:eD.MRv,backendName:"webgl",kernelFunc:m8},SpaceToBatchND_spaceToBatchND=F=>{let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{blockShape:K,paddings:Z}=G;eD.D5U.assert(H.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let ee=K.reduce((F,$)=>F*$),et=[[0,0]];et.push(...Z);for(let F=1+K.length;F<H.shape.length;++F)et.push([0,0]);let en=[],ea=PadV2_padV2({inputs:{x:H},backend:V,attrs:{paddings:et,constantValue:0}}),ei=eD.backend_util.getReshaped(ea.shape,K,ee,!1),eo=eD.backend_util.getPermuted(ei.length,K.length,!1),es=eD.backend_util.getReshapedPermuted(ea.shape,K,ee,!1),eu=kernels_Reshape_reshape({inputs:{x:ea},backend:V,attrs:{shape:ei}}),ec=Transpose_transpose({inputs:{x:eu},backend:V,attrs:{perm:eo}}),ep=kernels_Reshape_reshape({inputs:{x:ec},backend:V,attrs:{shape:es}});return en.push(ea),en.push(eu),en.push(ec),en.forEach(F=>V.disposeIntermediateTensorInfo(F)),ep},ge={kernelName:eD.TQc,backendName:"webgl",kernelFunc:SpaceToBatchND_spaceToBatchND};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SparseFillEmptyRows_sparseFillEmptyRows(F){let{inputs:$,backend:V}=F,{indices:G,values:H,denseShape:K,defaultValue:Z}=$;if(1!==K.shape.length)throw Error(`Dense shape must be a vector, saw:
         ${K.shape}`);if(2!==G.shape.length)throw Error(`Indices must be a matrix, saw:
         ${G.shape}`);if(1!==H.shape.length)throw Error(`Values must be a vector, saw:
         ${H.shape}`);if(0!==Z.shape.length)throw Error(`Default value must be a scalar, saw:
        ${Z.shape}`);let ee=V.readSync(G.dataId),et=V.readSync(H.dataId),en=V.readSync(K.dataId),ea=V.readSync(Z.dataId)[0],[ei,eo,es,eu,ec]=(0,c5.X8)(ee,G.shape,G.dtype,et,H.dtype,en,ea);return[V.makeTensorInfo(eo,G.dtype,ei),V.makeTensorInfo([eo[0]],H.dtype,es),V.makeTensorInfo([eu.length],"bool",new Uint8Array(eu.map(F=>Number(F)))),V.makeTensorInfo([ec.length],G.dtype,new Int32Array(ec))]}let gt={kernelName:eD.O3z,backendName:"webgl",kernelFunc:SparseFillEmptyRows_sparseFillEmptyRows};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SparseReshape_sparseReshape(F){let{inputs:$,backend:V}=F,{inputIndices:G,inputShape:H,newShape:K}=$;if(2!==G.shape.length)throw Error(`Input indices should be a matrix but received shape ${G.shape}`);if(1!==H.shape.length)throw Error(`Input shape should be a vector but received shape ${H.shape}`);if(1!==K.shape.length)throw Error(`Target shape should be a vector but received shape ${K.shape}`);let Z=Array.from(V.readSync(H.dataId)),ee=V.readSync(G.dataId),et=Array.from(V.readSync(K.dataId)),[en,ea,ei]=(0,c5.LS)(ee,G.shape,G.dtype,Z,et);return[V.makeTensorInfo(ea,G.dtype,en),V.makeTensorInfo([ei.length],K.dtype,new Int32Array(ei))]}let gr={kernelName:eD.nhH,backendName:"webgl",kernelFunc:SparseReshape_sparseReshape};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SparseSegmentMean_sparseSegmentMean(F){let{inputs:$,backend:V}=F,{data:G,indices:H,segmentIds:K}=$;if(G.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==H.shape.length)throw Error(`Indices should be a vector but received shape
              ${H.shape}`);if(1!==K.shape.length)throw Error(`Segment ids should be a vector but received shape
              ${K.shape}`);let Z=V.readSync(G.dataId),ee=V.readSync(H.dataId),et=V.readSync(K.dataId),[en,ea]=(0,c5.AR)(Z,G.shape,G.dtype,ee,et,!0);return V.makeTensorInfo(ea,G.dtype,en)}let gn={kernelName:eD.w3H,backendName:"webgl",kernelFunc:SparseSegmentMean_sparseSegmentMean};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SparseSegmentSum_sparseSegmentSum(F){let{inputs:$,backend:V}=F,{data:G,indices:H,segmentIds:K}=$;if(G.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==H.shape.length)throw Error(`Indices should be a vector but received shape
             ${H.shape}`);if(1!==K.shape.length)throw Error(`Segment ids should be a vector but received shape
             ${K.shape}`);let Z=V.readSync(G.dataId),ee=V.readSync(H.dataId),et=V.readSync(K.dataId),[en,ea]=(0,c5.AR)(Z,G.shape,G.dtype,ee,et);return V.makeTensorInfo(ea,G.dtype,en)}let ga={kernelName:eD.ZjV,backendName:"webgl",kernelFunc:SparseSegmentSum_sparseSegmentSum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SparseToDense_sparseToDense(F){let{inputs:$,backend:V,attrs:G}=F,{sparseIndices:H,sparseValues:K,defaultValue:Z}=$,{outputShape:ee}=G,{sliceRank:et,numUpdates:en,sliceSize:ea,strides:ei,outputSize:eo}=eD.backend_util.calculateShapes(K,H,ee),es=!1;if("string"===K.dtype){let F=V.bufferSync(H),$=V.bufferSync(K),G=eD.D5U.decodeString(V.readSync(Z.dataId)[0]),eu=(0,c5.Y1)(F,$,ee,eo,ea,en,et,ei,G,es);return V.makeTensorInfo(ee,eu.dtype,eu.values)}let eu=new ScatterProgram(en,et,H.shape.length,K.shape.length,ei,[eo,1],es),ec=V.runWebGLProgram(eu,[K,H,Z],K.dtype),ep=kernels_Reshape_reshape({inputs:{x:ec},backend:V,attrs:{shape:ee}});return V.disposeIntermediateTensorInfo(ec),ep}let gi={kernelName:eD.D2d,backendName:"webgl",kernelFunc:SparseToDense_sparseToDense};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SplitV_splitV(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{numOrSizeSplits:K,axis:Z}=G,ee=eD.D5U.parseAxisParam(Z,H.shape)[0],et=eD.backend_util.prepareSplitSize(H,K,ee),en=H.shape.length,ea=Array(en).fill(0),ei=H.shape.slice();return et.map(F=>{let $=[...ei];$[ee]=F;let G=Slice_slice({inputs:{x:H},backend:V,attrs:{begin:ea,size:$}});return ea[ee]+=F,G})}let go={kernelName:eD.L8s,backendName:"webgl",kernelFunc:SplitV_splitV},gs="return sqrt(x);",gu=unaryKernelFunc({opSnippet:gs,packedOpSnippet:gs,cpuKernelImpl:c5.Bk}),gc={kernelName:eD.FKq,backendName:"webgl",kernelFunc:gu},gp="return x * x;",gh=unaryKernelFunc({opSnippet:gp}),gf={kernelName:eD.bK0,backendName:"webgl",kernelFunc:gh},gd="return (a - b) * (a - b);",gm=binaryKernelFunc({opSnippet:gd,packedOpSnippet:gd}),gg={kernelName:eD._tC,backendName:"webgl",kernelFunc:gm};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function staticRegexReplace(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$;if("string"!==H.dtype)throw Error("Input must be of datatype string");let K=V.readSync(H.dataId),Z=eD.backend_util.fromUint8ToStringArray(K),ee=(0,c5.F1)(Z,"string",G);return V.makeTensorInfo(H.shape,"string",ee)}let gy={kernelName:eD.e0R,backendName:"webgl",kernelFunc:staticRegexReplace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Step_step({inputs:F,attrs:$,backend:V}){let{x:G}=F,H=cJ.D1+`
    return x > 0.0 ? 1.0 : float(${$.alpha});
  `,K=new cJ.l(G.shape,H);return V.runWebGLProgram(K,[G],G.dtype)}let gb={kernelName:eD.h8e,backendName:"webgl",kernelFunc:kernels_Step_step};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let StridedSliceProgram=class StridedSliceProgram{constructor(F,$,V){this.variableNames=["x"],this.outputShape=V;let G=V.length,H=(0,cU.kW)(V.length),K=(0,cU.kW)(V.length),Z="";if(1===G)Z="coords * strides + begin";else{let F=0;Z=V.map(($,G)=>(F++,1===V.length?`coords * strides[${G}] + begin[${G}]`:`coords[${F-1}] * strides[${G}] + begin[${G}]`)).join(",")}this.userCode=`
      ${H} begin = ${H}(${F});
      ${H} strides = ${H}(${$});

      void main() {
        ${K} coords = getOutputCoords();
        setOutput(getX(${Z}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function StridedSlice_stridedSlice(F){let $;let{inputs:V,backend:G,attrs:H}=F,{x:K}=V,{begin:Z,end:ee,strides:et,beginMask:en,endMask:ea,ellipsisMask:ei,newAxisMask:eo,shrinkAxisMask:es}=H,{finalShapeSparse:eu,finalShape:ec,isIdentity:ep,sliceDim0:eh,isSimpleSlice:ef,begin:ed,end:em,strides:eg}=eD.kuN.sliceInfo(K.shape,Z,ee,et,en,ea,ei,eo,es);if(ep)$=kernels_Reshape_reshape({inputs:{x:K},backend:G,attrs:{shape:ec}});else if(eh||ef){eD.D5U.assert(K.shape.length>=1,()=>`Input must have rank at least 1, got: ${K.shape.length}`);let F=eD.kuN.computeOutShape(ed,em,eg),V=Slice_slice({inputs:{x:K},backend:G,attrs:{begin:ed,size:F}});$=kernels_Reshape_reshape({inputs:{x:V},backend:G,attrs:{shape:ec}}),G.disposeIntermediateTensorInfo(V)}else{let F=G.shouldExecuteOnCPU([K]);if(F){let F=G.readSync(K.dataId),V=(0,eD.f3b)(K.shape,K.dtype,F),H=(0,c5.$u)(eu,V,eg,ed);$=G.makeTensorInfo(ec,K.dtype,H.values)}else{let F=new StridedSliceProgram(ed,eg,eu);$=G.runWebGLProgram(F,[K],K.dtype)}}let ey=kernels_Reshape_reshape({inputs:{x:$},backend:G,attrs:{shape:ec}});return G.disposeIntermediateTensorInfo($),ey}let gx={kernelName:eD.jQk,backendName:"webgl",kernelFunc:StridedSlice_stridedSlice};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function StringNGrams_stringNGrams(F){let{inputs:$,backend:V,attrs:G}=F,{separator:H,nGramWidths:K,leftPad:Z,rightPad:ee,padWidth:et,preserveShortSequences:en}=G,{data:ea,dataSplits:ei}=$,eo=V.readSync(ea.dataId),es=V.readSync(ei.dataId),[eu,ec]=(0,c5.$j)(eo,es,H,K,Z,ee,et,en);return[V.makeTensorInfo([eu.length],"string",eu),V.makeTensorInfo(ei.shape,"int32",ec)]}let gv={kernelName:eD._JP,backendName:"webgl",kernelFunc:StringNGrams_stringNGrams};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function StringSplit_stringSplit(F){let{inputs:$,backend:V,attrs:G}=F,{skipEmpty:H}=G,{input:K,delimiter:Z}=$;if("string"!==K.dtype)throw Error("Input must be of datatype string");if(1!==K.shape.length)throw Error(`Input must be a vector, got shape: ${K.shape}`);if(0!==Z.shape.length)throw Error(`Delimiter must be a scalar, got shape: ${Z.shape}`);let ee=V.readSync(K.dataId),et=V.readSync(Z.dataId)[0],[en,ea,ei]=(0,c5.A0)(ee,et,H),eo=ea.length;return[V.makeTensorInfo([eo,2],"int32",en),V.makeTensorInfo([eo],"string",ea),V.makeTensorInfo([2],"int32",new Int32Array(ei))]}let gw={kernelName:eD.s1s,backendName:"webgl",kernelFunc:StringSplit_stringSplit};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function StringToHashBucketFast_stringToHashBucketFast(F){let{inputs:$,backend:V,attrs:G}=F,{numBuckets:H}=G,{input:K}=$;if("string"!==K.dtype)throw Error("Input must be of datatype string");if(H<=0)throw Error("Number of buckets must be at least 1");let Z=V.readSync(K.dataId),ee=(0,c5._9)(Z,H);return V.makeTensorInfo(K.shape,"int32",ee)}let gS={kernelName:eD.XkS,backendName:"webgl",kernelFunc:StringToHashBucketFast_stringToHashBucketFast},g_="return tan(x);",gN=unaryKernelFunc({opSnippet:g_}),gk={kernelName:eD.sEM,backendName:"webgl",kernelFunc:gN},gI=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,gT=unaryKernelFunc({opSnippet:gI}),gC={kernelName:eD.MIZ,backendName:"webgl",kernelFunc:gT};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TensorScatterUpdate_tensorScatterUpdate(F){let{inputs:$,backend:V,attrs:G}=F,{tensor:H,indices:K,updates:Z}=$,{}=G,{sliceRank:ee,numUpdates:et,sliceSize:en,strides:ea,outputSize:ei}=eD.backend_util.calculateShapes(Z,K,H.shape),eo=[ei/en,en];if(0===ei)return V.makeTensorInfo(H.shape,K.dtype);let es=kernels_Reshape_reshape({inputs:{x:K},backend:V,attrs:{shape:[et,ee]}}),eu=kernels_Reshape_reshape({inputs:{x:Z},backend:V,attrs:{shape:[et,en]}}),ec=kernels_Reshape_reshape({inputs:{x:H},backend:V,attrs:{shape:eo}}),ep=new ScatterProgram(et,ee,es.shape.length,eu.shape.length,ea,eo,!1,!0),eh=V.runWebGLProgram(ep,[eu,es,ec],ec.dtype),ef=kernels_Reshape_reshape({inputs:{x:eh},backend:V,attrs:{shape:H.shape}});return V.disposeIntermediateTensorInfo(es),V.disposeIntermediateTensorInfo(eu),V.disposeIntermediateTensorInfo(ec),V.disposeIntermediateTensorInfo(eh),ef}let gE={kernelName:eD.SIB,backendName:"webgl",kernelFunc:TensorScatterUpdate_tensorScatterUpdate};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TileProgram=class TileProgram{constructor(F,$){this.variableNames=["A"];let V=Array(F.length);for(let G=0;G<V.length;G++)V[G]=F[G]*$[G];this.outputShape=V,this.rank=V.length;let G=(0,cU.kW)(this.rank),H=tile_gpu_getSourceCoords(F);this.userCode=`
      void main() {
        ${G} resRC = getOutputCoords();
        setOutput(getA(${H}));
      }
    `}};function tile_gpu_getSourceCoords(F){let $=F.length;if($>5)throw Error(`Tile for rank ${$} is not yet supported`);if(1===$)return`imod(resRC, ${F[0]})`;let V=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],G=[];for(let $=0;$<F.length;$++)G.push(`imod(${V[$]}, ${F[$]})`);return G.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Tile_tile(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{reps:K}=G;if("string"===H.dtype||H.shape.length>5){let F=V.readSync(H.dataId),$="string"===H.dtype?F.map(F=>eD.D5U.decodeString(F)):F,G=(0,eD.f3b)(H.shape,H.dtype,$),Z=(0,c5.KX)(G,K);return V.makeTensorInfo(Z.shape,Z.dtype,Z.values)}let Z=new TileProgram(H.shape,K),ee=V.runWebGLProgram(Z,[H],H.dtype);return ee}let gA={kernelName:eD.n9L,backendName:"webgl",kernelFunc:kernels_Tile_tile};let SwapProgram=class SwapProgram{constructor(F){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=F,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}};let MergeProgram=class MergeProgram{constructor(F){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=F,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function disposeIntermediateTensorInfoOrNull(F,$){null!==$&&F.disposeIntermediateTensorInfo($)}function roundUpToPow2(F){let $=1;for(;$<F;)$*=2;return $}function TopK_topK(F){let{inputs:$,backend:V,attrs:G}=F,{x:H}=$,{k:K,sorted:Z}=G,ee=(0,eD.OBj)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),et=(0,eD.OBj)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),en=H.shape,ea=en[en.length-1];if(V.shouldExecuteOnCPU([H])||ea<ee||K>et){let F=V.readSync(H.dataId),[$,G]=(0,c5.oC)(F,en,H.dtype,K,Z);return[V.makeTensorInfo($.shape,$.dtype,$.values),V.makeTensorInfo(G.shape,G.dtype,G.values)]}if(0===K)return en[en.length-1]=0,[V.makeTensorInfo(en,H.dtype,[]),V.makeTensorInfo(en,"int32",[])];if(1===ea)return[H,Fill_fill({attrs:{shape:en,dtype:"int32",value:0},backend:V})];let ei=V.texData.get(H.dataId),eo=null!==ei&&ei.isPacked,es=eo?V.unpackTensor(H):H,eu=eD.D5U.sizeFromShape(en),ec=eu/ea,ep=kernels_Reshape_reshape({inputs:{x:es},attrs:{shape:[ec,ea]},backend:V});eo&&disposeIntermediateTensorInfoOrNull(V,es);let eh=roundUpToPow2(K),ef=roundUpToPow2(ea),ed=null,getInputs=()=>null===ed?[ep,ep]:[ep,ed],runSwap=(F,$,G)=>{let H=getInputs(),K=new SwapProgram(G),Z=null===ed?1:0,ee=[[ea],[Z],[Number.NEGATIVE_INFINITY],[F],[$]],et=ed;ed=V.runWebGLProgram(K,H,"int32",ee),disposeIntermediateTensorInfoOrNull(V,et)};for(let F=1;F<eh;F*=2){let $=2*F;for(let V=F;V>=1;V/=2)runSwap($,V,[ec,ef])}for(let F=ef;F>eh;F/=2){let $=getInputs(),G=new MergeProgram([ec,F/2]),H=null===ed?1:0,K=[[ea],[H],[eh]],Z=ed;ed=V.runWebGLProgram(G,$,"int32",K),disposeIntermediateTensorInfoOrNull(V,Z);let ee=eh/2,et=2*ee;for(let F=ee;F>=1;F/=2)runSwap(et,F,ed.shape)}let em=ed;ed=Slice_slice({inputs:{x:ed},backend:V,attrs:{begin:0,size:[ec,K]}}),disposeIntermediateTensorInfoOrNull(V,em);let eg=GatherV2_gatherV2({inputs:{x:ep,indices:ed},backend:V,attrs:{axis:1,batchDims:1}});disposeIntermediateTensorInfoOrNull(V,ep);let ey=en.slice(0,-1);ey.push(K),em=ed,ed=kernels_Reshape_reshape({inputs:{x:ed},attrs:{shape:ey},backend:V}),disposeIntermediateTensorInfoOrNull(V,em);let eb=eg;return eg=kernels_Reshape_reshape({inputs:{x:eg},attrs:{shape:ey},backend:V}),disposeIntermediateTensorInfoOrNull(V,eb),[eg,ed]}let gD={kernelName:eD.cWu,backendName:"webgl",kernelFunc:TopK_topK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TransformProgram=class TransformProgram{constructor(F,$,V,G,H,K){let Z;this.variableNames=["Image","Transforms"],this.outputShape=K;let ee="nearest"===V?1:2;switch(G){case"constant":default:Z=1;break;case"reflect":Z=2;break;case"wrap":Z=3;break;case"nearest":Z=4}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${Z} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${Z} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${Z} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${F} && 0 <= coordX && coordX < ${$}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${H});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${H});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${$}));
                float mapY = mapCoord(inY, float(${F}));

                if (${ee} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Transform_transform(F){let{inputs:$,backend:V,attrs:G}=F,{image:H,transforms:K}=$,{interpolation:Z,fillMode:ee,fillValue:et,outputShape:en}=G,[ea,ei,eo,es]=H.shape,[eu,ec]=null!=en?en:[ei,eo],ep=[ea,eu,ec,es],eh=new TransformProgram(ei,eo,Z,ee,et,ep);return V.runWebGLProgram(eh,[H,K],"float32")}let gM={kernelName:eD.wx7,backendName:"webgl",kernelFunc:Transform_transform};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kernels_Unique_unique(F){let{inputs:$,attrs:V,backend:G}=F,{axis:H}=V,{x:K}=$;(0,cO.assertNotComplex)(K,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let Z=G.readSync(K.dataId),{outputValues:ee,outputShape:et,indices:en}=(0,c5.CV)(Z,H,K.shape,K.dtype);return[G.makeTensorInfo(et,K.dtype,ee),G.makeTensorInfo([en.length],"int32",en)]}let gR={kernelName:eD.kpP,backendName:"webgl",kernelFunc:kernels_Unique_unique};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Unpack_unpack(F){let{inputs:$,backend:V,attrs:G}=F,{value:H}=$,{axis:K}=G;K<0&&(K+=H.shape.length);let Z=H,ee=Z.shape.length,et=H.shape[K],en=Array(ee-1),ea=0;for(let F=0;F<ee;F++)F!==K&&(en[ea++]=Z.shape[F]);let ei=[],eo=Array(ee).fill(0),es=Z.shape.slice();es[K]=1;let eu=Array(et);for(let F=0;F<eu.length;F++){eo[K]=F;let $=Slice_slice({inputs:{x:Z},backend:V,attrs:{begin:eo,size:es}}),G=kernels_Reshape_reshape({inputs:{x:$},backend:V,attrs:{shape:en}});eu[F]=G,ei.push($)}return ei.forEach(F=>V.disposeIntermediateTensorInfo(F)),eu}let gF={kernelName:eD.ToN,backendName:"webgl",kernelFunc:Unpack_unpack};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SegmentOpProgram=class SegmentOpProgram{constructor(F,$){this.variableNames=["x","segmentIds"];let V=F.windowSize,G=F.batchSize,H=F.inSize,K=F.numSegments,Z=K*Math.ceil(H/V);this.outputShape=[G,Z];let ee="0.0",et="sumValue",en=4*Math.floor(V/4),ea=V%4,ei=`
        sumValue += dot(values, segFilter);
    `,eo="";H%V>0&&(eo=`
        if (inIdx < 0 || inIdx >= ${H}) {
          return initializationValue;
        }
      `);let es="";H%V>0&&(es=`
        if (inIdx < 0 || inIdx >= ${H}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${ee};

      float getValue(int batch, int inIdx) {
        ${eo}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${es}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${K})) * float(${V}));
        int currentSeg = int(mod(float(outIdx), float(${K})));

        float sumValue = 0.0;

        for (int i = 0; i < ${en}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${ei}
        }

        int inIdx = inOffset + ${en};
        if (${1===ea}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${ei}
        } else if (${2===ea}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${ei}
        } else if (${3===ea}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${ei}
        }
        setOutput(${et});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UnsortedSegmentSum_unsortedSegmentSum(F){let{inputs:$,backend:V,attrs:G}=F,{x:H,segmentIds:K}=$,{numSegments:Z}=G,ee=H.shape.length,et=[],en=0,ea=eD.backend_util.getAxesPermutation([en],ee),ei=H;null!=ea&&(ei=Transpose_transpose({inputs:{x:H},backend:V,attrs:{perm:ea}}),et.push(ei),en=eD.backend_util.getInnerMostAxes(1,ee)[0]);let eo=eD.backend_util.segment_util.computeOutShape(ei.shape,en,Z),es=eD.D5U.sizeFromShape([ei.shape[en]]),eu=kernels_Reshape_reshape({inputs:{x:ei},backend:V,attrs:{shape:[-1,es]}});et.push(eu);let ec=(0,eD.z4k)(H.dtype),segOpCompute=(F,$,G,H,K)=>{let Z=F.shape[0],ee=F.shape[1],en=eD.backend_util.segment_util.segOpComputeOptimalWindowSize(ee,K),ea={windowSize:en,inSize:ee,batchSize:Z,numSegments:K},ei=new SegmentOpProgram(ea,$),eo=V.compileAndRun(ei,[F,G],H);if(et.push(eo),eo.shape[1]===K)return eo;let es=Range_range({backend:V,attrs:{start:0,stop:K,step:1,dtype:"float32"}}),eu=kernels_Tile_tile({inputs:{x:es},backend:V,attrs:{reps:[ee/en]}});et.push(es),et.push(eu);let ec=segOpCompute(eo,$,eu,H,K);return ec},ep=segOpCompute(eu,"unsortedSegmentSum",K,ec,Z),eh=kernels_Reshape_reshape({inputs:{x:ep},backend:V,attrs:{shape:eo}}),ef=eh;if(null!=ea){et.push(eh);let F=eD.backend_util.getUndoAxesPermutation(ea);ef=Transpose_transpose({inputs:{x:ef},backend:V,attrs:{perm:F}})}return et.forEach(F=>V.disposeIntermediateTensorInfo(F)),ef}let gO={kernelName:eD.Qvg,backendName:"webgl",kernelFunc:UnsortedSegmentSum_unsortedSegmentSum},gP=[pc,pf,pg,pw,pN,pI,pT,pC,pE,pA,pR,pP,pL,pW,pH,pX,pK,pQ,pZ,pY,pJ,p9,p8,ht,hr,hl,hh,hf,cq,hd,hg,hb,hx,hv,hw,hS,h_,hE,hM,hR,hP,hB,h$,hL,hz,hV,hU,hW,hj,hG,hK,hY,h2,h6,h7,fe,fa,fi,fo,fu,fh,fg,fb,fv,fw,fS,f_,fT,fD,cG,fM,hm,fO,f$,fV,cK,fG,fK,fQ,f0,f4,f8,dr,dl,dc,dh,df,dS,d_,dN,dI,dT,dC,dE,dA,dF,dO,dL,dK,c8,dY,d3,d6,d7,ho,mt,mn,ma,mo,mp,cY,mh,md,mm,mg,my,hs,dj,mv,mN,mC,pe,mE,mA,mD,mM,mR,mF,mB,mz,mV,mU,mW,mq,mQ,mJ,m3,m5,p5,dX,m7,ge,gt,gr,gn,ga,gi,go,gc,gf,gg,gy,gb,gx,gv,gw,gS,dH,po,gk,gC,gE,gA,gD,gM,pu,gR,gF,gO,mr];for(let F of gP)(0,eD.wCN)(F);/** @license See the LICENSE file. */let gB="4.15.0",g$={"tfjs-core":eD.jTM,"tfjs-backend-cpu":od,"tfjs-backend-webgl":cR,"tfjs-data":ol,"tfjs-layers":iD.i,"tfjs-converter":i7,tfjs:gB}},61977:function(F,$){var V;/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/!function(G){"use strict";var H=Math.cosh||function(F){return 1e-9>Math.abs(F)?1-F:(Math.exp(F)+Math.exp(-F))*.5},K=Math.sinh||function(F){return 1e-9>Math.abs(F)?F:(Math.exp(F)-Math.exp(-F))*.5},cosm1=function(F){var $=Math.PI/4;if(-$>F||F>$)return Math.cos(F)-1;var V=F*F;return V*(V*(V*(V*(V*(V*(V*(V/20922789888e3-1/87178291200)+1/479001600)-1/3628800)+1/40320)-1/720)+1/24)-.5)},hypot=function(F,$){var V=Math.abs(F),G=Math.abs($);return V<3e3&&G<3e3?Math.sqrt(V*V+G*G):(V<G?(V=G,G=F/$):G=$/F,V*Math.sqrt(1+G*G))},parser_exit=function(){throw SyntaxError("Invalid Param")};function logHypot(F,$){var V=Math.abs(F),G=Math.abs($);return 0===F?Math.log(G):0===$?Math.log(V):V<3e3&&G<3e3?.5*Math.log(F*F+$*$):.5*Math.log((F/=2)*F+($/=2)*$)+Math.LN2}var parse=function(F,$){var V={re:0,im:0};if(null==F)V.re=V.im=0;else if(void 0!==$)V.re=F,V.im=$;else switch(typeof F){case"object":if("im"in F&&"re"in F)V.re=F.re,V.im=F.im;else if("abs"in F&&"arg"in F){if(!Number.isFinite(F.abs)&&Number.isFinite(F.arg))return Complex.INFINITY;V.re=F.abs*Math.cos(F.arg),V.im=F.abs*Math.sin(F.arg)}else if("r"in F&&"phi"in F){if(!Number.isFinite(F.r)&&Number.isFinite(F.phi))return Complex.INFINITY;V.re=F.r*Math.cos(F.phi),V.im=F.r*Math.sin(F.phi)}else 2===F.length?(V.re=F[0],V.im=F[1]):parser_exit();break;case"string":V.im=V.re=0;var G=F.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g),H=1,K=0;null===G&&parser_exit();for(var Z=0;Z<G.length;Z++){var ee=G[Z];" "===ee||"	"===ee||"\n"===ee||("+"===ee?H++:"-"===ee?K++:("i"===ee||"I"===ee?(H+K===0&&parser_exit()," "===G[Z+1]||isNaN(G[Z+1])?V.im+=parseFloat((K%2?"-":"")+"1"):(V.im+=parseFloat((K%2?"-":"")+G[Z+1]),Z++)):((H+K===0||isNaN(ee))&&parser_exit(),"i"===G[Z+1]||"I"===G[Z+1]?(V.im+=parseFloat((K%2?"-":"")+ee),Z++):V.re+=parseFloat((K%2?"-":"")+ee)),H=K=0))}H+K>0&&parser_exit();break;case"number":V.im=0,V.re=F;break;default:parser_exit()}return isNaN(V.re)||isNaN(V.im),V};function Complex(F,$){if(!(this instanceof Complex))return new Complex(F,$);var V=parse(F,$);this.re=V.re,this.im=V.im}Complex.prototype={re:0,im:0,sign:function(){var F=this.abs();return new Complex(this.re/F,this.im/F)},add:function(F,$){var V=new Complex(F,$);return this.isInfinite()&&V.isInfinite()?Complex.NAN:this.isInfinite()||V.isInfinite()?Complex.INFINITY:new Complex(this.re+V.re,this.im+V.im)},sub:function(F,$){var V=new Complex(F,$);return this.isInfinite()&&V.isInfinite()?Complex.NAN:this.isInfinite()||V.isInfinite()?Complex.INFINITY:new Complex(this.re-V.re,this.im-V.im)},mul:function(F,$){var V=new Complex(F,$);return this.isInfinite()&&V.isZero()||this.isZero()&&V.isInfinite()?Complex.NAN:this.isInfinite()||V.isInfinite()?Complex.INFINITY:0===V.im&&0===this.im?new Complex(this.re*V.re,0):new Complex(this.re*V.re-this.im*V.im,this.re*V.im+this.im*V.re)},div:function(F,$){var V,G,H=new Complex(F,$);if(this.isZero()&&H.isZero()||this.isInfinite()&&H.isInfinite())return Complex.NAN;if(this.isInfinite()||H.isZero())return Complex.INFINITY;if(this.isZero()||H.isInfinite())return Complex.ZERO;F=this.re,$=this.im;var K=H.re,Z=H.im;return 0===Z?new Complex(F/K,$/K):Math.abs(K)<Math.abs(Z)?(G=K/Z,V=K*G+Z,new Complex((F*G+$)/V,($*G-F)/V)):(G=Z/K,V=Z*G+K,new Complex((F+$*G)/V,($-F*G)/V))},pow:function(F,$){var V=new Complex(F,$);if(F=this.re,$=this.im,V.isZero())return Complex.ONE;if(0===V.im){if(0===$&&F>0)return new Complex(Math.pow(F,V.re),0);if(0===F)switch((V.re%4+4)%4){case 0:return new Complex(Math.pow($,V.re),0);case 1:return new Complex(0,Math.pow($,V.re));case 2:return new Complex(-Math.pow($,V.re),0);case 3:return new Complex(0,-Math.pow($,V.re))}}if(0===F&&0===$&&V.re>0&&V.im>=0)return Complex.ZERO;var G=Math.atan2($,F),H=logHypot(F,$);return F=Math.exp(V.re*H-V.im*G),$=V.im*H+V.re*G,new Complex(F*Math.cos($),F*Math.sin($))},sqrt:function(){var F,$,V=this.re,G=this.im,H=this.abs();if(V>=0){if(0===G)return new Complex(Math.sqrt(V),0);F=.5*Math.sqrt(2*(H+V))}else F=Math.abs(G)/Math.sqrt(2*(H-V));return $=V<=0?.5*Math.sqrt(2*(H-V)):Math.abs(G)/Math.sqrt(2*(H+V)),new Complex(F,G<0?-$:$)},exp:function(){var F=Math.exp(this.re);return this.im,new Complex(F*Math.cos(this.im),F*Math.sin(this.im))},expm1:function(){var F=this.re,$=this.im;return new Complex(Math.expm1(F)*Math.cos($)+cosm1($),Math.exp(F)*Math.sin($))},log:function(){var F=this.re,$=this.im;return new Complex(logHypot(F,$),Math.atan2($,F))},abs:function(){return hypot(this.re,this.im)},arg:function(){return Math.atan2(this.im,this.re)},sin:function(){var F=this.re,$=this.im;return new Complex(Math.sin(F)*H($),Math.cos(F)*K($))},cos:function(){var F=this.re,$=this.im;return new Complex(Math.cos(F)*H($),-Math.sin(F)*K($))},tan:function(){var F=2*this.re,$=2*this.im,V=Math.cos(F)+H($);return new Complex(Math.sin(F)/V,K($)/V)},cot:function(){var F=2*this.re,$=2*this.im,V=Math.cos(F)-H($);return new Complex(-Math.sin(F)/V,K($)/V)},sec:function(){var F=this.re,$=this.im,V=.5*H(2*$)+.5*Math.cos(2*F);return new Complex(Math.cos(F)*H($)/V,Math.sin(F)*K($)/V)},csc:function(){var F=this.re,$=this.im,V=.5*H(2*$)-.5*Math.cos(2*F);return new Complex(Math.sin(F)*H($)/V,-Math.cos(F)*K($)/V)},asin:function(){var F=this.re,$=this.im,V=new Complex($*$-F*F+1,-2*F*$).sqrt(),G=new Complex(V.re-$,V.im+F).log();return new Complex(G.im,-G.re)},acos:function(){var F=this.re,$=this.im,V=new Complex($*$-F*F+1,-2*F*$).sqrt(),G=new Complex(V.re-$,V.im+F).log();return new Complex(Math.PI/2-G.im,G.re)},atan:function(){var F=this.re,$=this.im;if(0===F){if(1===$)return new Complex(0,1/0);if(-1===$)return new Complex(0,-1/0)}var V=F*F+(1-$)*(1-$),G=new Complex((1-$*$-F*F)/V,-2*F/V).log();return new Complex(-.5*G.im,.5*G.re)},acot:function(){var F=this.re,$=this.im;if(0===$)return new Complex(Math.atan2(1,F),0);var V=F*F+$*$;return 0!==V?new Complex(F/V,-$/V).atan():new Complex(0!==F?F/0:0,0!==$?-$/0:0).atan()},asec:function(){var F=this.re,$=this.im;if(0===F&&0===$)return new Complex(0,1/0);var V=F*F+$*$;return 0!==V?new Complex(F/V,-$/V).acos():new Complex(0!==F?F/0:0,0!==$?-$/0:0).acos()},acsc:function(){var F=this.re,$=this.im;if(0===F&&0===$)return new Complex(Math.PI/2,1/0);var V=F*F+$*$;return 0!==V?new Complex(F/V,-$/V).asin():new Complex(0!==F?F/0:0,0!==$?-$/0:0).asin()},sinh:function(){var F=this.re,$=this.im;return new Complex(K(F)*Math.cos($),H(F)*Math.sin($))},cosh:function(){var F=this.re,$=this.im;return new Complex(H(F)*Math.cos($),K(F)*Math.sin($))},tanh:function(){var F=2*this.re,$=2*this.im,V=H(F)+Math.cos($);return new Complex(K(F)/V,Math.sin($)/V)},coth:function(){var F=2*this.re,$=2*this.im,V=H(F)-Math.cos($);return new Complex(K(F)/V,-Math.sin($)/V)},csch:function(){var F=this.re,$=this.im,V=Math.cos(2*$)-H(2*F);return new Complex(-2*K(F)*Math.cos($)/V,2*H(F)*Math.sin($)/V)},sech:function(){var F=this.re,$=this.im,V=Math.cos(2*$)+H(2*F);return new Complex(2*H(F)*Math.cos($)/V,-2*K(F)*Math.sin($)/V)},asinh:function(){var F=this.im;this.im=-this.re,this.re=F;var $=this.asin();return this.re=-this.im,this.im=F,F=$.re,$.re=-$.im,$.im=F,$},acosh:function(){var F=this.acos();if(F.im<=0){var $=F.re;F.re=-F.im,F.im=$}else{var $=F.im;F.im=-F.re,F.re=$}return F},atanh:function(){var F=this.re,$=this.im,V=F>1&&0===$,G=1-F,H=1+F,K=G*G+$*$,Z=0!==K?new Complex((H*G-$*$)/K,($*G+H*$)/K):new Complex(-1!==F?F/0:0,0!==$?$/0:0),ee=Z.re;return Z.re=logHypot(Z.re,Z.im)/2,Z.im=Math.atan2(Z.im,ee)/2,V&&(Z.im=-Z.im),Z},acoth:function(){var F=this.re,$=this.im;if(0===F&&0===$)return new Complex(0,Math.PI/2);var V=F*F+$*$;return 0!==V?new Complex(F/V,-$/V).atanh():new Complex(0!==F?F/0:0,0!==$?-$/0:0).atanh()},acsch:function(){var F=this.re,$=this.im;if(0===$)return new Complex(0!==F?Math.log(F+Math.sqrt(F*F+1)):1/0,0);var V=F*F+$*$;return 0!==V?new Complex(F/V,-$/V).asinh():new Complex(0!==F?F/0:0,0!==$?-$/0:0).asinh()},asech:function(){var F=this.re,$=this.im;if(this.isZero())return Complex.INFINITY;var V=F*F+$*$;return 0!==V?new Complex(F/V,-$/V).acosh():new Complex(0!==F?F/0:0,0!==$?-$/0:0).acosh()},inverse:function(){if(this.isZero())return Complex.INFINITY;if(this.isInfinite())return Complex.ZERO;var F=this.re,$=this.im,V=F*F+$*$;return new Complex(F/V,-$/V)},conjugate:function(){return new Complex(this.re,-this.im)},neg:function(){return new Complex(-this.re,-this.im)},ceil:function(F){return F=Math.pow(10,F||0),new Complex(Math.ceil(this.re*F)/F,Math.ceil(this.im*F)/F)},floor:function(F){return F=Math.pow(10,F||0),new Complex(Math.floor(this.re*F)/F,Math.floor(this.im*F)/F)},round:function(F){return F=Math.pow(10,F||0),new Complex(Math.round(this.re*F)/F,Math.round(this.im*F)/F)},equals:function(F,$){var V=new Complex(F,$);return Math.abs(V.re-this.re)<=Complex.EPSILON&&Math.abs(V.im-this.im)<=Complex.EPSILON},clone:function(){return new Complex(this.re,this.im)},toString:function(){var F=this.re,$=this.im,V="";return this.isNaN()?"NaN":this.isInfinite()?"Infinity":(Math.abs(F)<Complex.EPSILON&&(F=0),Math.abs($)<Complex.EPSILON&&($=0),0===$)?V+F:(0!==F?(V+=F+" ",$<0?($=-$,V+="-"):V+="+",V+=" "):$<0&&($=-$,V+="-"),1!==$&&(V+=$),V+"i")},toVector:function(){return[this.re,this.im]},valueOf:function(){return 0===this.im?this.re:null},isNaN:function(){return isNaN(this.re)||isNaN(this.im)},isZero:function(){return 0===this.im&&0===this.re},isFinite:function(){return isFinite(this.re)&&isFinite(this.im)},isInfinite:function(){return!(this.isNaN()||this.isFinite())}},Complex.ZERO=new Complex(0,0),Complex.ONE=new Complex(1,0),Complex.I=new Complex(0,1),Complex.PI=new Complex(Math.PI,0),Complex.E=new Complex(Math.E,0),Complex.INFINITY=new Complex(1/0,1/0),Complex.NAN=new Complex(NaN,NaN),Complex.EPSILON=1e-15,void 0!==(V=(function(){return Complex}).apply($,[]))&&(F.exports=V)}(0)},17187:function(F){"use strict";var $,V="object"==typeof Reflect?Reflect:null,G=V&&"function"==typeof V.apply?V.apply:function(F,$,V){return Function.prototype.apply.call(F,$,V)};function ProcessEmitWarning(F){console&&console.warn&&console.warn(F)}$=V&&"function"==typeof V.ownKeys?V.ownKeys:Object.getOwnPropertySymbols?function(F){return Object.getOwnPropertyNames(F).concat(Object.getOwnPropertySymbols(F))}:function(F){return Object.getOwnPropertyNames(F)};var H=Number.isNaN||function(F){return F!=F};function EventEmitter(){EventEmitter.init.call(this)}F.exports=EventEmitter,F.exports.once=once,EventEmitter.EventEmitter=EventEmitter,EventEmitter.prototype._events=void 0,EventEmitter.prototype._eventsCount=0,EventEmitter.prototype._maxListeners=void 0;var K=10;function checkListener(F){if("function"!=typeof F)throw TypeError('The "listener" argument must be of type Function. Received type '+typeof F)}function _getMaxListeners(F){return void 0===F._maxListeners?EventEmitter.defaultMaxListeners:F._maxListeners}function _addListener(F,$,V,G){if(checkListener(V),void 0===(K=F._events)?(K=F._events=Object.create(null),F._eventsCount=0):(void 0!==K.newListener&&(F.emit("newListener",$,V.listener?V.listener:V),K=F._events),Z=K[$]),void 0===Z)Z=K[$]=V,++F._eventsCount;else if("function"==typeof Z?Z=K[$]=G?[V,Z]:[Z,V]:G?Z.unshift(V):Z.push(V),(H=_getMaxListeners(F))>0&&Z.length>H&&!Z.warned){Z.warned=!0;var H,K,Z,ee=Error("Possible EventEmitter memory leak detected. "+Z.length+" "+String($)+" listeners added. Use emitter.setMaxListeners() to increase limit");ee.name="MaxListenersExceededWarning",ee.emitter=F,ee.type=$,ee.count=Z.length,ProcessEmitWarning(ee)}return F}function onceWrapper(){if(!this.fired)return(this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0==arguments.length)?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function _onceWrap(F,$,V){var G={fired:!1,wrapFn:void 0,target:F,type:$,listener:V},H=onceWrapper.bind(G);return H.listener=V,G.wrapFn=H,H}function _listeners(F,$,V){var G=F._events;if(void 0===G)return[];var H=G[$];return void 0===H?[]:"function"==typeof H?V?[H.listener||H]:[H]:V?unwrapListeners(H):arrayClone(H,H.length)}function listenerCount(F){var $=this._events;if(void 0!==$){var V=$[F];if("function"==typeof V)return 1;if(void 0!==V)return V.length}return 0}function arrayClone(F,$){for(var V=Array($),G=0;G<$;++G)V[G]=F[G];return V}function spliceOne(F,$){for(;$+1<F.length;$++)F[$]=F[$+1];F.pop()}function unwrapListeners(F){for(var $=Array(F.length),V=0;V<$.length;++V)$[V]=F[V].listener||F[V];return $}function once(F,$){return new Promise(function(V,G){function errorListener(V){F.removeListener($,resolver),G(V)}function resolver(){"function"==typeof F.removeListener&&F.removeListener("error",errorListener),V([].slice.call(arguments))}eventTargetAgnosticAddListener(F,$,resolver,{once:!0}),"error"!==$&&addErrorHandlerIfEventEmitter(F,errorListener,{once:!0})})}function addErrorHandlerIfEventEmitter(F,$,V){"function"==typeof F.on&&eventTargetAgnosticAddListener(F,"error",$,V)}function eventTargetAgnosticAddListener(F,$,V,G){if("function"==typeof F.on)G.once?F.once($,V):F.on($,V);else if("function"==typeof F.addEventListener)F.addEventListener($,function wrapListener(H){G.once&&F.removeEventListener($,wrapListener),V(H)});else throw TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof F)}Object.defineProperty(EventEmitter,"defaultMaxListeners",{enumerable:!0,get:function(){return K},set:function(F){if("number"!=typeof F||F<0||H(F))throw RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+F+".");K=F}}),EventEmitter.init=function(){(void 0===this._events||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},EventEmitter.prototype.setMaxListeners=function(F){if("number"!=typeof F||F<0||H(F))throw RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+F+".");return this._maxListeners=F,this},EventEmitter.prototype.getMaxListeners=function(){return _getMaxListeners(this)},EventEmitter.prototype.emit=function(F){for(var $=[],V=1;V<arguments.length;V++)$.push(arguments[V]);var H="error"===F,K=this._events;if(void 0!==K)H=H&&void 0===K.error;else if(!H)return!1;if(H){if($.length>0&&(Z=$[0]),Z instanceof Error)throw Z;var Z,ee=Error("Unhandled error."+(Z?" ("+Z.message+")":""));throw ee.context=Z,ee}var et=K[F];if(void 0===et)return!1;if("function"==typeof et)G(et,this,$);else for(var en=et.length,ea=arrayClone(et,en),V=0;V<en;++V)G(ea[V],this,$);return!0},EventEmitter.prototype.addListener=function(F,$){return _addListener(this,F,$,!1)},EventEmitter.prototype.on=EventEmitter.prototype.addListener,EventEmitter.prototype.prependListener=function(F,$){return _addListener(this,F,$,!0)},EventEmitter.prototype.once=function(F,$){return checkListener($),this.on(F,_onceWrap(this,F,$)),this},EventEmitter.prototype.prependOnceListener=function(F,$){return checkListener($),this.prependListener(F,_onceWrap(this,F,$)),this},EventEmitter.prototype.removeListener=function(F,$){var V,G,H,K,Z;if(checkListener($),void 0===(G=this._events)||void 0===(V=G[F]))return this;if(V===$||V.listener===$)0==--this._eventsCount?this._events=Object.create(null):(delete G[F],G.removeListener&&this.emit("removeListener",F,V.listener||$));else if("function"!=typeof V){for(H=-1,K=V.length-1;K>=0;K--)if(V[K]===$||V[K].listener===$){Z=V[K].listener,H=K;break}if(H<0)return this;0===H?V.shift():spliceOne(V,H),1===V.length&&(G[F]=V[0]),void 0!==G.removeListener&&this.emit("removeListener",F,Z||$)}return this},EventEmitter.prototype.off=EventEmitter.prototype.removeListener,EventEmitter.prototype.removeAllListeners=function(F){var $,V,G;if(void 0===(V=this._events))return this;if(void 0===V.removeListener)return 0==arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==V[F]&&(0==--this._eventsCount?this._events=Object.create(null):delete V[F]),this;if(0==arguments.length){var H,K=Object.keys(V);for(G=0;G<K.length;++G)"removeListener"!==(H=K[G])&&this.removeAllListeners(H);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof($=V[F]))this.removeListener(F,$);else if(void 0!==$)for(G=$.length-1;G>=0;G--)this.removeListener(F,$[G]);return this},EventEmitter.prototype.listeners=function(F){return _listeners(this,F,!0)},EventEmitter.prototype.rawListeners=function(F){return _listeners(this,F,!1)},EventEmitter.listenerCount=function(F,$){return"function"==typeof F.listenerCount?F.listenerCount($):listenerCount.call(F,$)},EventEmitter.prototype.listenerCount=listenerCount,EventEmitter.prototype.eventNames=function(){return this._eventsCount>0?$(this._events):[]}},63228:function(F){F.exports=function naturalSort(F,$){"use strict";var V,G,H=/(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,K=/(^[ ]*|[ ]*$)/g,Z=/(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,ee=/^0x[0-9a-f]+$/i,et=/^0/,i=function(F){return naturalSort.insensitive&&(""+F).toLowerCase()||""+F},en=i(F).replace(K,"")||"",ea=i($).replace(K,"")||"",ei=en.replace(H,"\x00$1\x00").replace(/\0$/,"").replace(/^\0/,"").split("\x00"),eo=ea.replace(H,"\x00$1\x00").replace(/\0$/,"").replace(/^\0/,"").split("\x00"),es=parseInt(en.match(ee),16)||1!==ei.length&&en.match(Z)&&Date.parse(en),eu=parseInt(ea.match(ee),16)||es&&ea.match(Z)&&Date.parse(ea)||null;if(eu){if(es<eu)return -1;if(es>eu)return 1}for(var ec=0,ep=Math.max(ei.length,eo.length);ec<ep;ec++){if(V=!(ei[ec]||"").match(et)&&parseFloat(ei[ec])||ei[ec]||0,G=!(eo[ec]||"").match(et)&&parseFloat(eo[ec])||eo[ec]||0,isNaN(V)!==isNaN(G))return isNaN(V)?1:-1;if(typeof V!=typeof G&&(V+="",G+=""),V<G)return -1;if(V>G)return 1}return 0}},1989:function(F,$,V){var G=V(51789),H=V(80401),K=V(57667),Z=V(21327),ee=V(81866);function Hash(F){var $=-1,V=null==F?0:F.length;for(this.clear();++$<V;){var G=F[$];this.set(G[0],G[1])}}Hash.prototype.clear=G,Hash.prototype.delete=H,Hash.prototype.get=K,Hash.prototype.has=Z,Hash.prototype.set=ee,F.exports=Hash},38407:function(F,$,V){var G=V(27040),H=V(14125),K=V(82117),Z=V(67518),ee=V(54705);function ListCache(F){var $=-1,V=null==F?0:F.length;for(this.clear();++$<V;){var G=F[$];this.set(G[0],G[1])}}ListCache.prototype.clear=G,ListCache.prototype.delete=H,ListCache.prototype.get=K,ListCache.prototype.has=Z,ListCache.prototype.set=ee,F.exports=ListCache},57071:function(F,$,V){var G=V(10852)(V(55639),"Map");F.exports=G},83369:function(F,$,V){var G=V(24785),H=V(11285),K=V(96e3),Z=V(49916),ee=V(95265);function MapCache(F){var $=-1,V=null==F?0:F.length;for(this.clear();++$<V;){var G=F[$];this.set(G[0],G[1])}}MapCache.prototype.clear=G,MapCache.prototype.delete=H,MapCache.prototype.get=K,MapCache.prototype.has=Z,MapCache.prototype.set=ee,F.exports=MapCache},58525:function(F,$,V){var G=V(10852)(V(55639),"Set");F.exports=G},88668:function(F,$,V){var G=V(83369),H=V(90619),K=V(72385);function SetCache(F){var $=-1,V=null==F?0:F.length;for(this.__data__=new G;++$<V;)this.add(F[$])}SetCache.prototype.add=SetCache.prototype.push=H,SetCache.prototype.has=K,F.exports=SetCache},62705:function(F,$,V){var G=V(55639).Symbol;F.exports=G},47443:function(F,$,V){var G=V(42118);function arrayIncludes(F,$){return!!(null==F?0:F.length)&&G(F,$,0)>-1}F.exports=arrayIncludes},1196:function(F){function arrayIncludesWith(F,$,V){for(var G=-1,H=null==F?0:F.length;++G<H;)if(V($,F[G]))return!0;return!1}F.exports=arrayIncludesWith},14636:function(F,$,V){var G=V(22545),H=V(35694),K=V(1469),Z=V(44144),ee=V(65776),et=V(36719),en=Object.prototype.hasOwnProperty;function arrayLikeKeys(F,$){var V=K(F),ea=!V&&H(F),ei=!V&&!ea&&Z(F),eo=!V&&!ea&&!ei&&et(F),es=V||ea||ei||eo,eu=es?G(F.length,String):[],ec=eu.length;for(var ep in F)($||en.call(F,ep))&&!(es&&("length"==ep||ei&&("offset"==ep||"parent"==ep)||eo&&("buffer"==ep||"byteLength"==ep||"byteOffset"==ep)||ee(ep,ec)))&&eu.push(ep);return eu}F.exports=arrayLikeKeys},29932:function(F){function arrayMap(F,$){for(var V=-1,G=null==F?0:F.length,H=Array(G);++V<G;)H[V]=$(F[V],V,F);return H}F.exports=arrayMap},94311:function(F,$,V){var G=V(69877);function arraySample(F){var $=F.length;return $?F[G(0,$-1)]:void 0}F.exports=arraySample},70151:function(F,$,V){var G=V(278),H=V(73480);function arrayShuffle(F){return H(G(F))}F.exports=arrayShuffle},18470:function(F,$,V){var G=V(77813);function assocIndexOf(F,$){for(var V=F.length;V--;)if(G(F[V][0],$))return V;return -1}F.exports=assocIndexOf},41848:function(F){function baseFindIndex(F,$,V,G){for(var H=F.length,K=V+(G?1:-1);G?K--:++K<H;)if($(F[K],K,F))return K;return -1}F.exports=baseFindIndex},44239:function(F,$,V){var G=V(62705),H=V(89607),K=V(2333),Z="[object Null]",ee="[object Undefined]",et=G?G.toStringTag:void 0;function baseGetTag(F){return null==F?void 0===F?ee:Z:et&&et in Object(F)?H(F):K(F)}F.exports=baseGetTag},42118:function(F,$,V){var G=V(41848),H=V(62722),K=V(42351);function baseIndexOf(F,$,V){return $==$?K(F,$,V):G(F,H,V)}F.exports=baseIndexOf},9454:function(F,$,V){var G=V(44239),H=V(37005),K="[object Arguments]";function baseIsArguments(F){return H(F)&&G(F)==K}F.exports=baseIsArguments},62722:function(F){function baseIsNaN(F){return F!=F}F.exports=baseIsNaN},28458:function(F,$,V){var G=V(23560),H=V(15346),K=V(13218),Z=V(80346),ee=/[\\^$.*+?()[\]{}|]/g,et=/^\[object .+?Constructor\]$/,en=Object.prototype,ea=Function.prototype.toString,ei=en.hasOwnProperty,eo=RegExp("^"+ea.call(ei).replace(ee,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function baseIsNative(F){return!(!K(F)||H(F))&&(G(F)?eo:et).test(Z(F))}F.exports=baseIsNative},38749:function(F,$,V){var G=V(44239),H=V(41780),K=V(37005),Z="[object Arguments]",ee="[object Array]",et="[object Boolean]",en="[object Date]",ea="[object Error]",ei="[object Function]",eo="[object Map]",es="[object Number]",eu="[object Object]",ec="[object RegExp]",ep="[object Set]",eh="[object String]",ef="[object WeakMap]",ed="[object ArrayBuffer]",em="[object DataView]",eg="[object Float64Array]",ey="[object Int8Array]",eb="[object Int16Array]",ew="[object Int32Array]",eS="[object Uint8Array]",e_="[object Uint8ClampedArray]",eN="[object Uint16Array]",ek="[object Uint32Array]",eI={};function baseIsTypedArray(F){return K(F)&&H(F.length)&&!!eI[G(F)]}eI["[object Float32Array]"]=eI[eg]=eI[ey]=eI[eb]=eI[ew]=eI[eS]=eI[e_]=eI[eN]=eI[ek]=!0,eI[Z]=eI[ee]=eI[ed]=eI[et]=eI[em]=eI[en]=eI[ea]=eI[ei]=eI[eo]=eI[es]=eI[eu]=eI[ec]=eI[ep]=eI[eh]=eI[ef]=!1,F.exports=baseIsTypedArray},280:function(F,$,V){var G=V(25726),H=V(86916),K=Object.prototype.hasOwnProperty;function baseKeys(F){if(!G(F))return H(F);var $=[];for(var V in Object(F))K.call(F,V)&&"constructor"!=V&&$.push(V);return $}F.exports=baseKeys},69877:function(F){var $=Math.floor,V=Math.random;function baseRandom(F,G){return F+$(V()*(G-F+1))}F.exports=baseRandom},84992:function(F,$,V){var G=V(94311),H=V(52628);function baseSample(F){return G(H(F))}F.exports=baseSample},25127:function(F,$,V){var G=V(73480),H=V(52628);function baseShuffle(F){return G(H(F))}F.exports=baseShuffle},22545:function(F){function baseTimes(F,$){for(var V=-1,G=Array(F);++V<F;)G[V]=$(V);return G}F.exports=baseTimes},7518:function(F){function baseUnary(F){return function($){return F($)}}F.exports=baseUnary},45652:function(F,$,V){var G=V(88668),H=V(47443),K=V(1196),Z=V(74757),ee=V(23593),et=V(21814),en=200;function baseUniq(F,$,V){var ea=-1,ei=H,eo=F.length,es=!0,eu=[],ec=eu;if(V)es=!1,ei=K;else if(eo>=en){var ep=$?null:ee(F);if(ep)return et(ep);es=!1,ei=Z,ec=new G}else ec=$?[]:eu;e:for(;++ea<eo;){var eh=F[ea],ef=$?$(eh):eh;if(eh=V||0!==eh?eh:0,es&&ef==ef){for(var ed=ec.length;ed--;)if(ec[ed]===ef)continue e;$&&ec.push(ef),eu.push(eh)}else ei(ec,ef,V)||(ec!==eu&&ec.push(ef),eu.push(eh))}return eu}F.exports=baseUniq},47415:function(F,$,V){var G=V(29932);function baseValues(F,$){return G($,function($){return F[$]})}F.exports=baseValues},74757:function(F){function cacheHas(F,$){return F.has($)}F.exports=cacheHas},278:function(F){function copyArray(F,$){var V=-1,G=F.length;for($||($=Array(G));++V<G;)$[V]=F[V];return $}F.exports=copyArray},14429:function(F,$,V){var G=V(55639)["__core-js_shared__"];F.exports=G},23593:function(F,$,V){var G=V(58525),H=V(50308),K=V(21814),Z=1/0,ee=G&&1/K(new G([,-0]))[1]==Z?function(F){return new G(F)}:H;F.exports=ee},31957:function(F,$,V){var G="object"==typeof V.g&&V.g&&V.g.Object===Object&&V.g;F.exports=G},45050:function(F,$,V){var G=V(37019);function getMapData(F,$){var V=F.__data__;return G($)?V["string"==typeof $?"string":"hash"]:V.map}F.exports=getMapData},10852:function(F,$,V){var G=V(28458),H=V(47801);function getNative(F,$){var V=H(F,$);return G(V)?V:void 0}F.exports=getNative},89607:function(F,$,V){var G=V(62705),H=Object.prototype,K=H.hasOwnProperty,Z=H.toString,ee=G?G.toStringTag:void 0;function getRawTag(F){var $=K.call(F,ee),V=F[ee];try{F[ee]=void 0;var G=!0}catch(F){}var H=Z.call(F);return G&&($?F[ee]=V:delete F[ee]),H}F.exports=getRawTag},47801:function(F){function getValue(F,$){return null==F?void 0:F[$]}F.exports=getValue},51789:function(F,$,V){var G=V(94536);function hashClear(){this.__data__=G?G(null):{},this.size=0}F.exports=hashClear},80401:function(F){function hashDelete(F){var $=this.has(F)&&delete this.__data__[F];return this.size-=$?1:0,$}F.exports=hashDelete},57667:function(F,$,V){var G=V(94536),H="__lodash_hash_undefined__",K=Object.prototype.hasOwnProperty;function hashGet(F){var $=this.__data__;if(G){var V=$[F];return V===H?void 0:V}return K.call($,F)?$[F]:void 0}F.exports=hashGet},21327:function(F,$,V){var G=V(94536),H=Object.prototype.hasOwnProperty;function hashHas(F){var $=this.__data__;return G?void 0!==$[F]:H.call($,F)}F.exports=hashHas},81866:function(F,$,V){var G=V(94536),H="__lodash_hash_undefined__";function hashSet(F,$){var V=this.__data__;return this.size+=this.has(F)?0:1,V[F]=G&&void 0===$?H:$,this}F.exports=hashSet},65776:function(F){var $=9007199254740991,V=/^(?:0|[1-9]\d*)$/;function isIndex(F,G){var H=typeof F;return!!(G=null==G?$:G)&&("number"==H||"symbol"!=H&&V.test(F))&&F>-1&&F%1==0&&F<G}F.exports=isIndex},37019:function(F){function isKeyable(F){var $=typeof F;return"string"==$||"number"==$||"symbol"==$||"boolean"==$?"__proto__"!==F:null===F}F.exports=isKeyable},15346:function(F,$,V){var G=V(14429),H=function(){var F=/[^.]+$/.exec(G&&G.keys&&G.keys.IE_PROTO||"");return F?"Symbol(src)_1."+F:""}();function isMasked(F){return!!H&&H in F}F.exports=isMasked},25726:function(F){var $=Object.prototype;function isPrototype(F){var V=F&&F.constructor;return F===("function"==typeof V&&V.prototype||$)}F.exports=isPrototype},27040:function(F){function listCacheClear(){this.__data__=[],this.size=0}F.exports=listCacheClear},14125:function(F,$,V){var G=V(18470),H=Array.prototype.splice;function listCacheDelete(F){var $=this.__data__,V=G($,F);return!(V<0)&&(V==$.length-1?$.pop():H.call($,V,1),--this.size,!0)}F.exports=listCacheDelete},82117:function(F,$,V){var G=V(18470);function listCacheGet(F){var $=this.__data__,V=G($,F);return V<0?void 0:$[V][1]}F.exports=listCacheGet},67518:function(F,$,V){var G=V(18470);function listCacheHas(F){return G(this.__data__,F)>-1}F.exports=listCacheHas},54705:function(F,$,V){var G=V(18470);function listCacheSet(F,$){var V=this.__data__,H=G(V,F);return H<0?(++this.size,V.push([F,$])):V[H][1]=$,this}F.exports=listCacheSet},24785:function(F,$,V){var G=V(1989),H=V(38407),K=V(57071);function mapCacheClear(){this.size=0,this.__data__={hash:new G,map:new(K||H),string:new G}}F.exports=mapCacheClear},11285:function(F,$,V){var G=V(45050);function mapCacheDelete(F){var $=G(this,F).delete(F);return this.size-=$?1:0,$}F.exports=mapCacheDelete},96e3:function(F,$,V){var G=V(45050);function mapCacheGet(F){return G(this,F).get(F)}F.exports=mapCacheGet},49916:function(F,$,V){var G=V(45050);function mapCacheHas(F){return G(this,F).has(F)}F.exports=mapCacheHas},95265:function(F,$,V){var G=V(45050);function mapCacheSet(F,$){var V=G(this,F),H=V.size;return V.set(F,$),this.size+=V.size==H?0:1,this}F.exports=mapCacheSet},94536:function(F,$,V){var G=V(10852)(Object,"create");F.exports=G},86916:function(F,$,V){var G=V(5569)(Object.keys,Object);F.exports=G},31167:function(F,$,V){F=V.nmd(F);var G=V(31957),H=$&&!$.nodeType&&$,K=H&&F&&!F.nodeType&&F,Z=K&&K.exports===H&&G.process,ee=function(){try{var F=K&&K.require&&K.require("util").types;if(F)return F;return Z&&Z.binding&&Z.binding("util")}catch(F){}}();F.exports=ee},2333:function(F){var $=Object.prototype.toString;function objectToString(F){return $.call(F)}F.exports=objectToString},5569:function(F){function overArg(F,$){return function(V){return F($(V))}}F.exports=overArg},55639:function(F,$,V){var G=V(31957),H="object"==typeof self&&self&&self.Object===Object&&self,K=G||H||Function("return this")();F.exports=K},90619:function(F){var $="__lodash_hash_undefined__";function setCacheAdd(F){return this.__data__.set(F,$),this}F.exports=setCacheAdd},72385:function(F){function setCacheHas(F){return this.__data__.has(F)}F.exports=setCacheHas},21814:function(F){function setToArray(F){var $=-1,V=Array(F.size);return F.forEach(function(F){V[++$]=F}),V}F.exports=setToArray},73480:function(F,$,V){var G=V(69877);function shuffleSelf(F,$){var V=-1,H=F.length,K=H-1;for($=void 0===$?H:$;++V<$;){var Z=G(V,K),ee=F[Z];F[Z]=F[V],F[V]=ee}return F.length=$,F}F.exports=shuffleSelf},42351:function(F){function strictIndexOf(F,$,V){for(var G=V-1,H=F.length;++G<H;)if(F[G]===$)return G;return -1}F.exports=strictIndexOf},80346:function(F){var $=Function.prototype.toString;function toSource(F){if(null!=F){try{return $.call(F)}catch(F){}try{return F+""}catch(F){}}return""}F.exports=toSource},77813:function(F){function eq(F,$){return F===$||F!=F&&$!=$}F.exports=eq},35694:function(F,$,V){var G=V(9454),H=V(37005),K=Object.prototype,Z=K.hasOwnProperty,ee=K.propertyIsEnumerable,et=G(function(){return arguments}())?G:function(F){return H(F)&&Z.call(F,"callee")&&!ee.call(F,"callee")};F.exports=et},1469:function(F){var $=Array.isArray;F.exports=$},98612:function(F,$,V){var G=V(23560),H=V(41780);function isArrayLike(F){return null!=F&&H(F.length)&&!G(F)}F.exports=isArrayLike},44144:function(F,$,V){F=V.nmd(F);var G=V(55639),H=V(95062),K=$&&!$.nodeType&&$,Z=K&&F&&!F.nodeType&&F,ee=Z&&Z.exports===K?G.Buffer:void 0,et=(ee?ee.isBuffer:void 0)||H;F.exports=et},23560:function(F,$,V){var G=V(44239),H=V(13218),K="[object AsyncFunction]",Z="[object Function]",ee="[object GeneratorFunction]",et="[object Proxy]";function isFunction(F){if(!H(F))return!1;var $=G(F);return $==Z||$==ee||$==K||$==et}F.exports=isFunction},41780:function(F){var $=9007199254740991;function isLength(F){return"number"==typeof F&&F>-1&&F%1==0&&F<=$}F.exports=isLength},13218:function(F){function isObject(F){var $=typeof F;return null!=F&&("object"==$||"function"==$)}F.exports=isObject},37005:function(F){function isObjectLike(F){return null!=F&&"object"==typeof F}F.exports=isObjectLike},36719:function(F,$,V){var G=V(38749),H=V(7518),K=V(31167),Z=K&&K.isTypedArray,ee=Z?H(Z):G;F.exports=ee},3674:function(F,$,V){var G=V(14636),H=V(280),K=V(98612);function keys(F){return K(F)?G(F):H(F)}F.exports=keys},50308:function(F){function noop(){}F.exports=noop},95534:function(F,$,V){var G=V(94311),H=V(84992),K=V(1469);function sample(F){return(K(F)?G:H)(F)}F.exports=sample},69983:function(F,$,V){var G=V(70151),H=V(25127),K=V(1469);function shuffle(F){return(K(F)?G:H)(F)}F.exports=shuffle},95062:function(F){function stubFalse(){return!1}F.exports=stubFalse},44908:function(F,$,V){var G=V(45652);function uniq(F){return F&&F.length?G(F):[]}F.exports=uniq},52628:function(F,$,V){var G=V(47415),H=V(3674);function values(F){return null==F?[]:G(F,H(F))}F.exports=values},43720:function(F){F.exports=Long;var $=null;try{$=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(F){}function Long(F,$,V){this.low=0|F,this.high=0|$,this.unsigned=!!V}function isLong(F){return!0===(F&&F.__isLong__)}Long.prototype.__isLong__,Object.defineProperty(Long.prototype,"__isLong__",{value:!0}),Long.isLong=isLong;var V={},G={};function fromInt(F,$){var H,K,Z;return $?(F>>>=0,(Z=0<=F&&F<256)&&(K=G[F]))?K:(H=fromBits(F,(0|F)<0?-1:0,!0),Z&&(G[F]=H),H):(F|=0,(Z=-128<=F&&F<128)&&(K=V[F]))?K:(H=fromBits(F,F<0?-1:0,!1),Z&&(V[F]=H),H)}function fromNumber(F,$){if(isNaN(F))return $?ea:en;if($){if(F<0)return ea;if(F>=Z)return ec}else{if(F<=-ee)return ep;if(F+1>=ee)return eu}return F<0?fromNumber(-F,$).neg():fromBits(F%K|0,F/K|0,$)}function fromBits(F,$,V){return new Long(F,$,V)}Long.fromInt=fromInt,Long.fromNumber=fromNumber,Long.fromBits=fromBits;var H=Math.pow;function fromString(F,$,V){if(0===F.length)throw Error("empty string");if("NaN"===F||"Infinity"===F||"+Infinity"===F||"-Infinity"===F)return en;if("number"==typeof $?(V=$,$=!1):$=!!$,(V=V||10)<2||36<V)throw RangeError("radix");if((G=F.indexOf("-"))>0)throw Error("interior hyphen");if(0===G)return fromString(F.substring(1),$,V).neg();for(var G,K=fromNumber(H(V,8)),Z=en,ee=0;ee<F.length;ee+=8){var et=Math.min(8,F.length-ee),ea=parseInt(F.substring(ee,ee+et),V);if(et<8){var ei=fromNumber(H(V,et));Z=Z.mul(ei).add(fromNumber(ea))}else Z=(Z=Z.mul(K)).add(fromNumber(ea))}return Z.unsigned=$,Z}function fromValue(F,$){return"number"==typeof F?fromNumber(F,$):"string"==typeof F?fromString(F,$):fromBits(F.low,F.high,"boolean"==typeof $?$:F.unsigned)}Long.fromString=fromString,Long.fromValue=fromValue;var K=4294967296,Z=18446744073709552e3,ee=0x7fffffffffffffff,et=fromInt(16777216),en=fromInt(0);Long.ZERO=en;var ea=fromInt(0,!0);Long.UZERO=ea;var ei=fromInt(1);Long.ONE=ei;var eo=fromInt(1,!0);Long.UONE=eo;var es=fromInt(-1);Long.NEG_ONE=es;var eu=fromBits(-1,2147483647,!1);Long.MAX_VALUE=eu;var ec=fromBits(-1,-1,!0);Long.MAX_UNSIGNED_VALUE=ec;var ep=fromBits(0,-2147483648,!1);Long.MIN_VALUE=ep;var eh=Long.prototype;eh.toInt=function(){return this.unsigned?this.low>>>0:this.low},eh.toNumber=function(){return this.unsigned?(this.high>>>0)*K+(this.low>>>0):this.high*K+(this.low>>>0)},eh.toString=function(F){if((F=F||10)<2||36<F)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(!this.eq(ep))return"-"+this.neg().toString(F);var $=fromNumber(F),V=this.div($),G=V.mul($).sub(this);return V.toString(F)+G.toInt().toString(F)}for(var K=fromNumber(H(F,6),this.unsigned),Z=this,ee="";;){var et=Z.div(K),en=(Z.sub(et.mul(K)).toInt()>>>0).toString(F);if((Z=et).isZero())return en+ee;for(;en.length<6;)en="0"+en;ee=""+en+ee}},eh.getHighBits=function(){return this.high},eh.getHighBitsUnsigned=function(){return this.high>>>0},eh.getLowBits=function(){return this.low},eh.getLowBitsUnsigned=function(){return this.low>>>0},eh.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ep)?64:this.neg().getNumBitsAbs();for(var F=0!=this.high?this.high:this.low,$=31;$>0&&(F&1<<$)==0;$--);return 0!=this.high?$+33:$+1},eh.isZero=function(){return 0===this.high&&0===this.low},eh.eqz=eh.isZero,eh.isNegative=function(){return!this.unsigned&&this.high<0},eh.isPositive=function(){return this.unsigned||this.high>=0},eh.isOdd=function(){return(1&this.low)==1},eh.isEven=function(){return(1&this.low)==0},eh.equals=function(F){return isLong(F)||(F=fromValue(F)),(this.unsigned===F.unsigned||this.high>>>31!=1||F.high>>>31!=1)&&this.high===F.high&&this.low===F.low},eh.eq=eh.equals,eh.notEquals=function(F){return!this.eq(F)},eh.neq=eh.notEquals,eh.ne=eh.notEquals,eh.lessThan=function(F){return 0>this.comp(F)},eh.lt=eh.lessThan,eh.lessThanOrEqual=function(F){return 0>=this.comp(F)},eh.lte=eh.lessThanOrEqual,eh.le=eh.lessThanOrEqual,eh.greaterThan=function(F){return this.comp(F)>0},eh.gt=eh.greaterThan,eh.greaterThanOrEqual=function(F){return this.comp(F)>=0},eh.gte=eh.greaterThanOrEqual,eh.ge=eh.greaterThanOrEqual,eh.compare=function(F){if(isLong(F)||(F=fromValue(F)),this.eq(F))return 0;var $=this.isNegative(),V=F.isNegative();return $&&!V?-1:!$&&V?1:this.unsigned?F.high>>>0>this.high>>>0||F.high===this.high&&F.low>>>0>this.low>>>0?-1:1:this.sub(F).isNegative()?-1:1},eh.comp=eh.compare,eh.negate=function(){return!this.unsigned&&this.eq(ep)?ep:this.not().add(ei)},eh.neg=eh.negate,eh.add=function(F){isLong(F)||(F=fromValue(F));var $,V,G=this.high>>>16,H=65535&this.high,K=this.low>>>16,Z=65535&this.low,ee=F.high>>>16,et=65535&F.high,en=F.low>>>16,ea=65535&F.low,ei=0,eo=0;return $=0+((V=0+(Z+ea))>>>16),V&=65535,$+=K+en,eo+=$>>>16,$&=65535,eo+=H+et,ei+=eo>>>16,eo&=65535,ei+=G+ee,fromBits($<<16|V,(ei&=65535)<<16|eo,this.unsigned)},eh.subtract=function(F){return isLong(F)||(F=fromValue(F)),this.add(F.neg())},eh.sub=eh.subtract,eh.multiply=function(F){if(this.isZero())return en;if(isLong(F)||(F=fromValue(F)),$)return fromBits($.mul(this.low,this.high,F.low,F.high),$.get_high(),this.unsigned);if(F.isZero())return en;if(this.eq(ep))return F.isOdd()?ep:en;if(F.eq(ep))return this.isOdd()?ep:en;if(this.isNegative())return F.isNegative()?this.neg().mul(F.neg()):this.neg().mul(F).neg();if(F.isNegative())return this.mul(F.neg()).neg();if(this.lt(et)&&F.lt(et))return fromNumber(this.toNumber()*F.toNumber(),this.unsigned);var V,G,H=this.high>>>16,K=65535&this.high,Z=this.low>>>16,ee=65535&this.low,ea=F.high>>>16,ei=65535&F.high,eo=F.low>>>16,es=65535&F.low,eu=0,ec=0;return V=0+((G=0+ee*es)>>>16),G&=65535,V+=Z*es,ec+=V>>>16,V&=65535,V+=ee*eo,ec+=V>>>16,V&=65535,ec+=K*es,eu+=ec>>>16,ec&=65535,ec+=Z*eo,eu+=ec>>>16,ec&=65535,ec+=ee*ei,eu+=ec>>>16,ec&=65535,eu+=H*es+K*eo+Z*ei+ee*ea,fromBits(V<<16|G,(eu&=65535)<<16|ec,this.unsigned)},eh.mul=eh.multiply,eh.divide=function(F){if(isLong(F)||(F=fromValue(F)),F.isZero())throw Error("division by zero");if($){var V,G,K;return this.unsigned||-2147483648!==this.high||-1!==F.low||-1!==F.high?fromBits((this.unsigned?$.div_u:$.div_s)(this.low,this.high,F.low,F.high),$.get_high(),this.unsigned):this}if(this.isZero())return this.unsigned?ea:en;if(this.unsigned){if(F.unsigned||(F=F.toUnsigned()),F.gt(this))return ea;if(F.gt(this.shru(1)))return eo;K=ea}else{if(this.eq(ep))return F.eq(ei)||F.eq(es)?ep:F.eq(ep)?ei:(V=this.shr(1).div(F).shl(1)).eq(en)?F.isNegative()?ei:es:(G=this.sub(F.mul(V)),K=V.add(G.div(F)));if(F.eq(ep))return this.unsigned?ea:en;if(this.isNegative())return F.isNegative()?this.neg().div(F.neg()):this.neg().div(F).neg();if(F.isNegative())return this.div(F.neg()).neg();K=en}for(G=this;G.gte(F);){for(var Z=Math.ceil(Math.log(V=Math.max(1,Math.floor(G.toNumber()/F.toNumber())))/Math.LN2),ee=Z<=48?1:H(2,Z-48),et=fromNumber(V),eu=et.mul(F);eu.isNegative()||eu.gt(G);)V-=ee,eu=(et=fromNumber(V,this.unsigned)).mul(F);et.isZero()&&(et=ei),K=K.add(et),G=G.sub(eu)}return K},eh.div=eh.divide,eh.modulo=function(F){return(isLong(F)||(F=fromValue(F)),$)?fromBits((this.unsigned?$.rem_u:$.rem_s)(this.low,this.high,F.low,F.high),$.get_high(),this.unsigned):this.sub(this.div(F).mul(F))},eh.mod=eh.modulo,eh.rem=eh.modulo,eh.not=function(){return fromBits(~this.low,~this.high,this.unsigned)},eh.and=function(F){return isLong(F)||(F=fromValue(F)),fromBits(this.low&F.low,this.high&F.high,this.unsigned)},eh.or=function(F){return isLong(F)||(F=fromValue(F)),fromBits(this.low|F.low,this.high|F.high,this.unsigned)},eh.xor=function(F){return isLong(F)||(F=fromValue(F)),fromBits(this.low^F.low,this.high^F.high,this.unsigned)},eh.shiftLeft=function(F){return(isLong(F)&&(F=F.toInt()),0==(F&=63))?this:F<32?fromBits(this.low<<F,this.high<<F|this.low>>>32-F,this.unsigned):fromBits(0,this.low<<F-32,this.unsigned)},eh.shl=eh.shiftLeft,eh.shiftRight=function(F){return(isLong(F)&&(F=F.toInt()),0==(F&=63))?this:F<32?fromBits(this.low>>>F|this.high<<32-F,this.high>>F,this.unsigned):fromBits(this.high>>F-32,this.high>=0?0:-1,this.unsigned)},eh.shr=eh.shiftRight,eh.shiftRightUnsigned=function(F){if(isLong(F)&&(F=F.toInt()),0==(F&=63))return this;var $=this.high;return F<32?fromBits(this.low>>>F|$<<32-F,$>>>F,this.unsigned):32===F?fromBits($,0,this.unsigned):fromBits($>>>F-32,0,this.unsigned)},eh.shru=eh.shiftRightUnsigned,eh.shr_u=eh.shiftRightUnsigned,eh.toSigned=function(){return this.unsigned?fromBits(this.low,this.high,!1):this},eh.toUnsigned=function(){return this.unsigned?this:fromBits(this.low,this.high,!0)},eh.toBytes=function(F){return F?this.toBytesLE():this.toBytesBE()},eh.toBytesLE=function(){var F=this.high,$=this.low;return[255&$,$>>>8&255,$>>>16&255,$>>>24,255&F,F>>>8&255,F>>>16&255,F>>>24]},eh.toBytesBE=function(){var F=this.high,$=this.low;return[F>>>24,F>>>16&255,F>>>8&255,255&F,$>>>24,$>>>16&255,$>>>8&255,255&$]},Long.fromBytes=function(F,$,V){return V?Long.fromBytesLE(F,$):Long.fromBytesBE(F,$)},Long.fromBytesLE=function(F,$){return new Long(F[0]|F[1]<<8|F[2]<<16|F[3]<<24,F[4]|F[5]<<8|F[6]<<16|F[7]<<24,$)},Long.fromBytesBE=function(F,$){return new Long(F[4]<<24|F[5]<<16|F[6]<<8|F[7],F[0]<<24|F[1]<<16|F[2]<<8|F[3],$)}},45520:function(F){!function(){function a(F){for(var $=0,V=F.length-1,G=void 0,H=void 0,K=void 0,Z=c($,V);;){if(V<=$)return F[Z];if(V==$+1)return F[$]>F[V]&&b(F,$,V),F[Z];for(F[G=c($,V)]>F[V]&&b(F,G,V),F[$]>F[V]&&b(F,$,V),F[G]>F[$]&&b(F,G,$),b(F,G,$+1),H=$+1,K=V;;){do H++;while(F[$]>F[H]);do K--;while(F[K]>F[$]);if(K<H)break;b(F,H,K)}b(F,$,K),K<=Z&&($=H),K>=Z&&(V=K-1)}}var b=function(F,$,V){var G;return G=[F[V],F[$]],F[$]=G[0],F[V]=G[1],G},c=function(F,$){return~~((F+$)/2)};F.exports?F.exports=a:window.median=a}()},82023:function(F,$,V){"use strict";V.d($,{L:function(){return RandomForestRegression}});var G=V(44091),H=V(93396);function sum(F){if(!(0,G.isAnyArray)(F))throw TypeError("input must be an array");if(0===F.length)throw TypeError("input must not be empty");for(var $=0,V=0;V<F.length;V++)$+=F[V];return $}function mean(F){return sum(F)/F.length}function toDiscreteDistribution(F,$){let V=Array($).fill(0);for(let $=0;$<F.length;++$)V[F[$]]+=1/F.length;return H.y3.rowVector(V)}function giniImpurity(F){if(0===F.length)return 0;let $=toDiscreteDistribution(F,getNumberOfClasses(F)).getRow(0),V=0;for(let F=0;F<$.length;++F)V+=$[F]*$[F];return 1-V}function getNumberOfClasses(F){return F.filter((F,$,V)=>V.indexOf(F)===$).map(F=>F+1).reduce((F,$)=>Math.max(F,$))}function giniGain(F,$){let V=0,G=["greater","lesser"];for(let H=0;H<G.length;++H){let K=$[G[H]];V+=giniImpurity(K)*K.length/F.length}return giniImpurity(F)-V}function squaredError(F){let $=F.length;if(0===$)return 0;let V=mean(F),G=0;for(let H=0;H<$;++H){let $=F[H];G+=($-V)*($-V)}return G}function regressionError(F,$){let V=0,G=["greater","lesser"];for(let F=0;F<G.length;++F)V+=squaredError($[G[F]]);return V}function matrixSplitter(F,$,V,G){let H=[],K=[],Z=[],ee=[];for(let et=0;et<F.rows;++et)F.get(et,V)<G?(H.push(F.getRow(et)),Z.push($[et])):(K.push(F.getRow(et)),ee.push($[et]));return{greaterX:K,greaterY:ee,lesserX:H,lesserY:Z}}function utils_mean(F,$){return(F+$)/2}function zip(F,$){if(F.length!==$.length)throw TypeError(`Error on zip: the size of a: ${F.length} is different from b: ${$.length}`);let V=Array(F.length);for(let G=0;G<F.length;++G)V[G]=[F[G],$[G]];return V}let K={gini:giniGain,regression:regressionError},Z={mean:utils_mean};let TreeNode=class TreeNode{constructor(F){this.kind=F.kind,this.gainFunction=F.gainFunction,this.splitFunction=F.splitFunction,this.minNumSamples=F.minNumSamples,this.maxDepth=F.maxDepth,this.gainThreshold=F.gainThreshold||0}bestSplit(F,$){let V,G,H,Z="classifier"===this.kind?-1/0:1/0,ee="classifier"===this.kind?(F,$)=>F>$:(F,$)=>F<$;for(let et=0;et<F.rows;++et){let en=F.getRow(et),ea=this.featureSplit(en,$);for(let F=0;F<ea.length;++F){let ei=ea[F],eo=this.split(en,$,ei),es=K[this.gainFunction]($,eo);ee(es,Z)&&(V=et,G=ei,Z=es,H=en.length)}}return{maxGain:Z,maxColumn:V,maxValue:G,numberSamples:H}}split(F,$,V){let G=[],H=[];for(let K=0;K<F.length;++K)F[K]<V?G.push($[K]):H.push($[K]);return{greater:H,lesser:G}}featureSplit(F,$){let V=[],G=zip(F,$);G.sort((F,$)=>F[0]-$[0]);for(let F=1;F<G.length;++F)G[F-1][1]!==G[F][1]&&V.push(Z[this.splitFunction](G[F-1][0],G[F][0]));return V}calculatePrediction(F){if("classifier"===this.kind){if(this.distribution=toDiscreteDistribution(F,getNumberOfClasses(F)),0===this.distribution.columns)throw TypeError("Error on calculate the prediction")}else this.distribution=mean(F)}train(F,$,V,G){if(F.rows<=this.minNumSamples){this.calculatePrediction($);return}void 0===G&&(G=0);let K=F.transpose(),Z=this.bestSplit(K,$);this.splitValue=Z.maxValue,this.splitColumn=Z.maxColumn,this.gain=Z.maxGain,this.numberSamples=Z.numberSamples;let ee=matrixSplitter(F,$,this.splitColumn,this.splitValue);if(V<this.maxDepth&&this.gain>this.gainThreshold&&this.gain!==G&&ee.lesserX.length>0&&ee.greaterX.length>0){this.left=new TreeNode(this),this.right=new TreeNode(this);let F=new H.y3(ee.lesserX),$=new H.y3(ee.greaterX);this.left.train(F,ee.lesserY,V+1,this.gain),this.right.train($,ee.greaterY,V+1,this.gain)}else this.calculatePrediction($)}classify(F){return this.right&&this.left?F[this.splitColumn]<this.splitValue?this.left.classify(F):this.right.classify(F):this.distribution}setNodeParameters(F){void 0!==F.distribution?this.distribution=F.distribution.constructor===Array?new H.y3(F.distribution):F.distribution:(this.distribution=void 0,this.splitValue=F.splitValue,this.splitColumn=F.splitColumn,this.gain=F.gain,this.left=new TreeNode(this),this.right=new TreeNode(this),F.left!=={}&&this.left.setNodeParameters(F.left),F.right!=={}&&this.right.setNodeParameters(F.right))}};let ee={gainFunction:"gini",splitFunction:"mean",minNumSamples:3,maxDepth:1/0,gainThreshold:.01};let DecisionTreeClassifier=class DecisionTreeClassifier{constructor(F,$){!0===F?(this.options=$.options,this.root=new TreeNode($.options),this.root.setNodeParameters($.root)):(this.options=Object.assign({},ee,F),this.options.kind="classifier")}train(F,$){this.root=new TreeNode(this.options),F=H.y3.checkMatrix(F),this.root.train(F,$,0,null)}predict(F){let $=Array((F=H.y3.checkMatrix(F)).rows);for(let V=0;V<F.rows;++V)$[V]=this.root.classify(F.getRow(V)).maxRowIndex(0)[1];return $}toJSON(){return{options:this.options,root:this.root,name:"DTClassifier"}}static load(F){if("DTClassifier"!==F.name)throw RangeError(`Invalid model: ${F.name}`);return new DecisionTreeClassifier(!0,F)}};let et={gainFunction:"regression",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};let DecisionTreeRegression=class DecisionTreeRegression{constructor(F,$){!0===F?(this.options=$.options,this.root=new TreeNode($.options),this.root.setNodeParameters($.root)):(this.options=Object.assign({},et,F),this.options.kind="regression")}train(F,$){this.root=new TreeNode(this.options),F=void 0!==F[0]&&void 0===F[0].length?H.y3.columnVector(F):H.y3.checkMatrix(F),this.root.train(F,$,0)}predict(F){void 0!==F[0]&&void 0===F[0].length&&(F=H.y3.columnVector(F));let $=Array((F=H.y3.checkMatrix(F)).rows);for(let V=0;V<F.rows;++V)$[V]=this.root.classify(F.getRow(V));return $}toJSON(){return{options:this.options,root:this.root,name:"DTRegression"}}static load(F){if("DTRegression"!==F.name)throw RangeError(`Invalid model:${F.name}`);return new DecisionTreeRegression(!0,F)}};let en=9007199254740992,ea=en-1,ei=4294967295,eo=ei+1,es=eo/2,eu=es-1,ec=2097152,ep=ec-1;function int32(F){return 0|F.next()}function add(F,$){return 0===$?F:V=>F(V)+$}function int53(F){let $=0|F.next(),V=F.next()>>>0;return($&ep)*eo+V+($&ec?-en:0)}function int53Full(F){for(;;){let $=0|F.next();if(4194304&$){if((8388607&$)==4194304&&(0|F.next())==0)return en}else{let V=F.next()>>>0;return($&ep)*eo+V+($&ec?-en:0)}}}function uint32(F){return F.next()>>>0}function uint53(F){let $=F.next()&ep,V=F.next()>>>0;return $*eo+V}function uint53Full(F){for(;;){let $=0|F.next();if($&ec){if(($&ep)==0&&(0|F.next())==0)return en}else{let V=F.next()>>>0;return($&ep)*eo+V}}}function isPowerOfTwoMinusOne(F){return(F+1&F)==0}function bitmask(F){return $=>$.next()&F}function downscaleToLoopCheckedRange(F){let $=F+1,V=$*Math.floor(eo/$);return F=>{let G=0;do G=F.next()>>>0;while(G>=V);return G%$}}function downscaleToRange(F){return isPowerOfTwoMinusOne(F)?bitmask(F):downscaleToLoopCheckedRange(F)}function isEvenlyDivisibleByMaxInt32(F){return(0|F)==0}function upscaleWithHighMasking(F){return $=>{let V=$.next()&F,G=$.next()>>>0;return V*eo+G}}function upscaleToLoopCheckedRange(F){let $=F*Math.floor(en/F);return V=>{let G=0;do{let F=V.next()&ep,$=V.next()>>>0;G=F*eo+$}while(G>=$);return G%F}}function upscaleWithinU53(F){let $=F+1;if(isEvenlyDivisibleByMaxInt32($)){let F=($/eo|0)-1;if(isPowerOfTwoMinusOne(F))return upscaleWithHighMasking(F)}return upscaleToLoopCheckedRange($)}function upscaleWithinI53AndLoopCheck(F,$){return V=>{let G=0;do{let F=0|V.next(),$=V.next()>>>0;G=(F&ep)*eo+$+(F&ec?-en:0)}while(G<F||G>$);return G}}function integer(F,$){if(F=Math.floor(F),$=Math.floor($),F<-en||!isFinite(F))throw RangeError(`Expected min to be at least ${-en}`);if($>en||!isFinite($))throw RangeError(`Expected max to be at most ${en}`);let V=$-F;if(V<=0||!isFinite(V))return()=>F;if(V===ei)return 0===F?uint32:add(int32,F+es);if(V<ei)return add(downscaleToRange(V),F);if(V===ea)return add(uint53,F);if(V<ea)return add(upscaleWithinU53(V),F);if($-1-F===ea)return add(uint53Full,F);if(F===-en&&$===en)return int53Full;else if(F===-en&&$===ea)return int53;else if(F===-ea&&$===en)return add(int53,1);else if($===en)return add(upscaleWithinI53AndLoopCheck(F-1,$-1),1);else return upscaleWithinI53AndLoopCheck(F,$)}let eh="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";function string(F=eh){let $=F.length;if(!$)throw Error("Expected pool not to be an empty string");let V=integer(0,$-1);return($,G)=>{let H="";for(let K=0;K<G;++K){let G=V($);H+=F.charAt(G)}return H}}let ef="0123456789abcdef";string(ef),string(ef.toUpperCase()),Array.prototype.slice,(()=>{try{if("xxx"==="x".repeat(3))return(F,$)=>F.repeat($)}catch(F){}return(F,$)=>{let V="";for(;$>0;)1&$&&(V+=F),$>>=1,F+=F;return V}})();let ed={next:()=>Math.random()*eo|0},em=(()=>{try{let F=new ArrayBuffer(4),$=new Int32Array(F);if($[0]=es,$[0]===-es)return Int32Array}catch(F){}return Array})();function createEntropy(F=ed,$=16){let V=[];V.push(0|new Date().getTime());for(let G=1;G<$;++G)V[G]=0|F.next();return V}let eg=(()=>{try{if(-5===Math.imul(ei,5))return Math.imul}catch(F){}let F=65535;return($,V)=>{let G=$>>>16&F,H=$&F,K=V>>>16&F,Z=V&F;return H*Z+(G*Z+H*K<<16>>>0)|0}})(),ey=624,eb=ey-1,ew=397,eS=ey-ew,e_=2567483615;let MersenneTwister19937=class MersenneTwister19937{constructor(){this.data=new em(ey),this.index=0,this.uses=0}static seed(F){return new MersenneTwister19937().seed(F)}static seedWithArray(F){return new MersenneTwister19937().seedWithArray(F)}static autoSeed(){return MersenneTwister19937.seedWithArray(createEntropy())}next(){(0|this.index)>=ey&&(refreshData(this.data),this.index=0);let F=this.data[this.index];return this.index=this.index+1|0,this.uses+=1,0|temper(F)}getUseCount(){return this.uses}discard(F){if(F<=0)return this;for(this.uses+=F,(0|this.index)>=ey&&(refreshData(this.data),this.index=0);F+this.index>ey;)F-=ey-this.index,refreshData(this.data),this.index=0;return this.index=this.index+F|0,this}seed(F){let $=0;this.data[0]=$=0|F;for(let F=1;F<ey;F=F+1|0)this.data[F]=$=eg($^$>>>30,1812433253)+F|0;return this.index=ey,this.uses=0,this}seedWithArray(F){return this.seed(19650218),seedWithArray(this.data,F),this}};function refreshData(F){let $=0,V=0;for(;(0|$)<eS;$=$+1|0)V=F[$]&es|F[$+1|0]&eu,F[$]=F[$+ew|0]^V>>>1^(1&V?e_:0);for(;(0|$)<eb;$=$+1|0)V=F[$]&es|F[$+1|0]&eu,F[$]=F[$-eS|0]^V>>>1^(1&V?e_:0);V=F[eb]&es|F[0]&eu,F[eb]=F[ew-1]^V>>>1^(1&V?e_:0)}function temper(F){return F^=F>>>11,F^=F<<7&2636928640,(F^=F<<15&4022730752)^F>>>18}function seedWithArray(F,$){let V=1,G=0,H=$.length,K=0|Math.max(H,ey),Z=0|F[0];for(;(0|K)>0;--K)F[V]=Z=(F[V]^eg(Z^Z>>>30,1664525))+(0|$[G])+(0|G)|0,V=V+1|0,++G,(0|V)>eb&&(F[0]=F[eb],V=1),G>=H&&(G=0);for(K=eb;(0|K)>0;--K)F[V]=Z=(F[V]^eg(Z^Z>>>30,1566083941))-V|0,(0|(V=V+1|0))>eb&&(F[0]=F[eb],V=1);F[0]=es}function checkFloat(F){return F>0&&F<=1}function isFloat(F){return Number(F)===F&&F%1!=0}function examplesBaggingWithReplacement(F,$,V){let G;let K=integer(0,F.rows-1);if(void 0===V)G=MersenneTwister19937.autoSeed();else if(Number.isInteger(V))G=MersenneTwister19937.seed(V);else throw RangeError(`Expected seed must be undefined or integer not ${V}`);let Z=Array(F.rows),ee=Array(F.rows),et=Array(F.rows).fill(0),en=F.rows;for(let V=0;V<F.rows;++V){let H=K(G);Z[V]=F.getRow(H),ee[V]=$[H],0==et[H]++&&en--}let ea=Array(en),ei=Array(en);for(let $=F.rows-1;$>=0&&en>0;--$)0===et[$]&&(ea[--en]=F.getRow($),ei[en]=$);return{X:new H.y3(Z),y:ee,Xoob:new H.y3(ea),ioob:ei,seed:G.next()}}function featureBagging(F,$,V,G){let K,Z,ee;if(F.columns<$)throw RangeError("N should be less or equal to the number of columns of X");let et=integer(0,F.columns-1);if(void 0===G)K=MersenneTwister19937.autoSeed();else if(Number.isInteger(G))K=MersenneTwister19937.seed(G);else throw RangeError(`Expected seed must be undefined or integer not ${G}`);let en=new H.y3(F.rows,$);if(V){Z=Array($);for(let V=0;V<$;++V)ee=et(K),Z[V]=ee,en.setColumn(V,F.getColumn(ee))}else{Z=new Set,ee=et(K);for(let V=0;V<$;++V){for(;Z.has(ee);)ee=et(K);en.setColumn(V,F.getColumn(ee)),Z.add(ee)}Z=Array.from(Z)}return{X:en,usedIndex:Z,seed:K.next()}}let collectOOB=(F,$,V)=>{let G=Array($.length);for(let H=0;H<$.length;H++){let K=[];for(let $=0;$<F.length;$++){let V=F[$];V.index[0]===H&&(K.push(V.predicted[0]),V.index=V.index.slice(1),V.predicted=V.predicted.slice(1))}G[H]={true:$[H],all:K,predicted:V(K)}}return G};let RandomForestBase_RandomForestBase=class RandomForestBase_RandomForestBase{constructor(F,$){if(!0===F){this.replacement=$.replacement,this.maxFeatures=$.maxFeatures,this.nEstimators=$.nEstimators,this.treeOptions=$.treeOptions,this.isClassifier=$.isClassifier,this.seed=$.seed,this.n=$.n,this.indexes=$.indexes,this.useSampleBagging=$.useSampleBagging,this.noOOB=!0,this.maxSamples=$.maxSamples;let F=this.isClassifier?DecisionTreeClassifier:DecisionTreeRegression;this.estimators=$.estimators.map($=>F.load($))}else this.replacement=F.replacement,this.maxFeatures=F.maxFeatures,this.nEstimators=F.nEstimators,this.treeOptions=F.treeOptions,this.isClassifier=F.isClassifier,this.seed=F.seed,this.useSampleBagging=F.useSampleBagging,this.noOOB=F.noOOB,this.maxSamples=F.maxSamples}train(F,$){let V,G=this.seed;if(F=H.y3.checkMatrix(F),this.maxFeatures=this.maxFeatures||F.columns,this.numberFeatures=F.columns,this.numberSamples=F.rows,checkFloat(this.maxFeatures))this.n=Math.floor(F.columns*this.maxFeatures);else if(Number.isInteger(this.maxFeatures)){if(this.maxFeatures>F.columns)throw RangeError(`The maxFeatures parameter should be less than ${F.columns}`);this.n=this.maxFeatures}else throw RangeError(`Cannot process the maxFeatures parameter ${this.maxFeatures}`);if(this.maxSamples){if(this.maxSamples<0)throw RangeError("Please choose a positive value for maxSamples");if(isFloat(this.maxSamples)){if(this.maxSamples>1)throw RangeError("Please choose either a float value between 0 and 1 or a positive integer for maxSamples");this.numberSamples=Math.floor(F.rows*this.maxSamples)}else if(Number.isInteger(this.maxSamples)){if(this.maxSamples>F.rows)throw RangeError(`The maxSamples parameter should be less than ${F.rows}`);this.numberSamples=this.maxSamples}}if(this.maxSamples&&F.rows!==this.numberSamples){let V=new H.y3(this.numberSamples,F.columns);for(let F=0;F<this.numberSamples;F++)V.removeRow(0);for(let $=0;$<this.numberSamples;$++)V.addRow(F.getRow($));F=V,$=$.slice(0,this.numberSamples)}V=this.isClassifier?DecisionTreeClassifier:DecisionTreeRegression,this.estimators=Array(this.nEstimators),this.indexes=Array(this.nEstimators);let K=Array(this.nEstimators);for(let Z=0;Z<this.nEstimators;++Z){let ee=this.useSampleBagging?examplesBaggingWithReplacement(F,$,G):{X:F,y:$,seed:G,Xoob:void 0,yoob:[],ioob:[]},et=ee.X,en=ee.y;G=ee.seed;let{Xoob:ea,ioob:ei}=ee;if(et=(ee=featureBagging(et,this.n,this.replacement,G)).X,G=ee.seed,this.indexes[Z]=ee.usedIndex,this.estimators[Z]=new V(this.treeOptions),this.estimators[Z].train(et,en),!this.noOOB&&this.useSampleBagging){let F=new H.qK(ea,this.indexes[Z]);K[Z]={index:ei,predicted:this.estimators[Z].predict(F)}}}!this.noOOB&&this.useSampleBagging&&K.length>0&&(this.oobResults=collectOOB(K,$,this.selection.bind(this)))}featureImportance(){let F=JSON.parse(JSON.stringify(this.estimators)),$=JSON.parse(JSON.stringify(this.indexes)),V=[];function computeFeatureImportances(F,$){if(!$||!("splitColumn"in $)||!($.gain>0))return;let G=$.gain*$.numberSamples;"left"in $&&(G-=($.left.gain||0)*($.left.numberSamples||0)),"right"in $&&(G-=($.right.gain||0)*($.right.numberSamples||0)),V[F][$.splitColumn]+=G,$.left&&computeFeatureImportances(F,$.left),$.right&&computeFeatureImportances(F,$.right)}function normalizeImportances(F){let $=V[F].reduce((F,$)=>F+=$,0);V[F]=V[F].map(F=>F/$)}for(let $=0;$<F.length;$++)V.push(Array(this.numberFeatures).fill(0)),computeFeatureImportances($,F[$].root),normalizeImportances($);let G=Array(this.numberFeatures).fill(0);for(let F=0;F<V.length;F++)for(let H=0;H<this.numberFeatures;H++)G[$[F][H]]+=V[F][H];let H=G.reduce((F,$)=>F+=$,0);return G.map(F=>F/H)}selection(F){throw Error("Abstract method 'selection' not implemented!")}predict(F){let $=this.predictionValues(F),V=Array($.rows);for(let F=0;F<$.rows;++F)V[F]=this.selection($.getRow(F));return V}predictionValues(F){let $=Array(this.nEstimators);F=H.y3.checkMatrix(F);for(let V=0;V<this.nEstimators;++V){let G=new H.qK(F,this.indexes[V]);$[V]=this.estimators[V].predict(G)}return new H.tU(new H.$r($))}predictOOB(){if(!this.oobResults||0===this.oobResults.length)throw Error("No Out-Of-Bag results found. Did you forgot to train first?");return this.oobResults.map(F=>F.predicted)}toJSON(){return{indexes:this.indexes,n:this.n,replacement:this.replacement,maxFeatures:this.maxFeatures,nEstimators:this.nEstimators,treeOptions:this.treeOptions,isClassifier:this.isClassifier,seed:this.seed,estimators:this.estimators.map(F=>F.toJSON()),useSampleBagging:this.useSampleBagging}}};var eN=V(45520),ek=V.n(eN);function median(F){if(!(0,G.isAnyArray)(F))throw TypeError("input must be an array");if(0===F.length)throw TypeError("input must not be empty");return ek()(F.slice())}let eI={mean:mean,median:median},eT={maxFeatures:1,replacement:!1,nEstimators:50,treeOptions:{},selectionMethod:"mean",seed:42,useSampleBagging:!0,noOOB:!1};let RandomForestRegression=class RandomForestRegression extends RandomForestBase_RandomForestBase{constructor(F,$){if(!0===F)super(!0,$.baseModel),this.selectionMethod=$.selectionMethod;else{if(!("mean"===(F=Object.assign({},eT,F)).selectionMethod||"median"===F.selectionMethod))throw RangeError(`Unsupported selection method ${F.selectionMethod}`);F.isClassifier=!1,super(F),this.selectionMethod=F.selectionMethod}}selection(F){return eI[this.selectionMethod](F)}toJSON(){return{baseModel:super.toJSON(),selectionMethod:this.selectionMethod,name:"RFRegression"}}static load(F){if("RFRegression"!==F.name)throw RangeError(`Invalid model: ${F.name}`);return new RandomForestRegression(!0,F)}}},21876:function(F){var $="/";!function(){var V={675:function(F,$){"use strict";$.byteLength=byteLength,$.toByteArray=toByteArray,$.fromByteArray=fromByteArray;for(var V=[],G=[],H="undefined"!=typeof Uint8Array?Uint8Array:Array,K="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Z=0,ee=K.length;Z<ee;++Z)V[Z]=K[Z],G[K.charCodeAt(Z)]=Z;function getLens(F){var $=F.length;if($%4>0)throw Error("Invalid string. Length must be a multiple of 4");var V=F.indexOf("=");-1===V&&(V=$);var G=V===$?0:4-V%4;return[V,G]}function byteLength(F){var $=getLens(F),V=$[0],G=$[1];return(V+G)*3/4-G}function _byteLength(F,$,V){return($+V)*3/4-V}function toByteArray(F){var $,V,K=getLens(F),Z=K[0],ee=K[1],et=new H(_byteLength(F,Z,ee)),en=0,ea=ee>0?Z-4:Z;for(V=0;V<ea;V+=4)$=G[F.charCodeAt(V)]<<18|G[F.charCodeAt(V+1)]<<12|G[F.charCodeAt(V+2)]<<6|G[F.charCodeAt(V+3)],et[en++]=$>>16&255,et[en++]=$>>8&255,et[en++]=255&$;return 2===ee&&($=G[F.charCodeAt(V)]<<2|G[F.charCodeAt(V+1)]>>4,et[en++]=255&$),1===ee&&($=G[F.charCodeAt(V)]<<10|G[F.charCodeAt(V+1)]<<4|G[F.charCodeAt(V+2)]>>2,et[en++]=$>>8&255,et[en++]=255&$),et}function tripletToBase64(F){return V[F>>18&63]+V[F>>12&63]+V[F>>6&63]+V[63&F]}function encodeChunk(F,$,V){for(var G=[],H=$;H<V;H+=3)G.push(tripletToBase64((F[H]<<16&16711680)+(F[H+1]<<8&65280)+(255&F[H+2])));return G.join("")}function fromByteArray(F){for(var $,G=F.length,H=G%3,K=[],Z=16383,ee=0,et=G-H;ee<et;ee+=Z)K.push(encodeChunk(F,ee,ee+Z>et?et:ee+Z));return 1===H?K.push(V[($=F[G-1])>>2]+V[$<<4&63]+"=="):2===H&&K.push(V[($=(F[G-2]<<8)+F[G-1])>>10]+V[$>>4&63]+V[$<<2&63]+"="),K.join("")}G["-".charCodeAt(0)]=62,G["_".charCodeAt(0)]=63},72:function(F,$,V){"use strict";/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */var G=V(675),H=V(783),K="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;$.Buffer=Buffer,$.SlowBuffer=SlowBuffer,$.INSPECT_MAX_BYTES=50;var Z=2147483647;function typedArraySupport(){try{var F=new Uint8Array(1),$={foo:function(){return 42}};return Object.setPrototypeOf($,Uint8Array.prototype),Object.setPrototypeOf(F,$),42===F.foo()}catch(F){return!1}}function createBuffer(F){if(F>Z)throw RangeError('The value "'+F+'" is invalid for option "size"');var $=new Uint8Array(F);return Object.setPrototypeOf($,Buffer.prototype),$}function Buffer(F,$,V){if("number"==typeof F){if("string"==typeof $)throw TypeError('The "string" argument must be of type string. Received type number');return allocUnsafe(F)}return from(F,$,V)}function from(F,$,V){if("string"==typeof F)return fromString(F,$);if(ArrayBuffer.isView(F))return fromArrayLike(F);if(null==F)throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof F);if(isInstance(F,ArrayBuffer)||F&&isInstance(F.buffer,ArrayBuffer)||"undefined"!=typeof SharedArrayBuffer&&(isInstance(F,SharedArrayBuffer)||F&&isInstance(F.buffer,SharedArrayBuffer)))return fromArrayBuffer(F,$,V);if("number"==typeof F)throw TypeError('The "value" argument must not be of type number. Received type number');var G=F.valueOf&&F.valueOf();if(null!=G&&G!==F)return Buffer.from(G,$,V);var H=fromObject(F);if(H)return H;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof F[Symbol.toPrimitive])return Buffer.from(F[Symbol.toPrimitive]("string"),$,V);throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof F)}function assertSize(F){if("number"!=typeof F)throw TypeError('"size" argument must be of type number');if(F<0)throw RangeError('The value "'+F+'" is invalid for option "size"')}function alloc(F,$,V){return(assertSize(F),F<=0)?createBuffer(F):void 0!==$?"string"==typeof V?createBuffer(F).fill($,V):createBuffer(F).fill($):createBuffer(F)}function allocUnsafe(F){return assertSize(F),createBuffer(F<0?0:0|checked(F))}function fromString(F,$){if(("string"!=typeof $||""===$)&&($="utf8"),!Buffer.isEncoding($))throw TypeError("Unknown encoding: "+$);var V=0|byteLength(F,$),G=createBuffer(V),H=G.write(F,$);return H!==V&&(G=G.slice(0,H)),G}function fromArrayLike(F){for(var $=F.length<0?0:0|checked(F.length),V=createBuffer($),G=0;G<$;G+=1)V[G]=255&F[G];return V}function fromArrayBuffer(F,$,V){var G;if($<0||F.byteLength<$)throw RangeError('"offset" is outside of buffer bounds');if(F.byteLength<$+(V||0))throw RangeError('"length" is outside of buffer bounds');return Object.setPrototypeOf(G=void 0===$&&void 0===V?new Uint8Array(F):void 0===V?new Uint8Array(F,$):new Uint8Array(F,$,V),Buffer.prototype),G}function fromObject(F){if(Buffer.isBuffer(F)){var $=0|checked(F.length),V=createBuffer($);return 0===V.length||F.copy(V,0,0,$),V}return void 0!==F.length?"number"!=typeof F.length||numberIsNaN(F.length)?createBuffer(0):fromArrayLike(F):"Buffer"===F.type&&Array.isArray(F.data)?fromArrayLike(F.data):void 0}function checked(F){if(F>=Z)throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+Z.toString(16)+" bytes");return 0|F}function SlowBuffer(F){return+F!=F&&(F=0),Buffer.alloc(+F)}function byteLength(F,$){if(Buffer.isBuffer(F))return F.length;if(ArrayBuffer.isView(F)||isInstance(F,ArrayBuffer))return F.byteLength;if("string"!=typeof F)throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof F);var V=F.length,G=arguments.length>2&&!0===arguments[2];if(!G&&0===V)return 0;for(var H=!1;;)switch($){case"ascii":case"latin1":case"binary":return V;case"utf8":case"utf-8":return utf8ToBytes(F).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*V;case"hex":return V>>>1;case"base64":return base64ToBytes(F).length;default:if(H)return G?-1:utf8ToBytes(F).length;$=(""+$).toLowerCase(),H=!0}}function slowToString(F,$,V){var G=!1;if((void 0===$||$<0)&&($=0),$>this.length||((void 0===V||V>this.length)&&(V=this.length),V<=0||(V>>>=0)<=($>>>=0)))return"";for(F||(F="utf8");;)switch(F){case"hex":return hexSlice(this,$,V);case"utf8":case"utf-8":return utf8Slice(this,$,V);case"ascii":return asciiSlice(this,$,V);case"latin1":case"binary":return latin1Slice(this,$,V);case"base64":return base64Slice(this,$,V);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return utf16leSlice(this,$,V);default:if(G)throw TypeError("Unknown encoding: "+F);F=(F+"").toLowerCase(),G=!0}}function swap(F,$,V){var G=F[$];F[$]=F[V],F[V]=G}function bidirectionalIndexOf(F,$,V,G,H){if(0===F.length)return -1;if("string"==typeof V?(G=V,V=0):V>2147483647?V=2147483647:V<-2147483648&&(V=-2147483648),numberIsNaN(V=+V)&&(V=H?0:F.length-1),V<0&&(V=F.length+V),V>=F.length){if(H)return -1;V=F.length-1}else if(V<0){if(!H)return -1;V=0}if("string"==typeof $&&($=Buffer.from($,G)),Buffer.isBuffer($))return 0===$.length?-1:arrayIndexOf(F,$,V,G,H);if("number"==typeof $)return($&=255,"function"==typeof Uint8Array.prototype.indexOf)?H?Uint8Array.prototype.indexOf.call(F,$,V):Uint8Array.prototype.lastIndexOf.call(F,$,V):arrayIndexOf(F,[$],V,G,H);throw TypeError("val must be string, number or Buffer")}function arrayIndexOf(F,$,V,G,H){var K,Z=1,ee=F.length,et=$.length;if(void 0!==G&&("ucs2"===(G=String(G).toLowerCase())||"ucs-2"===G||"utf16le"===G||"utf-16le"===G)){if(F.length<2||$.length<2)return -1;Z=2,ee/=2,et/=2,V/=2}function read(F,$){return 1===Z?F[$]:F.readUInt16BE($*Z)}if(H){var en=-1;for(K=V;K<ee;K++)if(read(F,K)===read($,-1===en?0:K-en)){if(-1===en&&(en=K),K-en+1===et)return en*Z}else -1!==en&&(K-=K-en),en=-1}else for(V+et>ee&&(V=ee-et),K=V;K>=0;K--){for(var ea=!0,ei=0;ei<et;ei++)if(read(F,K+ei)!==read($,ei)){ea=!1;break}if(ea)return K}return -1}function hexWrite(F,$,V,G){V=Number(V)||0;var H=F.length-V;G?(G=Number(G))>H&&(G=H):G=H;var K=$.length;G>K/2&&(G=K/2);for(var Z=0;Z<G;++Z){var ee=parseInt($.substr(2*Z,2),16);if(numberIsNaN(ee))break;F[V+Z]=ee}return Z}function utf8Write(F,$,V,G){return blitBuffer(utf8ToBytes($,F.length-V),F,V,G)}function asciiWrite(F,$,V,G){return blitBuffer(asciiToBytes($),F,V,G)}function latin1Write(F,$,V,G){return asciiWrite(F,$,V,G)}function base64Write(F,$,V,G){return blitBuffer(base64ToBytes($),F,V,G)}function ucs2Write(F,$,V,G){return blitBuffer(utf16leToBytes($,F.length-V),F,V,G)}function base64Slice(F,$,V){return 0===$&&V===F.length?G.fromByteArray(F):G.fromByteArray(F.slice($,V))}function utf8Slice(F,$,V){V=Math.min(F.length,V);for(var G=[],H=$;H<V;){var K,Z,ee,et,en=F[H],ea=null,ei=en>239?4:en>223?3:en>191?2:1;if(H+ei<=V)switch(ei){case 1:en<128&&(ea=en);break;case 2:(192&(K=F[H+1]))==128&&(et=(31&en)<<6|63&K)>127&&(ea=et);break;case 3:K=F[H+1],Z=F[H+2],(192&K)==128&&(192&Z)==128&&(et=(15&en)<<12|(63&K)<<6|63&Z)>2047&&(et<55296||et>57343)&&(ea=et);break;case 4:K=F[H+1],Z=F[H+2],ee=F[H+3],(192&K)==128&&(192&Z)==128&&(192&ee)==128&&(et=(15&en)<<18|(63&K)<<12|(63&Z)<<6|63&ee)>65535&&et<1114112&&(ea=et)}null===ea?(ea=65533,ei=1):ea>65535&&(ea-=65536,G.push(ea>>>10&1023|55296),ea=56320|1023&ea),G.push(ea),H+=ei}return decodeCodePointsArray(G)}$.kMaxLength=Z,Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport(),Buffer.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(Buffer.prototype,"parent",{enumerable:!0,get:function(){if(Buffer.isBuffer(this))return this.buffer}}),Object.defineProperty(Buffer.prototype,"offset",{enumerable:!0,get:function(){if(Buffer.isBuffer(this))return this.byteOffset}}),Buffer.poolSize=8192,Buffer.from=function(F,$,V){return from(F,$,V)},Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype),Object.setPrototypeOf(Buffer,Uint8Array),Buffer.alloc=function(F,$,V){return alloc(F,$,V)},Buffer.allocUnsafe=function(F){return allocUnsafe(F)},Buffer.allocUnsafeSlow=function(F){return allocUnsafe(F)},Buffer.isBuffer=function(F){return null!=F&&!0===F._isBuffer&&F!==Buffer.prototype},Buffer.compare=function(F,$){if(isInstance(F,Uint8Array)&&(F=Buffer.from(F,F.offset,F.byteLength)),isInstance($,Uint8Array)&&($=Buffer.from($,$.offset,$.byteLength)),!Buffer.isBuffer(F)||!Buffer.isBuffer($))throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(F===$)return 0;for(var V=F.length,G=$.length,H=0,K=Math.min(V,G);H<K;++H)if(F[H]!==$[H]){V=F[H],G=$[H];break}return V<G?-1:G<V?1:0},Buffer.isEncoding=function(F){switch(String(F).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Buffer.concat=function(F,$){if(!Array.isArray(F))throw TypeError('"list" argument must be an Array of Buffers');if(0===F.length)return Buffer.alloc(0);if(void 0===$)for(V=0,$=0;V<F.length;++V)$+=F[V].length;var V,G=Buffer.allocUnsafe($),H=0;for(V=0;V<F.length;++V){var K=F[V];if(isInstance(K,Uint8Array)&&(K=Buffer.from(K)),!Buffer.isBuffer(K))throw TypeError('"list" argument must be an Array of Buffers');K.copy(G,H),H+=K.length}return G},Buffer.byteLength=byteLength,Buffer.prototype._isBuffer=!0,Buffer.prototype.swap16=function(){var F=this.length;if(F%2!=0)throw RangeError("Buffer size must be a multiple of 16-bits");for(var $=0;$<F;$+=2)swap(this,$,$+1);return this},Buffer.prototype.swap32=function(){var F=this.length;if(F%4!=0)throw RangeError("Buffer size must be a multiple of 32-bits");for(var $=0;$<F;$+=4)swap(this,$,$+3),swap(this,$+1,$+2);return this},Buffer.prototype.swap64=function(){var F=this.length;if(F%8!=0)throw RangeError("Buffer size must be a multiple of 64-bits");for(var $=0;$<F;$+=8)swap(this,$,$+7),swap(this,$+1,$+6),swap(this,$+2,$+5),swap(this,$+3,$+4);return this},Buffer.prototype.toString=function(){var F=this.length;return 0===F?"":0==arguments.length?utf8Slice(this,0,F):slowToString.apply(this,arguments)},Buffer.prototype.toLocaleString=Buffer.prototype.toString,Buffer.prototype.equals=function(F){if(!Buffer.isBuffer(F))throw TypeError("Argument must be a Buffer");return this===F||0===Buffer.compare(this,F)},Buffer.prototype.inspect=function(){var F="",V=$.INSPECT_MAX_BYTES;return F=this.toString("hex",0,V).replace(/(.{2})/g,"$1 ").trim(),this.length>V&&(F+=" ... "),"<Buffer "+F+">"},K&&(Buffer.prototype[K]=Buffer.prototype.inspect),Buffer.prototype.compare=function(F,$,V,G,H){if(isInstance(F,Uint8Array)&&(F=Buffer.from(F,F.offset,F.byteLength)),!Buffer.isBuffer(F))throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof F);if(void 0===$&&($=0),void 0===V&&(V=F?F.length:0),void 0===G&&(G=0),void 0===H&&(H=this.length),$<0||V>F.length||G<0||H>this.length)throw RangeError("out of range index");if(G>=H&&$>=V)return 0;if(G>=H)return -1;if($>=V)return 1;if($>>>=0,V>>>=0,G>>>=0,H>>>=0,this===F)return 0;for(var K=H-G,Z=V-$,ee=Math.min(K,Z),et=this.slice(G,H),en=F.slice($,V),ea=0;ea<ee;++ea)if(et[ea]!==en[ea]){K=et[ea],Z=en[ea];break}return K<Z?-1:Z<K?1:0},Buffer.prototype.includes=function(F,$,V){return -1!==this.indexOf(F,$,V)},Buffer.prototype.indexOf=function(F,$,V){return bidirectionalIndexOf(this,F,$,V,!0)},Buffer.prototype.lastIndexOf=function(F,$,V){return bidirectionalIndexOf(this,F,$,V,!1)},Buffer.prototype.write=function(F,$,V,G){if(void 0===$)G="utf8",V=this.length,$=0;else if(void 0===V&&"string"==typeof $)G=$,V=this.length,$=0;else if(isFinite($))$>>>=0,isFinite(V)?(V>>>=0,void 0===G&&(G="utf8")):(G=V,V=void 0);else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");var H=this.length-$;if((void 0===V||V>H)&&(V=H),F.length>0&&(V<0||$<0)||$>this.length)throw RangeError("Attempt to write outside buffer bounds");G||(G="utf8");for(var K=!1;;)switch(G){case"hex":return hexWrite(this,F,$,V);case"utf8":case"utf-8":return utf8Write(this,F,$,V);case"ascii":return asciiWrite(this,F,$,V);case"latin1":case"binary":return latin1Write(this,F,$,V);case"base64":return base64Write(this,F,$,V);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ucs2Write(this,F,$,V);default:if(K)throw TypeError("Unknown encoding: "+G);G=(""+G).toLowerCase(),K=!0}},Buffer.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var ee=4096;function decodeCodePointsArray(F){var $=F.length;if($<=ee)return String.fromCharCode.apply(String,F);for(var V="",G=0;G<$;)V+=String.fromCharCode.apply(String,F.slice(G,G+=ee));return V}function asciiSlice(F,$,V){var G="";V=Math.min(F.length,V);for(var H=$;H<V;++H)G+=String.fromCharCode(127&F[H]);return G}function latin1Slice(F,$,V){var G="";V=Math.min(F.length,V);for(var H=$;H<V;++H)G+=String.fromCharCode(F[H]);return G}function hexSlice(F,$,V){var G=F.length;(!$||$<0)&&($=0),(!V||V<0||V>G)&&(V=G);for(var H="",K=$;K<V;++K)H+=en[F[K]];return H}function utf16leSlice(F,$,V){for(var G=F.slice($,V),H="",K=0;K<G.length;K+=2)H+=String.fromCharCode(G[K]+256*G[K+1]);return H}function checkOffset(F,$,V){if(F%1!=0||F<0)throw RangeError("offset is not uint");if(F+$>V)throw RangeError("Trying to access beyond buffer length")}function checkInt(F,$,V,G,H,K){if(!Buffer.isBuffer(F))throw TypeError('"buffer" argument must be a Buffer instance');if($>H||$<K)throw RangeError('"value" argument is out of bounds');if(V+G>F.length)throw RangeError("Index out of range")}function checkIEEE754(F,$,V,G,H,K){if(V+G>F.length||V<0)throw RangeError("Index out of range")}function writeFloat(F,$,V,G,K){return $=+$,V>>>=0,K||checkIEEE754(F,$,V,4,34028234663852886e22,-34028234663852886e22),H.write(F,$,V,G,23,4),V+4}function writeDouble(F,$,V,G,K){return $=+$,V>>>=0,K||checkIEEE754(F,$,V,8,17976931348623157e292,-17976931348623157e292),H.write(F,$,V,G,52,8),V+8}Buffer.prototype.slice=function(F,$){var V=this.length;F=~~F,$=void 0===$?V:~~$,F<0?(F+=V)<0&&(F=0):F>V&&(F=V),$<0?($+=V)<0&&($=0):$>V&&($=V),$<F&&($=F);var G=this.subarray(F,$);return Object.setPrototypeOf(G,Buffer.prototype),G},Buffer.prototype.readUIntLE=function(F,$,V){F>>>=0,$>>>=0,V||checkOffset(F,$,this.length);for(var G=this[F],H=1,K=0;++K<$&&(H*=256);)G+=this[F+K]*H;return G},Buffer.prototype.readUIntBE=function(F,$,V){F>>>=0,$>>>=0,V||checkOffset(F,$,this.length);for(var G=this[F+--$],H=1;$>0&&(H*=256);)G+=this[F+--$]*H;return G},Buffer.prototype.readUInt8=function(F,$){return F>>>=0,$||checkOffset(F,1,this.length),this[F]},Buffer.prototype.readUInt16LE=function(F,$){return F>>>=0,$||checkOffset(F,2,this.length),this[F]|this[F+1]<<8},Buffer.prototype.readUInt16BE=function(F,$){return F>>>=0,$||checkOffset(F,2,this.length),this[F]<<8|this[F+1]},Buffer.prototype.readUInt32LE=function(F,$){return F>>>=0,$||checkOffset(F,4,this.length),(this[F]|this[F+1]<<8|this[F+2]<<16)+16777216*this[F+3]},Buffer.prototype.readUInt32BE=function(F,$){return F>>>=0,$||checkOffset(F,4,this.length),16777216*this[F]+(this[F+1]<<16|this[F+2]<<8|this[F+3])},Buffer.prototype.readIntLE=function(F,$,V){F>>>=0,$>>>=0,V||checkOffset(F,$,this.length);for(var G=this[F],H=1,K=0;++K<$&&(H*=256);)G+=this[F+K]*H;return G>=(H*=128)&&(G-=Math.pow(2,8*$)),G},Buffer.prototype.readIntBE=function(F,$,V){F>>>=0,$>>>=0,V||checkOffset(F,$,this.length);for(var G=$,H=1,K=this[F+--G];G>0&&(H*=256);)K+=this[F+--G]*H;return K>=(H*=128)&&(K-=Math.pow(2,8*$)),K},Buffer.prototype.readInt8=function(F,$){return(F>>>=0,$||checkOffset(F,1,this.length),128&this[F])?-((255-this[F]+1)*1):this[F]},Buffer.prototype.readInt16LE=function(F,$){F>>>=0,$||checkOffset(F,2,this.length);var V=this[F]|this[F+1]<<8;return 32768&V?4294901760|V:V},Buffer.prototype.readInt16BE=function(F,$){F>>>=0,$||checkOffset(F,2,this.length);var V=this[F+1]|this[F]<<8;return 32768&V?4294901760|V:V},Buffer.prototype.readInt32LE=function(F,$){return F>>>=0,$||checkOffset(F,4,this.length),this[F]|this[F+1]<<8|this[F+2]<<16|this[F+3]<<24},Buffer.prototype.readInt32BE=function(F,$){return F>>>=0,$||checkOffset(F,4,this.length),this[F]<<24|this[F+1]<<16|this[F+2]<<8|this[F+3]},Buffer.prototype.readFloatLE=function(F,$){return F>>>=0,$||checkOffset(F,4,this.length),H.read(this,F,!0,23,4)},Buffer.prototype.readFloatBE=function(F,$){return F>>>=0,$||checkOffset(F,4,this.length),H.read(this,F,!1,23,4)},Buffer.prototype.readDoubleLE=function(F,$){return F>>>=0,$||checkOffset(F,8,this.length),H.read(this,F,!0,52,8)},Buffer.prototype.readDoubleBE=function(F,$){return F>>>=0,$||checkOffset(F,8,this.length),H.read(this,F,!1,52,8)},Buffer.prototype.writeUIntLE=function(F,$,V,G){if(F=+F,$>>>=0,V>>>=0,!G){var H=Math.pow(2,8*V)-1;checkInt(this,F,$,V,H,0)}var K=1,Z=0;for(this[$]=255&F;++Z<V&&(K*=256);)this[$+Z]=F/K&255;return $+V},Buffer.prototype.writeUIntBE=function(F,$,V,G){if(F=+F,$>>>=0,V>>>=0,!G){var H=Math.pow(2,8*V)-1;checkInt(this,F,$,V,H,0)}var K=V-1,Z=1;for(this[$+K]=255&F;--K>=0&&(Z*=256);)this[$+K]=F/Z&255;return $+V},Buffer.prototype.writeUInt8=function(F,$,V){return F=+F,$>>>=0,V||checkInt(this,F,$,1,255,0),this[$]=255&F,$+1},Buffer.prototype.writeUInt16LE=function(F,$,V){return F=+F,$>>>=0,V||checkInt(this,F,$,2,65535,0),this[$]=255&F,this[$+1]=F>>>8,$+2},Buffer.prototype.writeUInt16BE=function(F,$,V){return F=+F,$>>>=0,V||checkInt(this,F,$,2,65535,0),this[$]=F>>>8,this[$+1]=255&F,$+2},Buffer.prototype.writeUInt32LE=function(F,$,V){return F=+F,$>>>=0,V||checkInt(this,F,$,4,4294967295,0),this[$+3]=F>>>24,this[$+2]=F>>>16,this[$+1]=F>>>8,this[$]=255&F,$+4},Buffer.prototype.writeUInt32BE=function(F,$,V){return F=+F,$>>>=0,V||checkInt(this,F,$,4,4294967295,0),this[$]=F>>>24,this[$+1]=F>>>16,this[$+2]=F>>>8,this[$+3]=255&F,$+4},Buffer.prototype.writeIntLE=function(F,$,V,G){if(F=+F,$>>>=0,!G){var H=Math.pow(2,8*V-1);checkInt(this,F,$,V,H-1,-H)}var K=0,Z=1,ee=0;for(this[$]=255&F;++K<V&&(Z*=256);)F<0&&0===ee&&0!==this[$+K-1]&&(ee=1),this[$+K]=(F/Z>>0)-ee&255;return $+V},Buffer.prototype.writeIntBE=function(F,$,V,G){if(F=+F,$>>>=0,!G){var H=Math.pow(2,8*V-1);checkInt(this,F,$,V,H-1,-H)}var K=V-1,Z=1,ee=0;for(this[$+K]=255&F;--K>=0&&(Z*=256);)F<0&&0===ee&&0!==this[$+K+1]&&(ee=1),this[$+K]=(F/Z>>0)-ee&255;return $+V},Buffer.prototype.writeInt8=function(F,$,V){return F=+F,$>>>=0,V||checkInt(this,F,$,1,127,-128),F<0&&(F=255+F+1),this[$]=255&F,$+1},Buffer.prototype.writeInt16LE=function(F,$,V){return F=+F,$>>>=0,V||checkInt(this,F,$,2,32767,-32768),this[$]=255&F,this[$+1]=F>>>8,$+2},Buffer.prototype.writeInt16BE=function(F,$,V){return F=+F,$>>>=0,V||checkInt(this,F,$,2,32767,-32768),this[$]=F>>>8,this[$+1]=255&F,$+2},Buffer.prototype.writeInt32LE=function(F,$,V){return F=+F,$>>>=0,V||checkInt(this,F,$,4,2147483647,-2147483648),this[$]=255&F,this[$+1]=F>>>8,this[$+2]=F>>>16,this[$+3]=F>>>24,$+4},Buffer.prototype.writeInt32BE=function(F,$,V){return F=+F,$>>>=0,V||checkInt(this,F,$,4,2147483647,-2147483648),F<0&&(F=4294967295+F+1),this[$]=F>>>24,this[$+1]=F>>>16,this[$+2]=F>>>8,this[$+3]=255&F,$+4},Buffer.prototype.writeFloatLE=function(F,$,V){return writeFloat(this,F,$,!0,V)},Buffer.prototype.writeFloatBE=function(F,$,V){return writeFloat(this,F,$,!1,V)},Buffer.prototype.writeDoubleLE=function(F,$,V){return writeDouble(this,F,$,!0,V)},Buffer.prototype.writeDoubleBE=function(F,$,V){return writeDouble(this,F,$,!1,V)},Buffer.prototype.copy=function(F,$,V,G){if(!Buffer.isBuffer(F))throw TypeError("argument should be a Buffer");if(V||(V=0),G||0===G||(G=this.length),$>=F.length&&($=F.length),$||($=0),G>0&&G<V&&(G=V),G===V||0===F.length||0===this.length)return 0;if($<0)throw RangeError("targetStart out of bounds");if(V<0||V>=this.length)throw RangeError("Index out of range");if(G<0)throw RangeError("sourceEnd out of bounds");G>this.length&&(G=this.length),F.length-$<G-V&&(G=F.length-$+V);var H=G-V;if(this===F&&"function"==typeof Uint8Array.prototype.copyWithin)this.copyWithin($,V,G);else if(this===F&&V<$&&$<G)for(var K=H-1;K>=0;--K)F[K+$]=this[K+V];else Uint8Array.prototype.set.call(F,this.subarray(V,G),$);return H},Buffer.prototype.fill=function(F,$,V,G){if("string"==typeof F){if("string"==typeof $?(G=$,$=0,V=this.length):"string"==typeof V&&(G=V,V=this.length),void 0!==G&&"string"!=typeof G)throw TypeError("encoding must be a string");if("string"==typeof G&&!Buffer.isEncoding(G))throw TypeError("Unknown encoding: "+G);if(1===F.length){var H,K=F.charCodeAt(0);("utf8"===G&&K<128||"latin1"===G)&&(F=K)}}else"number"==typeof F?F&=255:"boolean"==typeof F&&(F=Number(F));if($<0||this.length<$||this.length<V)throw RangeError("Out of range index");if(V<=$)return this;if($>>>=0,V=void 0===V?this.length:V>>>0,F||(F=0),"number"==typeof F)for(H=$;H<V;++H)this[H]=F;else{var Z=Buffer.isBuffer(F)?F:Buffer.from(F,G),ee=Z.length;if(0===ee)throw TypeError('The value "'+F+'" is invalid for argument "value"');for(H=0;H<V-$;++H)this[H+$]=Z[H%ee]}return this};var et=/[^+/0-9A-Za-z-_]/g;function base64clean(F){if((F=(F=F.split("=")[0]).trim().replace(et,"")).length<2)return"";for(;F.length%4!=0;)F+="=";return F}function utf8ToBytes(F,$){$=$||1/0;for(var V,G=F.length,H=null,K=[],Z=0;Z<G;++Z){if((V=F.charCodeAt(Z))>55295&&V<57344){if(!H){if(V>56319||Z+1===G){($-=3)>-1&&K.push(239,191,189);continue}H=V;continue}if(V<56320){($-=3)>-1&&K.push(239,191,189),H=V;continue}V=(H-55296<<10|V-56320)+65536}else H&&($-=3)>-1&&K.push(239,191,189);if(H=null,V<128){if(($-=1)<0)break;K.push(V)}else if(V<2048){if(($-=2)<0)break;K.push(V>>6|192,63&V|128)}else if(V<65536){if(($-=3)<0)break;K.push(V>>12|224,V>>6&63|128,63&V|128)}else if(V<1114112){if(($-=4)<0)break;K.push(V>>18|240,V>>12&63|128,V>>6&63|128,63&V|128)}else throw Error("Invalid code point")}return K}function asciiToBytes(F){for(var $=[],V=0;V<F.length;++V)$.push(255&F.charCodeAt(V));return $}function utf16leToBytes(F,$){for(var V,G,H=[],K=0;K<F.length&&!(($-=2)<0);++K)G=(V=F.charCodeAt(K))>>8,H.push(V%256),H.push(G);return H}function base64ToBytes(F){return G.toByteArray(base64clean(F))}function blitBuffer(F,$,V,G){for(var H=0;H<G&&!(H+V>=$.length)&&!(H>=F.length);++H)$[H+V]=F[H];return H}function isInstance(F,$){return F instanceof $||null!=F&&null!=F.constructor&&null!=F.constructor.name&&F.constructor.name===$.name}function numberIsNaN(F){return F!=F}var en=function(){for(var F="0123456789abcdef",$=Array(256),V=0;V<16;++V)for(var G=16*V,H=0;H<16;++H)$[G+H]=F[V]+F[H];return $}()},783:function(F,$){/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */$.read=function(F,$,V,G,H){var K,Z,ee=8*H-G-1,et=(1<<ee)-1,en=et>>1,ea=-7,ei=V?H-1:0,eo=V?-1:1,es=F[$+ei];for(ei+=eo,K=es&(1<<-ea)-1,es>>=-ea,ea+=ee;ea>0;K=256*K+F[$+ei],ei+=eo,ea-=8);for(Z=K&(1<<-ea)-1,K>>=-ea,ea+=G;ea>0;Z=256*Z+F[$+ei],ei+=eo,ea-=8);if(0===K)K=1-en;else{if(K===et)return Z?NaN:(es?-1:1)*(1/0);Z+=Math.pow(2,G),K-=en}return(es?-1:1)*Z*Math.pow(2,K-G)},$.write=function(F,$,V,G,H,K){var Z,ee,et,en=8*K-H-1,ea=(1<<en)-1,ei=ea>>1,eo=23===H?5960464477539062e-23:0,es=G?0:K-1,eu=G?1:-1,ec=$<0||0===$&&1/$<0?1:0;for(isNaN($=Math.abs($))||$===1/0?(ee=isNaN($)?1:0,Z=ea):(Z=Math.floor(Math.log($)/Math.LN2),$*(et=Math.pow(2,-Z))<1&&(Z--,et*=2),Z+ei>=1?$+=eo/et:$+=eo*Math.pow(2,1-ei),$*et>=2&&(Z++,et/=2),Z+ei>=ea?(ee=0,Z=ea):Z+ei>=1?(ee=($*et-1)*Math.pow(2,H),Z+=ei):(ee=$*Math.pow(2,ei-1)*Math.pow(2,H),Z=0));H>=8;F[V+es]=255&ee,es+=eu,ee/=256,H-=8);for(Z=Z<<H|ee,en+=H;en>0;F[V+es]=255&Z,es+=eu,Z/=256,en-=8);F[V+es-eu]|=128*ec}}},G={};function __nccwpck_require__(F){var $=G[F];if(void 0!==$)return $.exports;var H=G[F]={exports:{}},K=!0;try{V[F](H,H.exports,__nccwpck_require__),K=!1}finally{K&&delete G[F]}return H.exports}__nccwpck_require__.ab=$+"/";var H=__nccwpck_require__(72);F.exports=H}()},79681:function(F,$,V){var G="/",H=V(83454);!function(){var $={782:function(F){"function"==typeof Object.create?F.exports=function(F,$){$&&(F.super_=$,F.prototype=Object.create($.prototype,{constructor:{value:F,enumerable:!1,writable:!0,configurable:!0}}))}:F.exports=function(F,$){if($){F.super_=$;var TempCtor=function(){};TempCtor.prototype=$.prototype,F.prototype=new TempCtor,F.prototype.constructor=F}}},646:function(F){"use strict";let $={};function createErrorType(F,V,G){function getMessage(F,$,G){return"string"==typeof V?V:V(F,$,G)}G||(G=Error);let NodeError=class NodeError extends G{constructor(F,$,V){super(getMessage(F,$,V))}};NodeError.prototype.name=G.name,NodeError.prototype.code=F,$[F]=NodeError}function oneOf(F,$){if(!Array.isArray(F))return`of ${$} ${String(F)}`;{let V=F.length;return(F=F.map(F=>String(F)),V>2)?`one of ${$} ${F.slice(0,V-1).join(", ")}, or `+F[V-1]:2===V?`one of ${$} ${F[0]} or ${F[1]}`:`of ${$} ${F[0]}`}}function startsWith(F,$,V){return F.substr(!V||V<0?0:+V,$.length)===$}function endsWith(F,$,V){return(void 0===V||V>F.length)&&(V=F.length),F.substring(V-$.length,V)===$}function includes(F,$,V){return"number"!=typeof V&&(V=0),!(V+$.length>F.length)&&-1!==F.indexOf($,V)}createErrorType("ERR_INVALID_OPT_VALUE",function(F,$){return'The value "'+$+'" is invalid for option "'+F+'"'},TypeError),createErrorType("ERR_INVALID_ARG_TYPE",function(F,$,V){let G,H;if("string"==typeof $&&startsWith($,"not ")?(G="must not be",$=$.replace(/^not /,"")):G="must be",endsWith(F," argument"))H=`The ${F} ${G} ${oneOf($,"type")}`;else{let V=includes(F,".")?"property":"argument";H=`The "${F}" ${V} ${G} ${oneOf($,"type")}`}return H+`. Received type ${typeof V}`},TypeError),createErrorType("ERR_STREAM_PUSH_AFTER_EOF","stream.push() after EOF"),createErrorType("ERR_METHOD_NOT_IMPLEMENTED",function(F){return"The "+F+" method is not implemented"}),createErrorType("ERR_STREAM_PREMATURE_CLOSE","Premature close"),createErrorType("ERR_STREAM_DESTROYED",function(F){return"Cannot call "+F+" after a stream was destroyed"}),createErrorType("ERR_MULTIPLE_CALLBACK","Callback called multiple times"),createErrorType("ERR_STREAM_CANNOT_PIPE","Cannot pipe, not readable"),createErrorType("ERR_STREAM_WRITE_AFTER_END","write after end"),createErrorType("ERR_STREAM_NULL_VALUES","May not write null values to stream",TypeError),createErrorType("ERR_UNKNOWN_ENCODING",function(F){return"Unknown encoding: "+F},TypeError),createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT","stream.unshift() after end event"),F.exports.q=$},403:function(F,$,V){"use strict";var G=Object.keys||function(F){var $=[];for(var V in F)$.push(V);return $};F.exports=Duplex;var K=V(709),Z=V(337);V(782)(Duplex,K);for(var ee=G(Z.prototype),et=0;et<ee.length;et++){var en=ee[et];Duplex.prototype[en]||(Duplex.prototype[en]=Z.prototype[en])}function Duplex(F){if(!(this instanceof Duplex))return new Duplex(F);K.call(this,F),Z.call(this,F),this.allowHalfOpen=!0,F&&(!1===F.readable&&(this.readable=!1),!1===F.writable&&(this.writable=!1),!1===F.allowHalfOpen&&(this.allowHalfOpen=!1,this.once("end",onend)))}function onend(){this._writableState.ended||H.nextTick(onEndNT,this)}function onEndNT(F){F.end()}Object.defineProperty(Duplex.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(Duplex.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(Duplex.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(Duplex.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&this._readableState.destroyed&&this._writableState.destroyed},set:function(F){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=F,this._writableState.destroyed=F)}})},889:function(F,$,V){"use strict";F.exports=PassThrough;var G=V(170);function PassThrough(F){if(!(this instanceof PassThrough))return new PassThrough(F);G.call(this,F)}V(782)(PassThrough,G),PassThrough.prototype._transform=function(F,$,V){V(null,F)}},709:function(F,$,G){"use strict";F.exports=Readable,Readable.ReadableState=ReadableState,G(361).EventEmitter;var K,Z,ee,et,en,a=function(F,$){return F.listeners($).length},ea=G(678),ei=G(300).Buffer,eo=V.g.Uint8Array||function(){};function _uint8ArrayToBuffer(F){return ei.from(F)}function _isUint8Array(F){return ei.isBuffer(F)||F instanceof eo}var es=G(837);Z=es&&es.debuglog?es.debuglog("stream"):function(){};var eu=G(379),ec=G(25),ep=G(776).getHighWaterMark,eh=G(646).q,ef=eh.ERR_INVALID_ARG_TYPE,ed=eh.ERR_STREAM_PUSH_AFTER_EOF,em=eh.ERR_METHOD_NOT_IMPLEMENTED,eg=eh.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;G(782)(Readable,ea);var ey=ec.errorOrDestroy,eb=["error","close","destroy","pause","resume"];function prependListener(F,$,V){if("function"==typeof F.prependListener)return F.prependListener($,V);F._events&&F._events[$]?Array.isArray(F._events[$])?F._events[$].unshift(V):F._events[$]=[V,F._events[$]]:F.on($,V)}function ReadableState(F,$,V){K=K||G(403),F=F||{},"boolean"!=typeof V&&(V=$ instanceof K),this.objectMode=!!F.objectMode,V&&(this.objectMode=this.objectMode||!!F.readableObjectMode),this.highWaterMark=ep(this,F,"readableHighWaterMark",V),this.buffer=new eu,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==F.emitClose,this.autoDestroy=!!F.autoDestroy,this.destroyed=!1,this.defaultEncoding=F.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,F.encoding&&(ee||(ee=G(704).s),this.decoder=new ee(F.encoding),this.encoding=F.encoding)}function Readable(F){if(K=K||G(403),!(this instanceof Readable))return new Readable(F);var $=this instanceof K;this._readableState=new ReadableState(F,this,$),this.readable=!0,F&&("function"==typeof F.read&&(this._read=F.read),"function"==typeof F.destroy&&(this._destroy=F.destroy)),ea.call(this)}function readableAddChunk(F,$,V,G,H){Z("readableAddChunk",$);var K,ee=F._readableState;if(null===$)ee.reading=!1,onEofChunk(F,ee);else if(H||(K=chunkInvalid(ee,$)),K)ey(F,K);else if(ee.objectMode||$&&$.length>0){if("string"==typeof $||ee.objectMode||Object.getPrototypeOf($)===ei.prototype||($=_uint8ArrayToBuffer($)),G)ee.endEmitted?ey(F,new eg):addChunk(F,ee,$,!0);else if(ee.ended)ey(F,new ed);else{if(ee.destroyed)return!1;ee.reading=!1,ee.decoder&&!V?($=ee.decoder.write($),ee.objectMode||0!==$.length?addChunk(F,ee,$,!1):maybeReadMore(F,ee)):addChunk(F,ee,$,!1)}}else G||(ee.reading=!1,maybeReadMore(F,ee));return!ee.ended&&(ee.length<ee.highWaterMark||0===ee.length)}function addChunk(F,$,V,G){$.flowing&&0===$.length&&!$.sync?($.awaitDrain=0,F.emit("data",V)):($.length+=$.objectMode?1:V.length,G?$.buffer.unshift(V):$.buffer.push(V),$.needReadable&&emitReadable(F)),maybeReadMore(F,$)}function chunkInvalid(F,$){var V;return _isUint8Array($)||"string"==typeof $||void 0===$||F.objectMode||(V=new ef("chunk",["string","Buffer","Uint8Array"],$)),V}Object.defineProperty(Readable.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(F){this._readableState&&(this._readableState.destroyed=F)}}),Readable.prototype.destroy=ec.destroy,Readable.prototype._undestroy=ec.undestroy,Readable.prototype._destroy=function(F,$){$(F)},Readable.prototype.push=function(F,$){var V,G=this._readableState;return G.objectMode?V=!0:"string"==typeof F&&(($=$||G.defaultEncoding)!==G.encoding&&(F=ei.from(F,$),$=""),V=!0),readableAddChunk(this,F,$,!1,V)},Readable.prototype.unshift=function(F){return readableAddChunk(this,F,null,!0,!1)},Readable.prototype.isPaused=function(){return!1===this._readableState.flowing},Readable.prototype.setEncoding=function(F){ee||(ee=G(704).s);var $=new ee(F);this._readableState.decoder=$,this._readableState.encoding=this._readableState.decoder.encoding;for(var V=this._readableState.buffer.head,H="";null!==V;)H+=$.write(V.data),V=V.next;return this._readableState.buffer.clear(),""!==H&&this._readableState.buffer.push(H),this._readableState.length=H.length,this};var ew=1073741824;function computeNewHighWaterMark(F){return F>=ew?F=ew:(F--,F|=F>>>1,F|=F>>>2,F|=F>>>4,F|=F>>>8,F|=F>>>16,F++),F}function howMuchToRead(F,$){return F<=0||0===$.length&&$.ended?0:$.objectMode?1:F!=F?$.flowing&&$.length?$.buffer.head.data.length:$.length:(F>$.highWaterMark&&($.highWaterMark=computeNewHighWaterMark(F)),F<=$.length)?F:$.ended?$.length:($.needReadable=!0,0)}function onEofChunk(F,$){if(Z("onEofChunk"),!$.ended){if($.decoder){var V=$.decoder.end();V&&V.length&&($.buffer.push(V),$.length+=$.objectMode?1:V.length)}$.ended=!0,$.sync?emitReadable(F):($.needReadable=!1,$.emittedReadable||($.emittedReadable=!0,emitReadable_(F)))}}function emitReadable(F){var $=F._readableState;Z("emitReadable",$.needReadable,$.emittedReadable),$.needReadable=!1,$.emittedReadable||(Z("emitReadable",$.flowing),$.emittedReadable=!0,H.nextTick(emitReadable_,F))}function emitReadable_(F){var $=F._readableState;Z("emitReadable_",$.destroyed,$.length,$.ended),!$.destroyed&&($.length||$.ended)&&(F.emit("readable"),$.emittedReadable=!1),$.needReadable=!$.flowing&&!$.ended&&$.length<=$.highWaterMark,flow(F)}function maybeReadMore(F,$){$.readingMore||($.readingMore=!0,H.nextTick(maybeReadMore_,F,$))}function maybeReadMore_(F,$){for(;!$.reading&&!$.ended&&($.length<$.highWaterMark||$.flowing&&0===$.length);){var V=$.length;if(Z("maybeReadMore read 0"),F.read(0),V===$.length)break}$.readingMore=!1}function pipeOnDrain(F){return function(){var $=F._readableState;Z("pipeOnDrain",$.awaitDrain),$.awaitDrain&&$.awaitDrain--,0===$.awaitDrain&&a(F,"data")&&($.flowing=!0,flow(F))}}function updateReadableListening(F){var $=F._readableState;$.readableListening=F.listenerCount("readable")>0,$.resumeScheduled&&!$.paused?$.flowing=!0:F.listenerCount("data")>0&&F.resume()}function nReadingNextTick(F){Z("readable nexttick read 0"),F.read(0)}function resume(F,$){$.resumeScheduled||($.resumeScheduled=!0,H.nextTick(resume_,F,$))}function resume_(F,$){Z("resume",$.reading),$.reading||F.read(0),$.resumeScheduled=!1,F.emit("resume"),flow(F),$.flowing&&!$.reading&&F.read(0)}function flow(F){var $=F._readableState;for(Z("flow",$.flowing);$.flowing&&null!==F.read(););}function fromList(F,$){var V;return 0===$.length?null:($.objectMode?V=$.buffer.shift():!F||F>=$.length?(V=$.decoder?$.buffer.join(""):1===$.buffer.length?$.buffer.first():$.buffer.concat($.length),$.buffer.clear()):V=$.buffer.consume(F,$.decoder),V)}function endReadable(F){var $=F._readableState;Z("endReadable",$.endEmitted),$.endEmitted||($.ended=!0,H.nextTick(endReadableNT,$,F))}function endReadableNT(F,$){if(Z("endReadableNT",F.endEmitted,F.length),!F.endEmitted&&0===F.length&&(F.endEmitted=!0,$.readable=!1,$.emit("end"),F.autoDestroy)){var V=$._writableState;(!V||V.autoDestroy&&V.finished)&&$.destroy()}}function indexOf(F,$){for(var V=0,G=F.length;V<G;V++)if(F[V]===$)return V;return -1}Readable.prototype.read=function(F){Z("read",F),F=parseInt(F,10);var $,V=this._readableState,G=F;if(0!==F&&(V.emittedReadable=!1),0===F&&V.needReadable&&((0!==V.highWaterMark?V.length>=V.highWaterMark:V.length>0)||V.ended))return Z("read: emitReadable",V.length,V.ended),0===V.length&&V.ended?endReadable(this):emitReadable(this),null;if(0===(F=howMuchToRead(F,V))&&V.ended)return 0===V.length&&endReadable(this),null;var H=V.needReadable;return Z("need readable",H),(0===V.length||V.length-F<V.highWaterMark)&&Z("length less than watermark",H=!0),V.ended||V.reading?Z("reading or ended",H=!1):H&&(Z("do read"),V.reading=!0,V.sync=!0,0===V.length&&(V.needReadable=!0),this._read(V.highWaterMark),V.sync=!1,V.reading||(F=howMuchToRead(G,V))),null===($=F>0?fromList(F,V):null)?(V.needReadable=V.length<=V.highWaterMark,F=0):(V.length-=F,V.awaitDrain=0),0===V.length&&(V.ended||(V.needReadable=!0),G!==F&&V.ended&&endReadable(this)),null!==$&&this.emit("data",$),$},Readable.prototype._read=function(F){ey(this,new em("_read()"))},Readable.prototype.pipe=function(F,$){var V=this,G=this._readableState;switch(G.pipesCount){case 0:G.pipes=F;break;case 1:G.pipes=[G.pipes,F];break;default:G.pipes.push(F)}G.pipesCount+=1,Z("pipe count=%d opts=%j",G.pipesCount,$);var K=$&&!1===$.end||F===H.stdout||F===H.stderr?unpipe:onend;function onunpipe(F,$){Z("onunpipe"),F===V&&$&&!1===$.hasUnpiped&&($.hasUnpiped=!0,cleanup())}function onend(){Z("onend"),F.end()}G.endEmitted?H.nextTick(K):V.once("end",K),F.on("unpipe",onunpipe);var ee=pipeOnDrain(V);F.on("drain",ee);var et=!1;function cleanup(){Z("cleanup"),F.removeListener("close",onclose),F.removeListener("finish",onfinish),F.removeListener("drain",ee),F.removeListener("error",onerror),F.removeListener("unpipe",onunpipe),V.removeListener("end",onend),V.removeListener("end",unpipe),V.removeListener("data",ondata),et=!0,G.awaitDrain&&(!F._writableState||F._writableState.needDrain)&&ee()}function ondata($){Z("ondata");var H=F.write($);Z("dest.write",H),!1===H&&((1===G.pipesCount&&G.pipes===F||G.pipesCount>1&&-1!==indexOf(G.pipes,F))&&!et&&(Z("false write response, pause",G.awaitDrain),G.awaitDrain++),V.pause())}function onerror($){Z("onerror",$),unpipe(),F.removeListener("error",onerror),0===a(F,"error")&&ey(F,$)}function onclose(){F.removeListener("finish",onfinish),unpipe()}function onfinish(){Z("onfinish"),F.removeListener("close",onclose),unpipe()}function unpipe(){Z("unpipe"),V.unpipe(F)}return V.on("data",ondata),prependListener(F,"error",onerror),F.once("close",onclose),F.once("finish",onfinish),F.emit("pipe",V),G.flowing||(Z("pipe resume"),V.resume()),F},Readable.prototype.unpipe=function(F){var $=this._readableState,V={hasUnpiped:!1};if(0===$.pipesCount)return this;if(1===$.pipesCount)return F&&F!==$.pipes||(F||(F=$.pipes),$.pipes=null,$.pipesCount=0,$.flowing=!1,F&&F.emit("unpipe",this,V)),this;if(!F){var G=$.pipes,H=$.pipesCount;$.pipes=null,$.pipesCount=0,$.flowing=!1;for(var K=0;K<H;K++)G[K].emit("unpipe",this,{hasUnpiped:!1});return this}var Z=indexOf($.pipes,F);return -1===Z||($.pipes.splice(Z,1),$.pipesCount-=1,1===$.pipesCount&&($.pipes=$.pipes[0]),F.emit("unpipe",this,V)),this},Readable.prototype.on=function(F,$){var V=ea.prototype.on.call(this,F,$),G=this._readableState;return"data"===F?(G.readableListening=this.listenerCount("readable")>0,!1!==G.flowing&&this.resume()):"readable"!==F||G.endEmitted||G.readableListening||(G.readableListening=G.needReadable=!0,G.flowing=!1,G.emittedReadable=!1,Z("on readable",G.length,G.reading),G.length?emitReadable(this):G.reading||H.nextTick(nReadingNextTick,this)),V},Readable.prototype.addListener=Readable.prototype.on,Readable.prototype.removeListener=function(F,$){var V=ea.prototype.removeListener.call(this,F,$);return"readable"===F&&H.nextTick(updateReadableListening,this),V},Readable.prototype.removeAllListeners=function(F){var $=ea.prototype.removeAllListeners.apply(this,arguments);return("readable"===F||void 0===F)&&H.nextTick(updateReadableListening,this),$},Readable.prototype.resume=function(){var F=this._readableState;return F.flowing||(Z("resume"),F.flowing=!F.readableListening,resume(this,F)),F.paused=!1,this},Readable.prototype.pause=function(){return Z("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(Z("pause"),this._readableState.flowing=!1,this.emit("pause")),this._readableState.paused=!0,this},Readable.prototype.wrap=function(F){var $=this,V=this._readableState,G=!1;for(var H in F.on("end",function(){if(Z("wrapped end"),V.decoder&&!V.ended){var F=V.decoder.end();F&&F.length&&$.push(F)}$.push(null)}),F.on("data",function(H){Z("wrapped data"),V.decoder&&(H=V.decoder.write(H)),(!V.objectMode||null!=H)&&(V.objectMode||H&&H.length)&&($.push(H)||(G=!0,F.pause()))}),F)void 0===this[H]&&"function"==typeof F[H]&&(this[H]=function($){return function(){return F[$].apply(F,arguments)}}(H));for(var K=0;K<eb.length;K++)F.on(eb[K],this.emit.bind(this,eb[K]));return this._read=function($){Z("wrapped _read",$),G&&(G=!1,F.resume())},this},"function"==typeof Symbol&&(Readable.prototype[Symbol.asyncIterator]=function(){return void 0===et&&(et=G(871)),et(this)}),Object.defineProperty(Readable.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(Readable.prototype,"readableBuffer",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(Readable.prototype,"readableFlowing",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(F){this._readableState&&(this._readableState.flowing=F)}}),Readable._fromList=fromList,Object.defineProperty(Readable.prototype,"readableLength",{enumerable:!1,get:function(){return this._readableState.length}}),"function"==typeof Symbol&&(Readable.from=function(F,$){return void 0===en&&(en=G(727)),en(Readable,F,$)})},170:function(F,$,V){"use strict";F.exports=Transform;var G=V(646).q,H=G.ERR_METHOD_NOT_IMPLEMENTED,K=G.ERR_MULTIPLE_CALLBACK,Z=G.ERR_TRANSFORM_ALREADY_TRANSFORMING,ee=G.ERR_TRANSFORM_WITH_LENGTH_0,et=V(403);function afterTransform(F,$){var V=this._transformState;V.transforming=!1;var G=V.writecb;if(null===G)return this.emit("error",new K);V.writechunk=null,V.writecb=null,null!=$&&this.push($),G(F);var H=this._readableState;H.reading=!1,(H.needReadable||H.length<H.highWaterMark)&&this._read(H.highWaterMark)}function Transform(F){if(!(this instanceof Transform))return new Transform(F);et.call(this,F),this._transformState={afterTransform:afterTransform.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,F&&("function"==typeof F.transform&&(this._transform=F.transform),"function"==typeof F.flush&&(this._flush=F.flush)),this.on("prefinish",prefinish)}function prefinish(){var F=this;"function"!=typeof this._flush||this._readableState.destroyed?done(this,null,null):this._flush(function($,V){done(F,$,V)})}function done(F,$,V){if($)return F.emit("error",$);if(null!=V&&F.push(V),F._writableState.length)throw new ee;if(F._transformState.transforming)throw new Z;return F.push(null)}V(782)(Transform,et),Transform.prototype.push=function(F,$){return this._transformState.needTransform=!1,et.prototype.push.call(this,F,$)},Transform.prototype._transform=function(F,$,V){V(new H("_transform()"))},Transform.prototype._write=function(F,$,V){var G=this._transformState;if(G.writecb=V,G.writechunk=F,G.writeencoding=$,!G.transforming){var H=this._readableState;(G.needTransform||H.needReadable||H.length<H.highWaterMark)&&this._read(H.highWaterMark)}},Transform.prototype._read=function(F){var $=this._transformState;null===$.writechunk||$.transforming?$.needTransform=!0:($.transforming=!0,this._transform($.writechunk,$.writeencoding,$.afterTransform))},Transform.prototype._destroy=function(F,$){et.prototype._destroy.call(this,F,function(F){$(F)})}},337:function(F,$,G){"use strict";function CorkedRequest(F){var $=this;this.next=null,this.entry=null,this.finish=function(){onCorkedFinish($,F)}}F.exports=Writable,Writable.WritableState=WritableState;var K,Z,ee={deprecate:G(769)},et=G(678),en=G(300).Buffer,ea=V.g.Uint8Array||function(){};function _uint8ArrayToBuffer(F){return en.from(F)}function _isUint8Array(F){return en.isBuffer(F)||F instanceof ea}var ei=G(25),eo=G(776).getHighWaterMark,es=G(646).q,eu=es.ERR_INVALID_ARG_TYPE,ec=es.ERR_METHOD_NOT_IMPLEMENTED,ep=es.ERR_MULTIPLE_CALLBACK,eh=es.ERR_STREAM_CANNOT_PIPE,ef=es.ERR_STREAM_DESTROYED,ed=es.ERR_STREAM_NULL_VALUES,em=es.ERR_STREAM_WRITE_AFTER_END,eg=es.ERR_UNKNOWN_ENCODING,ey=ei.errorOrDestroy;function nop(){}function WritableState(F,$,V){K=K||G(403),F=F||{},"boolean"!=typeof V&&(V=$ instanceof K),this.objectMode=!!F.objectMode,V&&(this.objectMode=this.objectMode||!!F.writableObjectMode),this.highWaterMark=eo(this,F,"writableHighWaterMark",V),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var H=!1===F.decodeStrings;this.decodeStrings=!H,this.defaultEncoding=F.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(F){onwrite($,F)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==F.emitClose,this.autoDestroy=!!F.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new CorkedRequest(this)}function Writable(F){var $=this instanceof(K=K||G(403));if(!$&&!Z.call(Writable,this))return new Writable(F);this._writableState=new WritableState(F,this,$),this.writable=!0,F&&("function"==typeof F.write&&(this._write=F.write),"function"==typeof F.writev&&(this._writev=F.writev),"function"==typeof F.destroy&&(this._destroy=F.destroy),"function"==typeof F.final&&(this._final=F.final)),et.call(this)}function writeAfterEnd(F,$){var V=new em;ey(F,V),H.nextTick($,V)}function validChunk(F,$,V,G){var K;return null===V?K=new ed:"string"==typeof V||$.objectMode||(K=new eu("chunk",["string","Buffer"],V)),!K||(ey(F,K),H.nextTick(G,K),!1)}function decodeChunk(F,$,V){return F.objectMode||!1===F.decodeStrings||"string"!=typeof $||($=en.from($,V)),$}function writeOrBuffer(F,$,V,G,H,K){if(!V){var Z=decodeChunk($,G,H);G!==Z&&(V=!0,H="buffer",G=Z)}var ee=$.objectMode?1:G.length;$.length+=ee;var et=$.length<$.highWaterMark;if(et||($.needDrain=!0),$.writing||$.corked){var en=$.lastBufferedRequest;$.lastBufferedRequest={chunk:G,encoding:H,isBuf:V,callback:K,next:null},en?en.next=$.lastBufferedRequest:$.bufferedRequest=$.lastBufferedRequest,$.bufferedRequestCount+=1}else doWrite(F,$,!1,ee,G,H,K);return et}function doWrite(F,$,V,G,H,K,Z){$.writelen=G,$.writecb=Z,$.writing=!0,$.sync=!0,$.destroyed?$.onwrite(new ef("write")):V?F._writev(H,$.onwrite):F._write(H,K,$.onwrite),$.sync=!1}function onwriteError(F,$,V,G,K){--$.pendingcb,V?(H.nextTick(K,G),H.nextTick(finishMaybe,F,$),F._writableState.errorEmitted=!0,ey(F,G)):(K(G),F._writableState.errorEmitted=!0,ey(F,G),finishMaybe(F,$))}function onwriteStateUpdate(F){F.writing=!1,F.writecb=null,F.length-=F.writelen,F.writelen=0}function onwrite(F,$){var V=F._writableState,G=V.sync,K=V.writecb;if("function"!=typeof K)throw new ep;if(onwriteStateUpdate(V),$)onwriteError(F,V,G,$,K);else{var Z=needFinish(V)||F.destroyed;Z||V.corked||V.bufferProcessing||!V.bufferedRequest||clearBuffer(F,V),G?H.nextTick(afterWrite,F,V,Z,K):afterWrite(F,V,Z,K)}}function afterWrite(F,$,V,G){V||onwriteDrain(F,$),$.pendingcb--,G(),finishMaybe(F,$)}function onwriteDrain(F,$){0===$.length&&$.needDrain&&($.needDrain=!1,F.emit("drain"))}function clearBuffer(F,$){$.bufferProcessing=!0;var V=$.bufferedRequest;if(F._writev&&V&&V.next){var G=Array($.bufferedRequestCount),H=$.corkedRequestsFree;H.entry=V;for(var K=0,Z=!0;V;)G[K]=V,V.isBuf||(Z=!1),V=V.next,K+=1;G.allBuffers=Z,doWrite(F,$,!0,$.length,G,"",H.finish),$.pendingcb++,$.lastBufferedRequest=null,H.next?($.corkedRequestsFree=H.next,H.next=null):$.corkedRequestsFree=new CorkedRequest($),$.bufferedRequestCount=0}else{for(;V;){var ee=V.chunk,et=V.encoding,en=V.callback,ea=$.objectMode?1:ee.length;if(doWrite(F,$,!1,ea,ee,et,en),V=V.next,$.bufferedRequestCount--,$.writing)break}null===V&&($.lastBufferedRequest=null)}$.bufferedRequest=V,$.bufferProcessing=!1}function needFinish(F){return F.ending&&0===F.length&&null===F.bufferedRequest&&!F.finished&&!F.writing}function callFinal(F,$){F._final(function(V){$.pendingcb--,V&&ey(F,V),$.prefinished=!0,F.emit("prefinish"),finishMaybe(F,$)})}function prefinish(F,$){$.prefinished||$.finalCalled||("function"!=typeof F._final||$.destroyed?($.prefinished=!0,F.emit("prefinish")):($.pendingcb++,$.finalCalled=!0,H.nextTick(callFinal,F,$)))}function finishMaybe(F,$){var V=needFinish($);if(V&&(prefinish(F,$),0===$.pendingcb&&($.finished=!0,F.emit("finish"),$.autoDestroy))){var G=F._readableState;(!G||G.autoDestroy&&G.endEmitted)&&F.destroy()}return V}function endWritable(F,$,V){$.ending=!0,finishMaybe(F,$),V&&($.finished?H.nextTick(V):F.once("finish",V)),$.ended=!0,F.writable=!1}function onCorkedFinish(F,$,V){var G=F.entry;for(F.entry=null;G;){var H=G.callback;$.pendingcb--,H(V),G=G.next}$.corkedRequestsFree.next=F}G(782)(Writable,et),WritableState.prototype.getBuffer=function(){for(var F=this.bufferedRequest,$=[];F;)$.push(F),F=F.next;return $},function(){try{Object.defineProperty(WritableState.prototype,"buffer",{get:ee.deprecate(function(){return this.getBuffer()},"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(F){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(Z=Function.prototype[Symbol.hasInstance],Object.defineProperty(Writable,Symbol.hasInstance,{value:function(F){return!!Z.call(this,F)||this===Writable&&F&&F._writableState instanceof WritableState}})):Z=function(F){return F instanceof this},Writable.prototype.pipe=function(){ey(this,new eh)},Writable.prototype.write=function(F,$,V){var G=this._writableState,H=!1,K=!G.objectMode&&_isUint8Array(F);return K&&!en.isBuffer(F)&&(F=_uint8ArrayToBuffer(F)),"function"==typeof $&&(V=$,$=null),K?$="buffer":$||($=G.defaultEncoding),"function"!=typeof V&&(V=nop),G.ending?writeAfterEnd(this,V):(K||validChunk(this,G,F,V))&&(G.pendingcb++,H=writeOrBuffer(this,G,K,F,$,V)),H},Writable.prototype.cork=function(){this._writableState.corked++},Writable.prototype.uncork=function(){var F=this._writableState;!F.corked||(F.corked--,F.writing||F.corked||F.bufferProcessing||!F.bufferedRequest||clearBuffer(this,F))},Writable.prototype.setDefaultEncoding=function(F){if("string"==typeof F&&(F=F.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((F+"").toLowerCase())>-1))throw new eg(F);return this._writableState.defaultEncoding=F,this},Object.defineProperty(Writable.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(Writable.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Writable.prototype._write=function(F,$,V){V(new ec("_write()"))},Writable.prototype._writev=null,Writable.prototype.end=function(F,$,V){var G=this._writableState;return"function"==typeof F?(V=F,F=null,$=null):"function"==typeof $&&(V=$,$=null),null!=F&&this.write(F,$),G.corked&&(G.corked=1,this.uncork()),G.ending||endWritable(this,G,V),this},Object.defineProperty(Writable.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(Writable.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(F){this._writableState&&(this._writableState.destroyed=F)}}),Writable.prototype.destroy=ei.destroy,Writable.prototype._undestroy=ei.undestroy,Writable.prototype._destroy=function(F,$){$(F)}},871:function(F,$,V){"use strict";function _defineProperty(F,$,V){return $ in F?Object.defineProperty(F,$,{value:V,enumerable:!0,configurable:!0,writable:!0}):F[$]=V,F}var G,K=V(698),Z=Symbol("lastResolve"),ee=Symbol("lastReject"),et=Symbol("error"),en=Symbol("ended"),ea=Symbol("lastPromise"),ei=Symbol("handlePromise"),eo=Symbol("stream");function createIterResult(F,$){return{value:F,done:$}}function readAndResolve(F){var $=F[Z];if(null!==$){var V=F[eo].read();null!==V&&(F[ea]=null,F[Z]=null,F[ee]=null,$(createIterResult(V,!1)))}}function onReadable(F){H.nextTick(readAndResolve,F)}function wrapForNext(F,$){return function(V,G){F.then(function(){if($[en]){V(createIterResult(void 0,!0));return}$[ei](V,G)},G)}}var es=Object.getPrototypeOf(function(){}),eu=Object.setPrototypeOf((_defineProperty(G={get stream(){return this[eo]},next:function(){var F,$=this,V=this[et];if(null!==V)return Promise.reject(V);if(this[en])return Promise.resolve(createIterResult(void 0,!0));if(this[eo].destroyed)return new Promise(function(F,V){H.nextTick(function(){$[et]?V($[et]):F(createIterResult(void 0,!0))})});var G=this[ea];if(G)F=new Promise(wrapForNext(G,this));else{var K=this[eo].read();if(null!==K)return Promise.resolve(createIterResult(K,!1));F=new Promise(this[ei])}return this[ea]=F,F}},Symbol.asyncIterator,function(){return this}),_defineProperty(G,"return",function(){var F=this;return new Promise(function($,V){F[eo].destroy(null,function(F){if(F){V(F);return}$(createIterResult(void 0,!0))})})}),G),es),p=function(F){var $,V=Object.create(eu,(_defineProperty($={},eo,{value:F,writable:!0}),_defineProperty($,Z,{value:null,writable:!0}),_defineProperty($,ee,{value:null,writable:!0}),_defineProperty($,et,{value:null,writable:!0}),_defineProperty($,en,{value:F._readableState.endEmitted,writable:!0}),_defineProperty($,ei,{value:function(F,$){var G=V[eo].read();G?(V[ea]=null,V[Z]=null,V[ee]=null,F(createIterResult(G,!1))):(V[Z]=F,V[ee]=$)},writable:!0}),$));return V[ea]=null,K(F,function(F){if(F&&"ERR_STREAM_PREMATURE_CLOSE"!==F.code){var $=V[ee];null!==$&&(V[ea]=null,V[Z]=null,V[ee]=null,$(F)),V[et]=F;return}var G=V[Z];null!==G&&(V[ea]=null,V[Z]=null,V[ee]=null,G(createIterResult(void 0,!0))),V[en]=!0}),F.on("readable",onReadable.bind(null,V)),V};F.exports=p},379:function(F,$,V){"use strict";function ownKeys(F,$){var V=Object.keys(F);if(Object.getOwnPropertySymbols){var G=Object.getOwnPropertySymbols(F);$&&(G=G.filter(function($){return Object.getOwnPropertyDescriptor(F,$).enumerable})),V.push.apply(V,G)}return V}function _objectSpread(F){for(var $=1;$<arguments.length;$++){var V=null!=arguments[$]?arguments[$]:{};$%2?ownKeys(Object(V),!0).forEach(function($){_defineProperty(F,$,V[$])}):Object.getOwnPropertyDescriptors?Object.defineProperties(F,Object.getOwnPropertyDescriptors(V)):ownKeys(Object(V)).forEach(function($){Object.defineProperty(F,$,Object.getOwnPropertyDescriptor(V,$))})}return F}function _defineProperty(F,$,V){return $ in F?Object.defineProperty(F,$,{value:V,enumerable:!0,configurable:!0,writable:!0}):F[$]=V,F}function _classCallCheck(F,$){if(!(F instanceof $))throw TypeError("Cannot call a class as a function")}function _defineProperties(F,$){for(var V=0;V<$.length;V++){var G=$[V];G.enumerable=G.enumerable||!1,G.configurable=!0,"value"in G&&(G.writable=!0),Object.defineProperty(F,G.key,G)}}function _createClass(F,$,V){return $&&_defineProperties(F.prototype,$),V&&_defineProperties(F,V),F}var G=V(300).Buffer,H=V(837).inspect,K=H&&H.custom||"inspect";function copyBuffer(F,$,V){G.prototype.copy.call(F,$,V)}F.exports=function(){function BufferList(){_classCallCheck(this,BufferList),this.head=null,this.tail=null,this.length=0}return _createClass(BufferList,[{key:"push",value:function(F){var $={data:F,next:null};this.length>0?this.tail.next=$:this.head=$,this.tail=$,++this.length}},{key:"unshift",value:function(F){var $={data:F,next:this.head};0===this.length&&(this.tail=$),this.head=$,++this.length}},{key:"shift",value:function(){if(0!==this.length){var F=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,F}}},{key:"clear",value:function(){this.head=this.tail=null,this.length=0}},{key:"join",value:function(F){if(0===this.length)return"";for(var $=this.head,V=""+$.data;$=$.next;)V+=F+$.data;return V}},{key:"concat",value:function(F){if(0===this.length)return G.alloc(0);for(var $=G.allocUnsafe(F>>>0),V=this.head,H=0;V;)copyBuffer(V.data,$,H),H+=V.data.length,V=V.next;return $}},{key:"consume",value:function(F,$){var V;return F<this.head.data.length?(V=this.head.data.slice(0,F),this.head.data=this.head.data.slice(F)):V=F===this.head.data.length?this.shift():$?this._getString(F):this._getBuffer(F),V}},{key:"first",value:function(){return this.head.data}},{key:"_getString",value:function(F){var $=this.head,V=1,G=$.data;for(F-=G.length;$=$.next;){var H=$.data,K=F>H.length?H.length:F;if(K===H.length?G+=H:G+=H.slice(0,F),0==(F-=K)){K===H.length?(++V,$.next?this.head=$.next:this.head=this.tail=null):(this.head=$,$.data=H.slice(K));break}++V}return this.length-=V,G}},{key:"_getBuffer",value:function(F){var $=G.allocUnsafe(F),V=this.head,H=1;for(V.data.copy($),F-=V.data.length;V=V.next;){var K=V.data,Z=F>K.length?K.length:F;if(K.copy($,$.length-F,0,Z),0==(F-=Z)){Z===K.length?(++H,V.next?this.head=V.next:this.head=this.tail=null):(this.head=V,V.data=K.slice(Z));break}++H}return this.length-=H,$}},{key:K,value:function(F,$){return H(this,_objectSpread({},$,{depth:0,customInspect:!1}))}}]),BufferList}()},25:function(F){"use strict";function destroy(F,$){var V=this,G=this._readableState&&this._readableState.destroyed,K=this._writableState&&this._writableState.destroyed;return G||K?$?$(F):F&&(this._writableState?this._writableState.errorEmitted||(this._writableState.errorEmitted=!0,H.nextTick(emitErrorNT,this,F)):H.nextTick(emitErrorNT,this,F)):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(F||null,function(F){!$&&F?V._writableState?V._writableState.errorEmitted?H.nextTick(emitCloseNT,V):(V._writableState.errorEmitted=!0,H.nextTick(emitErrorAndCloseNT,V,F)):H.nextTick(emitErrorAndCloseNT,V,F):$?(H.nextTick(emitCloseNT,V),$(F)):H.nextTick(emitCloseNT,V)})),this}function emitErrorAndCloseNT(F,$){emitErrorNT(F,$),emitCloseNT(F)}function emitCloseNT(F){(!F._writableState||F._writableState.emitClose)&&(!F._readableState||F._readableState.emitClose)&&F.emit("close")}function undestroy(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}function emitErrorNT(F,$){F.emit("error",$)}function errorOrDestroy(F,$){var V=F._readableState,G=F._writableState;V&&V.autoDestroy||G&&G.autoDestroy?F.destroy($):F.emit("error",$)}F.exports={destroy:destroy,undestroy:undestroy,errorOrDestroy:errorOrDestroy}},698:function(F,$,V){"use strict";var G=V(646).q.ERR_STREAM_PREMATURE_CLOSE;function once(F){var $=!1;return function(){if(!$){$=!0;for(var V=arguments.length,G=Array(V),H=0;H<V;H++)G[H]=arguments[H];F.apply(this,G)}}}function noop(){}function isRequest(F){return F.setHeader&&"function"==typeof F.abort}function eos(F,$,V){if("function"==typeof $)return eos(F,null,$);$||($={}),V=once(V||noop);var H=$.readable||!1!==$.readable&&F.readable,K=$.writable||!1!==$.writable&&F.writable,o=function(){F.writable||f()},Z=F._writableState&&F._writableState.finished,f=function(){K=!1,Z=!0,H||V.call(F)},ee=F._readableState&&F._readableState.endEmitted,u=function(){H=!1,ee=!0,K||V.call(F)},d=function($){V.call(F,$)},c=function(){var $;return H&&!ee?(F._readableState&&F._readableState.ended||($=new G),V.call(F,$)):K&&!Z?(F._writableState&&F._writableState.ended||($=new G),V.call(F,$)):void 0},h=function(){F.req.on("finish",f)};return isRequest(F)?(F.on("complete",f),F.on("abort",c),F.req?h():F.on("request",h)):K&&!F._writableState&&(F.on("end",o),F.on("close",o)),F.on("end",u),F.on("finish",f),!1!==$.error&&F.on("error",d),F.on("close",c),function(){F.removeListener("complete",f),F.removeListener("abort",c),F.removeListener("request",h),F.req&&F.req.removeListener("finish",f),F.removeListener("end",o),F.removeListener("close",o),F.removeListener("finish",f),F.removeListener("end",u),F.removeListener("error",d),F.removeListener("close",c)}}F.exports=eos},727:function(F,$,V){"use strict";function asyncGeneratorStep(F,$,V,G,H,K,Z){try{var ee=F[K](Z),et=ee.value}catch(F){V(F);return}ee.done?$(et):Promise.resolve(et).then(G,H)}function _asyncToGenerator(F){return function(){var $=this,V=arguments;return new Promise(function(G,H){var K=F.apply($,V);function _next(F){asyncGeneratorStep(K,G,H,_next,_throw,"next",F)}function _throw(F){asyncGeneratorStep(K,G,H,_next,_throw,"throw",F)}_next(void 0)})}}function ownKeys(F,$){var V=Object.keys(F);if(Object.getOwnPropertySymbols){var G=Object.getOwnPropertySymbols(F);$&&(G=G.filter(function($){return Object.getOwnPropertyDescriptor(F,$).enumerable})),V.push.apply(V,G)}return V}function _objectSpread(F){for(var $=1;$<arguments.length;$++){var V=null!=arguments[$]?arguments[$]:{};$%2?ownKeys(Object(V),!0).forEach(function($){_defineProperty(F,$,V[$])}):Object.getOwnPropertyDescriptors?Object.defineProperties(F,Object.getOwnPropertyDescriptors(V)):ownKeys(Object(V)).forEach(function($){Object.defineProperty(F,$,Object.getOwnPropertyDescriptor(V,$))})}return F}function _defineProperty(F,$,V){return $ in F?Object.defineProperty(F,$,{value:V,enumerable:!0,configurable:!0,writable:!0}):F[$]=V,F}var G=V(646).q.ERR_INVALID_ARG_TYPE;function from(F,$,V){if($&&"function"==typeof $.next)H=$;else if($&&$[Symbol.asyncIterator])H=$[Symbol.asyncIterator]();else if($&&$[Symbol.iterator])H=$[Symbol.iterator]();else throw new G("iterable",["Iterable"],$);var H,K=new F(_objectSpread({objectMode:!0},V)),Z=!1;function next(){return _next2.apply(this,arguments)}function _next2(){return(_next2=_asyncToGenerator(function*(){try{var F=yield H.next(),$=F.value;F.done?K.push(null):K.push((yield $))?next():Z=!1}catch(F){K.destroy(F)}})).apply(this,arguments)}return K._read=function(){Z||(Z=!0,next())},K}F.exports=from},442:function(F,$,V){"use strict";function once(F){var $=!1;return function(){$||($=!0,F.apply(void 0,arguments))}}var G,H=V(646).q,K=H.ERR_MISSING_ARGS,Z=H.ERR_STREAM_DESTROYED;function noop(F){if(F)throw F}function isRequest(F){return F.setHeader&&"function"==typeof F.abort}function destroyer(F,$,H,K){K=once(K);var ee=!1;F.on("close",function(){ee=!0}),void 0===G&&(G=V(698)),G(F,{readable:$,writable:H},function(F){if(F)return K(F);ee=!0,K()});var et=!1;return function($){if(!ee&&!et){if(et=!0,isRequest(F))return F.abort();if("function"==typeof F.destroy)return F.destroy();K($||new Z("pipe"))}}}function call(F){F()}function pipe(F,$){return F.pipe($)}function popCallback(F){return F.length&&"function"==typeof F[F.length-1]?F.pop():noop}function pipeline(){for(var F,$=arguments.length,V=Array($),G=0;G<$;G++)V[G]=arguments[G];var H=popCallback(V);if(Array.isArray(V[0])&&(V=V[0]),V.length<2)throw new K("streams");var Z=V.map(function($,G){var K=G<V.length-1;return destroyer($,K,G>0,function($){F||(F=$),$&&Z.forEach(call),K||(Z.forEach(call),H(F))})});return V.reduce(pipe)}F.exports=pipeline},776:function(F,$,V){"use strict";var G=V(646).q.ERR_INVALID_OPT_VALUE;function highWaterMarkFrom(F,$,V){return null!=F.highWaterMark?F.highWaterMark:$?F[V]:null}function getHighWaterMark(F,$,V,H){var K=highWaterMarkFrom($,H,V);if(null!=K){if(!(isFinite(K)&&Math.floor(K)===K)||K<0){var Z=H?V:"highWaterMark";throw new G(Z,K)}return Math.floor(K)}return F.objectMode?16:16384}F.exports={getHighWaterMark:getHighWaterMark}},678:function(F,$,V){F.exports=V(781)},55:function(F,$,V){var G=V(300),H=G.Buffer;function copyProps(F,$){for(var V in F)$[V]=F[V]}function SafeBuffer(F,$,V){return H(F,$,V)}H.from&&H.alloc&&H.allocUnsafe&&H.allocUnsafeSlow?F.exports=G:(copyProps(G,$),$.Buffer=SafeBuffer),SafeBuffer.prototype=Object.create(H.prototype),copyProps(H,SafeBuffer),SafeBuffer.from=function(F,$,V){if("number"==typeof F)throw TypeError("Argument must not be a number");return H(F,$,V)},SafeBuffer.alloc=function(F,$,V){if("number"!=typeof F)throw TypeError("Argument must be a number");var G=H(F);return void 0!==$?"string"==typeof V?G.fill($,V):G.fill($):G.fill(0),G},SafeBuffer.allocUnsafe=function(F){if("number"!=typeof F)throw TypeError("Argument must be a number");return H(F)},SafeBuffer.allocUnsafeSlow=function(F){if("number"!=typeof F)throw TypeError("Argument must be a number");return G.SlowBuffer(F)}},173:function(F,$,V){F.exports=Stream;var G=V(361).EventEmitter;function Stream(){G.call(this)}V(782)(Stream,G),Stream.Readable=V(709),Stream.Writable=V(337),Stream.Duplex=V(403),Stream.Transform=V(170),Stream.PassThrough=V(889),Stream.finished=V(698),Stream.pipeline=V(442),Stream.Stream=Stream,Stream.prototype.pipe=function(F,$){var V=this;function ondata($){F.writable&&!1===F.write($)&&V.pause&&V.pause()}function ondrain(){V.readable&&V.resume&&V.resume()}V.on("data",ondata),F.on("drain",ondrain),F._isStdio||$&&!1===$.end||(V.on("end",onend),V.on("close",onclose));var H=!1;function onend(){H||(H=!0,F.end())}function onclose(){H||(H=!0,"function"==typeof F.destroy&&F.destroy())}function onerror(F){if(cleanup(),0===G.listenerCount(this,"error"))throw F}function cleanup(){V.removeListener("data",ondata),F.removeListener("drain",ondrain),V.removeListener("end",onend),V.removeListener("close",onclose),V.removeListener("error",onerror),F.removeListener("error",onerror),V.removeListener("end",cleanup),V.removeListener("close",cleanup),F.removeListener("close",cleanup)}return V.on("error",onerror),F.on("error",onerror),V.on("end",cleanup),V.on("close",cleanup),F.on("close",cleanup),F.emit("pipe",V),F}},704:function(F,$,V){"use strict";var G=V(55).Buffer,H=G.isEncoding||function(F){switch((F=""+F)&&F.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function _normalizeEncoding(F){var $;if(!F)return"utf8";for(;;)switch(F){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return F;default:if($)return;F=(""+F).toLowerCase(),$=!0}}function normalizeEncoding(F){var $=_normalizeEncoding(F);if("string"!=typeof $&&(G.isEncoding===H||!H(F)))throw Error("Unknown encoding: "+F);return $||F}function StringDecoder(F){var $;switch(this.encoding=normalizeEncoding(F),this.encoding){case"utf16le":this.text=utf16Text,this.end=utf16End,$=4;break;case"utf8":this.fillLast=utf8FillLast,$=4;break;case"base64":this.text=base64Text,this.end=base64End,$=3;break;default:this.write=simpleWrite,this.end=simpleEnd;return}this.lastNeed=0,this.lastTotal=0,this.lastChar=G.allocUnsafe($)}function utf8CheckByte(F){return F<=127?0:F>>5==6?2:F>>4==14?3:F>>3==30?4:F>>6==2?-1:-2}function utf8CheckIncomplete(F,$,V){var G=$.length-1;if(G<V)return 0;var H=utf8CheckByte($[G]);return H>=0?(H>0&&(F.lastNeed=H-1),H):--G<V||-2===H?0:(H=utf8CheckByte($[G]))>=0?(H>0&&(F.lastNeed=H-2),H):--G<V||-2===H?0:(H=utf8CheckByte($[G]))>=0?(H>0&&(2===H?H=0:F.lastNeed=H-3),H):0}function utf8CheckExtraBytes(F,$,V){if((192&$[0])!=128)return F.lastNeed=0,"";if(F.lastNeed>1&&$.length>1){if((192&$[1])!=128)return F.lastNeed=1,"";if(F.lastNeed>2&&$.length>2&&(192&$[2])!=128)return F.lastNeed=2,""}}function utf8FillLast(F){var $=this.lastTotal-this.lastNeed,V=utf8CheckExtraBytes(this,F,$);return void 0!==V?V:this.lastNeed<=F.length?(F.copy(this.lastChar,$,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):void(F.copy(this.lastChar,$,0,F.length),this.lastNeed-=F.length)}function utf8Text(F,$){var V=utf8CheckIncomplete(this,F,$);if(!this.lastNeed)return F.toString("utf8",$);this.lastTotal=V;var G=F.length-(V-this.lastNeed);return F.copy(this.lastChar,0,G),F.toString("utf8",$,G)}function utf8End(F){var $=F&&F.length?this.write(F):"";return this.lastNeed?$+"":$}function utf16Text(F,$){if((F.length-$)%2==0){var V=F.toString("utf16le",$);if(V){var G=V.charCodeAt(V.length-1);if(G>=55296&&G<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=F[F.length-2],this.lastChar[1]=F[F.length-1],V.slice(0,-1)}return V}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=F[F.length-1],F.toString("utf16le",$,F.length-1)}function utf16End(F){var $=F&&F.length?this.write(F):"";if(this.lastNeed){var V=this.lastTotal-this.lastNeed;return $+this.lastChar.toString("utf16le",0,V)}return $}function base64Text(F,$){var V=(F.length-$)%3;return 0===V?F.toString("base64",$):(this.lastNeed=3-V,this.lastTotal=3,1===V?this.lastChar[0]=F[F.length-1]:(this.lastChar[0]=F[F.length-2],this.lastChar[1]=F[F.length-1]),F.toString("base64",$,F.length-V))}function base64End(F){var $=F&&F.length?this.write(F):"";return this.lastNeed?$+this.lastChar.toString("base64",0,3-this.lastNeed):$}function simpleWrite(F){return F.toString(this.encoding)}function simpleEnd(F){return F&&F.length?this.write(F):""}$.s=StringDecoder,StringDecoder.prototype.write=function(F){var $,V;if(0===F.length)return"";if(this.lastNeed){if(void 0===($=this.fillLast(F)))return"";V=this.lastNeed,this.lastNeed=0}else V=0;return V<F.length?$?$+this.text(F,V):this.text(F,V):$||""},StringDecoder.prototype.end=utf8End,StringDecoder.prototype.text=utf8Text,StringDecoder.prototype.fillLast=function(F){if(this.lastNeed<=F.length)return F.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);F.copy(this.lastChar,this.lastTotal-this.lastNeed,0,F.length),this.lastNeed-=F.length}},769:function(F){function deprecate(F,$){if(config("noDeprecation"))return F;var V=!1;return function(){if(!V){if(config("throwDeprecation"))throw Error($);config("traceDeprecation")?console.trace($):console.warn($),V=!0}return F.apply(this,arguments)}}function config(F){try{if(!V.g.localStorage)return!1}catch(F){return!1}var $=V.g.localStorage[F];return null!=$&&"true"===String($).toLowerCase()}F.exports=deprecate},300:function(F){"use strict";F.exports=V(21876)},361:function(F){"use strict";F.exports=V(17187)},781:function(F){"use strict";F.exports=V(17187).EventEmitter},837:function(F){"use strict";F.exports=V(79720)}},K={};function __nccwpck_require__(F){var V=K[F];if(void 0!==V)return V.exports;var G=K[F]={exports:{}},H=!0;try{$[F](G,G.exports,__nccwpck_require__),H=!1}finally{H&&delete K[F]}return G.exports}__nccwpck_require__.ab=G+"/";var Z=__nccwpck_require__(173);F.exports=Z}()},79720:function(F,$,V){var G="/",H=V(21876).Buffer,K=V(83454);!function(){var $={992:function(F){F.exports=function(F,V,G){if(F.filter)return F.filter(V,G);if(null==F||"function"!=typeof V)throw TypeError();for(var H=[],K=0;K<F.length;K++)if($.call(F,K)){var Z=F[K];V.call(G,Z,K,F)&&H.push(Z)}return H};var $=Object.prototype.hasOwnProperty},256:function(F,$,V){"use strict";var G=V(925),H=V(139),K=H(G("String.prototype.indexOf"));F.exports=function(F,$){var V=G(F,!!$);return"function"==typeof V&&K(F,".prototype.")>-1?H(V):V}},139:function(F,$,V){"use strict";var G=V(174),H=V(925),K=H("%Function.prototype.apply%"),Z=H("%Function.prototype.call%"),ee=H("%Reflect.apply%",!0)||G.call(Z,K),et=H("%Object.getOwnPropertyDescriptor%",!0),en=H("%Object.defineProperty%",!0),ea=H("%Math.max%");if(en)try{en({},"a",{value:1})}catch(F){en=null}F.exports=function(F){var $=ee(G,Z,arguments);return et&&en&&et($,"length").configurable&&en($,"length",{value:1+ea(0,F.length-(arguments.length-1))}),$};var s=function(){return ee(G,K,arguments)};en?en(F.exports,"apply",{value:s}):F.exports.apply=s},144:function(F){var $=Object.prototype.hasOwnProperty,V=Object.prototype.toString;F.exports=function(F,G,H){if("[object Function]"!==V.call(G))throw TypeError("iterator must be a function");var K=F.length;if(K===+K)for(var Z=0;Z<K;Z++)G.call(H,F[Z],Z,F);else for(var ee in F)$.call(F,ee)&&G.call(H,F[ee],ee,F)}},426:function(F){"use strict";var $="Function.prototype.bind called on incompatible ",V=Array.prototype.slice,G=Object.prototype.toString,H="[object Function]";F.exports=function(F){var K,Z=this;if("function"!=typeof Z||G.call(Z)!==H)throw TypeError($+Z);for(var ee=V.call(arguments,1),binder=function(){if(!(this instanceof K))return Z.apply(F,ee.concat(V.call(arguments)));var $=Z.apply(this,ee.concat(V.call(arguments)));return Object($)===$?$:this},et=Math.max(0,Z.length-ee.length),en=[],ea=0;ea<et;ea++)en.push("$"+ea);if(K=Function("binder","return function ("+en.join(",")+"){ return binder.apply(this,arguments); }")(binder),Z.prototype){var s=function(){};s.prototype=Z.prototype,K.prototype=new s,s.prototype=null}return K}},174:function(F,$,V){"use strict";var G=V(426);F.exports=Function.prototype.bind||G},500:function(F,$,V){"use strict";var G,H=SyntaxError,K=Function,Z=TypeError,getEvalledConstructor=function(F){try{return K('"use strict"; return ('+F+").constructor;")()}catch(F){}},ee=Object.getOwnPropertyDescriptor;if(ee)try{ee({},"")}catch(F){ee=null}var throwTypeError=function(){throw new Z},et=ee?function(){try{return arguments.callee,throwTypeError}catch(F){try{return ee(arguments,"callee").get}catch(F){return throwTypeError}}}():throwTypeError,en=V(115)(),ea=Object.getPrototypeOf||function(F){return F.__proto__},ei={},eo="undefined"==typeof Uint8Array?G:ea(Uint8Array),es={"%AggregateError%":"undefined"==typeof AggregateError?G:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?G:ArrayBuffer,"%ArrayIteratorPrototype%":en?ea([][Symbol.iterator]()):G,"%AsyncFromSyncIteratorPrototype%":G,"%AsyncFunction%":ei,"%AsyncGenerator%":ei,"%AsyncGeneratorFunction%":ei,"%AsyncIteratorPrototype%":ei,"%Atomics%":"undefined"==typeof Atomics?G:Atomics,"%BigInt%":"undefined"==typeof BigInt?G:BigInt,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?G:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":"undefined"==typeof Float32Array?G:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?G:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?G:FinalizationRegistry,"%Function%":K,"%GeneratorFunction%":ei,"%Int8Array%":"undefined"==typeof Int8Array?G:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?G:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?G:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":en?ea(ea([][Symbol.iterator]())):G,"%JSON%":"object"==typeof JSON?JSON:G,"%Map%":"undefined"==typeof Map?G:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&en?ea((new Map)[Symbol.iterator]()):G,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?G:Promise,"%Proxy%":"undefined"==typeof Proxy?G:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":"undefined"==typeof Reflect?G:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?G:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&en?ea((new Set)[Symbol.iterator]()):G,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?G:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":en?ea(""[Symbol.iterator]()):G,"%Symbol%":en?Symbol:G,"%SyntaxError%":H,"%ThrowTypeError%":et,"%TypedArray%":eo,"%TypeError%":Z,"%Uint8Array%":"undefined"==typeof Uint8Array?G:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?G:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?G:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?G:Uint32Array,"%URIError%":URIError,"%WeakMap%":"undefined"==typeof WeakMap?G:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?G:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?G:WeakSet},d=function doEval(F){var $;if("%AsyncFunction%"===F)$=getEvalledConstructor("async function () {}");else if("%GeneratorFunction%"===F)$=getEvalledConstructor("function* () {}");else if("%AsyncGeneratorFunction%"===F)$=getEvalledConstructor("async function* () {}");else if("%AsyncGenerator%"===F){var V=doEval("%AsyncGeneratorFunction%");V&&($=V.prototype)}else if("%AsyncIteratorPrototype%"===F){var G=doEval("%AsyncGenerator%");G&&($=ea(G.prototype))}return es[F]=$,$},eu={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},ec=V(174),ep=V(101),eh=ec.call(Function.call,Array.prototype.concat),ef=ec.call(Function.apply,Array.prototype.splice),ed=ec.call(Function.call,String.prototype.replace),em=ec.call(Function.call,String.prototype.slice),eg=ec.call(Function.call,RegExp.prototype.exec),ey=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,eb=/\\(\\)?/g,j=function(F){var $=em(F,0,1),V=em(F,-1);if("%"===$&&"%"!==V)throw new H("invalid intrinsic syntax, expected closing `%`");if("%"===V&&"%"!==$)throw new H("invalid intrinsic syntax, expected opening `%`");var G=[];return ed(F,ey,function(F,$,V,H){G[G.length]=V?ed(H,eb,"$1"):$||F}),G},E=function(F,$){var V,G=F;if(ep(eu,G)&&(G="%"+(V=eu[G])[0]+"%"),ep(es,G)){var K=es[G];if(K===ei&&(K=d(G)),void 0===K&&!$)throw new Z("intrinsic "+F+" exists, but is not available. Please file an issue!");return{alias:V,name:G,value:K}}throw new H("intrinsic "+F+" does not exist!")};F.exports=function(F,$){if("string"!=typeof F||0===F.length)throw new Z("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof $)throw new Z('"allowMissing" argument must be a boolean');if(null===eg(/^%?[^%]*%?$/g,F))throw new H("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var V=j(F),G=V.length>0?V[0]:"",K=E("%"+G+"%",$),et=K.name,en=K.value,ea=!1,ei=K.alias;ei&&(G=ei[0],ef(V,eh([0,1],ei)));for(var eo=1,eu=!0;eo<V.length;eo+=1){var ec=V[eo],ed=em(ec,0,1),ey=em(ec,-1);if(('"'===ed||"'"===ed||"`"===ed||'"'===ey||"'"===ey||"`"===ey)&&ed!==ey)throw new H("property names with quotes must have matching quotes");if("constructor"!==ec&&eu||(ea=!0),G+="."+ec,ep(es,et="%"+G+"%"))en=es[et];else if(null!=en){if(!(ec in en)){if(!$)throw new Z("base intrinsic for "+F+" exists, but the property is not available.");return}if(ee&&eo+1>=V.length){var eb=ee(en,ec);en=(eu=!!eb)&&"get"in eb&&!("originalValue"in eb.get)?eb.get:en[ec]}else eu=ep(en,ec),en=en[ec];eu&&!ea&&(es[et]=en)}}return en}},925:function(F,$,V){"use strict";var G,H=SyntaxError,K=Function,Z=TypeError,getEvalledConstructor=function(F){try{return K('"use strict"; return ('+F+").constructor;")()}catch(F){}},ee=Object.getOwnPropertyDescriptor;if(ee)try{ee({},"")}catch(F){ee=null}var throwTypeError=function(){throw new Z},et=ee?function(){try{return arguments.callee,throwTypeError}catch(F){try{return ee(arguments,"callee").get}catch(F){return throwTypeError}}}():throwTypeError,en=V(115)(),ea=V(504)(),ei=Object.getPrototypeOf||(ea?function(F){return F.__proto__}:null),eo={},es="undefined"!=typeof Uint8Array&&ei?ei(Uint8Array):G,eu={"%AggregateError%":"undefined"==typeof AggregateError?G:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?G:ArrayBuffer,"%ArrayIteratorPrototype%":en&&ei?ei([][Symbol.iterator]()):G,"%AsyncFromSyncIteratorPrototype%":G,"%AsyncFunction%":eo,"%AsyncGenerator%":eo,"%AsyncGeneratorFunction%":eo,"%AsyncIteratorPrototype%":eo,"%Atomics%":"undefined"==typeof Atomics?G:Atomics,"%BigInt%":"undefined"==typeof BigInt?G:BigInt,"%BigInt64Array%":"undefined"==typeof BigInt64Array?G:BigInt64Array,"%BigUint64Array%":"undefined"==typeof BigUint64Array?G:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?G:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":"undefined"==typeof Float32Array?G:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?G:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?G:FinalizationRegistry,"%Function%":K,"%GeneratorFunction%":eo,"%Int8Array%":"undefined"==typeof Int8Array?G:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?G:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?G:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":en&&ei?ei(ei([][Symbol.iterator]())):G,"%JSON%":"object"==typeof JSON?JSON:G,"%Map%":"undefined"==typeof Map?G:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&en&&ei?ei((new Map)[Symbol.iterator]()):G,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?G:Promise,"%Proxy%":"undefined"==typeof Proxy?G:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":"undefined"==typeof Reflect?G:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?G:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&en&&ei?ei((new Set)[Symbol.iterator]()):G,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?G:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":en&&ei?ei(""[Symbol.iterator]()):G,"%Symbol%":en?Symbol:G,"%SyntaxError%":H,"%ThrowTypeError%":et,"%TypedArray%":es,"%TypeError%":Z,"%Uint8Array%":"undefined"==typeof Uint8Array?G:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?G:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?G:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?G:Uint32Array,"%URIError%":URIError,"%WeakMap%":"undefined"==typeof WeakMap?G:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?G:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?G:WeakSet};if(ei)try{null.error}catch(F){var ec=ei(ei(F));eu["%Error.prototype%"]=ec}var v=function doEval(F){var $;if("%AsyncFunction%"===F)$=getEvalledConstructor("async function () {}");else if("%GeneratorFunction%"===F)$=getEvalledConstructor("function* () {}");else if("%AsyncGeneratorFunction%"===F)$=getEvalledConstructor("async function* () {}");else if("%AsyncGenerator%"===F){var V=doEval("%AsyncGeneratorFunction%");V&&($=V.prototype)}else if("%AsyncIteratorPrototype%"===F){var G=doEval("%AsyncGenerator%");G&&ei&&($=ei(G.prototype))}return eu[F]=$,$},ep={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},eh=V(174),ef=V(101),ed=eh.call(Function.call,Array.prototype.concat),em=eh.call(Function.apply,Array.prototype.splice),eg=eh.call(Function.call,String.prototype.replace),ey=eh.call(Function.call,String.prototype.slice),eb=eh.call(Function.call,RegExp.prototype.exec),ew=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,eS=/\\(\\)?/g,I=function(F){var $=ey(F,0,1),V=ey(F,-1);if("%"===$&&"%"!==V)throw new H("invalid intrinsic syntax, expected closing `%`");if("%"===V&&"%"!==$)throw new H("invalid intrinsic syntax, expected opening `%`");var G=[];return eg(F,ew,function(F,$,V,H){G[G.length]=V?eg(H,eS,"$1"):$||F}),G},B=function(F,$){var V,G=F;if(ef(ep,G)&&(G="%"+(V=ep[G])[0]+"%"),ef(eu,G)){var K=eu[G];if(K===eo&&(K=v(G)),void 0===K&&!$)throw new Z("intrinsic "+F+" exists, but is not available. Please file an issue!");return{alias:V,name:G,value:K}}throw new H("intrinsic "+F+" does not exist!")};F.exports=function(F,$){if("string"!=typeof F||0===F.length)throw new Z("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof $)throw new Z('"allowMissing" argument must be a boolean');if(null===eb(/^%?[^%]*%?$/,F))throw new H("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var V=I(F),G=V.length>0?V[0]:"",K=B("%"+G+"%",$),et=K.name,en=K.value,ea=!1,ei=K.alias;ei&&(G=ei[0],em(V,ed([0,1],ei)));for(var eo=1,es=!0;eo<V.length;eo+=1){var ec=V[eo],ep=ey(ec,0,1),eh=ey(ec,-1);if(('"'===ep||"'"===ep||"`"===ep||'"'===eh||"'"===eh||"`"===eh)&&ep!==eh)throw new H("property names with quotes must have matching quotes");if("constructor"!==ec&&es||(ea=!0),G+="."+ec,ef(eu,et="%"+G+"%"))en=eu[et];else if(null!=en){if(!(ec in en)){if(!$)throw new Z("base intrinsic for "+F+" exists, but the property is not available.");return}if(ee&&eo+1>=V.length){var eg=ee(en,ec);en=(es=!!eg)&&"get"in eg&&!("originalValue"in eg.get)?eg.get:en[ec]}else es=ef(en,ec),en=en[ec];es&&!ea&&(eu[et]=en)}}return en}},504:function(F){"use strict";var $={foo:{}},V=Object;F.exports=function(){return({__proto__:$}).foo===$.foo&&!(({__proto__:null})instanceof V)}},942:function(F,$,V){"use strict";var G="undefined"!=typeof Symbol&&Symbol,H=V(773);F.exports=function(){return"function"==typeof G&&"function"==typeof Symbol&&"symbol"==typeof G("foo")&&"symbol"==typeof Symbol("bar")&&H()}},773:function(F){"use strict";F.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var F={},$=Symbol("test"),V=Object($);if("string"==typeof $||"[object Symbol]"!==Object.prototype.toString.call($)||"[object Symbol]"!==Object.prototype.toString.call(V))return!1;var G=42;for($ in F[$]=G,F)return!1;if("function"==typeof Object.keys&&0!==Object.keys(F).length||"function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(F).length)return!1;var H=Object.getOwnPropertySymbols(F);if(1!==H.length||H[0]!==$||!Object.prototype.propertyIsEnumerable.call(F,$))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var K=Object.getOwnPropertyDescriptor(F,$);if(K.value!==G||!0!==K.enumerable)return!1}return!0}},115:function(F,$,V){"use strict";var G="undefined"!=typeof Symbol&&Symbol,H=V(832);F.exports=function(){return"function"==typeof G&&"function"==typeof Symbol&&"symbol"==typeof G("foo")&&"symbol"==typeof Symbol("bar")&&H()}},832:function(F){"use strict";F.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var F={},$=Symbol("test"),V=Object($);if("string"==typeof $||"[object Symbol]"!==Object.prototype.toString.call($)||"[object Symbol]"!==Object.prototype.toString.call(V))return!1;var G=42;for($ in F[$]=G,F)return!1;if("function"==typeof Object.keys&&0!==Object.keys(F).length||"function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(F).length)return!1;var H=Object.getOwnPropertySymbols(F);if(1!==H.length||H[0]!==$||!Object.prototype.propertyIsEnumerable.call(F,$))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var K=Object.getOwnPropertyDescriptor(F,$);if(K.value!==G||!0!==K.enumerable)return!1}return!0}},101:function(F,$,V){"use strict";var G=V(174);F.exports=G.call(Function.call,Object.prototype.hasOwnProperty)},782:function(F){"function"==typeof Object.create?F.exports=function(F,$){$&&(F.super_=$,F.prototype=Object.create($.prototype,{constructor:{value:F,enumerable:!1,writable:!0,configurable:!0}}))}:F.exports=function(F,$){if($){F.super_=$;var TempCtor=function(){};TempCtor.prototype=$.prototype,F.prototype=new TempCtor,F.prototype.constructor=F}}},157:function(F){"use strict";var $="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag,V=Object.prototype.toString,o=function(F){return(!$||!F||"object"!=typeof F||!(Symbol.toStringTag in F))&&"[object Arguments]"===V.call(F)},n=function(F){return!!o(F)||null!==F&&"object"==typeof F&&"number"==typeof F.length&&F.length>=0&&"[object Array]"!==V.call(F)&&"[object Function]"===V.call(F.callee)},G=function(){return o(arguments)}();o.isLegacyArguments=n,F.exports=G?o:n},391:function(F){"use strict";var $=Object.prototype.toString,V=Function.prototype.toString,G=/^\s*(?:function)?\*/,H="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag,K=Object.getPrototypeOf,Z=function(){if(!H)return!1;try{return Function("return function*() {}")()}catch(F){}}(),ee=Z?K(Z):{};F.exports=function(F){return"function"==typeof F&&(!!G.test(V.call(F))||(H?K(F)===ee:"[object GeneratorFunction]"===$.call(F)))}},994:function(F,$,G){"use strict";var H=G(144),K=G(349),Z=G(256),ee=Z("Object.prototype.toString"),et=G(942)()&&"symbol"==typeof Symbol.toStringTag,en=K(),ea=Z("Array.prototype.indexOf",!0)||function(F,$){for(var V=0;V<F.length;V+=1)if(F[V]===$)return V;return -1},ei=Z("String.prototype.slice"),eo={},es=G(24),eu=Object.getPrototypeOf;et&&es&&eu&&H(en,function(F){var $=new V.g[F];if(!(Symbol.toStringTag in $))throw EvalError("this engine has support for Symbol.toStringTag, but "+F+" does not have the property! Please report this.");var G=eu($),H=es(G,Symbol.toStringTag);H||(H=es(eu(G),Symbol.toStringTag)),eo[F]=H.get});var g=function(F){var $=!1;return H(eo,function(V,G){if(!$)try{$=V.call(F)===G}catch(F){}}),$};F.exports=function(F){return!!F&&"object"==typeof F&&(et?!!es&&g(F):ea(en,ei(ee(F),8,-1))>-1)}},369:function(F){F.exports=function(F){return F instanceof H}},584:function(F,$,V){"use strict";var G=V(157),H=V(391),K=V(490),Z=V(994);function uncurryThis(F){return F.call.bind(F)}var ee="undefined"!=typeof BigInt,et="undefined"!=typeof Symbol,en=uncurryThis(Object.prototype.toString),ea=uncurryThis(Number.prototype.valueOf),ei=uncurryThis(String.prototype.valueOf),eo=uncurryThis(Boolean.prototype.valueOf);if(ee)var es=uncurryThis(BigInt.prototype.valueOf);if(et)var eu=uncurryThis(Symbol.prototype.valueOf);function checkBoxedPrimitive(F,$){if("object"!=typeof F)return!1;try{return $(F),!0}catch(F){return!1}}function isPromise(F){return"undefined"!=typeof Promise&&F instanceof Promise||null!==F&&"object"==typeof F&&"function"==typeof F.then&&"function"==typeof F.catch}function isArrayBufferView(F){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(F):Z(F)||isDataView(F)}function isUint8Array(F){return"Uint8Array"===K(F)}function isUint8ClampedArray(F){return"Uint8ClampedArray"===K(F)}function isUint16Array(F){return"Uint16Array"===K(F)}function isUint32Array(F){return"Uint32Array"===K(F)}function isInt8Array(F){return"Int8Array"===K(F)}function isInt16Array(F){return"Int16Array"===K(F)}function isInt32Array(F){return"Int32Array"===K(F)}function isFloat32Array(F){return"Float32Array"===K(F)}function isFloat64Array(F){return"Float64Array"===K(F)}function isBigInt64Array(F){return"BigInt64Array"===K(F)}function isBigUint64Array(F){return"BigUint64Array"===K(F)}function isMapToString(F){return"[object Map]"===en(F)}function isMap(F){return"undefined"!=typeof Map&&(isMapToString.working?isMapToString(F):F instanceof Map)}function isSetToString(F){return"[object Set]"===en(F)}function isSet(F){return"undefined"!=typeof Set&&(isSetToString.working?isSetToString(F):F instanceof Set)}function isWeakMapToString(F){return"[object WeakMap]"===en(F)}function isWeakMap(F){return"undefined"!=typeof WeakMap&&(isWeakMapToString.working?isWeakMapToString(F):F instanceof WeakMap)}function isWeakSetToString(F){return"[object WeakSet]"===en(F)}function isWeakSet(F){return isWeakSetToString(F)}function isArrayBufferToString(F){return"[object ArrayBuffer]"===en(F)}function isArrayBuffer(F){return"undefined"!=typeof ArrayBuffer&&(isArrayBufferToString.working?isArrayBufferToString(F):F instanceof ArrayBuffer)}function isDataViewToString(F){return"[object DataView]"===en(F)}function isDataView(F){return"undefined"!=typeof DataView&&(isDataViewToString.working?isDataViewToString(F):F instanceof DataView)}$.isArgumentsObject=G,$.isGeneratorFunction=H,$.isTypedArray=Z,$.isPromise=isPromise,$.isArrayBufferView=isArrayBufferView,$.isUint8Array=isUint8Array,$.isUint8ClampedArray=isUint8ClampedArray,$.isUint16Array=isUint16Array,$.isUint32Array=isUint32Array,$.isInt8Array=isInt8Array,$.isInt16Array=isInt16Array,$.isInt32Array=isInt32Array,$.isFloat32Array=isFloat32Array,$.isFloat64Array=isFloat64Array,$.isBigInt64Array=isBigInt64Array,$.isBigUint64Array=isBigUint64Array,isMapToString.working="undefined"!=typeof Map&&isMapToString(new Map),$.isMap=isMap,isSetToString.working="undefined"!=typeof Set&&isSetToString(new Set),$.isSet=isSet,isWeakMapToString.working="undefined"!=typeof WeakMap&&isWeakMapToString(new WeakMap),$.isWeakMap=isWeakMap,isWeakSetToString.working="undefined"!=typeof WeakSet&&isWeakSetToString(new WeakSet),$.isWeakSet=isWeakSet,isArrayBufferToString.working="undefined"!=typeof ArrayBuffer&&isArrayBufferToString(new ArrayBuffer),$.isArrayBuffer=isArrayBuffer,isDataViewToString.working="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView&&isDataViewToString(new DataView(new ArrayBuffer(1),0,1)),$.isDataView=isDataView;var ec="undefined"!=typeof SharedArrayBuffer?SharedArrayBuffer:void 0;function isSharedArrayBufferToString(F){return"[object SharedArrayBuffer]"===en(F)}function isSharedArrayBuffer(F){return void 0!==ec&&(void 0===isSharedArrayBufferToString.working&&(isSharedArrayBufferToString.working=isSharedArrayBufferToString(new ec)),isSharedArrayBufferToString.working?isSharedArrayBufferToString(F):F instanceof ec)}function isAsyncFunction(F){return"[object AsyncFunction]"===en(F)}function isMapIterator(F){return"[object Map Iterator]"===en(F)}function isSetIterator(F){return"[object Set Iterator]"===en(F)}function isGeneratorObject(F){return"[object Generator]"===en(F)}function isWebAssemblyCompiledModule(F){return"[object WebAssembly.Module]"===en(F)}function isNumberObject(F){return checkBoxedPrimitive(F,ea)}function isStringObject(F){return checkBoxedPrimitive(F,ei)}function isBooleanObject(F){return checkBoxedPrimitive(F,eo)}function isBigIntObject(F){return ee&&checkBoxedPrimitive(F,es)}function isSymbolObject(F){return et&&checkBoxedPrimitive(F,eu)}function isBoxedPrimitive(F){return isNumberObject(F)||isStringObject(F)||isBooleanObject(F)||isBigIntObject(F)||isSymbolObject(F)}function isAnyArrayBuffer(F){return"undefined"!=typeof Uint8Array&&(isArrayBuffer(F)||isSharedArrayBuffer(F))}$.isSharedArrayBuffer=isSharedArrayBuffer,$.isAsyncFunction=isAsyncFunction,$.isMapIterator=isMapIterator,$.isSetIterator=isSetIterator,$.isGeneratorObject=isGeneratorObject,$.isWebAssemblyCompiledModule=isWebAssemblyCompiledModule,$.isNumberObject=isNumberObject,$.isStringObject=isStringObject,$.isBooleanObject=isBooleanObject,$.isBigIntObject=isBigIntObject,$.isSymbolObject=isSymbolObject,$.isBoxedPrimitive=isBoxedPrimitive,$.isAnyArrayBuffer=isAnyArrayBuffer,["isProxy","isExternal","isModuleNamespaceObject"].forEach(function(F){Object.defineProperty($,F,{enumerable:!1,value:function(){throw Error(F+" is not supported in userland")}})})},177:function(F,$,V){var G=Object.getOwnPropertyDescriptors||function(F){for(var $=Object.keys(F),V={},G=0;G<$.length;G++)V[$[G]]=Object.getOwnPropertyDescriptor(F,$[G]);return V},H=/%[sdj%]/g;$.format=function(F){if(!isString(F)){for(var $=[],V=0;V<arguments.length;V++)$.push(inspect(arguments[V]));return $.join(" ")}for(var V=1,G=arguments,K=G.length,Z=String(F).replace(H,function(F){if("%%"===F)return"%";if(V>=K)return F;switch(F){case"%s":return String(G[V++]);case"%d":return Number(G[V++]);case"%j":try{return JSON.stringify(G[V++])}catch(F){return"[Circular]"}default:return F}}),ee=G[V];V<K;ee=G[++V])isNull(ee)||!isObject(ee)?Z+=" "+ee:Z+=" "+inspect(ee);return Z},$.deprecate=function(F,V){if(void 0!==K&&!0===K.noDeprecation)return F;if(void 0===K)return function(){return $.deprecate(F,V).apply(this,arguments)};var G=!1;return function(){if(!G){if(K.throwDeprecation)throw Error(V);K.traceDeprecation?console.trace(V):console.error(V),G=!0}return F.apply(this,arguments)}};var Z={},ee=/^$/;if(K.env.NODE_DEBUG){var et=K.env.NODE_DEBUG;ee=RegExp("^"+(et=et.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase())+"$","i")}function inspect(F,V){var G={seen:[],stylize:stylizeNoColor};return arguments.length>=3&&(G.depth=arguments[2]),arguments.length>=4&&(G.colors=arguments[3]),isBoolean(V)?G.showHidden=V:V&&$._extend(G,V),isUndefined(G.showHidden)&&(G.showHidden=!1),isUndefined(G.depth)&&(G.depth=2),isUndefined(G.colors)&&(G.colors=!1),isUndefined(G.customInspect)&&(G.customInspect=!0),G.colors&&(G.stylize=stylizeWithColor),formatValue(G,F,G.depth)}function stylizeWithColor(F,$){var V=inspect.styles[$];return V?"\x1b["+inspect.colors[V][0]+"m"+F+"\x1b["+inspect.colors[V][1]+"m":F}function stylizeNoColor(F,$){return F}function arrayToHash(F){var $={};return F.forEach(function(F,V){$[F]=!0}),$}function formatValue(F,V,G){if(F.customInspect&&V&&isFunction(V.inspect)&&V.inspect!==$.inspect&&!(V.constructor&&V.constructor.prototype===V)){var H,K=V.inspect(G,F);return isString(K)||(K=formatValue(F,K,G)),K}var Z=formatPrimitive(F,V);if(Z)return Z;var ee=Object.keys(V),et=arrayToHash(ee);if(F.showHidden&&(ee=Object.getOwnPropertyNames(V)),isError(V)&&(ee.indexOf("message")>=0||ee.indexOf("description")>=0))return formatError(V);if(0===ee.length){if(isFunction(V)){var en=V.name?": "+V.name:"";return F.stylize("[Function"+en+"]","special")}if(isRegExp(V))return F.stylize(RegExp.prototype.toString.call(V),"regexp");if(isDate(V))return F.stylize(Date.prototype.toString.call(V),"date");if(isError(V))return formatError(V)}var ea="",ei=!1,eo=["{","}"];return(isArray(V)&&(ei=!0,eo=["[","]"]),isFunction(V)&&(ea=" [Function"+(V.name?": "+V.name:"")+"]"),isRegExp(V)&&(ea=" "+RegExp.prototype.toString.call(V)),isDate(V)&&(ea=" "+Date.prototype.toUTCString.call(V)),isError(V)&&(ea=" "+formatError(V)),0!==ee.length||ei&&0!=V.length)?G<0?isRegExp(V)?F.stylize(RegExp.prototype.toString.call(V),"regexp"):F.stylize("[Object]","special"):(F.seen.push(V),H=ei?formatArray(F,V,G,et,ee):ee.map(function($){return formatProperty(F,V,G,et,$,ei)}),F.seen.pop(),reduceToSingleString(H,ea,eo)):eo[0]+ea+eo[1]}function formatPrimitive(F,$){if(isUndefined($))return F.stylize("undefined","undefined");if(isString($)){var V="'"+JSON.stringify($).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return F.stylize(V,"string")}return isNumber($)?F.stylize(""+$,"number"):isBoolean($)?F.stylize(""+$,"boolean"):isNull($)?F.stylize("null","null"):void 0}function formatError(F){return"["+Error.prototype.toString.call(F)+"]"}function formatArray(F,$,V,G,H){for(var K=[],Z=0,ee=$.length;Z<ee;++Z)hasOwnProperty($,String(Z))?K.push(formatProperty(F,$,V,G,String(Z),!0)):K.push("");return H.forEach(function(H){H.match(/^\d+$/)||K.push(formatProperty(F,$,V,G,H,!0))}),K}function formatProperty(F,$,V,G,H,K){var Z,ee,et;if((et=Object.getOwnPropertyDescriptor($,H)||{value:$[H]}).get?ee=et.set?F.stylize("[Getter/Setter]","special"):F.stylize("[Getter]","special"):et.set&&(ee=F.stylize("[Setter]","special")),hasOwnProperty(G,H)||(Z="["+H+"]"),!ee&&(0>F.seen.indexOf(et.value)?(ee=isNull(V)?formatValue(F,et.value,null):formatValue(F,et.value,V-1)).indexOf("\n")>-1&&(ee=K?ee.split("\n").map(function(F){return"  "+F}).join("\n").substr(2):"\n"+ee.split("\n").map(function(F){return"   "+F}).join("\n")):ee=F.stylize("[Circular]","special")),isUndefined(Z)){if(K&&H.match(/^\d+$/))return ee;(Z=JSON.stringify(""+H)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(Z=Z.substr(1,Z.length-2),Z=F.stylize(Z,"name")):(Z=Z.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),Z=F.stylize(Z,"string"))}return Z+": "+ee}function reduceToSingleString(F,$,V){var G=0;return F.reduce(function(F,$){return G++,$.indexOf("\n")>=0&&G++,F+$.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60?V[0]+(""===$?"":$+"\n ")+" "+F.join(",\n  ")+" "+V[1]:V[0]+$+" "+F.join(", ")+" "+V[1]}function isArray(F){return Array.isArray(F)}function isBoolean(F){return"boolean"==typeof F}function isNull(F){return null===F}function isNullOrUndefined(F){return null==F}function isNumber(F){return"number"==typeof F}function isString(F){return"string"==typeof F}function isSymbol(F){return"symbol"==typeof F}function isUndefined(F){return void 0===F}function isRegExp(F){return isObject(F)&&"[object RegExp]"===objectToString(F)}function isObject(F){return"object"==typeof F&&null!==F}function isDate(F){return isObject(F)&&"[object Date]"===objectToString(F)}function isError(F){return isObject(F)&&("[object Error]"===objectToString(F)||F instanceof Error)}function isFunction(F){return"function"==typeof F}function isPrimitive(F){return null===F||"boolean"==typeof F||"number"==typeof F||"string"==typeof F||"symbol"==typeof F||void 0===F}function objectToString(F){return Object.prototype.toString.call(F)}function pad(F){return F<10?"0"+F.toString(10):F.toString(10)}$.debuglog=function(F){if(!Z[F=F.toUpperCase()]){if(ee.test(F)){var V=K.pid;Z[F]=function(){var G=$.format.apply($,arguments);console.error("%s %d: %s",F,V,G)}}else Z[F]=function(){}}return Z[F]},$.inspect=inspect,inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},inspect.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},$.types=V(584),$.isArray=isArray,$.isBoolean=isBoolean,$.isNull=isNull,$.isNullOrUndefined=isNullOrUndefined,$.isNumber=isNumber,$.isString=isString,$.isSymbol=isSymbol,$.isUndefined=isUndefined,$.isRegExp=isRegExp,$.types.isRegExp=isRegExp,$.isObject=isObject,$.isDate=isDate,$.types.isDate=isDate,$.isError=isError,$.types.isNativeError=isError,$.isFunction=isFunction,$.isPrimitive=isPrimitive,$.isBuffer=V(369);var en=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function timestamp(){var F=new Date,$=[pad(F.getHours()),pad(F.getMinutes()),pad(F.getSeconds())].join(":");return[F.getDate(),en[F.getMonth()],$].join(" ")}function hasOwnProperty(F,$){return Object.prototype.hasOwnProperty.call(F,$)}$.log=function(){console.log("%s - %s",timestamp(),$.format.apply($,arguments))},$.inherits=V(782),$._extend=function(F,$){if(!$||!isObject($))return F;for(var V=Object.keys($),G=V.length;G--;)F[V[G]]=$[V[G]];return F};var ea="undefined"!=typeof Symbol?Symbol("util.promisify.custom"):void 0;function callbackifyOnRejected(F,$){if(!F){var V=Error("Promise was rejected with a falsy value");V.reason=F,F=V}return $(F)}function callbackify(F){if("function"!=typeof F)throw TypeError('The "original" argument must be of type Function');function callbackified(){for(var $=[],V=0;V<arguments.length;V++)$.push(arguments[V]);var G=$.pop();if("function"!=typeof G)throw TypeError("The last argument must be of type Function");var H=this,cb=function(){return G.apply(H,arguments)};F.apply(this,$).then(function(F){K.nextTick(cb.bind(null,null,F))},function(F){K.nextTick(callbackifyOnRejected.bind(null,F,cb))})}return Object.setPrototypeOf(callbackified,Object.getPrototypeOf(F)),Object.defineProperties(callbackified,G(F)),callbackified}$.promisify=function(F){if("function"!=typeof F)throw TypeError('The "original" argument must be of type Function');if(ea&&F[ea]){var e=F[ea];if("function"!=typeof e)throw TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(e,ea,{value:e,enumerable:!1,writable:!1,configurable:!0}),e}function e(){for(var $,V,G=new Promise(function(F,G){$=F,V=G}),H=[],K=0;K<arguments.length;K++)H.push(arguments[K]);H.push(function(F,G){F?V(F):$(G)});try{F.apply(this,H)}catch(F){V(F)}return G}return Object.setPrototypeOf(e,Object.getPrototypeOf(F)),ea&&Object.defineProperty(e,ea,{value:e,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(e,G(F))},$.promisify.custom=ea,$.callbackify=callbackify},490:function(F,$,G){"use strict";var H=G(144),K=G(349),Z=G(256),ee=Z("Object.prototype.toString"),et=G(942)()&&"symbol"==typeof Symbol.toStringTag,en=K(),ea=Z("String.prototype.slice"),ei={},eo=G(24),es=Object.getPrototypeOf;et&&eo&&es&&H(en,function(F){if("function"==typeof V.g[F]){var $=new V.g[F];if(!(Symbol.toStringTag in $))throw EvalError("this engine has support for Symbol.toStringTag, but "+F+" does not have the property! Please report this.");var G=es($),H=eo(G,Symbol.toStringTag);H||(H=eo(es(G),Symbol.toStringTag)),ei[F]=H.get}});var d=function(F){var $=!1;return H(ei,function(V,G){if(!$)try{var H=V.call(F);H===G&&($=H)}catch(F){}}),$},eu=G(994);F.exports=function(F){return!!eu(F)&&(et?d(F):ea(ee(F),8,-1))}},349:function(F,$,G){"use strict";var H=G(992);F.exports=function(){return H(["BigInt64Array","BigUint64Array","Float32Array","Float64Array","Int16Array","Int32Array","Int8Array","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray"],function(F){return"function"==typeof V.g[F]})}},24:function(F,$,V){"use strict";var G=V(500)("%Object.getOwnPropertyDescriptor%",!0);if(G)try{G([],"length")}catch(F){G=null}F.exports=G}},Z={};function __nccwpck_require__(F){var V=Z[F];if(void 0!==V)return V.exports;var G=Z[F]={exports:{}},H=!0;try{$[F](G,G.exports,__nccwpck_require__),H=!1}finally{H&&delete Z[F]}return G.exports}__nccwpck_require__.ab=G+"/";var ee=__nccwpck_require__(177);F.exports=ee}()},51951:function(module){var __dirname="/";!function(){var __webpack_modules__={950:function(__unused_webpack_module,exports){var indexOf=function(F,$){if(F.indexOf)return F.indexOf($);for(var V=0;V<F.length;V++)if(F[V]===$)return V;return -1},Object_keys=function(F){if(Object.keys)return Object.keys(F);var $=[];for(var V in F)$.push(V);return $},forEach=function(F,$){if(F.forEach)return F.forEach($);for(var V=0;V<F.length;V++)$(F[V],V,F)},defineProp=function(){try{return Object.defineProperty({},"_",{}),function(F,$,V){Object.defineProperty(F,$,{writable:!0,enumerable:!1,configurable:!0,value:V})}}catch(F){return function(F,$,V){F[$]=V}}}(),globals=["Array","Boolean","Date","Error","EvalError","Function","Infinity","JSON","Math","NaN","Number","Object","RangeError","ReferenceError","RegExp","String","SyntaxError","TypeError","URIError","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","eval","isFinite","isNaN","parseFloat","parseInt","undefined","unescape"];function Context(){}Context.prototype={};var Script=exports.Script=function(F){if(!(this instanceof Script))return new Script(F);this.code=F};Script.prototype.runInContext=function(F){if(!(F instanceof Context))throw TypeError("needs a 'context' argument.");var $=document.createElement("iframe");$.style||($.style={}),$.style.display="none",document.body.appendChild($);var V=$.contentWindow,G=V.eval,H=V.execScript;!G&&H&&(H.call(V,"null"),G=V.eval),forEach(Object_keys(F),function($){V[$]=F[$]}),forEach(globals,function($){F[$]&&(V[$]=F[$])});var K=Object_keys(V),Z=G.call(V,this.code);return forEach(Object_keys(V),function($){($ in F||-1===indexOf(K,$))&&(F[$]=V[$])}),forEach(globals,function($){$ in F||defineProp(F,$,V[$])}),document.body.removeChild($),Z},Script.prototype.runInThisContext=function(){return eval(this.code)},Script.prototype.runInNewContext=function(F){var $=Script.createContext(F),V=this.runInContext($);return F&&forEach(Object_keys($),function(V){F[V]=$[V]}),V},forEach(Object_keys(Script.prototype),function(F){exports[F]=Script[F]=function($){var V=Script($);return V[F].apply(V,[].slice.call(arguments,1))}}),exports.isContext=function(F){return F instanceof Context},exports.createScript=function(F){return exports.Script(F)},exports.createContext=Script.createContext=function(F){var $=new Context;return"object"==typeof F&&forEach(Object_keys(F),function(V){$[V]=F[V]}),$}}};"undefined"!=typeof __nccwpck_require__&&(__nccwpck_require__.ab=__dirname+"/");var __nested_webpack_exports__={};__webpack_modules__[950](0,__nested_webpack_exports__),module.exports=__nested_webpack_exports__}()},76519:function(F,$,V){"use strict";V.r($),V.d($,{ClassificationCriterion:function(){return ClassificationCriterion},ColumnTransformer:function(){return ColumnTransformer},DecisionTree:function(){return DecisionTree},DecisionTreeBase:function(){return DecisionTreeBase},DecisionTreeClassifier:function(){return DecisionTreeClassifier},DecisionTreeRegressor:function(){return DecisionTreeRegressor},DummyClassifier:function(){return DummyClassifier},DummyRegressor:function(){return DummyRegressor},ElasticNet:function(){return ElasticNet},GaussianNB:function(){return GaussianNB},KFold:function(){return KFold},KMeans:function(){return KMeans},KNeighborsClassifier:function(){return KNeighborsClassifier},KNeighborsRegressor:function(){return KNeighborsRegressor},LabelEncoder:function(){return LabelEncoder},LassoRegression:function(){return LassoRegression},LinearRegression:function(){return LinearRegression},LinearSVC:function(){return LinearSVC},LinearSVR:function(){return LinearSVR},LogisticRegression:function(){return LogisticRegression},MaxAbsScaler:function(){return MaxAbsScaler},MinMaxScaler:function(){return MinMaxScaler},Normalizer:function(){return Normalizer},OneHotEncoder:function(){return OneHotEncoder},OrdinalEncoder:function(){return OrdinalEncoder},Pipeline:function(){return Pipeline},RegressionCriterion:function(){return RegressionCriterion},RidgeRegression:function(){return RidgeRegression},RobustScaler:function(){return RobustScaler},Serialize:function(){return Serialize},SimpleImputer:function(){return SimpleImputer},Splitter:function(){return Splitter},StandardScaler:function(){return StandardScaler},VotingClassifier:function(){return VotingClassifier},VotingRegressor:function(){return VotingRegressor},crossValScore:function(){return crossValScore},dataUrls:function(){return iW},fromJSON:function(){return fromJSON},fromObject:function(){return fromObject},getBackend:function(){return tf_singleton_getBackend},makeLowRankMatrix:function(){return makeLowRankMatrix},makePipeline:function(){return makePipeline},makeRegression:function(){return makeRegression},makeVotingClassifier:function(){return makeVotingClassifier},makeVotingRegressor:function(){return makeVotingRegressor},metrics:function(){return G},setBackend:function(){return setBackend},trainTestSplit:function(){return trainTestSplit}});var G={};V.r(G),V.d(G,{accuracyScore:function(){return accuracyScore},confusionMatrix:function(){return confusionMatrix},hingeLoss:function(){return hingeLoss},huberLoss:function(){return huberLoss},logLoss:function(){return logLoss},meanAbsoluteError:function(){return meanAbsoluteError},meanSquaredError:function(){return meanSquaredError},meanSquaredLogError:function(){return meanSquaredLogError},precisionScore:function(){return precisionScore},r2Score:function(){return r2Score},recallScore:function(){return recallScore},rocAucScore:function(){return rocAucScore},zeroOneLoss:function(){return zeroOneLoss}});let H=null;function setBackend(F){H=F}function tf_singleton_getBackend(){if(null===H)throw Error(`
============================
Howdy . Looks like you are running scikit but you haven't set a Tensorflow backend. 
To do so, simply import (or require) your tensorflow library, and call setBackend like so,

import * as tf from '@tensorflow/tfjs'
import * as sk from 'scikitjs'
sk.setBackend(tf)

That will let scikit know you wish to use a tensorflow library to perform your calculations.
============================
    `);return H}/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/function isString(F){return"string"==typeof F||F instanceof String}function isBoolean(F){return"boolean"==typeof F}function isNumber(F){return"number"==typeof F}function typesUtils_assert(F,$){if(!F)throw Error($)}function inferShape(F,$){let V=F;if(isTypedArray(F))return"string"===$?[]:[F.length];if(!Array.isArray(F))return[];let G=[];for(;Array.isArray(V)||isTypedArray(V)&&"string"!==$;)G.push(V.length),V=V[0];return Array.isArray(F)&&deepAssertShapeConsistency(F,G,[]),G}function deepAssertShapeConsistency(F,$,V){if(V=V||[],!Array.isArray(F)&&!isTypedArray(F)){typesUtils_assert(0===$.length,`Element arr[${V.join("][")}] is a primitive, but should be an array/TypedArray of ${$[0]} elements`);return}typesUtils_assert($.length>0,`Element arr[${V.join("][")}] should be a primitive, but is an array of ${F.length} elements`),typesUtils_assert(F.length===$[0],`Element arr[${V.join("][")}] should have ${$[0]} elements, but has ${F.length} elements`);let G=$.slice(1);for(let $=0;$<F.length;++$)deepAssertShapeConsistency(F[$],G,V.concat($))}function inferDtype(F){return Array.isArray(F)?inferDtype(F[0]):F instanceof Float32Array?"float32":F instanceof Int32Array||F instanceof Uint8Array?"int32":isNumber(F)?"float32":isString(F)?"string":isBoolean(F)?"bool":null}function isTypedArray(F){return F instanceof Float32Array||F instanceof Int32Array||F instanceof Uint8Array}function isScikitLike1D(F){let $=inferShape(F),V=inferDtype(F);return 1===$.length&&null!==V}function isScikitLike2D(F){let $=inferShape(F),V=inferDtype(F);return 2===$.length&&null!==V}function typesUtils_isTensor(F){return F instanceof tf_singleton_getBackend().Tensor}function typesUtils_isSeriesInterface(F){return"object"==typeof F&&!!F&&!!F.iloc&&!F.applyMap}function typesUtils_isDataFrameInterface(F){return"object"==typeof F&&!!F&&!!F.iloc&&!!F.applyMap}function isScikit1D(F){return!!typesUtils_isSeriesInterface(F)||(typesUtils_isTensor(F)?1===F.rank:isScikitLike1D(F))}function isScikit2D(F){return!!typesUtils_isDataFrameInterface(F)||(typesUtils_isTensor(F)?2===F.rank:isScikitLike2D(F))}function isScikitVecOrMatrix(F){return isScikit1D(F)||isScikit2D(F)}function utils_convertToTensor1D(F,$){let V=tf_singleton_getBackend();if(typesUtils_isSeriesInterface(F))return $?F.tensor.asType($):F.tensor;if(typesUtils_isTensor(F)){if(1===F.shape.length)return $&&F.dtype!=$?F.asType($):F;throw Error("ParamError: if data is a Tensor it must be a Tensor1D. If you really meant to reshape this tensor than use tf.reshape")}return $?V.tensor1d(F,$):V.tensor1d(F)}function convertToNumericTensor1D(F,$){let V=utils_convertToTensor1D(F,$);if("string"===V.dtype)throw Error("ParamError: data has string dtype, can't convert to numeric Tensor");return V}function convertToTensor2D(F,$){let V=tf_singleton_getBackend();if(typesUtils_isDataFrameInterface(F))return $?F.tensor.asType($):F.tensor;if(typesUtils_isTensor(F)){if(2===F.shape.length)return $&&F.dtype!=$?F.asType($):F;throw Error("ParamError: if data is a Tensor it must be a Tensor2D. If you really meant to reshape this tensor than use tf.reshape")}if(Array.isArray(F)&&isTypedArray(F[0])){let G=inferShape(F),H=F.map(F=>Array.from(F));return $?V.tensor2d(H,G,$):V.tensor2d(H,G)}return $?V.tensor2d(F,void 0,$):V.tensor2d(F,void 0)}function convertToTensor1D_2D(F,$){try{let V=utils_convertToTensor1D(F,$);return V}catch(V){try{let V=convertToTensor2D(F,$);return V}catch(F){throw Error('ParamError: Can"t convert data into 1D or 2D tensor')}}}function convertToNumericTensor2D(F,$){let V=convertToTensor2D(F,$);if("string"===V.dtype)throw Error("ParamError: data has string dtype, can't convert to numeric Tensor");return V}function convertToNumericTensor1D_2D(F,$){let V=convertToTensor1D_2D(F,$);if("string"===V.dtype)throw Error("ParamError: data has string dtype, can't convert to numeric Tensor");return V}function convertScikit2DToArray(F){return typesUtils_isDataFrameInterface(F)?F.values:typesUtils_isTensor(F)?F.arraySync():F}function convertScikit1DToArray(F){return typesUtils_isSeriesInterface(F)?F.values:typesUtils_isTensor(F)?F.arraySync():F}function getLength(F){return(typesUtils_assert(isScikitVecOrMatrix(F),"X isn't a Scikit2D or Scikit1D object"),typesUtils_isTensor(F))?F.shape[0]:typesUtils_isDataFrameInterface(F)||typesUtils_isSeriesInterface(F)?F.size:F.length}function sampleWithoutReplacement(F,$,V){let G=tf_singleton_getBackend(),H=new Map,K=[],Z=G.randomUniform([$],0,F,"float32",V).dataSync();for(let $=0;$<Z.length;$++){Z[$]=Z[$]*(F-$)/F;let V=Math.floor(Z[$]),G=F-$-1;void 0===H.get(V)&&H.set(V,V),void 0===H.get(G)&&H.set(G,G);let ee=H.get(G);H.set(G,H.get(V)),H.set(V,ee),K.push(H.get(G))}return K}var K=V(44908),Z=V.n(K);/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/function assertInputIsWellFormed(F,$){typesUtils_assert(isScikit1D(F),"Labels can't be converted to a 1D Tensor"),typesUtils_assert(isScikit1D($),"Predictions can't be converted to a 1D Tensor");let V=convertToNumericTensor1D(F),G=convertToNumericTensor1D($);return typesUtils_assert(V.size>0,"Must have 1 label or more"),typesUtils_assert(G.size>0,"Must have 1 prediction or more"),typesUtils_assert(V.size===G.size,"Not the same size arrays"),{labelsT:V,predictionsT:G}}function accuracyScore(F,$){let{labelsT:V,predictionsT:G}=assertInputIsWellFormed(F,$),H=V.equal(G).sum().div(V.size);return H.dataSync()[0]}function precisionScore(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=V.metrics.precision(G,H);return K.dataSync()[0]}function recallScore(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=V.metrics.recall(G,H);return K.dataSync()[0]}function r2Score(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=V.metrics.meanSquaredError(G,H),Z=V.metrics.meanSquaredError(G,G.mean()),ee=V.sub(1,K.div(Z));return ee.dataSync()[0]}function meanAbsoluteError(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=V.metrics.meanAbsoluteError(G,H);return K.dataSync()[0]}function meanSquaredError(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=V.metrics.meanSquaredError(G,H);return K.dataSync()[0]}function meanSquaredLogError(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=V.square(G.log1p().sub(H.log1p())).sum().div(G.size);return K.dataSync()[0]}function hingeLoss(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=V.losses.hingeLoss(G,H);return K.dataSync()[0]}function huberLoss(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=V.losses.huberLoss(G,H);return K.dataSync()[0]}function logLoss(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=V.losses.logLoss(G,H);return K.dataSync()[0]}function zeroOneLoss(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=V.sub(1,accuracyScore(G,H));return K.dataSync()[0]}function confusionMatrix(F,$){let V=tf_singleton_getBackend(),{labelsT:G,predictionsT:H}=assertInputIsWellFormed(F,$),K=Z()(G.dataSync());return V.math.confusionMatrix(G,H,K.length).arraySync()}function rocAucScore(F,$){let{labelsT:V,predictionsT:G}=assertInputIsWellFormed(F,$),H=V.arraySync(),K=G.arraySync();H.push(1),K.push(1);let Z=0;for(let F=0;F<H.length-1;F++)Z+=H[F]*K[F+1]-H[F+1]*K[F];return Math.abs(Z-=1)/2}for(var ee="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",et="undefined"==typeof Uint8Array?[]:new Uint8Array(256),en=0;en<ee.length;en++)et[ee.charCodeAt(en)]=en;var encode=function(F){var $,V=new Uint8Array(F),G=V.length,H="";for($=0;$<G;$+=3)H+=ee[V[$]>>2]+ee[(3&V[$])<<4|V[$+1]>>4]+ee[(15&V[$+1])<<2|V[$+2]>>6]+ee[63&V[$+2]];return G%3==2?H=H.substring(0,H.length-1)+"=":G%3==1&&(H=H.substring(0,H.length-2)+"=="),H},decode=function(F){var $,V,G,H,K,Z=.75*F.length,ee=F.length,en=0;"="===F[F.length-1]&&(Z--,"="===F[F.length-2]&&Z--);var ea=new ArrayBuffer(Z),ei=new Uint8Array(ea);for($=0;$<ee;$+=4)V=et[F.charCodeAt($)],G=et[F.charCodeAt($+1)],H=et[F.charCodeAt($+2)],K=et[F.charCodeAt($+3)],ei[en++]=V<<2|G>>4,ei[en++]=(15&G)<<4|H>>2,ei[en++]=(3&H)<<6|63&K;return ea};let ea=["KNeighborsRegressor","LinearRegression","LassoRegression","RidgeRegression","ElasticNet","LogisticRegression","DummyRegressor","DummyClassifier","MinMaxScaler","StandardScaler","MaxAbsScaler","SimpleImputer","OneHotEncoder","LabelEncoder","OrdinalEncoder","Normalizer","Pipeline","ColumnTransformer","RobustScaler","KMeans","VotingRegressor","VotingClassifier","LinearSVC","LinearSVR","GaussianNB","DecisionTreeClassifier","DecisionTreeRegressor","ClassificationCriterion","RegressionCriterion","Splitter","DecisionTreeBase","DecisionTree"],ei="abcdefghijklmnopqrstuvwxy";function randomString(F){let $="";for(let V=0;V<F;V++){let F=Math.floor(Math.random()*ei.length);$+=ei[F]}return $}let JSONHandler=class JSONHandler{savedArtifacts;constructor(F){this.savedArtifacts=F||null}async save(F){F.weightData=encode(F.weightData);let $={};for(let V=0;V<F.modelTopology.config.layers.length;V++){let G=F.modelTopology.config.layers[V],H=randomString(6);$[G.config.name]=H,G.config.name=H}for(let V=0;V<F.weightSpecs.length;V++){let G=F.weightSpecs[V];Object.keys($).forEach(F=>{G.name.includes(F)&&(G.name=G.name.replace(F,$[F]))})}return this.savedArtifacts=F,{modelArtifactsInfo:{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:JSON.stringify(F.modelTopology).length,weightSpecsBytes:JSON.stringify(F.weightSpecs).length,weightDataBytes:F.weightData.byteLength}}}async load(){return this.savedArtifacts.weightData=decode(this.savedArtifacts.weightData),this.savedArtifacts}};async function toObjectInner(F,$=[]){let V=tf_singleton_getBackend();if(["number","string","undefined","boolean"].includes(typeof F))return F;if("function"==typeof F&&(console.warn(`warning: Serializing function ${F}. Not going to be able to deserialize this later.`),F.name))return F.name;if("object"==typeof F){if(null===F)return null;if(Array.isArray(F))return await Promise.all(F.map(async F=>await toObjectInner(F,$)));if(F instanceof V.Tensor)return{name:"Tensor",value:F.arraySync()};if(F instanceof Int32Array)return{name:"Int32Array",value:Array.from(F)};if(F instanceof Float32Array)return{name:"Float32Array",value:Array.from(F)};if(F instanceof V.Sequential){let $=new JSONHandler;return await F.save($),{name:"Sequential",artifacts:$.savedArtifacts}}if(F.ENV&&F.AdadeltaOptimizer&&F.version)return{name:"TF",version:F.version.tfjs};let G={};for(let V of Object.keys(F))$.includes(V)||(G[V]=await toObjectInner(F[V],$));return G}}async function fromObjectInner(F){let $=tf_singleton_getBackend();if("object"!=typeof F)return F;if(null===F)return null;if("Tensor"===F.name)return $.tensor(F.value);if("Sequential"===F.name){let V=new JSONHandler(F.artifacts);return await $.loadLayersModel(V)}if("Int32Array"===F.name)return new Int32Array(F.value);if("Float32Array"===F.name)return new Float32Array(F.value);if("TF"===F.name)return $;if(Array.isArray(F))return await Promise.all(F.map(async F=>await fromObjectInner(F)));for(let $ of Object.keys(F))F[$]=await fromObjectInner(F[$]);if(ea.includes(F.name)){let $=new(await Promise.resolve().then(V.bind(V,76519)))[F.name](F);for(let V of Object.keys(F))$[V]=F[V];return $}return F}async function fromObject(F){try{return await fromObjectInner(F)}catch(F){console.error(F)}}async function fromJSON(F){return await fromObject(JSON.parse(F))}let eo=["modelCompileArgs","modelFitArgs","denseLayerArgs"];let Serialize=class Serialize{async toObject(){return await toObjectInner(this,eo)}async toJSON(){return JSON.stringify(await this.toObject())}};let TransformerMixin=class TransformerMixin extends Serialize{fitTransform(F){return this.fit(F).transform(F)}};let RegressorMixin=class RegressorMixin extends Serialize{EstimatorType="regressor";score(F,$){let V=this.predict(F);return r2Score($,V)}};let ClassifierMixin=class ClassifierMixin extends Serialize{EstimatorType="classifier";score(F,$){let V=this.predict(F),G=convertToNumericTensor1D_2D($);return(typesUtils_assert(V.shape.length===G.shape.length,"The shape of the model output doesn't match the shape of the actual y values"),isScikit2D($))?accuracyScore(G.argMax(1),V.argMax(1)):accuracyScore($,V)}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let SGDRegressor=class SGDRegressor extends RegressorMixin{model;modelFitArgs;modelCompileArgs;denseLayerArgs;isMultiOutput;optimizerType;lossType;constructor({modelFitArgs:F,modelCompileArgs:$,denseLayerArgs:V,optimizerType:G,lossType:H}){super(),this.tf=tf_singleton_getBackend(),this.model=this.tf.sequential(),this.modelFitArgs=F,this.modelCompileArgs=$,this.denseLayerArgs=V,this.isMultiOutput=!1,this.optimizerType=G,this.lossType=H}initializeModel(F,$,V=[]){this.denseLayerArgs.units=1===$.shape.length?1:$.shape[1];let G=this.tf.sequential();G.add(this.tf.layers.dense({inputShape:[F.shape[1]],...this.denseLayerArgs})),G.compile(this.modelCompileArgs),V?.length&&G.setWeights(V),this.model=G}async fit(F,$){let V=convertToNumericTensor2D(F),G=convertToNumericTensor1D_2D($);return G.shape.length>1&&(this.isMultiOutput=!0),0===this.model.layers.length&&this.initializeModel(V,G),await this.model.fit(V,G,{...this.modelFitArgs}),this}importModel(F){let $=this.tf.tensor2d(F.coef,[F.coef.length,1],"float32"),V=this.tf.tensor1d([F.intercept],"float32");return this.initializeModel($,V,[$,V]),this}getParams(){return{modelFitArgs:this.modelFitArgs,modelCompileArgs:this.modelCompileArgs,denseLayerArgs:this.denseLayerArgs,optimizerType:this.optimizerType,lossType:this.lossType}}setParams(F){return this.modelCompileArgs=F.modelCompileArgs,this.modelFitArgs=F.modelFitArgs,this.denseLayerArgs=F.denseLayerArgs,this}predict(F){let $=convertToNumericTensor2D(F);if(0===this.model.layers.length)throw RangeError('Need to call "fit" before "predict"');let V=this.model.predict($);return this.isMultiOutput?V:V.reshape([-1])}get coef(){let F=this.model.getWeights();if(0===F.length)return this.tf.tensor2d([]);let $=F[0];return 1===$.shape[1]?$.reshape([$.shape[0]]):$}get intercept(){let F=this.model.getWeights();if(F.length<2)return 0;let $=F[1];return 1===$.size?$.arraySync()[0]:$}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let LinearRegression=class LinearRegression extends SGDRegressor{constructor({fitIntercept:F=!0,modelFitOptions:$}={}){let V=tf_singleton_getBackend();super({modelCompileArgs:{optimizer:V.train.adam(.1),loss:V.losses.meanSquaredError,metrics:["mse"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[V.callbacks.earlyStopping({monitor:"mse",patience:30})],...$},denseLayerArgs:{units:1,useBias:!!F},optimizerType:"adam",lossType:"meanSquaredError"}),this.name="LinearRegression"}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let LassoRegression=class LassoRegression extends SGDRegressor{constructor({fitIntercept:F=!0,alpha:$=1}={}){let V=tf_singleton_getBackend();super({modelCompileArgs:{optimizer:V.train.adam(.1),loss:V.losses.meanSquaredError,metrics:["mse"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[V.callbacks.earlyStopping({monitor:"mse",patience:50})]},denseLayerArgs:{units:1,kernelRegularizer:V.regularizers.l1({l1:$}),useBias:!!F},optimizerType:"adam",lossType:"meanSquaredError"}),this.name="LassoRegression"}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let RidgeRegression=class RidgeRegression extends SGDRegressor{constructor({fitIntercept:F=!0,alpha:$=.01}={}){let V=tf_singleton_getBackend();super({modelCompileArgs:{optimizer:V.train.adam(.1),loss:V.losses.meanSquaredError,metrics:["mse"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[V.callbacks.earlyStopping({monitor:"mse",patience:50})]},denseLayerArgs:{units:1,kernelRegularizer:V.regularizers.l2({l2:$}),useBias:!!F},optimizerType:"adam",lossType:"meanSquaredError"}),this.name="RidgeRegression"}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let ElasticNet=class ElasticNet extends SGDRegressor{constructor({alpha:F=1,l1Ratio:$=.5,fitIntercept:V=!0}={}){let G=tf_singleton_getBackend();super({modelCompileArgs:{optimizer:G.train.adam(.1),loss:G.losses.meanSquaredError,metrics:["mse"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[G.callbacks.earlyStopping({monitor:"mse",patience:50})]},denseLayerArgs:{units:1,kernelRegularizer:G.regularizers.l1l2({l1:F*$,l2:.5*F*(1-$)}),useBias:!!V},optimizerType:"adam",lossType:"meanSquaredError"}),this.name="ElasticNet"}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let OneHotEncoder=class OneHotEncoder extends TransformerMixin{categories;handleUnknown;categoriesParam;drop;nFeaturesIn;featureNamesIn;name="OneHotEncoder";constructor({categories:F="auto",handleUnknown:$="error",drop:V}={}){super(),this.tf=tf_singleton_getBackend(),this.categoriesParam=F,this.categories=[],this.handleUnknown=$,this.nFeaturesIn=0,this.featureNamesIn=[],this.drop=V}classesToMapping(F){let $=new Map;return F.forEach((F,V)=>{$.set(F,V)}),$}loopOver2DArrayToSetLabels(F){for(let $=0;$<F[0].length;$++){let V=new Set;for(let G=0;G<F.length;G++)V.add(F[G][$]);let G=Array.from(V);this.categories.push(G)}}fit(F,$){let V=convertScikit2DToArray(F);return"auto"===this.categoriesParam?this.loopOver2DArrayToSetLabels(V):(this.categories=this.categoriesParam,this.nFeaturesIn=0===V.length?0:V[0].length||0,typesUtils_isDataFrameInterface(F)&&(this.featureNamesIn=[...F.columns])),this}loopOver2DArrayToUseLabels(F){let $=this.categories.map(F=>this.classesToMapping(F)),V=[];for(let G=0;G<F.length;G++){let H=[];for(let V=0;V<F[0].length;V++){let K=F[G][V],Z=$[V].get(K);if(void 0===Z){if("error"===this.handleUnknown)throw Error(`Unknown value ${K} encountered while transforming. Not encountered in training data`);Z=-1}"first"===this.drop&&(Z-=1),H.push(Z)}V.push(H)}return V}convertToOneHot(F,$){return $>=2?this.tf.oneHot(F,$):1===$?(F=this.tf.where(F.equal(0),this.tf.ones(F.shape,"int32"),this.tf.zeros(F.shape,"int32"))).reshape([-1,1]):this.tf.tensor2d([])}transform(F,$){let V=convertScikit2DToArray(F),G=this.loopOver2DArrayToUseLabels(V),H=this.tf.tensor2d(G,void 0,"int32");return this.tf.concat(H.unstack(1).map((F,$)=>{let V=this.categories[$].length,G="first"===this.drop?V-1:V;return this.convertToOneHot(F,G)}),1)}inverseTransform(F){let $=this.classesToMapping(this.categories[0]),V=F.argMax(1),G=new Map(Array.from($,F=>F.reverse())),H=V.arraySync().map(F=>void 0===G.get(F)?null:G.get(F));return H}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let SGDClassifier=class SGDClassifier extends ClassifierMixin{model;modelFitArgs;modelCompileArgs;denseLayerArgs;optimizerType;lossType;oneHot;tf;isMultiOutput;constructor({modelFitArgs:F,modelCompileArgs:$,denseLayerArgs:V,optimizerType:G,lossType:H}){super(),this.tf=tf_singleton_getBackend(),this.model=this.tf.sequential(),this.modelFitArgs=F,this.modelCompileArgs=$,this.denseLayerArgs=V,this.optimizerType=G,this.lossType=H,this.isMultiOutput=!1,this.oneHot=new OneHotEncoder}initializeModelForClassification(F){let $=F.toInt();if(2===$.shape.length)return this.modelCompileArgs.loss=this.tf.losses.softmaxCrossEntropy,$;{let $=F.reshape([-1,1]),V=this.oneHot.fitTransform($);return this.oneHot.categories[0].length>2?this.modelCompileArgs.loss=this.tf.losses.softmaxCrossEntropy:this.modelCompileArgs.loss=this.tf.losses.sigmoidCrossEntropy,V}}initializeModel(F,$,V=[]){this.denseLayerArgs.units=1===$.shape.length?1:$.shape[1];let G=this.tf.sequential();G.add(this.tf.layers.dense({inputShape:[F.shape[1]],...this.denseLayerArgs})),G.compile(this.modelCompileArgs),V?.length&&G.setWeights(V),this.model=G}async fit(F,$){let V=convertToNumericTensor2D(F),G=convertToNumericTensor1D_2D($),H=this.initializeModelForClassification(G);return G.shape.length>1&&(this.isMultiOutput=!0),0===this.model.layers.length&&this.initializeModel(V,H),await this.model.fit(V,H,{...this.modelFitArgs}),this}importModel(F){let $=this.tf.tensor2d(F.coef,[F.coef.length,1],"float32"),V=this.tf.tensor1d([F.intercept],"float32");return this.initializeModel($,V,[$,V]),this}getParams(){return{modelFitArgs:this.modelFitArgs,modelCompileArgs:this.modelCompileArgs,denseLayerArgs:this.denseLayerArgs,optimizerType:this.optimizerType,lossType:this.lossType}}setParams(F){return this.modelCompileArgs=F.modelCompileArgs,this.modelFitArgs=F.modelFitArgs,this.denseLayerArgs=F.denseLayerArgs,this}predictProba(F){typesUtils_assert(this.model.layers.length>0,'Need to call "fit" before "predict"');let $=convertToNumericTensor2D(F);return this.model.predict($)}predict(F){typesUtils_assert(this.model.layers.length>0,'Need to call "fit" before "predict"');let $=this.predictProba(F);return this.isMultiOutput?this.tf.oneHot($.argMax(1),$.shape[1]):this.tf.tensor1d(this.oneHot.inverseTransform($))}get coef(){let F=this.model.getWeights();if(0===F.length)return this.tf.tensor2d([]);let $=F[0];return 1===$.shape[1]?$.reshape([$.shape[0]]):$}get intercept(){let F=this.model.getWeights();if(F.length<2)return 0;let $=F[1];return 1===$.size?$.arraySync()[0]:$}};// *  @license
let LogisticRegression=class LogisticRegression extends SGDClassifier{constructor({penalty:F="l2",C:$=1,fitIntercept:V=!0,modelFitOptions:G}={}){let H=tf_singleton_getBackend();super({modelCompileArgs:{optimizer:H.train.adam(.1),loss:H.losses.softmaxCrossEntropy,metrics:["accuracy"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[H.callbacks.earlyStopping({monitor:"loss",patience:50})],...G},denseLayerArgs:{units:1,useBias:!!V,activation:"softmax",kernelInitializer:H.initializers.zeros(),biasInitializer:H.initializers.zeros(),kernelRegularizer:"l2"===F?H.regularizers.l2({l2:$}):"l1"===F?H.regularizers.l1({l1:$}):void 0},isClassification:!0,optimizerType:"adam",lossType:"softmaxCrossEntropy"}),this.name="LogisticRegression"}};function _extends(){return(_extends=Object.assign?Object.assign.bind():function(F){for(var $=1;$<arguments.length;$++){var V=arguments[$];for(var G in V)Object.prototype.hasOwnProperty.call(V,G)&&(F[G]=V[G])}return F}).apply(this,arguments)}var es={epsilon:1e-12,matrix:"Matrix",number:"number",precision:64,predictable:!1,randomSeed:null},config=function(F){if(F)throw Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");return Object.freeze(es)};_extends(config,es,{MATRIX_OPTIONS:["Matrix","Array"],NUMBER_OPTIONS:["number","BigNumber","Fraction"]});/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */var eu,ec,ep=9e15,eh=1e9,ef="0123456789abcdef",ed="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",em="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",eg={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-9e15,maxE:9e15,crypto:!1},ey=!0,eb="[DecimalError] ",ew=eb+"Invalid argument: ",eS=eb+"Precision limit exceeded",e_=eb+"crypto unavailable",eN="[object Decimal]",ek=Math.floor,eI=Math.pow,eT=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,eC=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,eE=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,eA=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,eD=1e7,eM=7,eR=9007199254740991,eF=ed.length-1,eO=em.length-1,eP={toStringTag:eN};function digitsToString(F){var $,V,G,H=F.length-1,K="",Z=F[0];if(H>0){for(K+=Z,$=1;$<H;$++)(V=eM-(G=F[$]+"").length)&&(K+=getZeroString(V)),K+=G;(V=eM-(G=(Z=F[$])+"").length)&&(K+=getZeroString(V))}else if(0===Z)return"0";for(;Z%10==0;)Z/=10;return K+Z}function checkInt32(F,$,V){if(F!==~~F||F<$||F>V)throw Error(ew+F)}function checkRoundingDigits(F,$,V,G){var H,K,Z,ee;for(K=F[0];K>=10;K/=10)--$;return--$<0?($+=eM,H=0):(H=Math.ceil(($+1)/eM),$%=eM),K=eI(10,eM-$),ee=F[H]%K|0,null==G?$<3?(0==$?ee=ee/100|0:1==$&&(ee=ee/10|0),Z=V<4&&99999==ee||V>3&&49999==ee||5e4==ee||0==ee):Z=(V<4&&ee+1==K||V>3&&ee+1==K/2)&&(F[H+1]/K/100|0)==eI(10,$-2)-1||(ee==K/2||0==ee)&&(F[H+1]/K/100|0)==0:$<4?(0==$?ee=ee/1e3|0:1==$?ee=ee/100|0:2==$&&(ee=ee/10|0),Z=(G||V<4)&&9999==ee||!G&&V>3&&4999==ee):Z=((G||V<4)&&ee+1==K||!G&&V>3&&ee+1==K/2)&&(F[H+1]/K/1e3|0)==eI(10,$-3)-1,Z}function convertBase(F,$,V){for(var G,H,K=[0],Z=0,ee=F.length;Z<ee;){for(H=K.length;H--;)K[H]*=$;for(K[0]+=ef.indexOf(F.charAt(Z++)),G=0;G<K.length;G++)K[G]>V-1&&(void 0===K[G+1]&&(K[G+1]=0),K[G+1]+=K[G]/V|0,K[G]%=V)}return K.reverse()}function cosine(F,$){var V,G,H;if($.isZero())return $;(G=$.d.length)<32?H=(1/tinyPow(4,V=Math.ceil(G/3))).toString():(V=16,H="2.3283064365386962890625e-10"),F.precision+=V,$=taylorSeries(F,1,$.times(H),new F(1));for(var K=V;K--;){var Z=$.times($);$=Z.times(Z).minus(Z).times(8).plus(1)}return F.precision-=V,$}eP.absoluteValue=eP.abs=function(){var F=new this.constructor(this);return F.s<0&&(F.s=1),finalise(F)},eP.ceil=function(){return finalise(new this.constructor(this),this.e+1,2)},eP.clampedTo=eP.clamp=function(F,$){var V=this,G=V.constructor;if(F=new G(F),$=new G($),!F.s||!$.s)return new G(NaN);if(F.gt($))throw Error(ew+$);return 0>V.cmp(F)?F:V.cmp($)>0?$:new G(V)},eP.comparedTo=eP.cmp=function(F){var $,V,G,H,K=this,Z=K.d,ee=(F=new K.constructor(F)).d,et=K.s,en=F.s;if(!Z||!ee)return et&&en?et!==en?et:Z===ee?0:!Z^et<0?1:-1:NaN;if(!Z[0]||!ee[0])return Z[0]?et:ee[0]?-en:0;if(et!==en)return et;if(K.e!==F.e)return K.e>F.e^et<0?1:-1;for($=0,V=(G=Z.length)<(H=ee.length)?G:H;$<V;++$)if(Z[$]!==ee[$])return Z[$]>ee[$]^et<0?1:-1;return G===H?0:G>H^et<0?1:-1},eP.cosine=eP.cos=function(){var F,$,V=this,G=V.constructor;return V.d?V.d[0]?(F=G.precision,$=G.rounding,G.precision=F+Math.max(V.e,V.sd())+eM,G.rounding=1,V=cosine(G,toLessThanHalfPi(G,V)),G.precision=F,G.rounding=$,finalise(2==ec||3==ec?V.neg():V,F,$,!0)):new G(1):new G(NaN)},eP.cubeRoot=eP.cbrt=function(){var F,$,V,G,H,K,Z,ee,et,en,ea=this,ei=ea.constructor;if(!ea.isFinite()||ea.isZero())return new ei(ea);for(ey=!1,(K=ea.s*eI(ea.s*ea,1/3))&&Math.abs(K)!=1/0?G=new ei(K.toString()):(V=digitsToString(ea.d),(K=((F=ea.e)-V.length+1)%3)&&(V+=1==K||-2==K?"0":"00"),K=eI(V,1/3),F=ek((F+1)/3)-(F%3==(F<0?-1:2)),V=K==1/0?"5e"+F:(V=K.toExponential()).slice(0,V.indexOf("e")+1)+F,(G=new ei(V)).s=ea.s),Z=(F=ei.precision)+3;;)if(G=eB((en=(et=(ee=G).times(ee).times(ee)).plus(ea)).plus(ea).times(ee),en.plus(et),Z+2,1),digitsToString(ee.d).slice(0,Z)===(V=digitsToString(G.d)).slice(0,Z)){if("9999"!=(V=V.slice(Z-3,Z+1))&&(H||"4999"!=V)){+V&&(+V.slice(1)||"5"!=V.charAt(0))||(finalise(G,F+1,1),$=!G.times(G).times(G).eq(ea));break}if(!H&&(finalise(ee,F+1,0),ee.times(ee).times(ee).eq(ea))){G=ee;break}Z+=4,H=1}return ey=!0,finalise(G,F,ei.rounding,$)},eP.decimalPlaces=eP.dp=function(){var F,$=this.d,V=NaN;if($){if(V=((F=$.length-1)-ek(this.e/eM))*eM,F=$[F])for(;F%10==0;F/=10)V--;V<0&&(V=0)}return V},eP.dividedBy=eP.div=function(F){return eB(this,new this.constructor(F))},eP.dividedToIntegerBy=eP.divToInt=function(F){var $=this,V=$.constructor;return finalise(eB($,new V(F),0,1,1),V.precision,V.rounding)},eP.equals=eP.eq=function(F){return 0===this.cmp(F)},eP.floor=function(){return finalise(new this.constructor(this),this.e+1,3)},eP.greaterThan=eP.gt=function(F){return this.cmp(F)>0},eP.greaterThanOrEqualTo=eP.gte=function(F){var $=this.cmp(F);return 1==$||0===$},eP.hyperbolicCosine=eP.cosh=function(){var F,$,V,G,H,K=this,Z=K.constructor,ee=new Z(1);if(!K.isFinite())return new Z(K.s?1/0:NaN);if(K.isZero())return ee;V=Z.precision,G=Z.rounding,Z.precision=V+Math.max(K.e,K.sd())+4,Z.rounding=1,(H=K.d.length)<32?$=(1/tinyPow(4,F=Math.ceil(H/3))).toString():(F=16,$="2.3283064365386962890625e-10"),K=taylorSeries(Z,1,K.times($),new Z(1),!0);for(var et,en=F,ea=new Z(8);en--;)et=K.times(K),K=ee.minus(et.times(ea.minus(et.times(ea))));return finalise(K,Z.precision=V,Z.rounding=G,!0)},eP.hyperbolicSine=eP.sinh=function(){var F,$,V,G,H=this,K=H.constructor;if(!H.isFinite()||H.isZero())return new K(H);if($=K.precision,V=K.rounding,K.precision=$+Math.max(H.e,H.sd())+4,K.rounding=1,(G=H.d.length)<3)H=taylorSeries(K,2,H,H,!0);else{F=(F=1.4*Math.sqrt(G))>16?16:0|F,H=taylorSeries(K,2,H=H.times(1/tinyPow(5,F)),H,!0);for(var Z,ee=new K(5),et=new K(16),en=new K(20);F--;)Z=H.times(H),H=H.times(ee.plus(Z.times(et.times(Z).plus(en))))}return K.precision=$,K.rounding=V,finalise(H,$,V,!0)},eP.hyperbolicTangent=eP.tanh=function(){var F,$,V=this,G=V.constructor;return V.isFinite()?V.isZero()?new G(V):(F=G.precision,$=G.rounding,G.precision=F+7,G.rounding=1,eB(V.sinh(),V.cosh(),G.precision=F,G.rounding=$)):new G(V.s)},eP.inverseCosine=eP.acos=function(){var F,$=this,V=$.constructor,G=$.abs().cmp(1),H=V.precision,K=V.rounding;return -1!==G?0===G?$.isNeg()?getPi(V,H,K):new V(0):new V(NaN):$.isZero()?getPi(V,H+4,K).times(.5):(V.precision=H+6,V.rounding=1,$=$.asin(),F=getPi(V,H+4,K).times(.5),V.precision=H,V.rounding=K,F.minus($))},eP.inverseHyperbolicCosine=eP.acosh=function(){var F,$,V=this,G=V.constructor;return V.lte(1)?new G(V.eq(1)?0:NaN):V.isFinite()?(F=G.precision,$=G.rounding,G.precision=F+Math.max(Math.abs(V.e),V.sd())+4,G.rounding=1,ey=!1,V=V.times(V).minus(1).sqrt().plus(V),ey=!0,G.precision=F,G.rounding=$,V.ln()):new G(V)},eP.inverseHyperbolicSine=eP.asinh=function(){var F,$,V=this,G=V.constructor;return!V.isFinite()||V.isZero()?new G(V):(F=G.precision,$=G.rounding,G.precision=F+2*Math.max(Math.abs(V.e),V.sd())+6,G.rounding=1,ey=!1,V=V.times(V).plus(1).sqrt().plus(V),ey=!0,G.precision=F,G.rounding=$,V.ln())},eP.inverseHyperbolicTangent=eP.atanh=function(){var F,$,V,G,H=this,K=H.constructor;return H.isFinite()?H.e>=0?new K(H.abs().eq(1)?H.s/0:H.isZero()?H:NaN):(F=K.precision,$=K.rounding,Math.max(G=H.sd(),F)<-(2*H.e)-1)?finalise(new K(H),F,$,!0):(K.precision=V=G-H.e,H=eB(H.plus(1),new K(1).minus(H),V+F,1),K.precision=F+4,K.rounding=1,H=H.ln(),K.precision=F,K.rounding=$,H.times(.5)):new K(NaN)},eP.inverseSine=eP.asin=function(){var F,$,V,G,H=this,K=H.constructor;return H.isZero()?new K(H):($=H.abs().cmp(1),V=K.precision,G=K.rounding,-1!==$)?0===$?((F=getPi(K,V+4,G).times(.5)).s=H.s,F):new K(NaN):(K.precision=V+6,K.rounding=1,H=H.div(new K(1).minus(H.times(H)).sqrt().plus(1)).atan(),K.precision=V,K.rounding=G,H.times(2))},eP.inverseTangent=eP.atan=function(){var F,$,V,G,H,K,Z,ee,et,en=this,ea=en.constructor,ei=ea.precision,eo=ea.rounding;if(en.isFinite()){if(en.isZero())return new ea(en);if(en.abs().eq(1)&&ei+4<=eO)return(Z=getPi(ea,ei+4,eo).times(.25)).s=en.s,Z}else{if(!en.s)return new ea(NaN);if(ei+4<=eO)return(Z=getPi(ea,ei+4,eo).times(.5)).s=en.s,Z}for(ea.precision=ee=ei+10,ea.rounding=1,F=V=Math.min(28,ee/eM+2|0);F;--F)en=en.div(en.times(en).plus(1).sqrt().plus(1));for(ey=!1,$=Math.ceil(ee/eM),G=1,et=en.times(en),Z=new ea(en),H=en;-1!==F;)if(H=H.times(et),K=Z.minus(H.div(G+=2)),H=H.times(et),void 0!==(Z=K.plus(H.div(G+=2))).d[$])for(F=$;Z.d[F]===K.d[F]&&F--;);return V&&(Z=Z.times(2<<V-1)),ey=!0,finalise(Z,ea.precision=ei,ea.rounding=eo,!0)},eP.isFinite=function(){return!!this.d},eP.isInteger=eP.isInt=function(){return!!this.d&&ek(this.e/eM)>this.d.length-2},eP.isNaN=function(){return!this.s},eP.isNegative=eP.isNeg=function(){return this.s<0},eP.isPositive=eP.isPos=function(){return this.s>0},eP.isZero=function(){return!!this.d&&0===this.d[0]},eP.lessThan=eP.lt=function(F){return 0>this.cmp(F)},eP.lessThanOrEqualTo=eP.lte=function(F){return 1>this.cmp(F)},eP.logarithm=eP.log=function(F){var $,V,G,H,K,Z,ee,et,en=this,ea=en.constructor,ei=ea.precision,eo=ea.rounding,es=5;if(null==F)F=new ea(10),$=!0;else{if(V=(F=new ea(F)).d,F.s<0||!V||!V[0]||F.eq(1))return new ea(NaN);$=F.eq(10)}if(V=en.d,en.s<0||!V||!V[0]||en.eq(1))return new ea(V&&!V[0]?-1/0:1!=en.s?NaN:V?0:1/0);if($){if(V.length>1)K=!0;else{for(H=V[0];H%10==0;)H/=10;K=1!==H}}if(ey=!1,checkRoundingDigits((et=eB(Z=naturalLogarithm(en,ee=ei+es),G=$?getLn10(ea,ee+10):naturalLogarithm(F,ee),ee,1)).d,H=ei,eo))do if(ee+=10,et=eB(Z=naturalLogarithm(en,ee),G=$?getLn10(ea,ee+10):naturalLogarithm(F,ee),ee,1),!K){+digitsToString(et.d).slice(H+1,H+15)+1==1e14&&(et=finalise(et,ei+1,0));break}while(checkRoundingDigits(et.d,H+=10,eo));return ey=!0,finalise(et,ei,eo)},eP.minus=eP.sub=function(F){var $,V,G,H,K,Z,ee,et,en,ea,ei,eo,es=this,eu=es.constructor;if(F=new eu(F),!es.d||!F.d)return es.s&&F.s?es.d?F.s=-F.s:F=new eu(F.d||es.s!==F.s?es:NaN):F=new eu(NaN),F;if(es.s!=F.s)return F.s=-F.s,es.plus(F);if(en=es.d,eo=F.d,ee=eu.precision,et=eu.rounding,!en[0]||!eo[0]){if(eo[0])F.s=-F.s;else{if(!en[0])return new eu(3===et?-0:0);F=new eu(es)}return ey?finalise(F,ee,et):F}if(V=ek(F.e/eM),ea=ek(es.e/eM),en=en.slice(),K=ea-V){for((ei=K<0)?($=en,K=-K,Z=eo.length):($=eo,V=ea,Z=en.length),K>(G=Math.max(Math.ceil(ee/eM),Z)+2)&&(K=G,$.length=1),$.reverse(),G=K;G--;)$.push(0);$.reverse()}else{for((ei=(G=en.length)<(Z=eo.length))&&(Z=G),G=0;G<Z;G++)if(en[G]!=eo[G]){ei=en[G]<eo[G];break}K=0}for(ei&&($=en,en=eo,eo=$,F.s=-F.s),Z=en.length,G=eo.length-Z;G>0;--G)en[Z++]=0;for(G=eo.length;G>K;){if(en[--G]<eo[G]){for(H=G;H&&0===en[--H];)en[H]=eD-1;--en[H],en[G]+=eD}en[G]-=eo[G]}for(;0===en[--Z];)en.pop();for(;0===en[0];en.shift())--V;return en[0]?(F.d=en,F.e=getBase10Exponent(en,V),ey?finalise(F,ee,et):F):new eu(3===et?-0:0)},eP.modulo=eP.mod=function(F){var $,V=this,G=V.constructor;return(F=new G(F),V.d&&F.s&&(!F.d||F.d[0]))?F.d&&(!V.d||V.d[0])?(ey=!1,9==G.modulo?($=eB(V,F.abs(),0,3,1),$.s*=F.s):$=eB(V,F,0,G.modulo,1),$=$.times(F),ey=!0,V.minus($)):finalise(new G(V),G.precision,G.rounding):new G(NaN)},eP.naturalExponential=eP.exp=function(){return naturalExponential(this)},eP.naturalLogarithm=eP.ln=function(){return naturalLogarithm(this)},eP.negated=eP.neg=function(){var F=new this.constructor(this);return F.s=-F.s,finalise(F)},eP.plus=eP.add=function(F){var $,V,G,H,K,Z,ee,et,en,ea,ei=this,eo=ei.constructor;if(F=new eo(F),!ei.d||!F.d)return ei.s&&F.s?ei.d||(F=new eo(F.d||ei.s===F.s?ei:NaN)):F=new eo(NaN),F;if(ei.s!=F.s)return F.s=-F.s,ei.minus(F);if(en=ei.d,ea=F.d,ee=eo.precision,et=eo.rounding,!en[0]||!ea[0])return ea[0]||(F=new eo(ei)),ey?finalise(F,ee,et):F;if(K=ek(ei.e/eM),G=ek(F.e/eM),en=en.slice(),H=K-G){for(H<0?(V=en,H=-H,Z=ea.length):(V=ea,G=K,Z=en.length),H>(Z=(K=Math.ceil(ee/eM))>Z?K+1:Z+1)&&(H=Z,V.length=1),V.reverse();H--;)V.push(0);V.reverse()}for((Z=en.length)-(H=ea.length)<0&&(H=Z,V=ea,ea=en,en=V),$=0;H;)$=(en[--H]=en[H]+ea[H]+$)/eD|0,en[H]%=eD;for($&&(en.unshift($),++G),Z=en.length;0==en[--Z];)en.pop();return F.d=en,F.e=getBase10Exponent(en,G),ey?finalise(F,ee,et):F},eP.precision=eP.sd=function(F){var $,V=this;if(void 0!==F&&!!F!==F&&1!==F&&0!==F)throw Error(ew+F);return V.d?($=getPrecision(V.d),F&&V.e+1>$&&($=V.e+1)):$=NaN,$},eP.round=function(){var F=this,$=F.constructor;return finalise(new $(F),F.e+1,$.rounding)},eP.sine=eP.sin=function(){var F,$,V=this,G=V.constructor;return V.isFinite()?V.isZero()?new G(V):(F=G.precision,$=G.rounding,G.precision=F+Math.max(V.e,V.sd())+eM,G.rounding=1,V=sine(G,toLessThanHalfPi(G,V)),G.precision=F,G.rounding=$,finalise(ec>2?V.neg():V,F,$,!0)):new G(NaN)},eP.squareRoot=eP.sqrt=function(){var F,$,V,G,H,K,Z=this,ee=Z.d,et=Z.e,en=Z.s,ea=Z.constructor;if(1!==en||!ee||!ee[0])return new ea(!en||en<0&&(!ee||ee[0])?NaN:ee?Z:1/0);for(ey=!1,0==(en=Math.sqrt(+Z))||en==1/0?((($=digitsToString(ee)).length+et)%2==0&&($+="0"),en=Math.sqrt($),et=ek((et+1)/2)-(et<0||et%2),$=en==1/0?"5e"+et:($=en.toExponential()).slice(0,$.indexOf("e")+1)+et,G=new ea($)):G=new ea(en.toString()),V=(et=ea.precision)+3;;)if(G=(K=G).plus(eB(Z,K,V+2,1)).times(.5),digitsToString(K.d).slice(0,V)===($=digitsToString(G.d)).slice(0,V)){if("9999"!=($=$.slice(V-3,V+1))&&(H||"4999"!=$)){+$&&(+$.slice(1)||"5"!=$.charAt(0))||(finalise(G,et+1,1),F=!G.times(G).eq(Z));break}if(!H&&(finalise(K,et+1,0),K.times(K).eq(Z))){G=K;break}V+=4,H=1}return ey=!0,finalise(G,et,ea.rounding,F)},eP.tangent=eP.tan=function(){var F,$,V=this,G=V.constructor;return V.isFinite()?V.isZero()?new G(V):(F=G.precision,$=G.rounding,G.precision=F+10,G.rounding=1,(V=V.sin()).s=1,V=eB(V,new G(1).minus(V.times(V)).sqrt(),F+10,0),G.precision=F,G.rounding=$,finalise(2==ec||4==ec?V.neg():V,F,$,!0)):new G(NaN)},eP.times=eP.mul=function(F){var $,V,G,H,K,Z,ee,et,en,ea=this,ei=ea.constructor,eo=ea.d,es=(F=new ei(F)).d;if(F.s*=ea.s,!eo||!eo[0]||!es||!es[0])return new ei(F.s&&(!eo||eo[0]||es)&&(!es||es[0]||eo)?eo&&es?0*F.s:F.s/0:NaN);for(V=ek(ea.e/eM)+ek(F.e/eM),(et=eo.length)<(en=es.length)&&(K=eo,eo=es,es=K,Z=et,et=en,en=Z),K=[],G=Z=et+en;G--;)K.push(0);for(G=en;--G>=0;){for($=0,H=et+G;H>G;)ee=K[H]+es[G]*eo[H-G-1]+$,K[H--]=ee%eD|0,$=ee/eD|0;K[H]=(K[H]+$)%eD|0}for(;!K[--Z];)K.pop();return $?++V:K.shift(),F.d=K,F.e=getBase10Exponent(K,V),ey?finalise(F,ei.precision,ei.rounding):F},eP.toBinary=function(F,$){return toStringBinary(this,2,F,$)},eP.toDecimalPlaces=eP.toDP=function(F,$){var V=this,G=V.constructor;return(V=new G(V),void 0===F)?V:(checkInt32(F,0,eh),void 0===$?$=G.rounding:checkInt32($,0,8),finalise(V,F+V.e+1,$))},eP.toExponential=function(F,$){var V,G=this,H=G.constructor;return void 0===F?V=finiteToString(G,!0):(checkInt32(F,0,eh),void 0===$?$=H.rounding:checkInt32($,0,8),V=finiteToString(G=finalise(new H(G),F+1,$),!0,F+1)),G.isNeg()&&!G.isZero()?"-"+V:V},eP.toFixed=function(F,$){var V,G,H=this,K=H.constructor;return void 0===F?V=finiteToString(H):(checkInt32(F,0,eh),void 0===$?$=K.rounding:checkInt32($,0,8),V=finiteToString(G=finalise(new K(H),F+H.e+1,$),!1,F+G.e+1)),H.isNeg()&&!H.isZero()?"-"+V:V},eP.toFraction=function(F){var $,V,G,H,K,Z,ee,et,en,ea,ei,eo,es=this,eu=es.d,ec=es.constructor;if(!eu)return new ec(es);if(en=V=new ec(1),G=et=new ec(0),Z=(K=($=new ec(G)).e=getPrecision(eu)-es.e-1)%eM,$.d[0]=eI(10,Z<0?eM+Z:Z),null==F)F=K>0?$:en;else{if(!(ee=new ec(F)).isInt()||ee.lt(en))throw Error(ew+ee);F=ee.gt($)?K>0?$:en:ee}for(ey=!1,ee=new ec(digitsToString(eu)),ea=ec.precision,ec.precision=K=eu.length*eM*2;ei=eB(ee,$,0,1,1),1!=(H=V.plus(ei.times(G))).cmp(F);)V=G,G=H,H=en,en=et.plus(ei.times(H)),et=H,H=$,$=ee.minus(ei.times(H)),ee=H;return H=eB(F.minus(V),G,0,1,1),et=et.plus(H.times(en)),V=V.plus(H.times(G)),et.s=en.s=es.s,eo=1>eB(en,G,K,1).minus(es).abs().cmp(eB(et,V,K,1).minus(es).abs())?[en,G]:[et,V],ec.precision=ea,ey=!0,eo},eP.toHexadecimal=eP.toHex=function(F,$){return toStringBinary(this,16,F,$)},eP.toNearest=function(F,$){var V=this,G=V.constructor;if(V=new G(V),null==F){if(!V.d)return V;F=new G(1),$=G.rounding}else{if(F=new G(F),void 0===$?$=G.rounding:checkInt32($,0,8),!V.d)return F.s?V:F;if(!F.d)return F.s&&(F.s=V.s),F}return F.d[0]?(ey=!1,V=eB(V,F,0,$,1).times(F),ey=!0,finalise(V)):(F.s=V.s,V=F),V},eP.toNumber=function(){return+this},eP.toOctal=function(F,$){return toStringBinary(this,8,F,$)},eP.toPower=eP.pow=function(F){var $,V,G,H,K,Z,ee=this,et=ee.constructor,en=+(F=new et(F));if(!ee.d||!F.d||!ee.d[0]||!F.d[0])return new et(eI(+ee,en));if((ee=new et(ee)).eq(1))return ee;if(G=et.precision,K=et.rounding,F.eq(1))return finalise(ee,G,K);if(($=ek(F.e/eM))>=F.d.length-1&&(V=en<0?-en:en)<=eR)return H=intPow(et,ee,V,G),F.s<0?new et(1).div(H):finalise(H,G,K);if((Z=ee.s)<0){if($<F.d.length-1)return new et(NaN);if((1&F.d[$])==0&&(Z=1),0==ee.e&&1==ee.d[0]&&1==ee.d.length)return ee.s=Z,ee}return($=0!=(V=eI(+ee,en))&&isFinite(V)?new et(V+"").e:ek(en*(Math.log("0."+digitsToString(ee.d))/Math.LN10+ee.e+1)))>et.maxE+1||$<et.minE-1?new et($>0?Z/0:0):(ey=!1,et.rounding=ee.s=1,V=Math.min(12,($+"").length),(H=naturalExponential(F.times(naturalLogarithm(ee,G+V)),G)).d&&checkRoundingDigits((H=finalise(H,G+5,1)).d,G,K)&&($=G+10,+digitsToString((H=finalise(naturalExponential(F.times(naturalLogarithm(ee,$+V)),$),$+5,1)).d).slice(G+1,G+15)+1==1e14&&(H=finalise(H,G+1,0))),H.s=Z,ey=!0,et.rounding=K,finalise(H,G,K))},eP.toPrecision=function(F,$){var V,G=this,H=G.constructor;return void 0===F?V=finiteToString(G,G.e<=H.toExpNeg||G.e>=H.toExpPos):(checkInt32(F,1,eh),void 0===$?$=H.rounding:checkInt32($,0,8),V=finiteToString(G=finalise(new H(G),F,$),F<=G.e||G.e<=H.toExpNeg,F)),G.isNeg()&&!G.isZero()?"-"+V:V},eP.toSignificantDigits=eP.toSD=function(F,$){var V=this,G=V.constructor;return void 0===F?(F=G.precision,$=G.rounding):(checkInt32(F,1,eh),void 0===$?$=G.rounding:checkInt32($,0,8)),finalise(new G(V),F,$)},eP.toString=function(){var F=this,$=F.constructor,V=finiteToString(F,F.e<=$.toExpNeg||F.e>=$.toExpPos);return F.isNeg()&&!F.isZero()?"-"+V:V},eP.truncated=eP.trunc=function(){return finalise(new this.constructor(this),this.e+1,1)},eP.valueOf=eP.toJSON=function(){var F=this,$=F.constructor,V=finiteToString(F,F.e<=$.toExpNeg||F.e>=$.toExpPos);return F.isNeg()?"-"+V:V};var eB=function(){function multiplyInteger(F,$,V){var G,H=0,K=F.length;for(F=F.slice();K--;)G=F[K]*$+H,F[K]=G%V|0,H=G/V|0;return H&&F.unshift(H),F}function compare(F,$,V,G){var H,K;if(V!=G)K=V>G?1:-1;else for(H=K=0;H<V;H++)if(F[H]!=$[H]){K=F[H]>$[H]?1:-1;break}return K}function subtract(F,$,V,G){for(var H=0;V--;)F[V]-=H,H=F[V]<$[V]?1:0,F[V]=H*G+F[V]-$[V];for(;!F[0]&&F.length>1;)F.shift()}return function(F,$,V,G,H,K){var Z,ee,et,en,ea,ei,eo,es,ec,ep,eh,ef,ed,em,eg,ey,eb,ew,eS,e_,eN=F.constructor,eI=F.s==$.s?1:-1,eT=F.d,eC=$.d;if(!eT||!eT[0]||!eC||!eC[0])return new eN(F.s&&$.s&&(eT?!eC||eT[0]!=eC[0]:eC)?eT&&0==eT[0]||!eC?0*eI:eI/0:NaN);for(K?(ea=1,ee=F.e-$.e):(K=eD,ea=eM,ee=ek(F.e/ea)-ek($.e/ea)),eS=eC.length,eb=eT.length,ep=(ec=new eN(eI)).d=[],et=0;eC[et]==(eT[et]||0);et++);if(eC[et]>(eT[et]||0)&&ee--,null==V?(em=V=eN.precision,G=eN.rounding):em=H?V+(F.e-$.e)+1:V,em<0)ep.push(1),ei=!0;else{if(em=em/ea+2|0,et=0,1==eS){for(en=0,eC=eC[0],em++;(et<eb||en)&&em--;et++)eg=en*K+(eT[et]||0),ep[et]=eg/eC|0,en=eg%eC|0;ei=en||et<eb}else{for((en=K/(eC[0]+1)|0)>1&&(eC=multiplyInteger(eC,en,K),eT=multiplyInteger(eT,en,K),eS=eC.length,eb=eT.length),ey=eS,ef=(eh=eT.slice(0,eS)).length;ef<eS;)eh[ef++]=0;(e_=eC.slice()).unshift(0),ew=eC[0],eC[1]>=K/2&&++ew;do en=0,(Z=compare(eC,eh,eS,ef))<0?(ed=eh[0],eS!=ef&&(ed=ed*K+(eh[1]||0)),(en=ed/ew|0)>1?(en>=K&&(en=K-1),es=(eo=multiplyInteger(eC,en,K)).length,ef=eh.length,1==(Z=compare(eo,eh,es,ef))&&(en--,subtract(eo,eS<es?e_:eC,es,K))):(0==en&&(Z=en=1),eo=eC.slice()),(es=eo.length)<ef&&eo.unshift(0),subtract(eh,eo,ef,K),-1==Z&&(ef=eh.length,(Z=compare(eC,eh,eS,ef))<1&&(en++,subtract(eh,eS<ef?e_:eC,ef,K))),ef=eh.length):0===Z&&(en++,eh=[0]),ep[et++]=en,Z&&eh[0]?eh[ef++]=eT[ey]||0:(eh=[eT[ey]],ef=1);while((ey++<eb||void 0!==eh[0])&&em--);ei=void 0!==eh[0]}ep[0]||ep.shift()}if(1==ea)ec.e=ee,eu=ei;else{for(et=1,en=ep[0];en>=10;en/=10)et++;ec.e=et+ee*ea-1,finalise(ec,H?V+ec.e+1:V,G,ei)}return ec}}();function finalise(F,$,V,G){var H,K,Z,ee,et,en,ea,ei,eo,es=F.constructor;t:if(null!=$){if(!(ei=F.d))return F;for(H=1,ee=ei[0];ee>=10;ee/=10)H++;if((K=$-H)<0)K+=eM,Z=$,et=(ea=ei[eo=0])/eI(10,H-Z-1)%10|0;else if((eo=Math.ceil((K+1)/eM))>=(ee=ei.length)){if(G){for(;ee++<=eo;)ei.push(0);ea=et=0,H=1,K%=eM,Z=K-eM+1}else break t}else{for(H=1,ea=ee=ei[eo];ee>=10;ee/=10)H++;K%=eM,et=(Z=K-eM+H)<0?0:ea/eI(10,H-Z-1)%10|0}if(G=G||$<0||void 0!==ei[eo+1]||(Z<0?ea:ea%eI(10,H-Z-1)),en=V<4?(et||G)&&(0==V||V==(F.s<0?3:2)):et>5||5==et&&(4==V||G||6==V&&(K>0?Z>0?ea/eI(10,H-Z):0:ei[eo-1])%10&1||V==(F.s<0?8:7)),$<1||!ei[0])return ei.length=0,en?($-=F.e+1,ei[0]=eI(10,(eM-$%eM)%eM),F.e=-$||0):ei[0]=F.e=0,F;if(0==K?(ei.length=eo,ee=1,eo--):(ei.length=eo+1,ee=eI(10,eM-K),ei[eo]=Z>0?(ea/eI(10,H-Z)%eI(10,Z)|0)*ee:0),en)for(;;){if(0==eo){for(K=1,Z=ei[0];Z>=10;Z/=10)K++;for(Z=ei[0]+=ee,ee=1;Z>=10;Z/=10)ee++;K!=ee&&(F.e++,ei[0]==eD&&(ei[0]=1));break}if(ei[eo]+=ee,ei[eo]!=eD)break;ei[eo--]=0,ee=1}for(K=ei.length;0===ei[--K];)ei.pop()}return ey&&(F.e>es.maxE?(F.d=null,F.e=NaN):F.e<es.minE&&(F.e=0,F.d=[0])),F}function finiteToString(F,$,V){if(!F.isFinite())return nonFiniteToString(F);var G,H=F.e,K=digitsToString(F.d),Z=K.length;return $?(V&&(G=V-Z)>0?K=K.charAt(0)+"."+K.slice(1)+getZeroString(G):Z>1&&(K=K.charAt(0)+"."+K.slice(1)),K=K+(F.e<0?"e":"e+")+F.e):H<0?(K="0."+getZeroString(-H-1)+K,V&&(G=V-Z)>0&&(K+=getZeroString(G))):H>=Z?(K+=getZeroString(H+1-Z),V&&(G=V-H-1)>0&&(K=K+"."+getZeroString(G))):((G=H+1)<Z&&(K=K.slice(0,G)+"."+K.slice(G)),V&&(G=V-Z)>0&&(H+1===Z&&(K+="."),K+=getZeroString(G))),K}function getBase10Exponent(F,$){var V=F[0];for($*=eM;V>=10;V/=10)$++;return $}function getLn10(F,$,V){if($>eF)throw ey=!0,V&&(F.precision=V),Error(eS);return finalise(new F(ed),$,1,!0)}function getPi(F,$,V){if($>eO)throw Error(eS);return finalise(new F(em),$,V,!0)}function getPrecision(F){var $=F.length-1,V=$*eM+1;if($=F[$]){for(;$%10==0;$/=10)V--;for($=F[0];$>=10;$/=10)V++}return V}function getZeroString(F){for(var $="";F--;)$+="0";return $}function intPow(F,$,V,G){var H,K=new F(1),Z=Math.ceil(G/eM+4);for(ey=!1;;){if(V%2&&truncate((K=K.times($)).d,Z)&&(H=!0),0===(V=ek(V/2))){V=K.d.length-1,H&&0===K.d[V]&&++K.d[V];break}truncate(($=$.times($)).d,Z)}return ey=!0,K}function isOdd(F){return 1&F.d[F.d.length-1]}function maxOrMin(F,$,V){for(var G,H=new F($[0]),K=0;++K<$.length;)if((G=new F($[K])).s)H[V](G)&&(H=G);else{H=G;break}return H}function naturalExponential(F,$){var V,G,H,K,Z,ee,et,en=0,ea=0,ei=0,eo=F.constructor,es=eo.rounding,eu=eo.precision;if(!F.d||!F.d[0]||F.e>17)return new eo(F.d?F.d[0]?F.s<0?0:1/0:1:F.s?F.s<0?0:F:0/0);for(null==$?(ey=!1,et=eu):et=$,ee=new eo(.03125);F.e>-2;)F=F.times(ee),ei+=5;for(et+=G=Math.log(eI(2,ei))/Math.LN10*2+5|0,V=K=Z=new eo(1),eo.precision=et;;){if(K=finalise(K.times(F),et,1),V=V.times(++ea),digitsToString((ee=Z.plus(eB(K,V,et,1))).d).slice(0,et)===digitsToString(Z.d).slice(0,et)){for(H=ei;H--;)Z=finalise(Z.times(Z),et,1);if(null!=$)return eo.precision=eu,Z;if(!(en<3&&checkRoundingDigits(Z.d,et-G,es,en)))return finalise(Z,eo.precision=eu,es,ey=!0);eo.precision=et+=10,V=K=ee=new eo(1),ea=0,en++}Z=ee}}function naturalLogarithm(F,$){var V,G,H,K,Z,ee,et,en,ea,ei,eo,es=1,eu=10,ec=F,ep=ec.d,eh=ec.constructor,ef=eh.rounding,ed=eh.precision;if(ec.s<0||!ep||!ep[0]||!ec.e&&1==ep[0]&&1==ep.length)return new eh(ep&&!ep[0]?-1/0:1!=ec.s?NaN:ep?0:ec);if(null==$?(ey=!1,ea=ed):ea=$,eh.precision=ea+=eu,G=(V=digitsToString(ep)).charAt(0),!(15e14>Math.abs(K=ec.e)))return en=getLn10(eh,ea+2,ed).times(K+""),ec=naturalLogarithm(new eh(G+"."+V.slice(1)),ea-eu).plus(en),eh.precision=ed,null==$?finalise(ec,ed,ef,ey=!0):ec;for(;G<7&&1!=G||1==G&&V.charAt(1)>3;)G=(V=digitsToString((ec=ec.times(F)).d)).charAt(0),es++;for(K=ec.e,G>1?(ec=new eh("0."+V),K++):ec=new eh(G+"."+V.slice(1)),ei=ec,et=Z=ec=eB(ec.minus(1),ec.plus(1),ea,1),eo=finalise(ec.times(ec),ea,1),H=3;;){if(Z=finalise(Z.times(eo),ea,1),digitsToString((en=et.plus(eB(Z,new eh(H),ea,1))).d).slice(0,ea)===digitsToString(et.d).slice(0,ea)){if(et=et.times(2),0!==K&&(et=et.plus(getLn10(eh,ea+2,ed).times(K+""))),et=eB(et,new eh(es),ea,1),null!=$)return eh.precision=ed,et;if(!checkRoundingDigits(et.d,ea-eu,ef,ee))return finalise(et,eh.precision=ed,ef,ey=!0);eh.precision=ea+=eu,en=Z=ec=eB(ei.minus(1),ei.plus(1),ea,1),eo=finalise(ec.times(ec),ea,1),H=ee=1}et=en,H+=2}}function nonFiniteToString(F){return String(F.s*F.s/0)}function parseDecimal(F,$){var V,G,H;for((V=$.indexOf("."))>-1&&($=$.replace(".","")),(G=$.search(/e/i))>0?(V<0&&(V=G),V+=+$.slice(G+1),$=$.substring(0,G)):V<0&&(V=$.length),G=0;48===$.charCodeAt(G);G++);for(H=$.length;48===$.charCodeAt(H-1);--H);if($=$.slice(G,H)){if(H-=G,F.e=V=V-G-1,F.d=[],G=(V+1)%eM,V<0&&(G+=eM),G<H){for(G&&F.d.push(+$.slice(0,G)),H-=eM;G<H;)F.d.push(+$.slice(G,G+=eM));G=eM-($=$.slice(G)).length}else G-=H;for(;G--;)$+="0";F.d.push(+$),ey&&(F.e>F.constructor.maxE?(F.d=null,F.e=NaN):F.e<F.constructor.minE&&(F.e=0,F.d=[0]))}else F.e=0,F.d=[0];return F}function parseOther(F,$){var V,G,H,K,Z,ee,et,en,ea;if($.indexOf("_")>-1){if($=$.replace(/(\d)_(?=\d)/g,"$1"),eA.test($))return parseDecimal(F,$)}else if("Infinity"===$||"NaN"===$)return+$||(F.s=NaN),F.e=NaN,F.d=null,F;if(eC.test($))V=16,$=$.toLowerCase();else if(eT.test($))V=2;else if(eE.test($))V=8;else throw Error(ew+$);for((K=$.search(/p/i))>0?(et=+$.slice(K+1),$=$.substring(2,K)):$=$.slice(2),Z=(K=$.indexOf("."))>=0,G=F.constructor,Z&&(K=(ee=($=$.replace(".","")).length)-K,H=intPow(G,new G(V),K,2*K)),K=ea=(en=convertBase($,V,eD)).length-1;0===en[K];--K)en.pop();return K<0?new G(0*F.s):(F.e=getBase10Exponent(en,ea),F.d=en,ey=!1,Z&&(F=eB(F,H,4*ee)),et&&(F=F.times(54>Math.abs(et)?eI(2,et):e$.pow(2,et))),ey=!0,F)}function sine(F,$){var V,G=$.d.length;if(G<3)return $.isZero()?$:taylorSeries(F,2,$,$);V=(V=1.4*Math.sqrt(G))>16?16:0|V,$=taylorSeries(F,2,$=$.times(1/tinyPow(5,V)),$);for(var H,K=new F(5),Z=new F(16),ee=new F(20);V--;)H=$.times($),$=$.times(K.plus(H.times(Z.times(H).minus(ee))));return $}function taylorSeries(F,$,V,G,H){var K,Z,ee,et,en=F.precision,ea=Math.ceil(en/eM);for(ey=!1,et=V.times(V),ee=new F(G);;){if(Z=eB(ee.times(et),new F($++*$++),en,1),ee=H?G.plus(Z):G.minus(Z),G=eB(Z.times(et),new F($++*$++),en,1),void 0!==(Z=ee.plus(G)).d[ea]){for(K=ea;Z.d[K]===ee.d[K]&&K--;);if(-1==K)break}K=ee,ee=G,G=Z,Z=K}return ey=!0,Z.d.length=ea+1,Z}function tinyPow(F,$){for(var V=F;--$;)V*=F;return V}function toLessThanHalfPi(F,$){var V,G=$.s<0,H=getPi(F,F.precision,1),K=H.times(.5);if(($=$.abs()).lte(K))return ec=G?4:1,$;if((V=$.divToInt(H)).isZero())ec=G?3:2;else{if(($=$.minus(V.times(H))).lte(K))return ec=isOdd(V)?G?2:3:G?4:1,$;ec=isOdd(V)?G?1:4:G?3:2}return $.minus(H).abs()}function toStringBinary(F,$,V,G){var H,K,Z,ee,et,en,ea,ei,eo,es=F.constructor,ec=void 0!==V;if(ec?(checkInt32(V,1,eh),void 0===G?G=es.rounding:checkInt32(G,0,8)):(V=es.precision,G=es.rounding),F.isFinite()){for(Z=(ea=finiteToString(F)).indexOf("."),ec?(H=2,16==$?V=4*V-3:8==$&&(V=3*V-2)):H=$,Z>=0&&(ea=ea.replace(".",""),(eo=new es(1)).e=ea.length-Z,eo.d=convertBase(finiteToString(eo),10,H),eo.e=eo.d.length),K=et=(ei=convertBase(ea,10,H)).length;0==ei[--et];)ei.pop();if(ei[0]){if(Z<0?K--:((F=new es(F)).d=ei,F.e=K,ei=(F=eB(F,eo,V,G,0,H)).d,K=F.e,en=eu),Z=ei[V],ee=H/2,en=en||void 0!==ei[V+1],en=G<4?(void 0!==Z||en)&&(0===G||G===(F.s<0?3:2)):Z>ee||Z===ee&&(4===G||en||6===G&&1&ei[V-1]||G===(F.s<0?8:7)),ei.length=V,en)for(;++ei[--V]>H-1;)ei[V]=0,V||(++K,ei.unshift(1));for(et=ei.length;!ei[et-1];--et);for(Z=0,ea="";Z<et;Z++)ea+=ef.charAt(ei[Z]);if(ec){if(et>1){if(16==$||8==$){for(Z=16==$?4:3,--et;et%Z;et++)ea+="0";for(et=(ei=convertBase(ea,H,$)).length;!ei[et-1];--et);for(Z=1,ea="1.";Z<et;Z++)ea+=ef.charAt(ei[Z])}else ea=ea.charAt(0)+"."+ea.slice(1)}ea=ea+(K<0?"p":"p+")+K}else if(K<0){for(;++K;)ea="0"+ea;ea="0."+ea}else if(++K>et)for(K-=et;K--;)ea+="0";else K<et&&(ea=ea.slice(0,K)+"."+ea.slice(K))}else ea=ec?"0p+0":"0";ea=(16==$?"0x":2==$?"0b":8==$?"0o":"")+ea}else ea=nonFiniteToString(F);return F.s<0?"-"+ea:ea}function truncate(F,$){if(F.length>$)return F.length=$,!0}function abs(F){return new this(F).abs()}function acos(F){return new this(F).acos()}function acosh(F){return new this(F).acosh()}function add(F,$){return new this(F).plus($)}function asin(F){return new this(F).asin()}function asinh(F){return new this(F).asinh()}function atan(F){return new this(F).atan()}function atanh(F){return new this(F).atanh()}function atan2(F,$){F=new this(F),$=new this($);var V,G=this.precision,H=this.rounding,K=G+4;return F.s&&$.s?F.d||$.d?!$.d||F.isZero()?(V=$.s<0?getPi(this,G,H):new this(0)).s=F.s:!F.d||$.isZero()?(V=getPi(this,K,1).times(.5)).s=F.s:$.s<0?(this.precision=K,this.rounding=1,V=this.atan(eB(F,$,K,1)),$=getPi(this,K,1),this.precision=G,this.rounding=H,V=F.s<0?V.minus($):V.plus($)):V=this.atan(eB(F,$,K,1)):(V=getPi(this,K,1).times($.s>0?.25:.75)).s=F.s:V=new this(NaN),V}function cbrt(F){return new this(F).cbrt()}function ceil(F){return finalise(F=new this(F),F.e+1,2)}function clamp(F,$,V){return new this(F).clamp($,V)}function decimal_config(F){if(!F||"object"!=typeof F)throw Error(eb+"Object expected");var $,V,G,H=!0===F.defaults,K=["precision",1,eh,"rounding",0,8,"toExpNeg",-ep,0,"toExpPos",0,ep,"maxE",0,ep,"minE",-ep,0,"modulo",0,9];for($=0;$<K.length;$+=3)if(V=K[$],H&&(this[V]=eg[V]),void 0!==(G=F[V])){if(ek(G)===G&&G>=K[$+1]&&G<=K[$+2])this[V]=G;else throw Error(ew+V+": "+G)}if(V="crypto",H&&(this[V]=eg[V]),void 0!==(G=F[V])){if(!0===G||!1===G||0===G||1===G){if(G){if("undefined"!=typeof crypto&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[V]=!0;else throw Error(e_)}else this[V]=!1}else throw Error(ew+V+": "+G)}return this}function cos(F){return new this(F).cos()}function cosh(F){return new this(F).cosh()}function decimal_clone(F){var $,V,G;function Decimal(F){var $,V,G,H=this;if(!(H instanceof Decimal))return new Decimal(F);if(H.constructor=Decimal,isDecimalInstance(F)){H.s=F.s,ey?!F.d||F.e>Decimal.maxE?(H.e=NaN,H.d=null):F.e<Decimal.minE?(H.e=0,H.d=[0]):(H.e=F.e,H.d=F.d.slice()):(H.e=F.e,H.d=F.d?F.d.slice():F.d);return}if("number"==(G=typeof F)){if(0===F){H.s=1/F<0?-1:1,H.e=0,H.d=[0];return}if(F<0?(F=-F,H.s=-1):H.s=1,F===~~F&&F<1e7){for($=0,V=F;V>=10;V/=10)$++;ey?$>Decimal.maxE?(H.e=NaN,H.d=null):$<Decimal.minE?(H.e=0,H.d=[0]):(H.e=$,H.d=[F]):(H.e=$,H.d=[F]);return}if(0*F!=0){F||(H.s=NaN),H.e=NaN,H.d=null;return}return parseDecimal(H,F.toString())}if("string"!==G)throw Error(ew+F);return 45===(V=F.charCodeAt(0))?(F=F.slice(1),H.s=-1):(43===V&&(F=F.slice(1)),H.s=1),eA.test(F)?parseDecimal(H,F):parseOther(H,F)}if(Decimal.prototype=eP,Decimal.ROUND_UP=0,Decimal.ROUND_DOWN=1,Decimal.ROUND_CEIL=2,Decimal.ROUND_FLOOR=3,Decimal.ROUND_HALF_UP=4,Decimal.ROUND_HALF_DOWN=5,Decimal.ROUND_HALF_EVEN=6,Decimal.ROUND_HALF_CEIL=7,Decimal.ROUND_HALF_FLOOR=8,Decimal.EUCLID=9,Decimal.config=Decimal.set=decimal_config,Decimal.clone=decimal_clone,Decimal.isDecimal=isDecimalInstance,Decimal.abs=abs,Decimal.acos=acos,Decimal.acosh=acosh,Decimal.add=add,Decimal.asin=asin,Decimal.asinh=asinh,Decimal.atan=atan,Decimal.atanh=atanh,Decimal.atan2=atan2,Decimal.cbrt=cbrt,Decimal.ceil=ceil,Decimal.clamp=clamp,Decimal.cos=cos,Decimal.cosh=cosh,Decimal.div=div,Decimal.exp=exp,Decimal.floor=floor,Decimal.hypot=hypot,Decimal.ln=ln,Decimal.log=log,Decimal.log10=log10,Decimal.log2=log2,Decimal.max=max,Decimal.min=min,Decimal.mod=mod,Decimal.mul=mul,Decimal.pow=pow,Decimal.random=random,Decimal.round=round,Decimal.sign=sign,Decimal.sin=sin,Decimal.sinh=sinh,Decimal.sqrt=sqrt,Decimal.sub=sub,Decimal.sum=sum,Decimal.tan=tan,Decimal.tanh=tanh,Decimal.trunc=trunc,void 0===F&&(F={}),F&&!0!==F.defaults)for($=0,G=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"];$<G.length;)F.hasOwnProperty(V=G[$++])||(F[V]=this[V]);return Decimal.config(F),Decimal}function div(F,$){return new this(F).div($)}function exp(F){return new this(F).exp()}function floor(F){return finalise(F=new this(F),F.e+1,3)}function hypot(){var F,$,V=new this(0);for(F=0,ey=!1;F<arguments.length;)if($=new this(arguments[F++]),$.d)V.d&&(V=V.plus($.times($)));else{if($.s)return ey=!0,new this(1/0);V=$}return ey=!0,V.sqrt()}function isDecimalInstance(F){return F instanceof e$||F&&F.toStringTag===eN||!1}function ln(F){return new this(F).ln()}function log(F,$){return new this(F).log($)}function log2(F){return new this(F).log(2)}function log10(F){return new this(F).log(10)}function max(){return maxOrMin(this,arguments,"lt")}function min(){return maxOrMin(this,arguments,"gt")}function mod(F,$){return new this(F).mod($)}function mul(F,$){return new this(F).mul($)}function pow(F,$){return new this(F).pow($)}function random(F){var $,V,G,H,K=0,Z=new this(1),ee=[];if(void 0===F?F=this.precision:checkInt32(F,1,eh),G=Math.ceil(F/eM),this.crypto){if(crypto.getRandomValues)for($=crypto.getRandomValues(new Uint32Array(G));K<G;)(H=$[K])>=429e7?$[K]=crypto.getRandomValues(new Uint32Array(1))[0]:ee[K++]=H%1e7;else if(crypto.randomBytes){for($=crypto.randomBytes(G*=4);K<G;)(H=$[K]+($[K+1]<<8)+($[K+2]<<16)+((127&$[K+3])<<24))>=214e7?crypto.randomBytes(4).copy($,K):(ee.push(H%1e7),K+=4);K=G/4}else throw Error(e_)}else for(;K<G;)ee[K++]=1e7*Math.random()|0;for(G=ee[--K],F%=eM,G&&F&&(H=eI(10,eM-F),ee[K]=(G/H|0)*H);0===ee[K];K--)ee.pop();if(K<0)V=0,ee=[0];else{for(V=-1;0===ee[0];V-=eM)ee.shift();for(G=1,H=ee[0];H>=10;H/=10)G++;G<eM&&(V-=eM-G)}return Z.e=V,Z.d=ee,Z}function round(F){return finalise(F=new this(F),F.e+1,this.rounding)}function sign(F){return(F=new this(F)).d?F.d[0]?F.s:0*F.s:F.s||NaN}function sin(F){return new this(F).sin()}function sinh(F){return new this(F).sinh()}function sqrt(F){return new this(F).sqrt()}function sub(F,$){return new this(F).sub($)}function sum(){var F=0,$=arguments,V=new this($[F]);for(ey=!1;V.s&&++F<$.length;)V=V.plus($[F]);return ey=!0,finalise(V,this.precision,this.rounding)}function tan(F){return new this(F).tan()}function tanh(F){return new this(F).tanh()}function trunc(F){return finalise(F=new this(F),F.e+1,1)}eP[Symbol.for("nodejs.util.inspect.custom")]=eP.toString,eP[Symbol.toStringTag]="Decimal";var e$=eP.constructor=decimal_clone(eg);ed=new e$(ed),em=new e$(em);var eL=e$;function is_isNumber(F){return"number"==typeof F}function isBigNumber(F){return!!F&&"object"==typeof F&&"function"==typeof F.constructor&&(!0===F.isBigNumber&&"object"==typeof F.constructor.prototype&&!0===F.constructor.prototype.isBigNumber||"function"==typeof F.constructor.isDecimal&&!0===F.constructor.isDecimal(F))}function isComplex(F){return F&&"object"==typeof F&&!0===Object.getPrototypeOf(F).isComplex||!1}function isFraction(F){return F&&"object"==typeof F&&!0===Object.getPrototypeOf(F).isFraction||!1}function isUnit(F){return F&&!0===F.constructor.prototype.isUnit||!1}function is_isString(F){return"string"==typeof F}var ez=Array.isArray;function isMatrix(F){return F&&!0===F.constructor.prototype.isMatrix||!1}function isCollection(F){return Array.isArray(F)||isMatrix(F)}function isDenseMatrix(F){return F&&F.isDenseMatrix&&!0===F.constructor.prototype.isMatrix||!1}function isSparseMatrix(F){return F&&F.isSparseMatrix&&!0===F.constructor.prototype.isMatrix||!1}function isRange(F){return F&&!0===F.constructor.prototype.isRange||!1}function isIndex(F){return F&&!0===F.constructor.prototype.isIndex||!1}function is_isBoolean(F){return"boolean"==typeof F}function isResultSet(F){return F&&!0===F.constructor.prototype.isResultSet||!1}function isHelp(F){return F&&!0===F.constructor.prototype.isHelp||!1}function isFunction(F){return"function"==typeof F}function isDate(F){return F instanceof Date}function isRegExp(F){return F instanceof RegExp}function is_isObject(F){return!!(F&&"object"==typeof F&&F.constructor===Object&&!isComplex(F)&&!isFraction(F))}function isNull(F){return null===F}function isUndefined(F){return void 0===F}function isAccessorNode(F){return F&&!0===F.isAccessorNode&&!0===F.constructor.prototype.isNode||!1}function isArrayNode(F){return F&&!0===F.isArrayNode&&!0===F.constructor.prototype.isNode||!1}function isAssignmentNode(F){return F&&!0===F.isAssignmentNode&&!0===F.constructor.prototype.isNode||!1}function isBlockNode(F){return F&&!0===F.isBlockNode&&!0===F.constructor.prototype.isNode||!1}function isConditionalNode(F){return F&&!0===F.isConditionalNode&&!0===F.constructor.prototype.isNode||!1}function isConstantNode(F){return F&&!0===F.isConstantNode&&!0===F.constructor.prototype.isNode||!1}function isFunctionAssignmentNode(F){return F&&!0===F.isFunctionAssignmentNode&&!0===F.constructor.prototype.isNode||!1}function isFunctionNode(F){return F&&!0===F.isFunctionNode&&!0===F.constructor.prototype.isNode||!1}function isIndexNode(F){return F&&!0===F.isIndexNode&&!0===F.constructor.prototype.isNode||!1}function isNode(F){return F&&!0===F.isNode&&!0===F.constructor.prototype.isNode||!1}function isObjectNode(F){return F&&!0===F.isObjectNode&&!0===F.constructor.prototype.isNode||!1}function isOperatorNode(F){return F&&!0===F.isOperatorNode&&!0===F.constructor.prototype.isNode||!1}function isParenthesisNode(F){return F&&!0===F.isParenthesisNode&&!0===F.constructor.prototype.isNode||!1}function isRangeNode(F){return F&&!0===F.isRangeNode&&!0===F.constructor.prototype.isNode||!1}function isSymbolNode(F){return F&&!0===F.isSymbolNode&&!0===F.constructor.prototype.isNode||!1}function isChain(F){return F&&!0===F.constructor.prototype.isChain||!1}function typeOf(F){var $=typeof F;return"object"===$?null===F?"null":Array.isArray(F)?"Array":F instanceof Date?"Date":F instanceof RegExp?"RegExp":isBigNumber(F)?"BigNumber":isComplex(F)?"Complex":isFraction(F)?"Fraction":isMatrix(F)?"Matrix":isUnit(F)?"Unit":isIndex(F)?"Index":isRange(F)?"Range":isResultSet(F)?"ResultSet":isNode(F)?F.type:isChain(F)?"Chain":isHelp(F)?"Help":"Object":"function"===$?"Function":$}function object_clone(F){var $=typeof F;if("number"===$||"string"===$||"boolean"===$||null==F)return F;if("function"==typeof F.clone)return F.clone();if(Array.isArray(F))return F.map(function(F){return object_clone(F)});if(F instanceof Date)return new Date(F.valueOf());if(isBigNumber(F))return F;if(F instanceof RegExp)throw TypeError("Cannot clone "+F);return object_mapObject(F,object_clone)}function object_mapObject(F,$){var V={};for(var G in F)object_hasOwnProperty(F,G)&&(V[G]=$(F[G]));return V}function extend(F,$){for(var V in $)object_hasOwnProperty($,V)&&(F[V]=$[V]);return F}function deepStrictEqual(F,$){var V,G,H;if(Array.isArray(F)){if(!Array.isArray($)||F.length!==$.length)return!1;for(G=0,H=F.length;G<H;G++)if(!deepStrictEqual(F[G],$[G]))return!1;return!0}if("function"==typeof F||!(F instanceof Object))return F===$;if(Array.isArray($)||!($ instanceof Object))return!1;for(V in F)if(!(V in $)||!deepStrictEqual(F[V],$[V]))return!1;for(V in $)if(!(V in F))return!1;return!0}function object_hasOwnProperty(F,$){return F&&Object.hasOwnProperty.call(F,$)}function pickShallow(F,$){for(var V={},G=0;G<$.length;G++){var H=$[G],K=F[H];void 0!==K&&(V[H]=K)}return V}function factory_factory(F,$,V,G){function assertAndCreate(G){var H=pickShallow(G,$.map(stripOptionalNotation));return assertDependencies(F,$,G),V(H)}return assertAndCreate.isFactory=!0,assertAndCreate.fn=F,assertAndCreate.dependencies=$.slice().sort(),G&&(assertAndCreate.meta=G),assertAndCreate}function assertDependencies(F,$,V){if(!$.filter(F=>!isOptionalDependency(F)).every(F=>void 0!==V[F])){var G=$.filter(F=>void 0===V[F]);throw Error('Cannot create function "'.concat(F,'", ')+"some dependencies are missing: ".concat(G.map(F=>'"'.concat(F,'"')).join(", "),"."))}}function isOptionalDependency(F){return F&&"?"===F[0]}function stripOptionalNotation(F){return F&&"?"===F[0]?F.slice(1):F}var eV=factory_factory("BigNumber",["?on","config"],F=>{var{on:$,config:V}=F,G=eL.clone({precision:V.precision,modulo:eL.EUCLID});return G.prototype=Object.create(G.prototype),G.prototype.type="BigNumber",G.prototype.isBigNumber=!0,G.prototype.toJSON=function(){return{mathjs:"BigNumber",value:this.toString()}},G.fromJSON=function(F){return new G(F.value)},$&&$("config",function(F,$){F.precision!==$.precision&&G.config({precision:F.precision})}),G},{isClass:!0}),eU=V(61977);function isInteger(F){return"boolean"==typeof F||!!isFinite(F)&&F===Math.round(F)}var eW=Math.sign||function(F){return F>0?1:F<0?-1:0},ej=Math.log2||function(F){return Math.log(F)/Math.LN2},eG=Math.log10||function(F){return Math.log(F)/Math.LN10},eH=Math.cbrt||function(F){if(0===F)return F;var $,V=F<0;return V&&(F=-F),isFinite(F)?($=Math.exp(Math.log(F)/3),$=(F/($*$)+2*$)/3):$=F,V?-$:$},eX=Math.expm1||function(F){return F>=2e-4||F<=-.0002?Math.exp(F)-1:F+F*F/2+F*F*F/6};function formatNumberToBase(F,$,V){var G={2:"0b",8:"0o",16:"0x"}[$],H="";if(V){if(V<1)throw Error("size must be in greater than 0");if(!isInteger(V))throw Error("size must be an integer");if(F>2**(V-1)-1||F<-(2**(V-1)))throw Error("Value must be in range [-2^".concat(V-1,", 2^").concat(V-1,"-1]"));if(!isInteger(F))throw Error("Value must be an integer");F<0&&(F+=2**V),H="i".concat(V)}var K="";return F<0&&(F=-F,K="-"),"".concat(K).concat(G).concat(F.toString($)).concat(H)}function format(F,$){if("function"==typeof $)return $(F);if(F===1/0)return"Infinity";if(F===-1/0)return"-Infinity";if(isNaN(F))return"NaN";var V,G,H="auto";if($&&($.notation&&(H=$.notation),is_isNumber($)?V=$:is_isNumber($.precision)&&(V=$.precision),$.wordSize&&"number"!=typeof(G=$.wordSize)))throw Error('Option "wordSize" must be a number');switch(H){case"fixed":return toFixed(F,V);case"exponential":return toExponential(F,V);case"engineering":return toEngineering(F,V);case"bin":return formatNumberToBase(F,2,G);case"oct":return formatNumberToBase(F,8,G);case"hex":return formatNumberToBase(F,16,G);case"auto":return toPrecision(F,V,$&&$).replace(/((\.\d*?)(0+))($|e)/,function(){var F=arguments[2],$=arguments[4];return"."!==F?F+$:$});default:throw Error('Unknown notation "'+H+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function splitNumber(F){var $=String(F).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);if(!$)throw SyntaxError("Invalid number "+F);var V=$[1],G=$[2],H=parseFloat($[4]||"0"),K=G.indexOf(".");H+=-1!==K?K-1:G.length-1;var Z=G.replace(".","").replace(/^0*/,function(F){return H-=F.length,""}).replace(/0*$/,"").split("").map(function(F){return parseInt(F)});return 0===Z.length&&(Z.push(0),H++),{sign:V,coefficients:Z,exponent:H}}function toEngineering(F,$){if(isNaN(F)||!isFinite(F))return String(F);var V=roundDigits(splitNumber(F),$),G=V.exponent,H=V.coefficients,K=G%3==0?G:G<0?G-3-G%3:G-G%3;if(is_isNumber($))for(;$>H.length||G-K+1>H.length;)H.push(0);else for(var Z=Math.abs(G-K)-(H.length-1),ee=0;ee<Z;ee++)H.push(0);for(var et=Math.abs(G-K),en=1;et>0;)en++,et--;var ea=H.slice(en).join(""),ei=is_isNumber($)&&ea.length||ea.match(/[1-9]/)?"."+ea:"",eo=H.slice(0,en).join("")+ei+"e"+(G>=0?"+":"")+K.toString();return V.sign+eo}function toFixed(F,$){if(isNaN(F)||!isFinite(F))return String(F);var V=splitNumber(F),G="number"==typeof $?roundDigits(V,V.exponent+1+$):V,H=G.coefficients,K=G.exponent+1,Z=K+($||0);return H.length<Z&&(H=H.concat(number_zeros(Z-H.length))),K<0&&(H=number_zeros(-K+1).concat(H),K=1),K<H.length&&H.splice(K,0,0===K?"0.":"."),G.sign+H.join("")}function toExponential(F,$){if(isNaN(F)||!isFinite(F))return String(F);var V=splitNumber(F),G=$?roundDigits(V,$):V,H=G.coefficients,K=G.exponent;H.length<$&&(H=H.concat(number_zeros($-H.length)));var Z=H.shift();return G.sign+Z+(H.length>0?"."+H.join(""):"")+"e"+(K>=0?"+":"")+K}function toPrecision(F,$,V){if(isNaN(F)||!isFinite(F))return String(F);var G=V&&void 0!==V.lowerExp?V.lowerExp:-3,H=V&&void 0!==V.upperExp?V.upperExp:5,K=splitNumber(F),Z=$?roundDigits(K,$):K;if(Z.exponent<G||Z.exponent>=H)return toExponential(F,$);var ee=Z.coefficients,et=Z.exponent;ee.length<$&&(ee=ee.concat(number_zeros($-ee.length))),ee=ee.concat(number_zeros(et-ee.length+1+(ee.length<$?$-ee.length:0))),ee=number_zeros(-et).concat(ee);var en=et>0?et:0;return en<ee.length-1&&ee.splice(en+1,0,"."),Z.sign+ee.join("")}function roundDigits(F,$){for(var V={sign:F.sign,coefficients:F.coefficients,exponent:F.exponent},G=V.coefficients;$<=0;)G.unshift(0),V.exponent++,$++;if(G.length>$&&G.splice($,G.length-$)[0]>=5){var H=$-1;for(G[H]++;10===G[H];)G.pop(),0===H&&(G.unshift(0),V.exponent++,H++),H--,G[H]++}return V}function number_zeros(F){for(var $=[],V=0;V<F;V++)$.push(0);return $}function digits(F){return F.toExponential().replace(/e.*$/,"").replace(/^0\.?0*|\./,"").length}var eK=Number.EPSILON||2220446049250313e-31;function number_nearlyEqual(F,$,V){if(null==V)return F===$;if(F===$)return!0;if(isNaN(F)||isNaN($))return!1;if(isFinite(F)&&isFinite($)){var G=Math.abs(F-$);return G<eK||G<=Math.max(Math.abs(F),Math.abs($))*V}return!1}var eQ=Math.acosh||function(F){return Math.log(Math.sqrt(F*F-1)+F)},eZ=Math.asinh||function(F){return Math.log(Math.sqrt(F*F+1)+F)},eY=Math.atanh||function(F){return Math.log((1+F)/(1-F))/2},eJ=Math.sinh||function(F){return(Math.exp(F)-Math.exp(-F))/2},e1=factory_factory("Complex",[],()=>(eU.prototype.type="Complex",eU.prototype.isComplex=!0,eU.prototype.toJSON=function(){return{mathjs:"Complex",re:this.re,im:this.im}},eU.prototype.toPolar=function(){return{r:this.abs(),phi:this.arg()}},eU.prototype.format=function(F){var $=this.im,V=this.re,G=format(this.re,F),H=format(this.im,F),K=is_isNumber(F)?F:F?F.precision:null;if(null!==K){var Z=Math.pow(10,-K);Math.abs(V/$)<Z&&(V=0),Math.abs($/V)<Z&&($=0)}return 0===$?G:0===V?1===$?"i":-1===$?"-i":H+"i":$<0?-1===$?G+" - i":G+" - "+H.substring(1)+"i":1===$?G+" + i":G+" + "+H+"i"},eU.fromPolar=function(F){switch(arguments.length){case 1:var $=arguments[0];if("object"==typeof $)return eU($);throw TypeError("Input has to be an object with r and phi keys.");case 2:var V=arguments[0],G=arguments[1];if(is_isNumber(V)){if(isUnit(G)&&G.hasBase("ANGLE")&&(G=G.toNumber("rad")),is_isNumber(G))return new eU({r:V,phi:G});throw TypeError("Phi is not a number nor an angle unit.")}throw TypeError("Radius r is not a number.");default:throw SyntaxError("Wrong number of arguments in function fromPolar")}},eU.prototype.valueOf=eU.prototype.toString,eU.fromJSON=function(F){return new eU(F)},eU.compare=function(F,$){return F.re>$.re?1:F.re<$.re?-1:F.im>$.im?1:F.im<$.im?-1:0},eU),{isClass:!0}),e2="10.6.4";function lruQueue(F){var $=0,V=1,G=Object.create(null),H=Object.create(null),K=0,del=function(F){var Z=H[F];if(Z&&(delete G[Z],delete H[F],--$,V===Z)){if(!$){K=0,V=1;return}for(;!hasOwnProperty.call(G,++V););}};return F=Math.abs(F),{hit:function(Z){var ee=H[Z],et=++K;if(G[et]=Z,H[Z]=et,!ee){if(++$<=F)return;return del(Z=G[V]),Z}if(delete G[ee],V===ee)for(;!hasOwnProperty.call(G,++V););},delete:del,clear:function(){$=K=0,V=1,G=Object.create(null),H=Object.create(null)}}}function memoize(F){var{hasher:$,limit:V}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return V=null==V?Number.POSITIVE_INFINITY:V,$=null==$?JSON.stringify:$,function memoize(){"object"!=typeof memoize.cache&&(memoize.cache={values:new Map,lru:lruQueue(V||Number.POSITIVE_INFINITY)});for(var G=[],H=0;H<arguments.length;H++)G[H]=arguments[H];var K=$(G);if(memoize.cache.values.has(K))return memoize.cache.lru.hit(K),memoize.cache.values.get(K);var Z=F.apply(F,G);return memoize.cache.values.set(K,Z),memoize.cache.values.delete(memoize.cache.lru.hit(K)),Z}}function maxArgumentCount(F){return Object.keys(F.signatures||{}).reduce(function(F,$){return Math.max(F,($.match(/,/g)||[]).length+1)},-1)}memoize(function(F){return new F(1).exp()},{hasher}),memoize(function(F){return new F(1).plus(new F(5).sqrt()).div(2)},{hasher});var e3=memoize(function(F){return F.acos(-1)},{hasher}),e4=memoize(function(F){return e3(F).times(2)},{hasher});function hasher(F){return F[0].precision}var e6=2*Math.PI;function recreateFactory(F,$,V){return factory_factory(F,$,V,{recreateOnConfigChange:!0})}function numberFactory(F,$){return factory_factory(F,["config","BigNumber"],F=>{var{config:V,BigNumber:G}=F;return"BigNumber"===V.number?new G($):$})}numberFactory("fineStructure",.0072973525693),numberFactory("weakMixingAngle",.2229),numberFactory("efimovFactor",22.7),numberFactory("sackurTetrode",-1.16487052358);/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/var e5=2e3,e9={s:1,n:0,d:1};function fraction_assign(F,$){if(isNaN(F=parseInt(F,10)))throw InvalidParameter();return F*$}function newFraction(F,$){if(0===$)throw DivisionByZero();var V=Object.create(Fraction.prototype);V.s=F<0?-1:1;var G=gcd(F=F<0?-F:F,$);return V.n=F/G,V.d=$/G,V}function factorize(F){for(var $={},V=F,G=2,H=4;H<=V;){for(;V%G==0;)V/=G,$[G]=($[G]||0)+1;H+=1+2*G++}return V!==F?V>1&&($[V]=($[V]||0)+1):$[F]=($[F]||0)+1,$}var parse=function(F,$){var V,G=0,H=1,K=1,Z=0,ee=0,et=0,en=1,ea=1,ei=0,eo=1,es=1,eu=1,ec=1e7;if(null==F);else if(void 0!==$){if(K=(G=F)*(H=$),G%1!=0||H%1!=0)throw NonIntegerParameter()}else switch(typeof F){case"object":if("d"in F&&"n"in F)G=F.n,H=F.d,"s"in F&&(G*=F.s);else if(0 in F)G=F[0],1 in F&&(H=F[1]);else throw InvalidParameter();K=G*H;break;case"number":if(F<0&&(K=F,F=-F),F%1==0)G=F;else if(F>0){for(F>=1&&(ea=Math.pow(10,Math.floor(1+Math.log(F)/Math.LN10)),F/=ea);eo<=ec&&eu<=ec;){if(F===(V=(ei+es)/(eo+eu))){eo+eu<=ec?(G=ei+es,H=eo+eu):eu>eo?(G=es,H=eu):(G=ei,H=eo);break}F>V?(ei+=es,eo+=eu):(es+=ei,eu+=eo),eo>ec?(G=es,H=eu):(G=ei,H=eo)}G*=ea}else(isNaN(F)||isNaN($))&&(H=G=NaN);break;case"string":if(null===(eo=F.match(/\d+|./g)))throw InvalidParameter();if("-"===eo[ei]?(K=-1,ei++):"+"===eo[ei]&&ei++,eo.length===ei+1?ee=fraction_assign(eo[ei++],K):"."===eo[ei+1]||"."===eo[ei]?("."!==eo[ei]&&(Z=fraction_assign(eo[ei++],K)),(++ei+1===eo.length||"("===eo[ei+1]&&")"===eo[ei+3]||"'"===eo[ei+1]&&"'"===eo[ei+3])&&(ee=fraction_assign(eo[ei],K),en=Math.pow(10,eo[ei].length),ei++),("("===eo[ei]&&")"===eo[ei+2]||"'"===eo[ei]&&"'"===eo[ei+2])&&(et=fraction_assign(eo[ei+1],K),ea=Math.pow(10,eo[ei+1].length)-1,ei+=3)):"/"===eo[ei+1]||":"===eo[ei+1]?(ee=fraction_assign(eo[ei],K),en=fraction_assign(eo[ei+2],1),ei+=3):"/"===eo[ei+3]&&" "===eo[ei+1]&&(Z=fraction_assign(eo[ei],K),ee=fraction_assign(eo[ei+2],K),en=fraction_assign(eo[ei+4],1),ei+=5),eo.length<=ei){K=G=et+(H=en*ea)*Z+ea*ee;break}default:throw InvalidParameter()}if(0===H)throw DivisionByZero();e9.s=K<0?-1:1,e9.n=Math.abs(G),e9.d=Math.abs(H)};function modpow(F,$,V){for(var G=1;$>0;F=F*F%V,$>>=1)1&$&&(G=G*F%V);return G}function cycleLen(F,$){for(;$%2==0;$/=2);for(;$%5==0;$/=5);if(1===$)return 0;for(var V=10%$,G=1;1!==V;G++)if(V=10*V%$,G>e5)return 0;return G}function cycleStart(F,$,V){for(var G=1,H=modpow(10,V,$),K=0;K<300;K++){if(G===H)return K;G=10*G%$,H=10*H%$}return 0}function gcd(F,$){if(!F)return $;if(!$)return F;for(;;){if(!(F%=$))return $;if(!($%=F))return F}}function Fraction(F,$){if(parse(F,$),!(this instanceof Fraction))return newFraction(e9.s*e9.n,e9.d);F=gcd(e9.d,e9.n),this.s=e9.s,this.n=e9.n/F,this.d=e9.d/F}var DivisionByZero=function(){return Error("Division by Zero")},InvalidParameter=function(){return Error("Invalid argument")},NonIntegerParameter=function(){return Error("Parameters must be integer")};Fraction.prototype={s:1,n:0,d:1,abs:function(){return newFraction(this.n,this.d)},neg:function(){return newFraction(-this.s*this.n,this.d)},add:function(F,$){return parse(F,$),newFraction(this.s*this.n*e9.d+e9.s*this.d*e9.n,this.d*e9.d)},sub:function(F,$){return parse(F,$),newFraction(this.s*this.n*e9.d-e9.s*this.d*e9.n,this.d*e9.d)},mul:function(F,$){return parse(F,$),newFraction(this.s*e9.s*this.n*e9.n,this.d*e9.d)},div:function(F,$){return parse(F,$),newFraction(this.s*e9.s*this.n*e9.d,this.d*e9.n)},clone:function(){return newFraction(this.s*this.n,this.d)},mod:function(F,$){if(isNaN(this.n)||isNaN(this.d))return new Fraction(NaN);if(void 0===F)return newFraction(this.s*this.n%this.d,1);if(parse(F,$),0===e9.n&&0===this.d)throw DivisionByZero();return newFraction(this.s*(e9.d*this.n)%(e9.n*this.d),e9.d*this.d)},gcd:function(F,$){return parse(F,$),newFraction(gcd(e9.n,this.n)*gcd(e9.d,this.d),e9.d*this.d)},lcm:function(F,$){return(parse(F,$),0===e9.n&&0===this.n)?newFraction(0,1):newFraction(e9.n*this.n,gcd(e9.n,this.n)*gcd(e9.d,this.d))},ceil:function(F){return(F=Math.pow(10,F||0),isNaN(this.n)||isNaN(this.d))?new Fraction(NaN):newFraction(Math.ceil(F*this.s*this.n/this.d),F)},floor:function(F){return(F=Math.pow(10,F||0),isNaN(this.n)||isNaN(this.d))?new Fraction(NaN):newFraction(Math.floor(F*this.s*this.n/this.d),F)},round:function(F){return(F=Math.pow(10,F||0),isNaN(this.n)||isNaN(this.d))?new Fraction(NaN):newFraction(Math.round(F*this.s*this.n/this.d),F)},roundTo:function(F,$){return parse(F,$),newFraction(this.s*Math.round(this.n*e9.d/(this.d*e9.n))*e9.n,e9.d)},inverse:function(){return newFraction(this.s*this.d,this.n)},pow:function(F,$){if(parse(F,$),1===e9.d)return e9.s<0?newFraction(Math.pow(this.s*this.d,e9.n),Math.pow(this.n,e9.n)):newFraction(Math.pow(this.s*this.n,e9.n),Math.pow(this.d,e9.n));if(this.s<0)return null;var V=factorize(this.n),G=factorize(this.d),H=1,K=1;for(var Z in V)if("1"!==Z){if("0"===Z){H=0;break}if(V[Z]*=e9.n,V[Z]%e9.d!=0)return null;V[Z]/=e9.d,H*=Math.pow(Z,V[Z])}for(var Z in G)if("1"!==Z){if(G[Z]*=e9.n,G[Z]%e9.d!=0)return null;G[Z]/=e9.d,K*=Math.pow(Z,G[Z])}return e9.s<0?newFraction(K,H):newFraction(H,K)},equals:function(F,$){return parse(F,$),this.s*this.n*e9.d==e9.s*e9.n*this.d},compare:function(F,$){parse(F,$);var V=this.s*this.n*e9.d-e9.s*e9.n*this.d;return(0<V)-(V<0)},simplify:function(F){if(isNaN(this.n)||isNaN(this.d))return this;F=F||.001;for(var $=this.abs(),V=$.toContinued(),G=1;G<V.length;G++){for(var H=newFraction(V[G-1],1),K=G-2;K>=0;K--)H=H.inverse().add(V[K]);if(Math.abs(H.sub($).valueOf())<F)return H.mul(this.s)}return this},divisible:function(F,$){return parse(F,$),!(!(e9.n*this.d)||this.n*e9.d%(e9.n*this.d))},valueOf:function(){return this.s*this.n/this.d},toFraction:function(F){var $,V="",G=this.n,H=this.d;return this.s<0&&(V+="-"),1===H?V+=G:(F&&($=Math.floor(G/H))>0&&(V+=$+" ",G%=H),V+=G+"/"+H),V},toLatex:function(F){var $,V="",G=this.n,H=this.d;return this.s<0&&(V+="-"),1===H?V+=G:(F&&($=Math.floor(G/H))>0&&(V+=$,G%=H),V+="\\frac{"+G+"}{"+H+"}"),V},toContinued:function(){var F,$=this.n,V=this.d,G=[];if(isNaN($)||isNaN(V))return G;do G.push(Math.floor($/V)),F=$%V,$=V,V=F;while(1!==$);return G},toString:function(F){var $=this.n,V=this.d;if(isNaN($)||isNaN(V))return"NaN";F=F||15;var G=cycleLen($,V),H=cycleStart($,V,G),K=this.s<0?"-":"";if(K+=$/V|0,$%=V,($*=10)&&(K+="."),G){for(var Z=H;Z--;)K+=$/V|0,$%=V,$*=10;K+="(";for(var Z=G;Z--;)K+=$/V|0,$%=V,$*=10;K+=")"}else for(var Z=F;$&&Z--;)K+=$/V|0,$%=V,$*=10;return K}};var e8=factory_factory("Fraction",[],()=>(Fraction.prototype.type="Fraction",Fraction.prototype.isFraction=!0,Fraction.prototype.toJSON=function(){return{mathjs:"Fraction",n:this.s*this.n,d:this.d}},Fraction.fromJSON=function(F){return new Fraction(F)},Fraction),{isClass:!0}),e7=factory_factory("Matrix",[],()=>{function Matrix(){if(!(this instanceof Matrix))throw SyntaxError("Constructor must be called with the new operator")}return Matrix.prototype.type="Matrix",Matrix.prototype.isMatrix=!0,Matrix.prototype.storage=function(){throw Error("Cannot invoke storage on a Matrix interface")},Matrix.prototype.datatype=function(){throw Error("Cannot invoke datatype on a Matrix interface")},Matrix.prototype.create=function(F,$){throw Error("Cannot invoke create on a Matrix interface")},Matrix.prototype.subset=function(F,$,V){throw Error("Cannot invoke subset on a Matrix interface")},Matrix.prototype.get=function(F){throw Error("Cannot invoke get on a Matrix interface")},Matrix.prototype.set=function(F,$,V){throw Error("Cannot invoke set on a Matrix interface")},Matrix.prototype.resize=function(F,$){throw Error("Cannot invoke resize on a Matrix interface")},Matrix.prototype.reshape=function(F,$){throw Error("Cannot invoke reshape on a Matrix interface")},Matrix.prototype.clone=function(){throw Error("Cannot invoke clone on a Matrix interface")},Matrix.prototype.size=function(){throw Error("Cannot invoke size on a Matrix interface")},Matrix.prototype.map=function(F,$){throw Error("Cannot invoke map on a Matrix interface")},Matrix.prototype.forEach=function(F){throw Error("Cannot invoke forEach on a Matrix interface")},Matrix.prototype[Symbol.iterator]=function(){throw Error("Cannot iterate a Matrix interface")},Matrix.prototype.toArray=function(){throw Error("Cannot invoke toArray on a Matrix interface")},Matrix.prototype.valueOf=function(){throw Error("Cannot invoke valueOf on a Matrix interface")},Matrix.prototype.format=function(F){throw Error("Cannot invoke format on a Matrix interface")},Matrix.prototype.toString=function(){throw Error("Cannot invoke toString on a Matrix interface")},Matrix},{isClass:!0});function formatBigNumberToBase(F,$,V){var G=new F.constructor(2),H="";if(V){if(V<1)throw Error("size must be in greater than 0");if(!isInteger(V))throw Error("size must be an integer");if(F.greaterThan(G.pow(V-1).sub(1))||F.lessThan(G.pow(V-1).mul(-1)))throw Error("Value must be in range [-2^".concat(V-1,", 2^").concat(V-1,"-1]"));if(!F.isInteger())throw Error("Value must be an integer");F.lessThan(0)&&(F=F.add(G.pow(V))),H="i".concat(V)}switch($){case 2:return"".concat(F.toBinary()).concat(H);case 8:return"".concat(F.toOctal()).concat(H);case 16:return"".concat(F.toHexadecimal()).concat(H);default:throw Error("Base ".concat($," not supported "))}}function formatter_format(F,$){if("function"==typeof $)return $(F);if(!F.isFinite())return F.isNaN()?"NaN":F.gt(0)?"Infinity":"-Infinity";var V="auto";if(void 0!==$&&($.notation&&(V=$.notation),"number"==typeof $?G=$:$.precision&&(G=$.precision),$.wordSize&&"number"!=typeof(H=$.wordSize)))throw Error('Option "wordSize" must be a number');switch(V){case"fixed":return formatter_toFixed(F,G);case"exponential":return formatter_toExponential(F,G);case"engineering":return formatter_toEngineering(F,G);case"bin":return formatBigNumberToBase(F,2,H);case"oct":return formatBigNumberToBase(F,8,H);case"hex":return formatBigNumberToBase(F,16,H);case"auto":var G,H,K,Z=$&&void 0!==$.lowerExp?$.lowerExp:-3,ee=$&&void 0!==$.upperExp?$.upperExp:5;if(F.isZero())return"0";var et=F.toSignificantDigits(G),en=et.e;return(K=en>=Z&&en<ee?et.toFixed():formatter_toExponential(F,G)).replace(/((\.\d*?)(0+))($|e)/,function(){var F=arguments[2],$=arguments[4];return"."!==F?F+$:$});default:throw Error('Unknown notation "'+V+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function formatter_toEngineering(F,$){var V=F.e,G=V%3==0?V:V<0?V-3-V%3:V-V%3,H=F.mul(Math.pow(10,-G)),K=H.toPrecision($);return -1!==K.indexOf("e")&&(K=H.toString()),K+"e"+(V>=0?"+":"")+G.toString()}function formatter_toExponential(F,$){return void 0!==$?F.toExponential($-1):F.toExponential()}function formatter_toFixed(F,$){return F.toFixed($)}function endsWith(F,$){var V=F.length-$.length,G=F.length;return F.substring(V,G)===$}function string_format(F,$){var V=_format(F,$);return $&&"object"==typeof $&&"truncate"in $&&V.length>$.truncate?V.substring(0,$.truncate-3)+"...":V}function _format(F,$){return"number"==typeof F?format(F,$):isBigNumber(F)?formatter_format(F,$):looksLikeFraction(F)?$&&"decimal"===$.fraction?F.toString():F.s*F.n+"/"+F.d:Array.isArray(F)?formatArray(F,$):is_isString(F)?'"'+F+'"':"function"==typeof F?F.syntax?String(F.syntax):"function":F&&"object"==typeof F?"function"==typeof F.format?F.format($):F&&F.toString($)!==({}).toString()?F.toString($):"{"+Object.keys(F).map(V=>'"'+V+'": '+string_format(F[V],$)).join(", ")+"}":String(F)}function formatArray(F,$){if(!Array.isArray(F))return string_format(F,$);for(var V="[",G=F.length,H=0;H<G;H++)0!==H&&(V+=", "),V+=formatArray(F[H],$);return V+"]"}function looksLikeFraction(F){return F&&"object"==typeof F&&"number"==typeof F.s&&"number"==typeof F.n&&"number"==typeof F.d||!1}function compareText(F,$){if(!is_isString(F))throw TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: "+typeOf(F)+", index: 0)");if(!is_isString($))throw TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: "+typeOf($)+", index: 1)");return F===$?0:F>$?1:-1}function DimensionError(F,$,V){if(!(this instanceof DimensionError))throw SyntaxError("Constructor must be called with the new operator");this.actual=F,this.expected=$,this.relation=V,this.message="Dimension mismatch ("+(Array.isArray(F)?"["+F.join(", ")+"]":F)+" "+(this.relation||"!=")+" "+(Array.isArray($)?"["+$.join(", ")+"]":$)+")",this.stack=Error().stack}function IndexError(F,$,V){if(!(this instanceof IndexError))throw SyntaxError("Constructor must be called with the new operator");this.index=F,arguments.length<3?(this.min=0,this.max=$):(this.min=$,this.max=V),void 0!==this.min&&this.index<this.min?this.message="Index out of range ("+this.index+" < "+this.min+")":void 0!==this.max&&this.index>=this.max?this.message="Index out of range ("+this.index+" > "+(this.max-1)+")":this.message="Index out of range ("+this.index+")",this.stack=Error().stack}function arraySize(F){for(var $=[];Array.isArray(F);)$.push(F.length),F=F[0];return $}function _validate(F,$,V){var G,H=F.length;if(H!==$[V])throw new DimensionError(H,$[V]);if(V<$.length-1){var K=V+1;for(G=0;G<H;G++){if(!Array.isArray(F[G]))throw new DimensionError($.length-1,$.length,"<");_validate(F[G],$,K)}}else for(G=0;G<H;G++)if(Array.isArray(F[G]))throw new DimensionError($.length+1,$.length,">")}function validate(F,$){if(0===$.length){if(Array.isArray(F))throw new DimensionError(F.length,0)}else _validate(F,$,0)}function validateIndex(F,$){if(!is_isNumber(F)||!isInteger(F))throw TypeError("Index must be an integer (value: "+F+")");if(F<0||"number"==typeof $&&F>=$)throw new IndexError(F,$)}function array_resize(F,$,V){if(!Array.isArray(F)||!Array.isArray($))throw TypeError("Array expected");if(0===$.length)throw Error("Resizing to scalar is not supported");return $.forEach(function(F){if(!is_isNumber(F)||!isInteger(F)||F<0)throw TypeError("Invalid size, must contain positive integers (size: "+string_format($)+")")}),_resize(F,$,0,void 0!==V?V:0),F}function _resize(F,$,V,G){var H,K,Z=F.length,ee=$[V],et=Math.min(Z,ee);if(F.length=ee,V<$.length-1){var en=V+1;for(H=0;H<et;H++)Array.isArray(K=F[H])||(K=[K],F[H]=K),_resize(K,$,en,G);for(H=et;H<ee;H++)K=[],F[H]=K,_resize(K,$,en,G)}else{for(H=0;H<et;H++)for(;Array.isArray(F[H]);)F[H]=F[H][0];for(H=et;H<ee;H++)F[H]=G}}function reshape(F,$){var V=flatten(F),G=V.length;if(!Array.isArray(F)||!Array.isArray($))throw TypeError("Array expected");if(0===$.length)throw new DimensionError(0,G,"!=");var H=product($=processSizesWildcard($,G));if(G!==H)throw new DimensionError(H,G,"!=");try{return _reshape(V,$)}catch(F){if(F instanceof DimensionError)throw new DimensionError(H,G,"!=");throw F}}function processSizesWildcard(F,$){var V=product(F),G=F.slice(),H=-1,K=F.indexOf(H);if(F.indexOf(H,K+1)>=0)throw Error("More than one wildcard in sizes");var Z=$%V==0;if(K>=0){if(Z)G[K]=-$/V;else throw Error("Could not replace wildcard, since "+$+" is no multiple of "+-V)}return G}function product(F){return F.reduce((F,$)=>F*$,1)}function _reshape(F,$){for(var V,G=F,H=$.length-1;H>0;H--){var K=$[H];V=[];for(var Z=G.length/K,ee=0;ee<Z;ee++)V.push(G.slice(ee*K,(ee+1)*K));G=V}return G}function _squeeze(F,$,V){var G,H;if(V<$){var K=V+1;for(G=0,H=F.length;G<H;G++)F[G]=_squeeze(F[G],$,K)}else for(;Array.isArray(F);)F=F[0];return F}function unsqueeze(F,$,V,G){var H=G||arraySize(F);if(V)for(var K=0;K<V;K++)F=[F],H.unshift(1);for(F=_unsqueeze(F,$,0);H.length<$;)H.push(1);return F}function _unsqueeze(F,$,V){var G,H;if(Array.isArray(F)){var K=V+1;for(G=0,H=F.length;G<H;G++)F[G]=_unsqueeze(F[G],$,K)}else for(var Z=V;Z<$;Z++)F=[F];return F}function flatten(F){if(!Array.isArray(F))return F;var $=[];return F.forEach(function callback(F){Array.isArray(F)?F.forEach(callback):$.push(F)}),$}function forEach(F,$){Array.prototype.forEach.call(F,$)}function filter(F,$){if(1!==arraySize(F).length)throw Error("Only one dimensional matrices supported");return Array.prototype.filter.call(F,$)}function identify(F){if(!Array.isArray(F))throw TypeError("Array input expected");if(0===F.length)return F;var $=[],V=0;$[0]={value:F[0],identifier:0};for(var G=1;G<F.length;G++)F[G]===F[G-1]?V++:V=0,$.push({value:F[G],identifier:V});return $}function generalize(F){if(!Array.isArray(F))throw TypeError("Array input expected");if(0===F.length)return F;for(var $=[],V=0;V<F.length;V++)$.push(F[V].value);return $}function getArrayDataType(F,$){for(var V,G=0,H=0;H<F.length;H++){var K=F[H],Z=Array.isArray(K);if(0===H&&Z&&(G=K.length),Z&&K.length!==G)return;var ee=Z?getArrayDataType(K,$):$(K);if(void 0===V)V=ee;else if(V!==ee)return"mixed"}return V}DimensionError.prototype=RangeError(),DimensionError.prototype.constructor=RangeError,DimensionError.prototype.name="DimensionError",DimensionError.prototype.isDimensionError=!0,IndexError.prototype=RangeError(),IndexError.prototype.constructor=RangeError,IndexError.prototype.name="IndexError",IndexError.prototype.isIndexError=!0;var te=factory_factory("DenseMatrix",["Matrix"],F=>{var{Matrix:$}=F;function DenseMatrix(F,$){if(!(this instanceof DenseMatrix))throw SyntaxError("Constructor must be called with the new operator");if($&&!is_isString($))throw Error("Invalid datatype: "+$);if(isMatrix(F))"DenseMatrix"===F.type?(this._data=object_clone(F._data),this._size=object_clone(F._size)):(this._data=F.toArray(),this._size=F.size()),this._datatype=$||F._datatype;else if(F&&ez(F.data)&&ez(F.size))this._data=F.data,this._size=F.size,validate(this._data,this._size),this._datatype=$||F.datatype;else if(ez(F))this._data=preprocess(F),this._size=arraySize(this._data),validate(this._data,this._size),this._datatype=$;else if(F)throw TypeError("Unsupported type of data ("+typeOf(F)+")");else this._data=[],this._size=[0],this._datatype=$}function _get(F,$){if(!isIndex($))throw TypeError("Invalid index");if($.isScalar())return F.get($.min());var V=$.size();if(V.length!==F._size.length)throw new DimensionError(V.length,F._size.length);for(var G=$.min(),H=$.max(),K=0,Z=F._size.length;K<Z;K++)validateIndex(G[K],F._size[K]),validateIndex(H[K],F._size[K]);return new DenseMatrix(_getSubmatrix(F._data,$,V.length,0),F._datatype)}function _getSubmatrix(F,$,V,G){var H=G===V-1,K=$.dimension(G);return H?K.map(function($){return validateIndex($,F.length),F[$]}).valueOf():K.map(function(H){return validateIndex(H,F.length),_getSubmatrix(F[H],$,V,G+1)}).valueOf()}function _set(F,$,V,G){if(!$||!0!==$.isIndex)throw TypeError("Invalid index");var H,K=$.size(),Z=$.isScalar();if(isMatrix(V)?(H=V.size(),V=V.valueOf()):H=arraySize(V),Z){if(0!==H.length)throw TypeError("Scalar expected");F.set($.min(),V,G)}else{if(K.length<F._size.length)throw new DimensionError(K.length,F._size.length,"<");if(H.length<K.length){for(var ee=0,et=0;1===K[ee]&&1===H[ee];)ee++;for(;1===K[ee];)et++,ee++;V=unsqueeze(V,K.length,et,H)}if(!deepStrictEqual(K,H))throw new DimensionError(K,H,">");_fit(F,$.max().map(function(F){return F+1}),G);var en=K.length,ea=0;_setSubmatrix(F._data,$,V,en,ea)}return F}function _setSubmatrix(F,$,V,G,H){var K=H===G-1,Z=$.dimension(H);K?Z.forEach(function($,G){validateIndex($),F[$]=V[G[0]]}):Z.forEach(function(K,Z){validateIndex(K),_setSubmatrix(F[K],$,V[Z[0]],G,H+1)})}function _resize(F,$,V){if(0===$.length){for(var G=F._data;ez(G);)G=G[0];return G}return F._size=$.slice(0),F._data=array_resize(F._data,F._size,V),F}function _fit(F,$,V){for(var G=F._size.slice(0),H=!1;G.length<$.length;)G.push(0),H=!0;for(var K=0,Z=$.length;K<Z;K++)$[K]>G[K]&&(G[K]=$[K],H=!0);H&&_resize(F,G,V)}function preprocess(F){for(var $=0,V=F.length;$<V;$++){var G=F[$];ez(G)?F[$]=preprocess(G):G&&!0===G.isMatrix&&(F[$]=preprocess(G.valueOf()))}return F}return DenseMatrix.prototype=new $,DenseMatrix.prototype.createDenseMatrix=function(F,$){return new DenseMatrix(F,$)},DenseMatrix.prototype.type="DenseMatrix",DenseMatrix.prototype.isDenseMatrix=!0,DenseMatrix.prototype.getDataType=function(){return getArrayDataType(this._data,typeOf)},DenseMatrix.prototype.storage=function(){return"dense"},DenseMatrix.prototype.datatype=function(){return this._datatype},DenseMatrix.prototype.create=function(F,$){return new DenseMatrix(F,$)},DenseMatrix.prototype.subset=function(F,$,V){switch(arguments.length){case 1:return _get(this,F);case 2:case 3:return _set(this,F,$,V);default:throw SyntaxError("Wrong number of arguments")}},DenseMatrix.prototype.get=function(F){if(!ez(F))throw TypeError("Array expected");if(F.length!==this._size.length)throw new DimensionError(F.length,this._size.length);for(var $=0;$<F.length;$++)validateIndex(F[$],this._size[$]);for(var V=this._data,G=0,H=F.length;G<H;G++){var K=F[G];validateIndex(K,V.length),V=V[K]}return V},DenseMatrix.prototype.set=function(F,$,V){if(!ez(F))throw TypeError("Array expected");if(F.length<this._size.length)throw new DimensionError(F.length,this._size.length,"<");_fit(this,F.map(function(F){return F+1}),V);var G,H,K,Z=this._data;for(G=0,H=F.length-1;G<H;G++)validateIndex(K=F[G],Z.length),Z=Z[K];return validateIndex(K=F[F.length-1],Z.length),Z[K]=$,this},DenseMatrix.prototype.resize=function(F,$,V){if(!isCollection(F))throw TypeError("Array or Matrix expected");var G=F.valueOf().map(F=>Array.isArray(F)&&1===F.length?F[0]:F);return _resize(V?this.clone():this,G,$)},DenseMatrix.prototype.reshape=function(F,$){var V=$?this.clone():this;V._data=reshape(V._data,F);var G=V._size.reduce((F,$)=>F*$);return V._size=processSizesWildcard(F,G),V},DenseMatrix.prototype.clone=function(){return new DenseMatrix({data:object_clone(this._data),size:object_clone(this._size),datatype:this._datatype})},DenseMatrix.prototype.size=function(){return this._size.slice(0)},DenseMatrix.prototype.map=function(F){var $=this,V=function recurse(V,G){return ez(V)?V.map(function(F,$){return recurse(F,G.concat($))}):F(V,G,$)}(this._data,[]),G=void 0!==this._datatype?getArrayDataType(V,typeOf):void 0;return new DenseMatrix(V,G)},DenseMatrix.prototype.forEach=function(F){var $=this;(function recurse(V,G){ez(V)?V.forEach(function(F,$){recurse(F,G.concat($))}):F(V,G,$)})(this._data,[])},DenseMatrix.prototype[Symbol.iterator]=function*(){var recurse=function* recurse(F,$){if(ez(F))for(var V=0;V<F.length;V++)yield*recurse(F[V],$.concat(V));else yield{value:F,index:$}};yield*recurse(this._data,[])},DenseMatrix.prototype.rows=function(){var F=[];if(2!==this.size().length)throw TypeError("Rows can only be returned for a 2D matrix.");for(var $ of this._data)F.push(new DenseMatrix([$],this._datatype));return F},DenseMatrix.prototype.columns=function(){var F=this,$=[],V=this.size();if(2!==V.length)throw TypeError("Rows can only be returned for a 2D matrix.");for(var G=this._data,_loop=function(V){var H=G.map(F=>[F[V]]);$.push(new DenseMatrix(H,F._datatype))},H=0;H<V[1];H++)_loop(H);return $},DenseMatrix.prototype.toArray=function(){return object_clone(this._data)},DenseMatrix.prototype.valueOf=function(){return this._data},DenseMatrix.prototype.format=function(F){return string_format(this._data,F)},DenseMatrix.prototype.toString=function(){return string_format(this._data)},DenseMatrix.prototype.toJSON=function(){return{mathjs:"DenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},DenseMatrix.prototype.diagonal=function(F){if(F){if(isBigNumber(F)&&(F=F.toNumber()),!is_isNumber(F)||!isInteger(F))throw TypeError("The parameter k must be an integer number")}else F=0;for(var $=F>0?F:0,V=F<0?-F:0,G=Math.min(this._size[0]-V,this._size[1]-$),H=[],K=0;K<G;K++)H[K]=this._data[K+V][K+$];return new DenseMatrix({data:H,size:[G],datatype:this._datatype})},DenseMatrix.diagonal=function(F,$,V,G){if(!ez(F))throw TypeError("Array expected, size parameter");if(2!==F.length)throw Error("Only two dimensions matrix are supported");if(F=F.map(function(F){if(isBigNumber(F)&&(F=F.toNumber()),!is_isNumber(F)||!isInteger(F)||F<1)throw Error("Size values must be positive integers");return F}),V){if(isBigNumber(V)&&(V=V.toNumber()),!is_isNumber(V)||!isInteger(V))throw TypeError("The parameter k must be an integer number")}else V=0;var H,K=V>0?V:0,Z=V<0?-V:0,ee=F[0],et=F[1],en=Math.min(ee-Z,et-K);if(ez($)){if($.length!==en)throw Error("Invalid value array length");H=function(F){return $[F]}}else if(isMatrix($)){var ea=$.size();if(1!==ea.length||ea[0]!==en)throw Error("Invalid matrix length");H=function(F){return $.get([F])}}else H=function(){return $};G||(G=isBigNumber(H(0))?H(0).mul(0):0);var ei=[];if(F.length>0){ei=array_resize(ei,F,G);for(var eo=0;eo<en;eo++)ei[eo+Z][eo+K]=H(eo)}return new DenseMatrix({data:ei,size:[ee,et]})},DenseMatrix.fromJSON=function(F){return new DenseMatrix(F)},DenseMatrix.prototype.swapRows=function(F,$){if(!is_isNumber(F)||!isInteger(F)||!is_isNumber($)||!isInteger($))throw Error("Row index must be positive integers");if(2!==this._size.length)throw Error("Only two dimensional matrix is supported");return validateIndex(F,this._size[0]),validateIndex($,this._size[0]),DenseMatrix._swapRows(F,$,this._data),this},DenseMatrix._swapRows=function(F,$,V){var G=V[F];V[F]=V[$],V[$]=G},DenseMatrix},{isClass:!0}),tt=V(82287);function getSafeProperty(F,$){if(isPlainObject(F)&&isSafeProperty(F,$))return F[$];if("function"==typeof F[$]&&isSafeMethod(F,$))throw Error('Cannot access method "'+$+'" as a property');throw Error('No access to property "'+$+'"')}function customs_setSafeProperty(F,$,V){if(isPlainObject(F)&&isSafeProperty(F,$))return F[$]=V,V;throw Error('No access to property "'+$+'"')}function hasSafeProperty(F,$){return $ in F}function isSafeProperty(F,$){return!!F&&"object"==typeof F&&(!!object_hasOwnProperty(tr,$)||!($ in Object.prototype)&&!($ in Function.prototype))}function isSafeMethod(F,$){return!(null==F||"function"!=typeof F[$]||object_hasOwnProperty(F,$)&&Object.getPrototypeOf&&$ in Object.getPrototypeOf(F))&&(!!object_hasOwnProperty(tn,$)||!($ in Object.prototype)&&!($ in Function.prototype))}function isPlainObject(F){return"object"==typeof F&&F&&F.constructor===Object}var tr={length:!0,name:!0},tn={toString:!0,valueOf:!0,toLocaleString:!0};let ObjectWrappingMap=class ObjectWrappingMap{constructor(F){this.wrappedObject=F}keys(){return Object.keys(this.wrappedObject)}get(F){return getSafeProperty(this.wrappedObject,F)}set(F,$){return customs_setSafeProperty(this.wrappedObject,F,$),this}has(F){return hasSafeProperty(this.wrappedObject,F)}};function isMap(F){return!!F&&(F instanceof Map||F instanceof ObjectWrappingMap||"function"==typeof F.set&&"function"==typeof F.get&&"function"==typeof F.keys&&"function"==typeof F.has)}var _createTyped2=function(){return _createTyped2=tt.create,tt},ta=factory_factory("typed",["?BigNumber","?Complex","?DenseMatrix","?Fraction"],function(F){var{BigNumber:$,Complex:V,DenseMatrix:G,Fraction:H}=F,K=_createTyped2();return K.types=[{name:"number",test:is_isNumber},{name:"Complex",test:isComplex},{name:"BigNumber",test:isBigNumber},{name:"Fraction",test:isFraction},{name:"Unit",test:isUnit},{name:"string",test:is_isString},{name:"Chain",test:isChain},{name:"Array",test:ez},{name:"Matrix",test:isMatrix},{name:"DenseMatrix",test:isDenseMatrix},{name:"SparseMatrix",test:isSparseMatrix},{name:"Range",test:isRange},{name:"Index",test:isIndex},{name:"boolean",test:is_isBoolean},{name:"ResultSet",test:isResultSet},{name:"Help",test:isHelp},{name:"function",test:isFunction},{name:"Date",test:isDate},{name:"RegExp",test:isRegExp},{name:"null",test:isNull},{name:"undefined",test:isUndefined},{name:"AccessorNode",test:isAccessorNode},{name:"ArrayNode",test:isArrayNode},{name:"AssignmentNode",test:isAssignmentNode},{name:"BlockNode",test:isBlockNode},{name:"ConditionalNode",test:isConditionalNode},{name:"ConstantNode",test:isConstantNode},{name:"FunctionNode",test:isFunctionNode},{name:"FunctionAssignmentNode",test:isFunctionAssignmentNode},{name:"IndexNode",test:isIndexNode},{name:"Node",test:isNode},{name:"ObjectNode",test:isObjectNode},{name:"OperatorNode",test:isOperatorNode},{name:"ParenthesisNode",test:isParenthesisNode},{name:"RangeNode",test:isRangeNode},{name:"SymbolNode",test:isSymbolNode},{name:"Map",test:isMap},{name:"Object",test:is_isObject}],K.conversions=[{from:"number",to:"BigNumber",convert:function(F){if($||throwNoBignumber(F),digits(F)>15)throw TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: "+F+"). Use function bignumber(x) to convert to BigNumber.");return new $(F)}},{from:"number",to:"Complex",convert:function(F){return V||throwNoComplex(F),new V(F,0)}},{from:"number",to:"string",convert:function(F){return F+""}},{from:"BigNumber",to:"Complex",convert:function(F){return V||throwNoComplex(F),new V(F.toNumber(),0)}},{from:"Fraction",to:"BigNumber",convert:function(F){throw TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.")}},{from:"Fraction",to:"Complex",convert:function(F){return V||throwNoComplex(F),new V(F.valueOf(),0)}},{from:"number",to:"Fraction",convert:function(F){H||throwNoFraction(F);var $=new H(F);if($.valueOf()!==F)throw TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: "+F+"). Use function fraction(x) to convert to Fraction.");return $}},{from:"string",to:"number",convert:function(F){var $=Number(F);if(isNaN($))throw Error('Cannot convert "'+F+'" to a number');return $}},{from:"string",to:"BigNumber",convert:function(F){$||throwNoBignumber(F);try{return new $(F)}catch($){throw Error('Cannot convert "'+F+'" to BigNumber')}}},{from:"string",to:"Fraction",convert:function(F){H||throwNoFraction(F);try{return new H(F)}catch($){throw Error('Cannot convert "'+F+'" to Fraction')}}},{from:"string",to:"Complex",convert:function(F){V||throwNoComplex(F);try{return new V(F)}catch($){throw Error('Cannot convert "'+F+'" to Complex')}}},{from:"boolean",to:"number",convert:function(F){return+F}},{from:"boolean",to:"BigNumber",convert:function(F){return $||throwNoBignumber(F),new $(+F)}},{from:"boolean",to:"Fraction",convert:function(F){return H||throwNoFraction(F),new H(+F)}},{from:"boolean",to:"string",convert:function(F){return String(F)}},{from:"Array",to:"Matrix",convert:function(F){return G||throwNoMatrix(),new G(F)}},{from:"Matrix",to:"Array",convert:function(F){return F.valueOf()}}],K});function throwNoBignumber(F){throw Error("Cannot convert value ".concat(F," into a BigNumber: no class 'BigNumber' provided"))}function throwNoComplex(F){throw Error("Cannot convert value ".concat(F," into a Complex number: no class 'Complex' provided"))}function throwNoMatrix(){throw Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided")}function throwNoFraction(F){throw Error("Cannot convert value ".concat(F," into a Fraction, no class 'Fraction' provided."))}function _switch(F){var $,V,G=F.length,H=F[0].length,K=[];for(V=0;V<H;V++){var Z=[];for($=0;$<G;$++)Z.push(F[$][V]);K.push(Z)}return K}function containsCollections(F){for(var $=0;$<F.length;$++)if(isCollection(F[$]))return!0;return!1}function deepForEach(F,$){isMatrix(F)&&(F=F.valueOf());for(var V=0,G=F.length;V<G;V++){var H=F[V];Array.isArray(H)?deepForEach(H,$):$(H)}}function deepMap(F,$,V){return F&&"function"==typeof F.map?F.map(function(F){return deepMap(F,$,V)}):$(F)}function reduce(F,$,V){var G=Array.isArray(F)?arraySize(F):F.size();if($<0||$>=G.length)throw new IndexError($,G.length);return isMatrix(F)?F.create(_reduce(F.valueOf(),$,V)):_reduce(F,$,V)}function _reduce(F,$,V){var G,H,K,Z;if($<=0){if(Array.isArray(F[0])){for(G=0,Z=_switch(F),H=[];G<Z.length;G++)H[G]=_reduce(Z[G],$-1,V);return H}for(G=1,K=F[0];G<F.length;G++)K=V(K,F[G]);return K}for(G=0,H=[];G<F.length;G++)H[G]=_reduce(F[G],$-1,V);return H}function scatter(F,$,V,G,H,K,Z,ee,et,en,ea){var ei,eo,es,eu,ec=F._values,ep=F._index,eh=F._ptr;if(G)for(eo=eh[$],es=eh[$+1],ei=eo;ei<es;ei++)V[eu=ep[ei]]!==K?(V[eu]=K,Z.push(eu),en?(G[eu]=et?ee(ec[ei],ea):ee(ea,ec[ei]),H[eu]=K):G[eu]=ec[ei]):(G[eu]=et?ee(ec[ei],G[eu]):ee(G[eu],ec[ei]),H[eu]=K);else for(eo=eh[$],es=eh[$+1],ei=eo;ei<es;ei++)V[eu=ep[ei]]!==K?(V[eu]=K,Z.push(eu)):H[eu]=K}var ti="number",ts="number, number";function absNumber(F){return Math.abs(F)}function addNumber(F,$){return F+$}function multiplyNumber(F,$){return F*$}function unaryMinusNumber(F){return-F}function unaryPlusNumber(F){return F}function cbrtNumber(F){return eH(F)}function cubeNumber(F){return F*F*F}function expNumber(F){return Math.exp(F)}function expm1Number(F){return eX(F)}function gcdNumber(F,$){var V;if(!isInteger(F)||!isInteger($))throw Error("Parameters in function gcd must be integer numbers");for(;0!==$;)V=F%$,F=$,$=V;return F<0?-F:F}function lcmNumber(F,$){if(!isInteger(F)||!isInteger($))throw Error("Parameters in function lcm must be integer numbers");if(0===F||0===$)return 0;for(var V,G=F*$;0!==$;)$=F%(V=$),F=V;return Math.abs(G/F)}function logNumber(F,$){return $?Math.log(F)/Math.log($):Math.log(F)}function log10Number(F){return eG(F)}function log2Number(F){return ej(F)}function modNumber(F,$){if($>0)return F-$*Math.floor(F/$);if(0===$)return F;throw Error("Cannot calculate mod for a negative divisor")}function signNumber(F){return eW(F)}function squareNumber(F){return F*F}function xgcdNumber(F,$){var V,G,H,K=0,Z=1,ee=1,et=0;if(!isInteger(F)||!isInteger($))throw Error("Parameters in function xgcd must be integer numbers");for(;$;)G=Math.floor(F/$),H=F-G*$,V=K,K=Z-G*K,Z=V,V=ee,ee=et-G*ee,et=V,F=$,$=H;return F<0?[-F,-Z,-et]:[F,F?Z:0,et]}function powNumber(F,$){return F*F<1&&$===1/0||F*F>1&&$===-1/0?0:Math.pow(F,$)}function roundNumber(F){var $=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!isInteger($)||$<0||$>15)throw Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");return parseFloat(toFixed(F,$))}absNumber.signature=ti,addNumber.signature=ts,multiplyNumber.signature=ts,unaryMinusNumber.signature=ti,unaryPlusNumber.signature=ti,cbrtNumber.signature=ti,cubeNumber.signature=ti,expNumber.signature=ti,expm1Number.signature=ti,gcdNumber.signature=ts,lcmNumber.signature=ts,log10Number.signature=ti,log2Number.signature=ti,modNumber.signature=ts,signNumber.signature=ti,squareNumber.signature=ti,xgcdNumber.signature=ts,powNumber.signature=ts;var tu="unaryPlus",tl=(F=>{var{typed:$,config:V,BigNumber:G}=F;return $(tu,{number:unaryPlusNumber,Complex:function(F){return F},BigNumber:function(F){return F},Fraction:function(F){return F},Unit:function(F){return F.clone()},"Array | Matrix":function(F){return deepMap(F,this,!0)},"boolean | string":function(F){return"BigNumber"===V.number?new G(+F):+F}})},"abs"),tc=factory_factory(tl,["typed"],F=>{var{typed:$}=F;return $(tl,{number:absNumber,Complex:function(F){return F.abs()},BigNumber:function(F){return F.abs()},Fraction:function(F){return F.abs()},"Array | Matrix":function(F){return deepMap(F,this,!0)},Unit:function(F){return F.abs()}})}),th="number";function acotNumber(F){return Math.atan(1/F)}function acothNumber(F){return isFinite(F)?(Math.log((F+1)/F)+Math.log(F/(F-1)))/2:0}function acscNumber(F){return Math.asin(1/F)}function acschNumber(F){var $=1/F;return Math.log($+Math.sqrt($*$+1))}function asecNumber(F){return Math.acos(1/F)}function asechNumber(F){var $=1/F;return Math.log(Math.sqrt($*$-1)+$)}function asinhNumber(F){return eZ(F)}function atanhNumber(F){return eY(F)}function cotNumber(F){return 1/Math.tan(F)}function cothNumber(F){var $=Math.exp(2*F);return($+1)/($-1)}function cscNumber(F){return 1/Math.sin(F)}function cschNumber(F){return 0===F?Number.POSITIVE_INFINITY:Math.abs(2/(Math.exp(F)-Math.exp(-F)))*eW(F)}function secNumber(F){return 1/Math.cos(F)}function sechNumber(F){return 2/(Math.exp(F)+Math.exp(-F))}function sinhNumber(F){return eJ(F)}(function acoshNumber(F){return eQ(F)}).signature=th,acotNumber.signature=th,acothNumber.signature=th,acscNumber.signature=th,acschNumber.signature=th,asecNumber.signature=th,asechNumber.signature=th,asinhNumber.signature=th,atanhNumber.signature=th,cotNumber.signature=th,cothNumber.signature=th,cscNumber.signature=th,cschNumber.signature=th,secNumber.signature=th,sechNumber.signature=th,sinhNumber.signature=th;var td="addScalar",tm=factory_factory(td,["typed"],F=>{var{typed:$}=F;return $(td,{"number, number":addNumber,"Complex, Complex":function(F,$){return F.add($)},"BigNumber, BigNumber":function(F,$){return F.plus($)},"Fraction, Fraction":function(F,$){return F.add($)},"Unit, Unit":function(F,$){if(null===F.value||void 0===F.value)throw Error("Parameter x contains a unit with undefined value");if(null===$.value||void 0===$.value)throw Error("Parameter y contains a unit with undefined value");if(!F.equalBase($))throw Error("Units do not match");var V=F.clone();return V.value=this(V.value,$.value),V.fixPrefix=!1,V}})}),tg=factory_factory("atan",["typed"],F=>{var{typed:$}=F;return $("atan",{number:function(F){return Math.atan(F)},Complex:function(F){return F.atan()},BigNumber:function(F){return F.atan()},"Array | Matrix":function(F){return deepMap(F,this,!0)}})}),ty=factory_factory("bignumber",["typed","BigNumber"],F=>{var{typed:$,BigNumber:V}=F;return $("bignumber",{"":function(){return new V(0)},number:function(F){return new V(F+"")},string:function(F){var $=F.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);if($){var G=$[2],H=V($[1]),K=new V(2).pow(Number(G));if(H.gt(K.sub(1)))throw SyntaxError('String "'.concat(F,'" is out of range'));var Z=new V(2).pow(Number(G)-1);return H.gte(Z)?H.sub(K):H}return new V(F)},BigNumber:function(F){return F},Fraction:function(F){return new V(F.n).div(F.d).times(F.s)},null:function(F){return new V(0)},"Array | Matrix":function(F){return deepMap(F,this)}})});function bitNotBigNumber(F){if(F.isFinite()&&!F.isInteger())throw Error("Integer expected in function bitNot");var $=F.constructor,V=$.precision;$.config({precision:1e9});var G=F.plus(new $(1));return G.s=-G.s||null,$.config({precision:V}),G}function bitwise(F,$,V){var G,H,K,Z,ee,et=F.constructor,en=+(F.s<0),ea=+($.s<0);if(en){G=decCoefficientToBinaryString(bitNotBigNumber(F));for(var ei=0;ei<G.length;++ei)G[ei]^=1}else G=decCoefficientToBinaryString(F);if(ea){H=decCoefficientToBinaryString(bitNotBigNumber($));for(var eo=0;eo<H.length;++eo)H[eo]^=1}else H=decCoefficientToBinaryString($);G.length<=H.length?(K=G,Z=H,ee=en):(K=H,Z=G,ee=ea);var es=K.length,eu=Z.length,ec=1^V(en,ea),ep=new et(1^ec),eh=new et(1),ef=new et(2),ed=et.precision;for(et.config({precision:1e9});es>0;)V(K[--es],Z[--eu])===ec&&(ep=ep.plus(eh)),eh=eh.times(ef);for(;eu>0;)V(ee,Z[--eu])===ec&&(ep=ep.plus(eh)),eh=eh.times(ef);return et.config({precision:ed}),0===ec&&(ep.s=-ep.s),ep}function decCoefficientToBinaryString(F){for(var $=F.d,V=$[0]+"",G=1;G<$.length;++G){for(var H=$[G]+"",K=7-H.length;K--;)H="0"+H;V+=H}for(var Z=V.length;"0"===V.charAt(Z);)Z--;var ee=F.e,et=V.slice(0,Z+1||1),en=et.length;if(ee>0){if(++ee>en)for(ee-=en;ee--;)et+="0";else ee<en&&(et=et.slice(0,ee)+"."+et.slice(ee))}for(var ea=[0],ei=0;ei<et.length;){for(var eo=ea.length;eo--;)ea[eo]*=10;ea[0]+=parseInt(et.charAt(ei++));for(var es=0;es<ea.length;++es)ea[es]>1&&((null===ea[es+1]||void 0===ea[es+1])&&(ea[es+1]=0),ea[es+1]+=ea[es]>>1,ea[es]&=1)}return ea.reverse()}var tb="number",tv="number, number";function bitNotNumber(F){if(!isInteger(F))throw Error("Integer expected in function bitNot");return~F}function bitOrNumber(F,$){if(!isInteger(F)||!isInteger($))throw Error("Integers expected in function bitOr");return F|$}function bitXorNumber(F,$){if(!isInteger(F)||!isInteger($))throw Error("Integers expected in function bitXor");return F^$}function leftShiftNumber(F,$){if(!isInteger(F)||!isInteger($))throw Error("Integers expected in function leftShift");return F<<$}function rightArithShiftNumber(F,$){if(!isInteger(F)||!isInteger($))throw Error("Integers expected in function rightArithShift");return F>>$}function rightLogShiftNumber(F,$){if(!isInteger(F)||!isInteger($))throw Error("Integers expected in function rightLogShift");return F>>>$}(function bitAndNumber(F,$){if(!isInteger(F)||!isInteger($))throw Error("Integers expected in function bitAnd");return F&$}).signature=tv,bitNotNumber.signature=tb,bitOrNumber.signature=tv,bitXorNumber.signature=tv,leftShiftNumber.signature=tv,rightArithShiftNumber.signature=tv,rightLogShiftNumber.signature=tv;var tw="clone";function product_product(F,$){if($<F)return 1;if($===F)return $;var V=$+F>>1;return product_product(F,V)*product_product(V+1,$)}function combinationsNumber(F,$){if(!isInteger(F)||F<0||!isInteger($)||$<0)throw TypeError("Positive integer value expected in function combinations");if($>F)throw TypeError("k must be less than or equal to n");for(var V=F-$,G=1,H=$<V?V+1:$+1,K=2,Z=$<V?$:V,ee=H;ee<=F;++ee)for(G*=ee;K<=Z&&G%K==0;)G/=K,++K;return K<=Z&&(G/=product_product(K,Z)),G}F=>{var{typed:$}=F;return $(tw,{any:object_clone})},combinationsNumber.signature="number, number";var tS="combinations";function isPositiveInteger(F){return F.isInteger()&&F.gte(0)}F=>{var{typed:$}=F;return $(tS,{"number, number":combinationsNumber,"BigNumber, BigNumber":function(F,$){var V,G,H=F.constructor,K=F.minus($),Z=new H(1);if(!isPositiveInteger(F)||!isPositiveInteger($))throw TypeError("Positive integer value expected in function combinations");if($.gt(F))throw TypeError("k must be less than n in function combinations");if(V=Z,$.lt(K))for(G=Z;G.lte(K);G=G.plus(Z))V=V.times($.plus(G)).dividedBy(G);else for(G=Z;G.lte($);G=G.plus(Z))V=V.times(K.plus(G)).dividedBy(G);return V}})};var t_=factory_factory("complex",["typed","Complex"],F=>{var{typed:$,Complex:V}=F;return $("complex",{"":function(){return V.ZERO},number:function(F){return new V(F,0)},"number, number":function(F,$){return new V(F,$)},"BigNumber, BigNumber":function(F,$){return new V(F.toNumber(),$.toNumber())},Fraction:function(F){return new V(F.valueOf(),0)},Complex:function(F){return F.clone()},string:function(F){return V(F)},null:function(F){return V(0)},Object:function(F){if("re"in F&&"im"in F)return new V(F.re,F.im);if("r"in F&&"phi"in F||"abs"in F&&"arg"in F)return new V(F);throw Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)")},"Array | Matrix":function(F){return deepMap(F,this)}})}),tN="conj",tk=factory_factory(tN,["typed"],F=>{var{typed:$}=F;return $(tN,{number:function(F){return F},BigNumber:function(F){return F},Complex:function(F){return F.conjugate()},"Array | Matrix":function(F){return deepMap(F,this)}})});function nearlyEqual_nearlyEqual(F,$,V){if(null==V)return F.eq($);if(F.eq($))return!0;if(F.isNaN()||$.isNaN())return!1;if(F.isFinite()&&$.isFinite()){var G=F.minus($).abs();if(G.isZero())return!0;var H=F.constructor.max(F.abs(),$.abs());return G.lte(H.times(V))}return!1}function complexEquals(F,$,V){return number_nearlyEqual(F.re,$.re,V)&&number_nearlyEqual(F.im,$.im,V)}var tI="equalScalar",tT=factory_factory(tI,["typed","config"],F=>{var{typed:$,config:V}=F;return $(tI,{"boolean, boolean":function(F,$){return F===$},"number, number":function(F,$){return number_nearlyEqual(F,$,V.epsilon)},"BigNumber, BigNumber":function(F,$){return F.eq($)||nearlyEqual_nearlyEqual(F,$,V.epsilon)},"Fraction, Fraction":function(F,$){return F.equals($)},"Complex, Complex":function(F,$){return complexEquals(F,$,V.epsilon)},"Unit, Unit":function(F,$){if(!F.equalBase($))throw Error("Cannot compare units with different base");return this(F.value,$.value)}})});factory_factory(tI,["typed","config"],F=>{var{typed:$,config:V}=F;return $(tI,{"number, number":function(F,$){return number_nearlyEqual(F,$,V.epsilon)}})}),F=>{var{typed:$}=F;return $("name",{number:function(F){var $=Math.abs(F);return $>=tM?eW(F):$<=tC?eW(F)*erf1($):$<=4?eW(F)*(1-erfc2($)):eW(F)*(1-erfc3($))},"Array | Matrix":function(F){return deepMap(F,this)}});function erf1(F){var $,V=F*F,G=tA[0][4]*V,H=V;for($=0;$<3;$+=1)G=(G+tA[0][$])*V,H=(H+tD[0][$])*V;return F*(G+tA[0][3])/(H+tD[0][3])}function erfc2(F){var $,V=tA[1][8]*F,G=F;for($=0;$<7;$+=1)V=(V+tA[1][$])*F,G=(G+tD[1][$])*F;var H=(V+tA[1][7])/(G+tD[1][7]),K=parseInt(16*F)/16,Z=(F-K)*(F+K);return Math.exp(-K*K)*Math.exp(-Z)*H}function erfc3(F){var $,V=1/(F*F),G=tA[2][5]*V,H=V;for($=0;$<4;$+=1)G=(G+tA[2][$])*V,H=(H+tD[2][$])*V;var K=V*(G+tA[2][4])/(H+tD[2][4]);K=(tE-K)/F,V=parseInt(16*F)/16;var Z=(F-V)*(F+V);return Math.exp(-V*V)*Math.exp(-Z)*K}};var tC=.46875,tE=.5641895835477563,tA=[[3.1611237438705655,113.86415415105016,377.485237685302,3209.3775891384694,.18577770618460315],[.5641884969886701,8.883149794388377,66.11919063714163,298.6351381974001,881.952221241769,1712.0476126340707,2051.0783778260716,1230.3393547979972,21531153547440383e-24],[.30532663496123236,.36034489994980445,.12578172611122926,.016083785148742275,6587491615298378e-19,.016315387137302097]],tD=[[23.601290952344122,244.02463793444417,1282.6165260773723,2844.236833439171],[15.744926110709835,117.6939508913125,537.1811018620099,1621.3895745666903,3290.7992357334597,4362.619090143247,3439.3676741437216,1230.3393548037495],[2.568520192289822,1.8729528499234604,.5279051029514285,.06051834131244132,.0023352049762686918]],tM=9007199254740992,tR="exp";F=>{var{typed:$}=F;return $(tR,{number:expNumber,Complex:function(F){return F.exp()},BigNumber:function(F){return F.exp()},"Array | Matrix":function(F){return deepMap(F,this)}})};var tF="format",tO=(F=>{var{typed:$}=F;return $(tF,{any:string_format,"any, Object | function | number":string_format})},"hex");factory_factory(tO,["typed","format"],F=>{var{typed:$,format:V}=F;return $(tO,{"number | BigNumber":function(F){return V(F,{notation:"hex"})},"number | BigNumber, number":function(F,$){return V(F,{notation:"hex",wordSize:$})}})});var tP="im",tB=factory_factory(tP,["typed"],F=>{var{typed:$}=F;return $(tP,{number:function(F){return 0},BigNumber:function(F){return F.mul(0)},Fraction:function(F){return F.mul(0)},Complex:function(F){return F.im},"Array | Matrix":function(F){return deepMap(F,this)}})}),t$="isInteger",tL=factory_factory(t$,["typed"],F=>{var{typed:$}=F;return $(t$,{number:isInteger,BigNumber:function(F){return F.isInt()},Fraction:function(F){return 1===F.d&&isFinite(F.n)},"Array | Matrix":function(F){return deepMap(F,this)}})}),tz="number";function isNegativeNumber(F){return F<0}function isPositiveNumber(F){return F>0}function isZeroNumber(F){return 0===F}function isNaNNumber(F){return Number.isNaN(F)}isNegativeNumber.signature=tz,isPositiveNumber.signature=tz,isZeroNumber.signature=tz,isNaNNumber.signature=tz;var tV="isNegative",tU=(F=>{var{typed:$}=F;return $(tV,{number:isNegativeNumber,BigNumber:function(F){return F.isNeg()&&!F.isZero()&&!F.isNaN()},Fraction:function(F){return F.s<0},Unit:function(F){return this(F.value)},"Array | Matrix":function(F){return deepMap(F,this)}})},"isPositive"),tW=(F=>{var{typed:$}=F;return $(tU,{number:isPositiveNumber,BigNumber:function(F){return!F.isNeg()&&!F.isZero()&&!F.isNaN()},Fraction:function(F){return F.s>0&&F.n>0},Unit:function(F){return this(F.value)},"Array | Matrix":function(F){return deepMap(F,this)}})},"isZero"),tj=factory_factory(tW,["typed"],F=>{var{typed:$}=F;return $(tW,{number:isZeroNumber,BigNumber:function(F){return F.isZero()},Complex:function(F){return 0===F.re&&0===F.im},Fraction:function(F){return 1===F.d&&0===F.n},Unit:function(F){return this(F.value)},"Array | Matrix":function(F){return deepMap(F,this)}})});function gammaNumber(F){if(isInteger(F))return F<=0?isFinite(F)?1/0:NaN:F>171?1/0:product_product(1,F-1);if(F<.5)return Math.PI/(Math.sin(Math.PI*F)*gammaNumber(1-F));if(F>=171.35)return 1/0;if(F>85){var $,V=F*F,G=V*F,H=G*F,K=H*F;return Math.sqrt(2*Math.PI/F)*Math.pow(F/Math.E,F)*(1+1/(12*F)+1/(288*V)-139/(51840*G)-571/(2488320*H)+163879/(209018880*K)+5246819/(75246796800*K*F))}--F,$=tq[0];for(var Z=1;Z<tq.length;++Z)$+=tq[Z]/(F+Z);var ee=F+tG+.5;return Math.sqrt(2*Math.PI)*Math.pow(ee,F+.5)*Math.exp(-ee)*$}gammaNumber.signature="number";var tG=4.7421875,tq=[.9999999999999971,57.15623566586292,-59.59796035547549,14.136097974741746,-.4919138160976202,3399464998481189e-20,4652362892704858e-20,-.00009837447530487956,1580887032249125e-19,-.00021026444172410488,21743961811521265e-20,-.0001643181065367639,8441822398385275e-20,-.000026190838401581408,36899182659531625e-22],tH=.9189385332046728,tX=5,tK=7,tQ=[1.000000000190015,76.18009172947146,-86.50532032941678,24.01409824083091,-1.231739572450155,.001208650973866179,-.000005395239384953];function lgammaNumber(F){if(F<0)return NaN;if(0===F)return 1/0;if(!isFinite(F))return F;if(F<.5)return Math.log(Math.PI/Math.sin(Math.PI*F))-lgammaNumber(1-F);for(var $=(F-=1)+tX+.5,V=tQ[0],G=tK-1;G>=1;G--)V+=tQ[G]/(F+G);return tH+(F+.5)*Math.log($)-$+Math.log(V)}lgammaNumber.signature="number";var tZ="map";function _map(F,$){var V=maxArgumentCount($);return function recurse(G,H){if(Array.isArray(G))return G.map(function(F,$){return recurse(F,H.concat($))});try{if(1===V)return $(G);if(2===V)return $(G,H);return $(G,H,F)}catch($){if($ instanceof TypeError&&"data"in $&&"wrongType"===$.data.category){var K="map attempted to call '".concat($.data.fn,"(").concat(G),Z=JSON.stringify(H);throw 2===V?K+=","+Z:1!==V&&(K+=",".concat(Z,",").concat(F)),TypeError(K+=")' but argument ".concat($.data.index+1," of type ")+"".concat($.data.actual," does not match expected type ")+$.data.expected.join(" or "))}throw $}}(F,[])}var tY=factory_factory("multiplyScalar",["typed"],F=>{var{typed:$}=F;return $("multiplyScalar",{"number, number":multiplyNumber,"Complex, Complex":function(F,$){return F.mul($)},"BigNumber, BigNumber":function(F,$){return F.times($)},"Fraction, Fraction":function(F,$){return F.mul($)},"number | Fraction | BigNumber | Complex, Unit":function(F,$){var V=$.clone();return V.value=null===V.value?V._normalize(F):this(V.value,F),V},"Unit, number | Fraction | BigNumber | Complex":function(F,$){var V=F.clone();return V.value=null===V.value?V._normalize($):this(V.value,$),V},"Unit, Unit":function(F,$){return F.multiply($)}})}),tJ="number",t4="number, number";function notNumber(F){return!F}function orNumber(F,$){return!!(F||$)}function xorNumber(F,$){return!!F!=!!$}function andNumber(F,$){return!!(F&&$)}notNumber.signature=tJ,orNumber.signature=t4,xorNumber.signature=t4,andNumber.signature=t4;var t6="not";function getNonDecimalNumberParts(F){var $=F.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);return $?{input:F,radix:({"0b":2,"0o":8,"0x":16})[$[1]],integerPart:$[2],fractionalPart:$[3]}:null}function makeNumberFromNonDecimalParts(F){for(var $=parseInt(F.integerPart,F.radix),V=0,G=0;G<F.fractionalPart.length;G++)V+=parseInt(F.fractionalPart[G],F.radix)/Math.pow(F.radix,G+1);var H=$+V;if(isNaN(H))throw SyntaxError('String "'+F.input+'" is no valid number');return H}var t5=factory_factory("number",["typed"],F=>{var{typed:$}=F,V=$("number",{"":function(){return 0},number:function(F){return F},string:function(F){if("NaN"===F)return NaN;var $=getNonDecimalNumberParts(F);if($)return makeNumberFromNonDecimalParts($);var V=0,G=F.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);G&&(V=Number(G[2]),F=G[1]);var H=Number(F);if(isNaN(H))throw SyntaxError('String "'+F+'" is no valid number');if(G){if(H>2**V-1)throw SyntaxError('String "'.concat(F,'" is out of range'));H>=2**(V-1)&&(H-=2**V)}return H},BigNumber:function(F){return F.toNumber()},Fraction:function(F){return F.valueOf()},Unit:function(F){throw Error("Second argument with valueless unit expected")},null:function(F){return 0},"Unit, string | Unit":function(F,$){return F.toNumber($)},"Array | Matrix":function(F){return deepMap(F,this)}});return V.fromJSON=function(F){return parseFloat(F.value)},V}),t9="oct";factory_factory(t9,["typed","format"],F=>{var{typed:$,format:V}=F;return $(t9,{"number | BigNumber":function(F){return V(F,{notation:"oct"})},"number | BigNumber, number":function(F,$){return V(F,{notation:"oct",wordSize:$})}})});var t8=V(36377),t7=t8(Date.now()),rt="re",rr=factory_factory(rt,["typed"],F=>{var{typed:$}=F;return $(rt,{number:function(F){return F},BigNumber:function(F){return F},Fraction:function(F){return F},Complex:function(F){return F.re},"Array | Matrix":function(F){return deepMap(F,this)}})}),rn="sign",ra=factory_factory(rn,["typed","BigNumber","Fraction","complex"],F=>{var{typed:$,BigNumber:V,complex:G,Fraction:H}=F;return $(rn,{number:signNumber,Complex:function(F){return 0===F.im?G(signNumber(F.re)):F.sign()},BigNumber:function(F){return new V(F.cmp(0))},Fraction:function(F){return new H(F.s,1)},"Array | Matrix":function(F){return deepMap(F,this,!0)},Unit:function(F){if(!F._isDerived()&&0!==F.units[0].unit.offset)throw TypeError("sign is ambiguous for units with offset");return this(F.value)}})}),ro="sin",rs=factory_factory(ro,["typed"],F=>{var{typed:$}=F;return $(ro,{number:Math.sin,Complex:function(F){return F.sin()},BigNumber:function(F){return F.sin()},Unit:function(F){if(!F.hasBase(F.constructor.BASE_UNITS.ANGLE))throw TypeError("Unit in function sin is no angle");return this(F.value)},"Array | Matrix":function(F){return deepMap(F,this,!0)}})}),ru=factory_factory("SparseMatrix",["typed","equalScalar","Matrix"],F=>{var{typed:$,equalScalar:V,Matrix:G}=F;function SparseMatrix(F,$){if(!(this instanceof SparseMatrix))throw SyntaxError("Constructor must be called with the new operator");if($&&!is_isString($))throw Error("Invalid datatype: "+$);if(isMatrix(F))_createFromMatrix(this,F,$);else if(F&&ez(F.index)&&ez(F.ptr)&&ez(F.size))this._values=F.values,this._index=F.index,this._ptr=F.ptr,this._size=F.size,this._datatype=$||F.datatype;else if(ez(F))_createFromArray(this,F,$);else if(F)throw TypeError("Unsupported type of data ("+typeOf(F)+")");else this._values=[],this._index=[],this._ptr=[0],this._size=[0,0],this._datatype=$}function _createFromMatrix(F,$,V){"SparseMatrix"===$.type?(F._values=$._values?object_clone($._values):void 0,F._index=object_clone($._index),F._ptr=object_clone($._ptr),F._size=object_clone($._size),F._datatype=V||$._datatype):_createFromArray(F,$.valueOf(),V||$._datatype)}function _createFromArray(F,G,H){F._values=[],F._index=[],F._ptr=[],F._datatype=H;var K=G.length,Z=0,ee=V,et=0;if(is_isString(H)&&(ee=$.find(V,[H,H])||V,et=$.convert(0,H)),K>0){var en=0;do{F._ptr.push(F._index.length);for(var ea=0;ea<K;ea++){var ei=G[ea];if(ez(ei)){if(0===en&&Z<ei.length&&(Z=ei.length),en<ei.length){var eo=ei[en];ee(eo,et)||(F._values.push(eo),F._index.push(ea))}}else 0===en&&Z<1&&(Z=1),ee(ei,et)||(F._values.push(ei),F._index.push(ea))}en++}while(en<Z)}F._ptr.push(F._index.length),F._size=[K,Z]}function _getsubset(F,$){if(!isIndex($))throw TypeError("Invalid index");if($.isScalar())return F.get($.min());var V,G,H,K,Z=$.size();if(Z.length!==F._size.length)throw new DimensionError(Z.length,F._size.length);var ee=$.min(),et=$.max();for(V=0,G=F._size.length;V<G;V++)validateIndex(ee[V],F._size[V]),validateIndex(et[V],F._size[V]);var en=F._values,ea=F._index,ei=F._ptr,eo=$.dimension(0),es=$.dimension(1),eu=[],ec=[];eo.forEach(function(F,$){ec[F]=$[0],eu[F]=!0});var ep=en?[]:void 0,eh=[],ef=[];return es.forEach(function(F){for(ef.push(eh.length),H=ei[F],K=ei[F+1];H<K;H++)!0===eu[V=ea[H]]&&(eh.push(ec[V]),ep&&ep.push(en[H]))}),ef.push(eh.length),new SparseMatrix({values:ep,index:eh,ptr:ef,size:Z,datatype:F._datatype})}function _setsubset(F,$,V,G){if(!$||!0!==$.isIndex)throw TypeError("Invalid index");var H,K=$.size(),Z=$.isScalar();if(isMatrix(V)?(H=V.size(),V=V.toArray()):H=arraySize(V),Z){if(0!==H.length)throw TypeError("Scalar expected");F.set($.min(),V,G)}else{if(1!==K.length&&2!==K.length)throw new DimensionError(K.length,F._size.length,"<");if(H.length<K.length){for(var ee=0,et=0;1===K[ee]&&1===H[ee];)ee++;for(;1===K[ee];)et++,ee++;V=unsqueeze(V,K.length,et,H)}if(!deepStrictEqual(K,H))throw new DimensionError(K,H,">");if(1===K.length)$.dimension(0).forEach(function($,H){validateIndex($),F.set([$,0],V[H[0]],G)});else{var en=$.dimension(0),ea=$.dimension(1);en.forEach(function($,H){validateIndex($),ea.forEach(function(K,Z){validateIndex(K),F.set([$,K],V[H[0]][Z[0]],G)})})}}return F}function _getValueIndex(F,$,V,G){if(V-$==0)return V;for(var H=$;H<V;H++)if(G[H]===F)return H;return $}function _remove(F,$,V,G,H){V.splice(F,1),G.splice(F,1);for(var K=$+1;K<H.length;K++)H[K]--}function _insert(F,$,V,G,H,K,Z){H.splice(F,0,G),K.splice(F,0,$);for(var ee=V+1;ee<Z.length;ee++)Z[ee]++}function _resize(F,G,H,K){var Z,ee,et,en=K||0,ea=V,ei=0;is_isString(F._datatype)&&(ea=$.find(V,[F._datatype,F._datatype])||V,ei=$.convert(0,F._datatype),en=$.convert(en,F._datatype));var eo=!ea(en,ei),es=F._size[0],eu=F._size[1];if(H>eu){for(ee=eu;ee<H;ee++)if(F._ptr[ee]=F._values.length,eo)for(Z=0;Z<es;Z++)F._values.push(en),F._index.push(Z);F._ptr[H]=F._values.length}else H<eu&&(F._ptr.splice(H+1,eu-H),F._values.splice(F._ptr[H],F._values.length),F._index.splice(F._ptr[H],F._index.length));if(eu=H,G>es){if(eo){var ec=0;for(ee=0;ee<eu;ee++){F._ptr[ee]=F._ptr[ee]+ec,et=F._ptr[ee+1]+ec;var ep=0;for(Z=es;Z<G;Z++,ep++)F._values.splice(et+ep,0,en),F._index.splice(et+ep,0,Z),ec++}F._ptr[eu]=F._values.length}}else if(G<es){var eh=0;for(ee=0;ee<eu;ee++){F._ptr[ee]=F._ptr[ee]-eh;var ef=F._ptr[ee],ed=F._ptr[ee+1]-eh;for(et=ef;et<ed;et++)(Z=F._index[et])>G-1&&(F._values.splice(et,1),F._index.splice(et,1),eh++)}F._ptr[ee]=F._values.length}return F._size[0]=G,F._size[1]=H,F}function _map(F,G,H,K,Z,ee,et){var en=[],ea=[],ei=[],eo=V,es=0;is_isString(F._datatype)&&(eo=$.find(V,[F._datatype,F._datatype])||V,es=$.convert(0,F._datatype));for(var invoke=function(F,$,V){F=ee(F,$,V),eo(F,es)||(en.push(F),ea.push($))},eu=K;eu<=Z;eu++){ei.push(en.length);var ec=F._ptr[eu],ep=F._ptr[eu+1];if(et)for(var eh=ec;eh<ep;eh++){var ef=F._index[eh];ef>=G&&ef<=H&&invoke(F._values[eh],ef-G,eu-K)}else{for(var ed={},em=ec;em<ep;em++)ed[F._index[em]]=F._values[em];for(var eg=G;eg<=H;eg++)invoke(eg in ed?ed[eg]:0,eg-G,eu-K)}}return ei.push(en.length),new SparseMatrix({values:en,index:ea,ptr:ei,size:[H-G+1,Z-K+1]})}function _toArray(F,$,V,G,H){var K,Z,ee=G[0],et=G[1],en=[];for(K=0;K<ee;K++)for(Z=0,en[K]=[];Z<et;Z++)en[K][Z]=0;for(Z=0;Z<et;Z++)for(var ea=V[Z],ei=V[Z+1],eo=ea;eo<ei;eo++)en[K=$[eo]][Z]=F?H?object_clone(F[eo]):F[eo]:1;return en}return SparseMatrix.prototype=new G,SparseMatrix.prototype.createSparseMatrix=function(F,$){return new SparseMatrix(F,$)},SparseMatrix.prototype.type="SparseMatrix",SparseMatrix.prototype.isSparseMatrix=!0,SparseMatrix.prototype.getDataType=function(){return getArrayDataType(this._values,typeOf)},SparseMatrix.prototype.storage=function(){return"sparse"},SparseMatrix.prototype.datatype=function(){return this._datatype},SparseMatrix.prototype.create=function(F,$){return new SparseMatrix(F,$)},SparseMatrix.prototype.density=function(){var F=this._size[0],$=this._size[1];return 0!==F&&0!==$?this._index.length/(F*$):0},SparseMatrix.prototype.subset=function(F,$,V){if(!this._values)throw Error("Cannot invoke subset on a Pattern only matrix");switch(arguments.length){case 1:return _getsubset(this,F);case 2:case 3:return _setsubset(this,F,$,V);default:throw SyntaxError("Wrong number of arguments")}},SparseMatrix.prototype.get=function(F){if(!ez(F))throw TypeError("Array expected");if(F.length!==this._size.length)throw new DimensionError(F.length,this._size.length);if(!this._values)throw Error("Cannot invoke get on a Pattern only matrix");var $=F[0],V=F[1];validateIndex($,this._size[0]),validateIndex(V,this._size[1]);var G=_getValueIndex($,this._ptr[V],this._ptr[V+1],this._index);return G<this._ptr[V+1]&&this._index[G]===$?this._values[G]:0},SparseMatrix.prototype.set=function(F,G,H){if(!ez(F))throw TypeError("Array expected");if(F.length!==this._size.length)throw new DimensionError(F.length,this._size.length);if(!this._values)throw Error("Cannot invoke set on a Pattern only matrix");var K=F[0],Z=F[1],ee=this._size[0],et=this._size[1],en=V,ea=0;is_isString(this._datatype)&&(en=$.find(V,[this._datatype,this._datatype])||V,ea=$.convert(0,this._datatype)),(K>ee-1||Z>et-1)&&(_resize(this,Math.max(K+1,ee),Math.max(Z+1,et),H),ee=this._size[0],et=this._size[1]),validateIndex(K,ee),validateIndex(Z,et);var ei=_getValueIndex(K,this._ptr[Z],this._ptr[Z+1],this._index);return ei<this._ptr[Z+1]&&this._index[ei]===K?en(G,ea)?_remove(ei,Z,this._values,this._index,this._ptr):this._values[ei]=G:_insert(ei,K,Z,G,this._values,this._index,this._ptr),this},SparseMatrix.prototype.resize=function(F,$,V){if(!isCollection(F))throw TypeError("Array or Matrix expected");var G=F.valueOf().map(F=>Array.isArray(F)&&1===F.length?F[0]:F);if(2!==G.length)throw Error("Only two dimensions matrix are supported");return G.forEach(function(F){if(!is_isNumber(F)||!isInteger(F)||F<0)throw TypeError("Invalid size, must contain positive integers (size: "+string_format(G)+")")}),_resize(V?this.clone():this,G[0],G[1],$)},SparseMatrix.prototype.reshape=function(F,$){if(!ez(F))throw TypeError("Array expected");if(2!==F.length)throw Error("Sparse matrices can only be reshaped in two dimensions");F.forEach(function($){if(!is_isNumber($)||!isInteger($)||$<=-2||0===$)throw TypeError("Invalid size, must contain positive integers or -1 (size: "+string_format(F)+")")});var V=this._size[0]*this._size[1],G=(F=processSizesWildcard(F,V))[0]*F[1];if(V!==G)throw Error("Reshaping sparse matrix will result in the wrong number of elements");var H=$?this.clone():this;if(this._size[0]===F[0]&&this._size[1]===F[1])return H;for(var K=[],Z=0;Z<H._ptr.length;Z++)for(var ee=0;ee<H._ptr[Z+1]-H._ptr[Z];ee++)K.push(Z);for(var et=H._values.slice(),en=H._index.slice(),ea=0;ea<H._index.length;ea++){var ei=en[ea],eo=K[ea],es=ei*H._size[1]+eo;K[ea]=es%F[1],en[ea]=Math.floor(es/F[1])}H._values.length=0,H._index.length=0,H._ptr.length=F[1]+1,H._size=F.slice();for(var eu=0;eu<H._ptr.length;eu++)H._ptr[eu]=0;for(var ec=0;ec<et.length;ec++){var ep=en[ec],eh=K[ec],ef=et[ec];_insert(_getValueIndex(ep,H._ptr[eh],H._ptr[eh+1],H._index),ep,eh,ef,H._values,H._index,H._ptr)}return H},SparseMatrix.prototype.clone=function(){return new SparseMatrix({values:this._values?object_clone(this._values):void 0,index:object_clone(this._index),ptr:object_clone(this._ptr),size:object_clone(this._size),datatype:this._datatype})},SparseMatrix.prototype.size=function(){return this._size.slice(0)},SparseMatrix.prototype.map=function(F,$){if(!this._values)throw Error("Cannot invoke map on a Pattern only matrix");var V=this;return _map(this,0,this._size[0]-1,0,this._size[1]-1,function($,G,H){return F($,[G,H],V)},$)},SparseMatrix.prototype.forEach=function(F,$){if(!this._values)throw Error("Cannot invoke forEach on a Pattern only matrix");for(var V=this,G=this._size[0],H=this._size[1],K=0;K<H;K++){var Z=this._ptr[K],ee=this._ptr[K+1];if($)for(var et=Z;et<ee;et++){var en=this._index[et];F(this._values[et],[en,K],V)}else{for(var ea={},ei=Z;ei<ee;ei++)ea[this._index[ei]]=this._values[ei];for(var eo=0;eo<G;eo++)F(eo in ea?ea[eo]:0,[eo,K],V)}}},SparseMatrix.prototype[Symbol.iterator]=function*(){if(!this._values)throw Error("Cannot iterate a Pattern only matrix");for(var F=this._size[1],$=0;$<F;$++)for(var V=this._ptr[$],G=this._ptr[$+1],H=V;H<G;H++){var K=this._index[H];yield{value:this._values[H],index:[K,$]}}},SparseMatrix.prototype.toArray=function(){return _toArray(this._values,this._index,this._ptr,this._size,!0)},SparseMatrix.prototype.valueOf=function(){return _toArray(this._values,this._index,this._ptr,this._size,!1)},SparseMatrix.prototype.format=function(F){for(var $=this._size[0],V=this._size[1],G=this.density(),H="Sparse Matrix ["+string_format($,F)+" x "+string_format(V,F)+"] density: "+string_format(G,F)+"\n",K=0;K<V;K++)for(var Z=this._ptr[K],ee=this._ptr[K+1],et=Z;et<ee;et++)H+="\n    ("+string_format(this._index[et],F)+", "+string_format(K,F)+") ==> "+(this._values?string_format(this._values[et],F):"X");return H},SparseMatrix.prototype.toString=function(){return string_format(this.toArray())},SparseMatrix.prototype.toJSON=function(){return{mathjs:"SparseMatrix",values:this._values,index:this._index,ptr:this._ptr,size:this._size,datatype:this._datatype}},SparseMatrix.prototype.diagonal=function(F){if(F){if(isBigNumber(F)&&(F=F.toNumber()),!is_isNumber(F)||!isInteger(F))throw TypeError("The parameter k must be an integer number")}else F=0;var $=F>0?F:0,V=F<0?-F:0,G=this._size[0],H=this._size[1],K=Math.min(G-V,H-$),Z=[],ee=[],et=[];et[0]=0;for(var en=$;en<H&&Z.length<K;en++)for(var ea=this._ptr[en],ei=this._ptr[en+1],eo=ea;eo<ei;eo++){var es=this._index[eo];if(es===en-$+V){Z.push(this._values[eo]),ee[Z.length-1]=es-V;break}}return et.push(Z.length),new SparseMatrix({values:Z,index:ee,ptr:et,size:[K,1]})},SparseMatrix.fromJSON=function(F){return new SparseMatrix(F)},SparseMatrix.diagonal=function(F,G,H,K,Z){if(!ez(F))throw TypeError("Array expected, size parameter");if(2!==F.length)throw Error("Only two dimensions matrix are supported");if(F=F.map(function(F){if(isBigNumber(F)&&(F=F.toNumber()),!is_isNumber(F)||!isInteger(F)||F<1)throw Error("Size values must be positive integers");return F}),H){if(isBigNumber(H)&&(H=H.toNumber()),!is_isNumber(H)||!isInteger(H))throw TypeError("The parameter k must be an integer number")}else H=0;var ee,et=V,en=0;is_isString(Z)&&(et=$.find(V,[Z,Z])||V,en=$.convert(0,Z));var ea=H>0?H:0,ei=H<0?-H:0,eo=F[0],es=F[1],eu=Math.min(eo-ei,es-ea);if(ez(G)){if(G.length!==eu)throw Error("Invalid value array length");ee=function(F){return G[F]}}else if(isMatrix(G)){var ec=G.size();if(1!==ec.length||ec[0]!==eu)throw Error("Invalid matrix length");ee=function(F){return G.get([F])}}else ee=function(){return G};for(var ep=[],eh=[],ef=[],ed=0;ed<es;ed++){ef.push(ep.length);var em=ed-ea;if(em>=0&&em<eu){var eg=ee(em);et(eg,en)||(eh.push(em+ei),ep.push(eg))}}return ef.push(ep.length),new SparseMatrix({values:ep,index:eh,ptr:ef,size:[eo,es]})},SparseMatrix.prototype.swapRows=function(F,$){if(!is_isNumber(F)||!isInteger(F)||!is_isNumber($)||!isInteger($))throw Error("Row index must be positive integers");if(2!==this._size.length)throw Error("Only two dimensional matrix is supported");return validateIndex(F,this._size[0]),validateIndex($,this._size[0]),SparseMatrix._swapRows(F,$,this._size[1],this._values,this._index,this._ptr),this},SparseMatrix._forEachRow=function(F,$,V,G,H){for(var K=G[F],Z=G[F+1],ee=K;ee<Z;ee++)H(V[ee],$[ee])},SparseMatrix._swapRows=function(F,$,V,G,H,K){for(var Z=0;Z<V;Z++){var ee=K[Z],et=K[Z+1],en=_getValueIndex(F,ee,et,H),ea=_getValueIndex($,ee,et,H);if(en<et&&ea<et&&H[en]===F&&H[ea]===$){if(G){var ei=G[en];G[en]=G[ea],G[ea]=ei}continue}if(en<et&&H[en]===F&&(ea>=et||H[ea]!==$)){var eo=G?G[en]:void 0;H.splice(ea,0,$),G&&G.splice(ea,0,eo),H.splice(ea<=en?en+1:en,1),G&&G.splice(ea<=en?en+1:en,1);continue}if(ea<et&&H[ea]===$&&(en>=et||H[en]!==F)){var es=G?G[ea]:void 0;H.splice(en,0,F),G&&G.splice(en,0,es),H.splice(en<=ea?ea+1:ea,1),G&&G.splice(en<=ea?ea+1:ea,1)}}},SparseMatrix},{isClass:!0}),rl="apply";function _apply(F,$,V){var G,H,K;if($<=0){if(!Array.isArray(F[0]))return V(F);for(G=0,K=apply_switch(F),H=[];G<K.length;G++)H[G]=_apply(K[G],$-1,V);return H}for(G=0,H=[];G<F.length;G++)H[G]=_apply(F[G],$-1,V);return H}function apply_switch(F){var $,V,G=F.length,H=F[0].length,K=[];for(V=0;V<H;V++){var Z=[];for($=0;$<G;$++)Z.push(F[$][V]);K.push(Z)}return K}F=>{var{typed:$,isInteger:V}=F;return $(rl,{"Array | Matrix, number | BigNumber, function":function(F,$,G){if(!V($))throw TypeError("Integer number expected for dimension");var H=Array.isArray(F)?arraySize(F):F.size();if($<0||$>=H.length)throw new IndexError($,H.length);return isMatrix(F)?F.create(_apply(F.valueOf(),$,G)):_apply(F,$,G)}})};var rc="bin";factory_factory(rc,["typed","format"],F=>{var{typed:$,format:V}=F;return $(rc,{"number | BigNumber":function(F){return V(F,{notation:"bin"})},"number | BigNumber, number":function(F,$){return V(F,{notation:"bin",wordSize:$})}})});var rp="cos",rh=factory_factory(rp,["typed"],F=>{var{typed:$}=F;return $(rp,{number:Math.cos,Complex:function(F){return F.cos()},BigNumber:function(F){return F.cos()},Unit:function(F){if(!F.hasBase(F.constructor.BASE_UNITS.ANGLE))throw TypeError("Unit in function cos is no angle");return this(F.value)},"Array | Matrix":function(F){return deepMap(F,this)}})}),rf="isNaN",rg=factory_factory(rf,["typed"],F=>{var{typed:$}=F;return $(rf,{number:isNaNNumber,BigNumber:function(F){return F.isNaN()},Fraction:function(F){return!1},Complex:function(F){return F.isNaN()},Unit:function(F){return Number.isNaN(F.value)},"Array | Matrix":function(F){return deepMap(F,Number.isNaN)}})}),ry=factory_factory("sqrt",["config","typed","Complex"],F=>{var{config:$,typed:V,Complex:G}=F;return V("sqrt",{number:_sqrtNumber,Complex:function(F){return F.sqrt()},BigNumber:function(F){return!F.isNegative()||$.predictable?F.sqrt():_sqrtNumber(F.toNumber())},"Array | Matrix":function(F){return deepMap(F,this,!0)},Unit:function(F){return F.pow(.5)}});function _sqrtNumber(F){return isNaN(F)?NaN:F>=0||$.predictable?Math.sqrt(F):new G(F,0).sqrt()}}),rb="unaryMinus",rx=factory_factory(rb,["typed"],F=>{var{typed:$}=F;return $(rb,{number:unaryMinusNumber,Complex:function(F){return F.neg()},BigNumber:function(F){return F.neg()},Fraction:function(F){return F.neg()},Unit:function(F){var $=F.clone();return $.value=this(F.value),$},"Array | Matrix":function(F){return deepMap(F,this,!0)}})}),rv=factory_factory("fraction",["typed","Fraction"],F=>{var{typed:$,Fraction:V}=F;return $("fraction",{number:function(F){if(!isFinite(F)||isNaN(F))throw Error(F+" cannot be represented as a fraction");return new V(F)},string:function(F){return new V(F)},"number, number":function(F,$){return new V(F,$)},null:function(F){return new V(0)},BigNumber:function(F){return new V(F.toString())},Fraction:function(F){return F},Object:function(F){return new V(F)},"Array | Matrix":function(F){return deepMap(F,this)}})}),rw="isNumeric",rS=factory_factory(rw,["typed"],F=>{var{typed:$}=F;return $(rw,{"number | BigNumber | Fraction | boolean":function(){return!0},"Complex | Unit | string | null | undefined | Node":function(){return!1},"Array | Matrix":function(F){return deepMap(F,this)}})}),r_="matrix",rN=factory_factory(r_,["typed","Matrix","DenseMatrix","SparseMatrix"],F=>{var{typed:$,Matrix:V,DenseMatrix:G,SparseMatrix:H}=F;return $(r_,{"":function(){return _create([])},string:function(F){return _create([],F)},"string, string":function(F,$){return _create([],F,$)},Array:function(F){return _create(F)},Matrix:function(F){return _create(F,F.storage())},"Array | Matrix, string":_create,"Array | Matrix, string, string":_create});function _create(F,$,V){if("dense"===$||"default"===$||void 0===$)return new G(F,V);if("sparse"===$)return new H(F,V);throw TypeError("Unknown matrix type "+JSON.stringify($)+".")}}),rk=factory_factory("algorithm02",["typed","equalScalar"],F=>{var{typed:$,equalScalar:V}=F;return function(F,G,H,K){var Z,ee=F._data,et=F._size,en=F._datatype,ea=G._values,ei=G._index,eo=G._ptr,es=G._size,eu=G._datatype;if(et.length!==es.length)throw new DimensionError(et.length,es.length);if(et[0]!==es[0]||et[1]!==es[1])throw RangeError("Dimension mismatch. Matrix A ("+et+") must match Matrix B ("+es+")");if(!ea)throw Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");var ec=et[0],ep=et[1],eh=V,ef=0,ed=H;"string"==typeof en&&en===eu&&(Z=en,eh=$.find(V,[Z,Z]),ef=$.convert(0,Z),ed=$.find(H,[Z,Z]));for(var em=[],eg=[],ey=[],eb=0;eb<ep;eb++){ey[eb]=eg.length;for(var ew=eo[eb],eS=eo[eb+1],e_=ew;e_<eS;e_++){var eN=ei[e_],ek=K?ed(ea[e_],ee[eN][eb]):ed(ee[eN][eb],ea[e_]);eh(ek,ef)||(eg.push(eN),em.push(ek))}}return ey[ep]=eg.length,G.createSparseMatrix({values:em,index:eg,ptr:ey,size:[ec,ep],datatype:Z})}}),rI=factory_factory("algorithm03",["typed"],F=>{var{typed:$}=F;return function(F,V,G,H){var K,Z=F._data,ee=F._size,et=F._datatype,en=V._values,ea=V._index,ei=V._ptr,eo=V._size,es=V._datatype;if(ee.length!==eo.length)throw new DimensionError(ee.length,eo.length);if(ee[0]!==eo[0]||ee[1]!==eo[1])throw RangeError("Dimension mismatch. Matrix A ("+ee+") must match Matrix B ("+eo+")");if(!en)throw Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");var eu=ee[0],ec=ee[1],ep=0,eh=G;"string"==typeof et&&et===es&&(K=et,ep=$.convert(0,K),eh=$.find(G,[K,K]));for(var ef=[],ed=0;ed<eu;ed++)ef[ed]=[];for(var em=[],eg=[],ey=0;ey<ec;ey++){for(var eb=ey+1,ew=ei[ey],eS=ei[ey+1],e_=ew;e_<eS;e_++){var eN=ea[e_];em[eN]=H?eh(en[e_],Z[eN][ey]):eh(Z[eN][ey],en[e_]),eg[eN]=eb}for(var ek=0;ek<eu;ek++)eg[ek]===eb?ef[ek][ey]=em[ek]:ef[ek][ey]=H?eh(ep,Z[ek][ey]):eh(Z[ek][ey],ep)}return F.createDenseMatrix({data:ef,size:[eu,ec],datatype:K})}}),rT=factory_factory("algorithm05",["typed","equalScalar"],F=>{var{typed:$,equalScalar:V}=F;return function(F,G,H){var K,Z,ee,et,en,ea=F._values,ei=F._index,eo=F._ptr,es=F._size,eu=F._datatype,ec=G._values,ep=G._index,eh=G._ptr,ef=G._size,ed=G._datatype;if(es.length!==ef.length)throw new DimensionError(es.length,ef.length);if(es[0]!==ef[0]||es[1]!==ef[1])throw RangeError("Dimension mismatch. Matrix A ("+es+") must match Matrix B ("+ef+")");var em=es[0],eg=es[1],ey=V,eb=0,ew=H;"string"==typeof eu&&eu===ed&&(K=eu,ey=$.find(V,[K,K]),eb=$.convert(0,K),ew=$.find(H,[K,K]));var eS=ea&&ec?[]:void 0,e_=[],eN=[],ek=eS?[]:void 0,eI=eS?[]:void 0,eT=[],eC=[];for(ee=0;ee<eg;ee++){eN[ee]=e_.length;var eE=ee+1;for(et=eo[ee],en=eo[ee+1];et<en;et++)Z=ei[et],e_.push(Z),eT[Z]=eE,ek&&(ek[Z]=ea[et]);for(et=eh[ee],en=eh[ee+1];et<en;et++)eT[Z=ep[et]]!==eE&&e_.push(Z),eC[Z]=eE,eI&&(eI[Z]=ec[et]);if(eS)for(et=eN[ee];et<e_.length;){var eA=eT[Z=e_[et]],eD=eC[Z];if(eA===eE||eD===eE){var eM=ew(eA===eE?ek[Z]:eb,eD===eE?eI[Z]:eb);ey(eM,eb)?e_.splice(et,1):(eS.push(eM),et++)}}}return eN[eg]=e_.length,F.createSparseMatrix({values:eS,index:e_,ptr:eN,size:[em,eg],datatype:K})}}),rC=factory_factory("algorithm11",["typed","equalScalar"],F=>{var{typed:$,equalScalar:V}=F;return function(F,G,H,K){var Z,ee=F._values,et=F._index,en=F._ptr,ea=F._size,ei=F._datatype;if(!ee)throw Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var eo=ea[0],es=ea[1],eu=V,ec=0,ep=H;"string"==typeof ei&&(Z=ei,eu=$.find(V,[Z,Z]),ec=$.convert(0,Z),G=$.convert(G,Z),ep=$.find(H,[Z,Z]));for(var eh=[],ef=[],ed=[],em=0;em<es;em++){ed[em]=ef.length;for(var eg=en[em],ey=en[em+1],eb=eg;eb<ey;eb++){var ew=et[eb],eS=K?ep(G,ee[eb]):ep(ee[eb],G);eu(eS,ec)||(ef.push(ew),eh.push(eS))}}return ed[es]=ef.length,F.createSparseMatrix({values:eh,index:ef,ptr:ed,size:[eo,es],datatype:Z})}}),rE=factory_factory("algorithm12",["typed","DenseMatrix"],F=>{var{typed:$,DenseMatrix:V}=F;return function(F,G,H,K){var Z,ee=F._values,et=F._index,en=F._ptr,ea=F._size,ei=F._datatype;if(!ee)throw Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var eo=ea[0],es=ea[1],eu=H;"string"==typeof ei&&(Z=ei,G=$.convert(G,Z),eu=$.find(H,[Z,Z]));for(var ec=[],ep=[],eh=[],ef=0;ef<es;ef++){for(var ed=ef+1,em=en[ef],eg=en[ef+1],ey=em;ey<eg;ey++){var eb=et[ey];ep[eb]=ee[ey],eh[eb]=ed}for(var ew=0;ew<eo;ew++)0===ef&&(ec[ew]=[]),eh[ew]===ed?ec[ew][ef]=K?eu(G,ep[ew]):eu(ep[ew],G):ec[ew][ef]=K?eu(G,0):eu(0,G)}return new V({data:ec,size:[eo,es],datatype:Z})}}),rA=factory_factory("algorithm13",["typed"],F=>{var{typed:$}=F;return function(F,V,G){var H,K=F._data,Z=F._size,ee=F._datatype,et=V._data,en=V._size,ea=V._datatype,ei=[];if(Z.length!==en.length)throw new DimensionError(Z.length,en.length);for(var eo=0;eo<Z.length;eo++){if(Z[eo]!==en[eo])throw RangeError("Dimension mismatch. Matrix A ("+Z+") must match Matrix B ("+en+")");ei[eo]=Z[eo]}var es=G;"string"==typeof ee&&ee===ea&&(H=ee,es=$.find(G,[H,H]));var eu=ei.length>0?_iterate(es,0,ei,ei[0],K,et):[];return F.createDenseMatrix({data:eu,size:ei,datatype:H})};function _iterate(F,$,V,G,H,K){var Z=[];if($===V.length-1)for(var ee=0;ee<G;ee++)Z[ee]=F(H[ee],K[ee]);else for(var et=0;et<G;et++)Z[et]=_iterate(F,$+1,V,V[$+1],H[et],K[et]);return Z}}),rD=factory_factory("algorithm14",["typed"],F=>{var{typed:$}=F;return function(F,V,G,H){var K,Z=F._data,ee=F._size,et=F._datatype,en=G;"string"==typeof et&&(K=et,V=$.convert(V,K),en=$.find(G,[K,K]));var ea=ee.length>0?_iterate(en,0,ee,ee[0],Z,V,H):[];return F.createDenseMatrix({data:ea,size:object_clone(ee),datatype:K})};function _iterate(F,$,V,G,H,K,Z){var ee=[];if($===V.length-1)for(var et=0;et<G;et++)ee[et]=Z?F(K,H[et]):F(H[et],K);else for(var en=0;en<G;en++)ee[en]=_iterate(F,$+1,V,V[$+1],H[en],K,Z);return ee}}),rM="mod",rR=(F=>{var{typed:$,matrix:V,equalScalar:G,DenseMatrix:H}=F,K=rk({typed:$,equalScalar:G}),Z=rI({typed:$}),ee=rT({typed:$,equalScalar:G}),et=rC({typed:$,equalScalar:G}),en=rE({typed:$,DenseMatrix:H}),ea=rA({typed:$}),ei=rD({typed:$});return $(rM,{"number, number":modNumber,"BigNumber, BigNumber":function(F,$){if($.isNeg())throw Error("Cannot calculate mod for a negative divisor");return $.isZero()?F:F.mod($)},"Fraction, Fraction":function(F,$){if(0>$.compare(0))throw Error("Cannot calculate mod for a negative divisor");return F.compare(0)>=0?F.mod($):F.mod($).add($).mod($)},"SparseMatrix, SparseMatrix":function(F,$){return ee(F,$,this,!1)},"SparseMatrix, DenseMatrix":function(F,$){return K($,F,this,!0)},"DenseMatrix, SparseMatrix":function(F,$){return Z(F,$,this,!1)},"DenseMatrix, DenseMatrix":function(F,$){return ea(F,$,this)},"Array, Array":function(F,$){return this(V(F),V($)).valueOf()},"Array, Matrix":function(F,$){return this(V(F),$)},"Matrix, Array":function(F,$){return this(F,V($))},"SparseMatrix, any":function(F,$){return et(F,$,this,!1)},"DenseMatrix, any":function(F,$){return ei(F,$,this,!1)},"any, SparseMatrix":function(F,$){return en($,F,this,!0)},"any, DenseMatrix":function(F,$){return ei($,F,this,!0)},"Array, any":function(F,$){return ei(V(F),$,this,!1).valueOf()},"any, Array":function(F,$){return ei(V($),F,this,!0).valueOf()}})},factory_factory("algorithm01",["typed"],F=>{var{typed:$}=F;return function(F,V,G,H){var K,Z,ee=F._data,et=F._size,en=F._datatype,ea=V._values,ei=V._index,eo=V._ptr,es=V._size,eu=V._datatype;if(et.length!==es.length)throw new DimensionError(et.length,es.length);if(et[0]!==es[0]||et[1]!==es[1])throw RangeError("Dimension mismatch. Matrix A ("+et+") must match Matrix B ("+es+")");if(!ea)throw Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");var ec=et[0],ep=et[1],eh="string"==typeof en&&en===eu?en:void 0,ef=eh?$.find(G,[eh,eh]):G,ed=[];for(K=0;K<ec;K++)ed[K]=[];var em=[],eg=[];for(Z=0;Z<ep;Z++){for(var ey=Z+1,eb=eo[Z],ew=eo[Z+1],eS=eb;eS<ew;eS++)em[K=ei[eS]]=H?ef(ea[eS],ee[K][Z]):ef(ee[K][Z],ea[eS]),eg[K]=ey;for(K=0;K<ec;K++)eg[K]===ey?ed[K][Z]=em[K]:ed[K][Z]=ee[K][Z]}return F.createDenseMatrix({data:ed,size:[ec,ep],datatype:eh})}}));function noBignumber(){throw Error('No "bignumber" implementation available')}function noFraction(){throw Error('No "fraction" implementation available')}function noMatrix(){throw Error('No "matrix" implementation available')}F=>{var{typed:$,equalScalar:V}=F;return function(F,G,H){var K,Z=F._values,ee=F._size,et=F._datatype,en=G._values,ea=G._size,ei=G._datatype;if(ee.length!==ea.length)throw new DimensionError(ee.length,ea.length);if(ee[0]!==ea[0]||ee[1]!==ea[1])throw RangeError("Dimension mismatch. Matrix A ("+ee+") must match Matrix B ("+ea+")");var eo=ee[0],es=ee[1],eu=V,ec=0,ep=H;"string"==typeof et&&et===ei&&(K=et,eu=$.find(V,[K,K]),ec=$.convert(0,K),ep=$.find(H,[K,K]));for(var eh=Z&&en?[]:void 0,ef=[],ed=[],em=eh?[]:void 0,eg=[],ey=[],eb=0;eb<es;eb++){ed[eb]=ef.length;var ew=eb+1;if(scatter(F,eb,eg,em,ey,ew,ef,ep),scatter(G,eb,eg,em,ey,ew,ef,ep),em)for(var eS=ed[eb];eS<ef.length;){var e_=ef[eS];if(ey[e_]===ew){var eN=em[e_];eu(eN,ec)?ef.splice(eS,1):(eh.push(eN),eS++)}else ef.splice(eS,1)}else for(var ek=ed[eb];ek<ef.length;)ey[ef[ek]]!==ew?ef.splice(ek,1):ek++}return ed[es]=ef.length,F.createSparseMatrix({values:eh,index:ef,ptr:ed,size:[eo,es],datatype:K})}};var rF=factory_factory("numeric",["number","?bignumber","?fraction"],F=>{var{number:$,bignumber:V,fraction:G}=F,H={string:!0,number:!0,BigNumber:!0,Fraction:!0},K={number:F=>$(F),BigNumber:V?F=>V(F):noBignumber,Fraction:G?F=>G(F):noFraction};return function(F,$){var V=typeOf(F);if(!(V in H))throw TypeError("Cannot convert "+F+' of type "'+V+'"; valid input types are '+Object.keys(H).join(", "));if(!($ in K))throw TypeError("Cannot convert "+F+' to type "'+$+'"; valid output types are '+Object.keys(K).join(", "));return $===V?F:K[$](F)}});function improveErrorMessage(F,$,V){var G;return -1!==String(F).indexOf("Unexpected type")?(G=arguments.length>2?" (type: "+typeOf(V)+", value: "+JSON.stringify(V)+")":" (type: "+F.data.actual+")",TypeError("Cannot calculate "+$+", unexpected type of argument"+G)):-1!==String(F).indexOf("complex numbers")?(G=arguments.length>2?" (type: "+typeOf(V)+", value: "+JSON.stringify(V)+")":"",TypeError("Cannot calculate "+$+", no ordering relation is defined for complex numbers"+G)):F}var rO="prod",rP="size",rB=factory_factory(rP,["typed","config","?matrix"],F=>{var{typed:$,config:V,matrix:G}=F;return $(rP,{Matrix:function(F){return F.create(F.size())},Array:arraySize,string:function(F){return"Array"===V.matrix?[F.length]:G([F.length])},"number | Complex | BigNumber | Unit | boolean | null":function(F){return"Array"===V.matrix?[]:G?G([]):noMatrix()}})}),r$=factory_factory("algorithm07",["typed","DenseMatrix"],F=>{var{typed:$,DenseMatrix:V}=F;return function(F,G,H){var K,Z,ee,et=F._size,en=F._datatype,ea=G._size,ei=G._datatype;if(et.length!==ea.length)throw new DimensionError(et.length,ea.length);if(et[0]!==ea[0]||et[1]!==ea[1])throw RangeError("Dimension mismatch. Matrix A ("+et+") must match Matrix B ("+ea+")");var eo=et[0],es=et[1],eu=0,ec=H;"string"==typeof en&&en===ei&&(K=en,eu=$.convert(0,K),ec=$.find(H,[K,K]));var ep=[];for(Z=0;Z<eo;Z++)ep[Z]=[];var eh=[],ef=[],ed=[],em=[];for(ee=0;ee<es;ee++){var eg=ee+1;for(_scatter(F,ee,ed,eh,eg),_scatter(G,ee,em,ef,eg),Z=0;Z<eo;Z++){var ey=ed[Z]===eg?eh[Z]:eu,eb=em[Z]===eg?ef[Z]:eu;ep[Z][ee]=ec(ey,eb)}}return new V({data:ep,size:[eo,es],datatype:K})};function _scatter(F,$,V,G,H){for(var K=F._values,Z=F._index,ee=F._ptr,et=ee[$],en=ee[$+1];et<en;et++){var ea=Z[et];V[ea]=H,G[ea]=K[et]}}}),rz="smaller",rV=factory_factory(rz,["typed","config","matrix","DenseMatrix"],F=>{var{typed:$,config:V,matrix:G,DenseMatrix:H}=F,K=rI({typed:$}),Z=r$({typed:$,DenseMatrix:H}),ee=rE({typed:$,DenseMatrix:H}),et=rA({typed:$}),en=rD({typed:$});return $(rz,{"boolean, boolean":function(F,$){return F<$},"number, number":function(F,$){return F<$&&!number_nearlyEqual(F,$,V.epsilon)},"BigNumber, BigNumber":function(F,$){return F.lt($)&&!nearlyEqual_nearlyEqual(F,$,V.epsilon)},"Fraction, Fraction":function(F,$){return -1===F.compare($)},"Complex, Complex":function(F,$){throw TypeError("No ordering relation is defined for complex numbers")},"Unit, Unit":function(F,$){if(!F.equalBase($))throw Error("Cannot compare units with different base");return this(F.value,$.value)},"SparseMatrix, SparseMatrix":function(F,$){return Z(F,$,this)},"SparseMatrix, DenseMatrix":function(F,$){return K($,F,this,!0)},"DenseMatrix, SparseMatrix":function(F,$){return K(F,$,this,!1)},"DenseMatrix, DenseMatrix":function(F,$){return et(F,$,this)},"Array, Array":function(F,$){return this(G(F),G($)).valueOf()},"Array, Matrix":function(F,$){return this(G(F),$)},"Matrix, Array":function(F,$){return this(F,G($))},"SparseMatrix, any":function(F,$){return ee(F,$,this,!1)},"DenseMatrix, any":function(F,$){return en(F,$,this,!1)},"any, SparseMatrix":function(F,$){return ee($,F,this,!0)},"any, DenseMatrix":function(F,$){return en($,F,this,!0)},"Array, any":function(F,$){return en(G(F),$,this,!1).valueOf()},"any, Array":function(F,$){return en(G($),F,this,!0).valueOf()}})}),rU="subset",rW=factory_factory(rU,["typed","matrix"],F=>{var{typed:$,matrix:V}=F;return $(rU,{"Array, Index":function(F,$){var G=V(F).subset($);return $.isScalar()?G:G.valueOf()},"Matrix, Index":function(F,$){return F.subset($)},"Object, Index":_getObjectProperty,"string, Index":_getSubstring,"Array, Index, any":function(F,$,G){return V(object_clone(F)).subset($,G,void 0).valueOf()},"Array, Index, any, any":function(F,$,G,H){return V(object_clone(F)).subset($,G,H).valueOf()},"Matrix, Index, any":function(F,$,V){return F.clone().subset($,V)},"Matrix, Index, any, any":function(F,$,V,G){return F.clone().subset($,V,G)},"string, Index, string":_setSubstring,"string, Index, string, string":_setSubstring,"Object, Index, any":_setObjectProperty})});function _getSubstring(F,$){if(!isIndex($))throw TypeError("Index expected");if(1!==$.size().length)throw new DimensionError($.size().length,1);var V=F.length;validateIndex($.min()[0],V),validateIndex($.max()[0],V);var G=$.dimension(0),H="";return G.forEach(function($){H+=F.charAt($)}),H}function _setSubstring(F,$,V,G){if(!$||!0!==$.isIndex)throw TypeError("Index expected");if(1!==$.size().length)throw new DimensionError($.size().length,1);if(void 0!==G){if("string"!=typeof G||1!==G.length)throw TypeError("Single character expected as defaultValue")}else G=" ";var H=$.dimension(0);if(H.size()[0]!==V.length)throw new DimensionError(H.size()[0],V.length);var K=F.length;validateIndex($.min()[0]),validateIndex($.max()[0]);for(var Z=[],ee=0;ee<K;ee++)Z[ee]=F.charAt(ee);if(H.forEach(function(F,$){Z[F]=V.charAt($[0])}),Z.length>K)for(var et=K-1,en=Z.length;et<en;et++)Z[et]||(Z[et]=G);return Z.join("")}function _getObjectProperty(F,$){if(1!==$.size().length)throw new DimensionError($.size(),1);var V=$.dimension(0);if("string"!=typeof V)throw TypeError("String expected as index to retrieve an object property");return getSafeProperty(F,V)}function _setObjectProperty(F,$,V){if(1!==$.size().length)throw new DimensionError($.size(),1);var G=$.dimension(0);if("string"!=typeof G)throw TypeError("String expected as index to retrieve an object property");var H=object_clone(F);return customs_setSafeProperty(H,G,V),H}var rj=factory_factory("algorithm10",["typed","DenseMatrix"],F=>{var{typed:$,DenseMatrix:V}=F;return function(F,G,H,K){var Z,ee=F._values,et=F._index,en=F._ptr,ea=F._size,ei=F._datatype;if(!ee)throw Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var eo=ea[0],es=ea[1],eu=H;"string"==typeof ei&&(Z=ei,G=$.convert(G,Z),eu=$.find(H,[Z,Z]));for(var ec=[],ep=[],eh=[],ef=0;ef<es;ef++){for(var ed=ef+1,em=en[ef],eg=en[ef+1],ey=em;ey<eg;ey++){var eb=et[ey];ep[eb]=ee[ey],eh[eb]=ed}for(var ew=0;ew<eo;ew++)0===ef&&(ec[ew]=[]),eh[ew]===ed?ec[ew][ef]=K?eu(G,ep[ew]):eu(ep[ew],G):ec[ew][ef]=G}return new V({data:ec,size:[eo,es],datatype:Z})}}),rG="subtract",rq=factory_factory(rG,["typed","matrix","equalScalar","addScalar","unaryMinus","DenseMatrix"],F=>{var{typed:$,matrix:V,equalScalar:G,addScalar:H,unaryMinus:K,DenseMatrix:Z}=F,ee=rR({typed:$}),et=rI({typed:$}),en=rT({typed:$,equalScalar:G}),ea=rj({typed:$,DenseMatrix:Z}),ei=rA({typed:$}),eo=rD({typed:$});return $(rG,{"number, number":function(F,$){return F-$},"Complex, Complex":function(F,$){return F.sub($)},"BigNumber, BigNumber":function(F,$){return F.minus($)},"Fraction, Fraction":function(F,$){return F.sub($)},"Unit, Unit":function(F,$){if(null===F.value)throw Error("Parameter x contains a unit with undefined value");if(null===$.value)throw Error("Parameter y contains a unit with undefined value");if(!F.equalBase($))throw Error("Units do not match");var V=F.clone();return V.value=this(V.value,$.value),V.fixPrefix=!1,V},"SparseMatrix, SparseMatrix":function(F,$){return checkEqualDimensions(F,$),en(F,$,this)},"SparseMatrix, DenseMatrix":function(F,$){return checkEqualDimensions(F,$),et($,F,this,!0)},"DenseMatrix, SparseMatrix":function(F,$){return checkEqualDimensions(F,$),ee(F,$,this,!1)},"DenseMatrix, DenseMatrix":function(F,$){return checkEqualDimensions(F,$),ei(F,$,this)},"Array, Array":function(F,$){return this(V(F),V($)).valueOf()},"Array, Matrix":function(F,$){return this(V(F),$)},"Matrix, Array":function(F,$){return this(F,V($))},"SparseMatrix, any":function(F,$){return ea(F,K($),H)},"DenseMatrix, any":function(F,$){return eo(F,$,this)},"any, SparseMatrix":function(F,$){return ea($,F,this,!0)},"any, DenseMatrix":function(F,$){return eo($,F,this,!0)},"Array, any":function(F,$){return eo(V(F),$,this,!1).valueOf()},"any, Array":function(F,$){return eo(V($),F,this,!0).valueOf()}})});function checkEqualDimensions(F,$){var V=F.size(),G=$.size();if(V.length!==G.length)throw new DimensionError(V.length,G.length)}var rH=factory_factory("transpose",["typed","matrix"],F=>{var{typed:$,matrix:V}=F;return $("transpose",{Array:function(F){return this(V(F)).valueOf()},Matrix:function(F){var $,V=F.size();switch(V.length){case 1:$=F.clone();break;case 2:var G=V[0],H=V[1];if(0===H)throw RangeError("Cannot transpose a 2D matrix with no columns (size: "+string_format(V)+")");switch(F.storage()){case"dense":$=_denseTranspose(F,G,H);break;case"sparse":$=_sparseTranspose(F,G,H)}break;default:throw RangeError("Matrix must be a vector or two dimensional (size: "+string_format(this._size)+")")}return $},any:function(F){return object_clone(F)}});function _denseTranspose(F,$,V){for(var G,H=F._data,K=[],Z=0;Z<V;Z++){G=K[Z]=[];for(var ee=0;ee<$;ee++)G[ee]=object_clone(H[ee][Z])}return F.createDenseMatrix({data:K,size:[V,$],datatype:F._datatype})}function _sparseTranspose(F,$,V){for(var G,H,K,Z=F._values,ee=F._index,et=F._ptr,en=Z?[]:void 0,ea=[],ei=[],eo=[],es=0;es<$;es++)eo[es]=0;for(G=0,H=ee.length;G<H;G++)eo[ee[G]]++;for(var eu=0,ec=0;ec<$;ec++)ei.push(eu),eu+=eo[ec],eo[ec]=ei[ec];for(ei.push(eu),K=0;K<V;K++)for(var ep=et[K],eh=et[K+1],ef=ep;ef<eh;ef++){var ed=eo[ee[ef]]++;ea[ed]=K,Z&&(en[ed]=object_clone(Z[ef]))}return F.createSparseMatrix({values:en,index:ea,ptr:ei,size:[V,$],datatype:F._datatype})}}),rX="xgcd",rK=(F=>{var{typed:$,config:V,matrix:G,BigNumber:H}=F;return $(rX,{"number, number":function(F,$){var H=xgcdNumber(F,$);return"Array"===V.matrix?H:G(H)},"BigNumber, BigNumber":_xgcdBigNumber});function _xgcdBigNumber(F,$){var K,Z,ee,et,en=new H(0),ea=new H(1),ei=en,eo=ea,es=ea,eu=en;if(!F.isInt()||!$.isInt())throw Error("Parameters in function xgcd must be integer numbers");for(;!$.isZero();)Z=F.div($).floor(),ee=F.mod($),K=ei,ei=eo.minus(Z.times(ei)),eo=K,K=es,es=eu.minus(Z.times(es)),eu=K,F=$,$=ee;return et=F.lt(en)?[F.neg(),eo.neg(),eu.neg()]:[F,F.isZero()?0:eo,eu],"Array"===V.matrix?et:G(et)}},"zeros"),rQ=factory_factory(rK,["typed","config","matrix","BigNumber"],F=>{var{typed:$,config:V,matrix:G,BigNumber:H}=F;return $(rK,{"":function(){return"Array"===V.matrix?_zeros([]):_zeros([],"default")},"...number | BigNumber | string":function(F){if("string"==typeof F[F.length-1]){var $=F.pop();return _zeros(F,$)}return"Array"===V.matrix?_zeros(F):_zeros(F,"default")},Array:_zeros,Matrix:function(F){var $=F.storage();return _zeros(F.valueOf(),$)},"Array | Matrix, string":function(F,$){return _zeros(F.valueOf(),$)}});function _zeros(F,$){var V=_normalize(F)?new H(0):0;if(_validate(F),$){var K=G($);return F.length>0?K.resize(F,V):K}var Z=[];return F.length>0?array_resize(Z,F,V):Z}function _normalize(F){var $=!1;return F.forEach(function(F,V,G){isBigNumber(F)&&($=!0,G[V]=F.toNumber())}),$}function _validate(F){F.forEach(function(F){if("number"!=typeof F||!isInteger(F)||F<0)throw Error("Parameters in function zeros must be positive integers")})}}),rZ="compare",rY=factory_factory(rZ,["typed","config","matrix","equalScalar","BigNumber","Fraction","DenseMatrix"],F=>{var{typed:$,config:V,equalScalar:G,matrix:H,BigNumber:K,Fraction:Z,DenseMatrix:ee}=F,et=rI({typed:$}),en=rT({typed:$,equalScalar:G}),ea=rE({typed:$,DenseMatrix:ee}),ei=rA({typed:$}),eo=rD({typed:$});return $(rZ,{"boolean, boolean":function(F,$){return F===$?0:F>$?1:-1},"number, number":function(F,$){return number_nearlyEqual(F,$,V.epsilon)?0:F>$?1:-1},"BigNumber, BigNumber":function(F,$){return new K(nearlyEqual_nearlyEqual(F,$,V.epsilon)?0:F.cmp($))},"Fraction, Fraction":function(F,$){return new Z(F.compare($))},"Complex, Complex":function(){throw TypeError("No ordering relation is defined for complex numbers")},"Unit, Unit":function(F,$){if(!F.equalBase($))throw Error("Cannot compare units with different base");return this(F.value,$.value)},"SparseMatrix, SparseMatrix":function(F,$){return en(F,$,this)},"SparseMatrix, DenseMatrix":function(F,$){return et($,F,this,!0)},"DenseMatrix, SparseMatrix":function(F,$){return et(F,$,this,!1)},"DenseMatrix, DenseMatrix":function(F,$){return ei(F,$,this)},"Array, Array":function(F,$){return this(H(F),H($)).valueOf()},"Array, Matrix":function(F,$){return this(H(F),$)},"Matrix, Array":function(F,$){return this(F,H($))},"SparseMatrix, any":function(F,$){return ea(F,$,this,!1)},"DenseMatrix, any":function(F,$){return eo(F,$,this,!1)},"any, SparseMatrix":function(F,$){return ea($,F,this,!0)},"any, DenseMatrix":function(F,$){return eo($,F,this,!0)},"Array, any":function(F,$){return eo(H(F),$,this,!1).valueOf()},"any, Array":function(F,$){return eo(H($),F,this,!0).valueOf()}})}),rJ="compareText",r0=(F=>{var{typed:$,matrix:V}=F,G=rA({typed:$}),H=rD({typed:$});return $(rJ,{"any, any":compareText,"DenseMatrix, DenseMatrix":function(F,$){return G(F,$,compareText)},"Array, Array":function(F,$){return this(V(F),V($)).valueOf()},"Array, Matrix":function(F,$){return this(V(F),$)},"Matrix, Array":function(F,$){return this(F,V($))},"DenseMatrix, any":function(F,$){return H(F,$,compareText,!1)},"any, DenseMatrix":function(F,$){return H($,F,compareText,!0)},"Array, any":function(F,$){return H(V(F),$,compareText,!1).valueOf()},"any, Array":function(F,$){return H(V($),F,compareText,!0).valueOf()}})},"concat");function _concat(F,$,V,G){if(!(G<V))return F.concat($);if(F.length!==$.length)throw new DimensionError(F.length,$.length);for(var H=[],K=0;K<F.length;K++)H[K]=_concat(F[K],$[K],V,G+1);return H}F=>{var{typed:$,matrix:V,isInteger:G}=F;return $(r0,{"...Array | Matrix | number | BigNumber":function(F){var $,H,K=F.length,Z=-1,ee=!1,et=[];for($=0;$<K;$++){var en=F[$];if(isMatrix(en)&&(ee=!0),is_isNumber(en)||isBigNumber(en)){if($!==K-1)throw Error("Dimension must be specified as last argument");if(H=Z,!G(Z=en.valueOf()))throw TypeError("Integer number expected for dimension");if(Z<0||$>0&&Z>H)throw new IndexError(Z,H+1)}else{var ea=object_clone(en).valueOf(),ei=arraySize(ea);if(et[$]=ea,H=Z,Z=ei.length-1,$>0&&Z!==H)throw new DimensionError(H+1,Z+1)}}if(0===et.length)throw SyntaxError("At least one matrix expected");for(var eo=et.shift();et.length;)eo=_concat(eo,et.shift(),Z,0);return ee?V(eo):eo},"...string":function(F){return F.join("")}})};var r2="ctranspose",r3=(F=>{var{typed:$,transpose:V,conj:G}=F;return $(r2,{any:function(F){return G(V(F))}})},"diag"),r4=factory_factory(r3,["typed","matrix","DenseMatrix","SparseMatrix"],F=>{var{typed:$,matrix:V,DenseMatrix:G,SparseMatrix:H}=F;return $(r3,{Array:function(F){return _diag(F,0,arraySize(F),null)},"Array, number":function(F,$){return _diag(F,$,arraySize(F),null)},"Array, BigNumber":function(F,$){return _diag(F,$.toNumber(),arraySize(F),null)},"Array, string":function(F,$){return _diag(F,0,arraySize(F),$)},"Array, number, string":function(F,$,V){return _diag(F,$,arraySize(F),V)},"Array, BigNumber, string":function(F,$,V){return _diag(F,$.toNumber(),arraySize(F),V)},Matrix:function(F){return _diag(F,0,F.size(),F.storage())},"Matrix, number":function(F,$){return _diag(F,$,F.size(),F.storage())},"Matrix, BigNumber":function(F,$){return _diag(F,$.toNumber(),F.size(),F.storage())},"Matrix, string":function(F,$){return _diag(F,0,F.size(),$)},"Matrix, number, string":function(F,$,V){return _diag(F,$,F.size(),V)},"Matrix, BigNumber, string":function(F,$,V){return _diag(F,$.toNumber(),F.size(),V)}});function _diag(F,$,V,G){if(!isInteger($))throw TypeError("Second parameter in function diag must be an integer");var H=$>0?$:0,K=$<0?-$:0;switch(V.length){case 1:return _createDiagonalMatrix(F,$,G,V[0],K,H);case 2:return _getDiagonal(F,$,G,V,K,H)}throw RangeError("Matrix for function diag must be 2 dimensional")}function _createDiagonalMatrix(F,$,V,K,Z,ee){var et=[K+Z,K+ee];if(V&&"sparse"!==V&&"dense"!==V)throw TypeError("Unknown matrix type ".concat(V,'"'));var en="sparse"===V?H.diagonal(et,F,$):G.diagonal(et,F,$);return null!==V?en:en.valueOf()}function _getDiagonal(F,$,G,H,K,Z){if(isMatrix(F)){var ee=F.diagonal($);return null!==G?G!==ee.storage()?V(ee,G):ee:ee.valueOf()}for(var et=Math.min(H[0]-K,H[1]-Z),en=[],ea=0;ea<et;ea++)en[ea]=F[ea+K][ea+Z];return null!==G?V(en):en}}),r6="divideScalar",r5=factory_factory(r6,["typed","numeric"],F=>{var{typed:$,numeric:V}=F;return $(r6,{"number, number":function(F,$){return F/$},"Complex, Complex":function(F,$){return F.div($)},"BigNumber, BigNumber":function(F,$){return F.div($)},"Fraction, Fraction":function(F,$){return F.div($)},"Unit, number | Fraction | BigNumber":function(F,$){var G=F.clone(),H=V(1,typeOf($));return G.value=this(null===G.value?G._normalize(H):G.value,$),G},"number | Fraction | BigNumber, Unit":function(F,$){var G=$.clone();G=G.pow(-1);var H=V(1,typeOf(F));return G.value=this(F,null===$.value?$._normalize(H):$.value),G},"Unit, Unit":function(F,$){return F.divide($)}})}),r9="dotDivide",r8=(F=>{var{typed:$,matrix:V,equalScalar:G,divideScalar:H,DenseMatrix:K}=F,Z=rk({typed:$,equalScalar:G}),ee=rI({typed:$}),et=r$({typed:$,DenseMatrix:K}),en=rC({typed:$,equalScalar:G}),ea=rE({typed:$,DenseMatrix:K}),ei=rA({typed:$}),eo=rD({typed:$});return $(r9,{"any, any":H,"SparseMatrix, SparseMatrix":function(F,$){return et(F,$,H,!1)},"SparseMatrix, DenseMatrix":function(F,$){return Z($,F,H,!0)},"DenseMatrix, SparseMatrix":function(F,$){return ee(F,$,H,!1)},"DenseMatrix, DenseMatrix":function(F,$){return ei(F,$,H)},"Array, Array":function(F,$){return this(V(F),V($)).valueOf()},"Array, Matrix":function(F,$){return this(V(F),$)},"Matrix, Array":function(F,$){return this(F,V($))},"SparseMatrix, any":function(F,$){return en(F,$,H,!1)},"DenseMatrix, any":function(F,$){return eo(F,$,H,!1)},"any, SparseMatrix":function(F,$){return ea($,F,H,!0)},"any, DenseMatrix":function(F,$){return eo($,F,H,!0)},"Array, any":function(F,$){return eo(V(F),$,H,!1).valueOf()},"any, Array":function(F,$){return eo(V($),F,H,!0).valueOf()}})},"equal"),r7=factory_factory(r8,["typed","matrix","equalScalar","DenseMatrix"],F=>{var{typed:$,matrix:V,equalScalar:G,DenseMatrix:H}=F,K=rI({typed:$}),Z=r$({typed:$,DenseMatrix:H}),ee=rE({typed:$,DenseMatrix:H}),et=rA({typed:$}),en=rD({typed:$});return $(r8,{"any, any":function(F,$){return null===F?null===$:null===$?null===F:void 0===F?void 0===$:void 0===$?void 0===F:G(F,$)},"SparseMatrix, SparseMatrix":function(F,$){return Z(F,$,G)},"SparseMatrix, DenseMatrix":function(F,$){return K($,F,G,!0)},"DenseMatrix, SparseMatrix":function(F,$){return K(F,$,G,!1)},"DenseMatrix, DenseMatrix":function(F,$){return et(F,$,G)},"Array, Array":function(F,$){return this(V(F),V($)).valueOf()},"Array, Matrix":function(F,$){return this(V(F),$)},"Matrix, Array":function(F,$){return this(F,V($))},"SparseMatrix, any":function(F,$){return ee(F,$,G,!1)},"DenseMatrix, any":function(F,$){return en(F,$,G,!1)},"any, SparseMatrix":function(F,$){return ee($,F,G,!0)},"any, DenseMatrix":function(F,$){return en($,F,G,!0)},"Array, any":function(F,$){return en(V(F),$,G,!1).valueOf()},"any, Array":function(F,$){return en(V($),F,G,!0).valueOf()}})});factory_factory(r8,["typed","equalScalar"],F=>{var{typed:$,equalScalar:V}=F;return $(r8,{"any, any":function(F,$){return null===F?null===$:null===$?null===F:void 0===F?void 0===$:void 0===$?void 0===F:V(F,$)}})});var ne="fft",nt=(F=>{var{typed:$,matrix:V,addScalar:G,multiplyScalar:H,divideScalar:K,exp:Z,tau:ee,i:et}=F;return $(ne,{Array:_ndFft,Matrix:function(F){return F.create(_ndFft(F.toArray()))}});function _ndFft(F){var $=arraySize(F);return 1===$.length?_fft(F,$[0]):_1dFft(F.map(F=>_ndFft(F,$.slice(1))),0)}function _1dFft(F,$){var V=arraySize(F);if(0!==$)return Array(V[0]).fill(0).map((V,G)=>_1dFft(F[G],$-1));if(1===V.length)return _fft(F);function _transpose(F){var $=arraySize(F);return Array($[1]).fill(0).map((V,G)=>Array($[0]).fill(0).map(($,V)=>F[V][G]))}return _transpose(_1dFft(_transpose(F),1))}function _fft(F){var $=F.length;if(1===$)return[F[0]];if($%2==0){for(var V=[..._fft(F.filter((F,$)=>$%2==0),$/2),..._fft(F.filter((F,$)=>$%2==1),$/2)],en=0;en<$/2;en++){var ea=V[en],ei=H(V[en+$/2],Z(H(H(ee,et),K(-en,$))));V[en]=G(ea,ei),V[en+$/2]=G(ea,H(-1,ei))}return V}throw Error("Can only calculate FFT of power-of-two size")}},"flatten"),nr=factory_factory(nt,["typed","matrix"],F=>{var{typed:$,matrix:V}=F;return $(nt,{Array:function(F){return flatten(object_clone(F))},Matrix:function(F){return V(flatten(object_clone(F.toArray())))}})}),nn=factory_factory("algorithm04",["typed","equalScalar"],F=>{var{typed:$,equalScalar:V}=F;return function(F,G,H){var K,Z,ee,et,en,ea,ei=F._values,eo=F._index,es=F._ptr,eu=F._size,ec=F._datatype,ep=G._values,eh=G._index,ef=G._ptr,ed=G._size,em=G._datatype;if(eu.length!==ed.length)throw new DimensionError(eu.length,ed.length);if(eu[0]!==ed[0]||eu[1]!==ed[1])throw RangeError("Dimension mismatch. Matrix A ("+eu+") must match Matrix B ("+ed+")");var eg=eu[0],ey=eu[1],eb=V,ew=0,eS=H;"string"==typeof ec&&ec===em&&(K=ec,eb=$.find(V,[K,K]),ew=$.convert(0,K),eS=$.find(H,[K,K]));var e_=ei&&ep?[]:void 0,eN=[],ek=[],eI=ei&&ep?[]:void 0,eT=ei&&ep?[]:void 0,eC=[],eE=[];for(ee=0;ee<ey;ee++){ek[ee]=eN.length;var eA=ee+1;for(en=es[ee],ea=es[ee+1],et=en;et<ea;et++)Z=eo[et],eN.push(Z),eC[Z]=eA,eI&&(eI[Z]=ei[et]);for(en=ef[ee],ea=ef[ee+1],et=en;et<ea;et++)if(eC[Z=eh[et]]===eA){if(eI){var eD=eS(eI[Z],ep[et]);eb(eD,ew)?eC[Z]=null:eI[Z]=eD}}else eN.push(Z),eE[Z]=eA,eT&&(eT[Z]=ep[et]);if(eI&&eT)for(et=ek[ee];et<eN.length;)eC[Z=eN[et]]===eA?(e_[et]=eI[Z],et++):eE[Z]===eA?(e_[et]=eT[Z],et++):eN.splice(et,1)}return ek[ey]=eN.length,F.createSparseMatrix({values:e_,index:eN,ptr:ek,size:[eg,ey],datatype:K})}}),ni="largerEq",no=factory_factory(ni,["typed","config","matrix","DenseMatrix"],F=>{var{typed:$,config:V,matrix:G,DenseMatrix:H}=F,K=rI({typed:$}),Z=r$({typed:$,DenseMatrix:H}),ee=rE({typed:$,DenseMatrix:H}),et=rA({typed:$}),en=rD({typed:$});return $(ni,{"boolean, boolean":function(F,$){return F>=$},"number, number":function(F,$){return F>=$||number_nearlyEqual(F,$,V.epsilon)},"BigNumber, BigNumber":function(F,$){return F.gte($)||nearlyEqual_nearlyEqual(F,$,V.epsilon)},"Fraction, Fraction":function(F,$){return -1!==F.compare($)},"Complex, Complex":function(){throw TypeError("No ordering relation is defined for complex numbers")},"Unit, Unit":function(F,$){if(!F.equalBase($))throw Error("Cannot compare units with different base");return this(F.value,$.value)},"SparseMatrix, SparseMatrix":function(F,$){return Z(F,$,this)},"SparseMatrix, DenseMatrix":function(F,$){return K($,F,this,!0)},"DenseMatrix, SparseMatrix":function(F,$){return K(F,$,this,!1)},"DenseMatrix, DenseMatrix":function(F,$){return et(F,$,this)},"Array, Array":function(F,$){return this(G(F),G($)).valueOf()},"Array, Matrix":function(F,$){return this(G(F),$)},"Matrix, Array":function(F,$){return this(F,G($))},"SparseMatrix, any":function(F,$){return ee(F,$,this,!1)},"DenseMatrix, any":function(F,$){return en(F,$,this,!1)},"any, SparseMatrix":function(F,$){return ee($,F,this,!0)},"any, DenseMatrix":function(F,$){return en($,F,this,!0)},"Array, any":function(F,$){return en(G(F),$,this,!1).valueOf()},"any, Array":function(F,$){return en(G($),F,this,!0).valueOf()}})});function createSolveValidation(F){var{DenseMatrix:$}=F;return function(F,V,G){var H=F.size();if(2!==H.length)throw RangeError("Matrix must be two dimensional (size: "+string_format(H)+")");var K=H[0];if(K!==H[1])throw RangeError("Matrix must be square (size: "+string_format(H)+")");var Z=[];if(isMatrix(V)){var ee=V.size(),et=V._data;if(1===ee.length){if(ee[0]!==K)throw RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var en=0;en<K;en++)Z[en]=[et[en]];return new $({data:Z,size:[K,1],datatype:V._datatype})}if(2===ee.length){if(ee[0]!==K||1!==ee[1])throw RangeError("Dimension mismatch. Matrix columns must match vector length.");if(isDenseMatrix(V)){if(G){Z=[];for(var ea=0;ea<K;ea++)Z[ea]=[et[ea][0]];return new $({data:Z,size:[K,1],datatype:V._datatype})}return V}if(isSparseMatrix(V)){for(var ei=0;ei<K;ei++)Z[ei]=[0];for(var eo=V._values,es=V._index,eu=V._ptr,ec=eu[1],ep=eu[0];ep<ec;ep++)Z[es[ep]][0]=eo[ep];return new $({data:Z,size:[K,1],datatype:V._datatype})}}throw RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.")}if(ez(V)){var eh=arraySize(V);if(1===eh.length){if(eh[0]!==K)throw RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var ef=0;ef<K;ef++)Z[ef]=[V[ef]];return new $({data:Z,size:[K,1]})}if(2===eh.length){if(eh[0]!==K||1!==eh[1])throw RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var ed=0;ed<K;ed++)Z[ed]=[V[ed][0]];return new $({data:Z,size:[K,1]})}throw RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.")}}}F=>{var{typed:$,equalScalar:V}=F;return function(F,G,H){var K,Z,ee,et,en,ea=F._values,ei=F._index,eo=F._ptr,es=F._size,eu=F._datatype,ec=G._values,ep=G._index,eh=G._ptr,ef=G._size,ed=G._datatype;if(es.length!==ef.length)throw new DimensionError(es.length,ef.length);if(es[0]!==ef[0]||es[1]!==ef[1])throw RangeError("Dimension mismatch. Matrix A ("+es+") must match Matrix B ("+ef+")");if(!ea||!ec)throw Error("Cannot perform operation on Pattern Sparse Matrices");var em=es[0],eg=es[1],ey=V,eb=0,ew=H;"string"==typeof eu&&eu===ed&&(K=eu,ey=$.find(V,[K,K]),eb=$.convert(0,K),ew=$.find(H,[K,K]));for(var eS=[],e_=[],eN=[],ek=[],eI=[],eT=0;eT<eg;eT++){eN[eT]=e_.length;var eC=eT+1;for(ee=eo[eT],et=eo[eT+1],Z=ee;Z<et;Z++)eI[en=ei[Z]]=eC,ek[en]=ea[Z],e_.push(en);for(ee=eh[eT],et=eh[eT+1],Z=ee;Z<et;Z++)eI[en=ep[Z]]===eC&&(ek[en]=ew(ek[en],ec[Z]));for(Z=eN[eT];Z<e_.length;){var eE=ek[en=e_[Z]];ey(eE,eb)?e_.splice(Z,1):(eS.push(eE),Z++)}}return eN[eg]=e_.length,F.createSparseMatrix({values:eS,index:e_,ptr:eN,size:[em,eg],datatype:K})}};var nu="lsolve",nl=(F=>{var{typed:$,matrix:V,divideScalar:G,multiplyScalar:H,subtract:K,equalScalar:Z,DenseMatrix:ee}=F,et=createSolveValidation({DenseMatrix:ee});return $(nu,{"SparseMatrix, Array | Matrix":function(F,$){return _sparseForwardSubstitution(F,$)},"DenseMatrix, Array | Matrix":function(F,$){return _denseForwardSubstitution(F,$)},"Array, Array | Matrix":function(F,$){return _denseForwardSubstitution(V(F),$).valueOf()}});function _denseForwardSubstitution(F,$){for(var V=($=et(F,$,!0))._data,en=F._size[0],ea=F._size[1],ei=[],eo=F._data,es=0;es<ea;es++){var eu=V[es][0]||0,ec=void 0;if(Z(eu,0))ec=0;else{var ep=eo[es][es];if(Z(ep,0))throw Error("Linear system cannot be solved since matrix is singular");ec=G(eu,ep);for(var eh=es+1;eh<en;eh++)V[eh]=[K(V[eh][0]||0,H(ec,eo[eh][es]))]}ei[es]=[ec]}return new ee({data:ei,size:[en,1]})}function _sparseForwardSubstitution(F,$){for(var V=($=et(F,$,!0))._data,en=F._size[0],ea=F._size[1],ei=F._values,eo=F._index,es=F._ptr,eu=[],ec=0;ec<ea;ec++){var ep=V[ec][0]||0;if(Z(ep,0))eu[ec]=[0];else{for(var eh=0,ef=[],ed=[],em=es[ec],eg=es[ec+1],ey=em;ey<eg;ey++){var eb=eo[ey];eb===ec?eh=ei[ey]:eb>ec&&(ef.push(ei[ey]),ed.push(eb))}if(Z(eh,0))throw Error("Linear system cannot be solved since matrix is singular");for(var ew=G(ep,eh),eS=0,e_=ed.length;eS<e_;eS++){var eN=ed[eS];V[eN]=[K(V[eN][0]||0,H(ew,ef[eS]))]}eu[ec]=[ew]}}return new ee({data:eu,size:[en,1]})}},"matrixFromColumns"),np=factory_factory(nl,["typed","matrix","flatten","size"],F=>{var{typed:$,matrix:V,flatten:G,size:H}=F;return $(nl,{"...Array":function(F){return _createArray(F)},"...Matrix":function(F){return V(_createArray(F.map(F=>F.toArray())))}});function _createArray(F){if(0===F.length)throw TypeError("At least one column is needed to construct a matrix.");for(var $=checkVectorTypeAndReturnLength(F[0]),V=[],H=0;H<$;H++)V[H]=[];for(var K of F){var Z=checkVectorTypeAndReturnLength(K);if(Z!==$)throw TypeError("The vectors had different length: "+(0|$)+"  "+(0|Z));for(var ee=G(K),et=0;et<$;et++)V[et].push(ee[et])}return V}function checkVectorTypeAndReturnLength(F){var $=H(F);if(1===$.length)return $[0];if(2===$.length){if(1===$[0])return $[1];if(1===$[1])return $[0];throw TypeError("At least one of the arguments is not a vector.")}throw TypeError("Only one- or two-dimensional vectors are supported.")}}),nh="partitionSelect",nf=factory_factory(nh,["typed","isNumeric","isNaN","compare"],F=>{var{typed:$,isNumeric:V,isNaN:G,compare:H}=F,K=H,desc=(F,$)=>-H(F,$);return $(nh,{"Array | Matrix, number":function(F,$){return _partitionSelect(F,$,K)},"Array | Matrix, number, string":function(F,$,V){if("asc"===V)return _partitionSelect(F,$,K);if("desc"===V)return _partitionSelect(F,$,desc);throw Error('Compare string must be "asc" or "desc"')},"Array | Matrix, number, function":_partitionSelect});function _partitionSelect(F,$,V){if(!isInteger($)||$<0)throw Error("k must be a non-negative integer");if(isMatrix(F)){if(F.size().length>1)throw Error("Only one dimensional matrices supported");return quickSelect(F.valueOf(),$,V)}if(Array.isArray(F))return quickSelect(F,$,V)}function quickSelect(F,$,H){if($>=F.length)throw Error("k out of bounds");for(var K=0;K<F.length;K++)if(V(F[K])&&G(F[K]))return F[K];for(var Z=0,ee=F.length-1;Z<ee;){for(var et=Z,en=ee,ea=F[Math.floor(Math.random()*(ee-Z+1))+Z];et<en;)if(H(F[et],ea)>=0){var ei=F[en];F[en]=F[et],F[et]=ei,--en}else++et;H(F[et],ea)>0&&--et,$<=et?ee=et:Z=et+1}return F[$]}});function ArgumentsError(F,$,V,G){if(!(this instanceof ArgumentsError))throw SyntaxError("Constructor must be called with the new operator");this.fn=F,this.count=$,this.min=V,this.max=G,this.message="Wrong number of arguments in function "+F+" ("+$+" provided, "+V+(null!=G?"-"+G:"")+" expected)",this.stack=Error().stack}ArgumentsError.prototype=Error(),ArgumentsError.prototype.constructor=Error,ArgumentsError.prototype.name="ArgumentsError",ArgumentsError.prototype.isArgumentsError=!0,F=>{var{config:$,matrix:V}=F;return function(F,G,H){if(2!=arguments.length&&3!=arguments.length)throw new ArgumentsError("resize",arguments.length,2,3);if(isMatrix(G)&&(G=G.valueOf()),isBigNumber(G[0])&&(G=G.map(function(F){return isBigNumber(F)?F.toNumber():F})),isMatrix(F))return F.resize(G,H,!0);if("string"==typeof F)return _resizeString(F,G,H);var K=!Array.isArray(F)&&"Array"!==$.matrix;if(0===G.length){for(;Array.isArray(F);)F=F[0];return object_clone(F)}Array.isArray(F)||(F=[F]);var Z=array_resize(F=object_clone(F),G,H);return K?V(Z):Z};function _resizeString(F,$,V){if(void 0!==V){if("string"!=typeof V||1!==V.length)throw TypeError("Single character expected as defaultValue")}else V=" ";if(1!==$.length)throw new DimensionError($.length,1);var G=$[0];if("number"!=typeof G||!isInteger(G))throw TypeError("Invalid size, must contain positive integers (size: "+string_format($)+")");if(F.length>G)return F.substring(0,G);if(!(F.length<G))return F;for(var H=F,K=0,Z=G-F.length;K<Z;K++)H+=V;return H}};var nm="Number of decimals in function round must be an integer",ng="round",ny=factory_factory(ng,["typed","matrix","equalScalar","zeros","BigNumber","DenseMatrix"],F=>{var{typed:$,matrix:V,equalScalar:G,zeros:H,BigNumber:K,DenseMatrix:Z}=F,ee=rC({typed:$,equalScalar:G}),et=rE({typed:$,DenseMatrix:Z}),en=rD({typed:$});return $(ng,{number:roundNumber,"number, number":roundNumber,"number, BigNumber":function(F,$){if(!$.isInteger())throw TypeError(nm);return new K(F).toDecimalPlaces($.toNumber())},Complex:function(F){return F.round()},"Complex, number":function(F,$){if($%1)throw TypeError(nm);return F.round($)},"Complex, BigNumber":function(F,$){if(!$.isInteger())throw TypeError(nm);var V=$.toNumber();return F.round(V)},BigNumber:function(F){return F.toDecimalPlaces(0)},"BigNumber, BigNumber":function(F,$){if(!$.isInteger())throw TypeError(nm);return F.toDecimalPlaces($.toNumber())},Fraction:function(F){return F.round()},"Fraction, number":function(F,$){if($%1)throw TypeError(nm);return F.round($)},"Fraction, BigNumber":function(F,$){if(!$.isInteger())throw TypeError(nm);return F.round($.toNumber())},"Array | Matrix":function(F){return deepMap(F,this,!0)},"SparseMatrix, number | BigNumber":function(F,$){return ee(F,$,this,!1)},"DenseMatrix, number | BigNumber":function(F,$){return en(F,$,this,!1)},"Array, number | BigNumber":function(F,$){return en(V(F),$,this,!1).valueOf()},"number | Complex | BigNumber | Fraction, SparseMatrix":function(F,$){return G(F,0)?H($.size(),$.storage()):et($,F,this,!0)},"number | Complex | BigNumber | Fraction, DenseMatrix":function(F,$){return G(F,0)?H($.size(),$.storage()):en($,F,this,!0)},"number | Complex | BigNumber | Fraction, Array":function(F,$){return en(V($),F,this,!0).valueOf()}})}),nx="smallerEq",nw=factory_factory(nx,["typed","config","matrix","DenseMatrix"],F=>{var{typed:$,config:V,matrix:G,DenseMatrix:H}=F,K=rI({typed:$}),Z=r$({typed:$,DenseMatrix:H}),ee=rE({typed:$,DenseMatrix:H}),et=rA({typed:$}),en=rD({typed:$});return $(nx,{"boolean, boolean":function(F,$){return F<=$},"number, number":function(F,$){return F<=$||number_nearlyEqual(F,$,V.epsilon)},"BigNumber, BigNumber":function(F,$){return F.lte($)||nearlyEqual_nearlyEqual(F,$,V.epsilon)},"Fraction, Fraction":function(F,$){return 1!==F.compare($)},"Complex, Complex":function(){throw TypeError("No ordering relation is defined for complex numbers")},"Unit, Unit":function(F,$){if(!F.equalBase($))throw Error("Cannot compare units with different base");return this(F.value,$.value)},"SparseMatrix, SparseMatrix":function(F,$){return Z(F,$,this)},"SparseMatrix, DenseMatrix":function(F,$){return K($,F,this,!0)},"DenseMatrix, SparseMatrix":function(F,$){return K(F,$,this,!1)},"DenseMatrix, DenseMatrix":function(F,$){return et(F,$,this)},"Array, Array":function(F,$){return this(G(F),G($)).valueOf()},"Array, Matrix":function(F,$){return this(G(F),$)},"Matrix, Array":function(F,$){return this(F,G($))},"SparseMatrix, any":function(F,$){return ee(F,$,this,!1)},"DenseMatrix, any":function(F,$){return en(F,$,this,!1)},"any, SparseMatrix":function(F,$){return ee($,F,this,!0)},"any, DenseMatrix":function(F,$){return en($,F,this,!0)},"Array, any":function(F,$){return en(G(F),$,this,!1).valueOf()},"any, Array":function(F,$){return en(G($),F,this,!0).valueOf()}})}),nS="unequal";F=>{var{typed:$,config:V,equalScalar:G,matrix:H,DenseMatrix:K}=F,Z=rI({typed:$}),ee=r$({typed:$,DenseMatrix:K}),et=rE({typed:$,DenseMatrix:K}),en=rA({typed:$}),ea=rD({typed:$});return $("unequal",{"any, any":function(F,$){return null===F?null!==$:null===$?null!==F:void 0===F?void 0!==$:void 0===$?void 0!==F:_unequal(F,$)},"SparseMatrix, SparseMatrix":function(F,$){return ee(F,$,_unequal)},"SparseMatrix, DenseMatrix":function(F,$){return Z($,F,_unequal,!0)},"DenseMatrix, SparseMatrix":function(F,$){return Z(F,$,_unequal,!1)},"DenseMatrix, DenseMatrix":function(F,$){return en(F,$,_unequal)},"Array, Array":function(F,$){return this(H(F),H($)).valueOf()},"Array, Matrix":function(F,$){return this(H(F),$)},"Matrix, Array":function(F,$){return this(F,H($))},"SparseMatrix, any":function(F,$){return et(F,$,_unequal,!1)},"DenseMatrix, any":function(F,$){return ea(F,$,_unequal,!1)},"any, SparseMatrix":function(F,$){return et($,F,_unequal,!0)},"any, DenseMatrix":function(F,$){return ea($,F,_unequal,!0)},"Array, any":function(F,$){return ea(H(F),$,_unequal,!1).valueOf()},"any, Array":function(F,$){return ea(H($),F,_unequal,!0).valueOf()}});function _unequal(F,$){return!G(F,$)}},factory_factory(nS,["typed","equalScalar"],F=>{var{typed:$,equalScalar:V}=F;return $(nS,{"any, any":function(F,$){return null===F?null!==$:null===$?null!==F:void 0===F?void 0!==$:void 0===$?void 0!==F:!V(F,$)}})});var n_="usolve",nN=factory_factory(n_,["typed","matrix","divideScalar","multiplyScalar","subtract","equalScalar","DenseMatrix"],F=>{var{typed:$,matrix:V,divideScalar:G,multiplyScalar:H,subtract:K,equalScalar:Z,DenseMatrix:ee}=F,et=createSolveValidation({DenseMatrix:ee});return $(n_,{"SparseMatrix, Array | Matrix":function(F,$){return _sparseBackwardSubstitution(F,$)},"DenseMatrix, Array | Matrix":function(F,$){return _denseBackwardSubstitution(F,$)},"Array, Array | Matrix":function(F,$){return _denseBackwardSubstitution(V(F),$).valueOf()}});function _denseBackwardSubstitution(F,$){for(var V=($=et(F,$,!0))._data,en=F._size[0],ea=F._size[1],ei=[],eo=F._data,es=ea-1;es>=0;es--){var eu=V[es][0]||0,ec=void 0;if(Z(eu,0))ec=0;else{var ep=eo[es][es];if(Z(ep,0))throw Error("Linear system cannot be solved since matrix is singular");ec=G(eu,ep);for(var eh=es-1;eh>=0;eh--)V[eh]=[K(V[eh][0]||0,H(ec,eo[eh][es]))]}ei[es]=[ec]}return new ee({data:ei,size:[en,1]})}function _sparseBackwardSubstitution(F,$){for(var V=($=et(F,$,!0))._data,en=F._size[0],ea=F._size[1],ei=F._values,eo=F._index,es=F._ptr,eu=[],ec=ea-1;ec>=0;ec--){var ep=V[ec][0]||0;if(Z(ep,0))eu[ec]=[0];else{for(var eh=0,ef=[],ed=[],em=es[ec],eg=es[ec+1],ey=eg-1;ey>=em;ey--){var eb=eo[ey];eb===ec?eh=ei[ey]:eb<ec&&(ef.push(ei[ey]),ed.push(eb))}if(Z(eh,0))throw Error("Linear system cannot be solved since matrix is singular");for(var ew=G(ep,eh),eS=0,e_=ed.length;eS<e_;eS++){var eN=ed[eS];V[eN]=[K(V[eN][0],H(ew,ef[eS]))]}eu[ec]=[ew]}}return new ee({data:eu,size:[en,1]})}}),nk="add",nI=factory_factory(nk,["typed","matrix","addScalar","equalScalar","DenseMatrix","SparseMatrix"],F=>{var{typed:$,matrix:V,addScalar:G,equalScalar:H,DenseMatrix:K,SparseMatrix:Z}=F,ee=rR({typed:$}),et=nn({typed:$,equalScalar:H}),en=rj({typed:$,DenseMatrix:K}),ea=rA({typed:$}),ei=rD({typed:$});return $(nk,extend({"DenseMatrix, DenseMatrix":function(F,$){return ea(F,$,G)},"DenseMatrix, SparseMatrix":function(F,$){return ee(F,$,G,!1)},"SparseMatrix, DenseMatrix":function(F,$){return ee($,F,G,!0)},"SparseMatrix, SparseMatrix":function(F,$){return et(F,$,G)},"Array, Array":function(F,$){return this(V(F),V($)).valueOf()},"Array, Matrix":function(F,$){return this(V(F),$)},"Matrix, Array":function(F,$){return this(F,V($))},"DenseMatrix, any":function(F,$){return ei(F,$,G,!1)},"SparseMatrix, any":function(F,$){return en(F,$,G,!1)},"any, DenseMatrix":function(F,$){return ei($,F,G,!0)},"any, SparseMatrix":function(F,$){return en($,F,G,!0)},"Array, any":function(F,$){return ei(V(F),$,G,!1).valueOf()},"any, Array":function(F,$){return ei(V($),F,G,!0).valueOf()},"any, any":G,"any, any, ...any":function(F,$,V){for(var G=this(F,$),H=0;H<V.length;H++)G=this(G,V[H]);return G}},G.signatures))}),nT=(F=>{var{typed:$,equalScalar:V}=F;return function(F,G,H){var K,Z,ee,et,en,ea,ei=F._values,eo=F._index,es=F._ptr,eu=F._size,ec=F._datatype,ep=G._values,eh=G._index,ef=G._ptr,ed=G._size,em=G._datatype;if(eu.length!==ed.length)throw new DimensionError(eu.length,ed.length);if(eu[0]!==ed[0]||eu[1]!==ed[1])throw RangeError("Dimension mismatch. Matrix A ("+eu+") must match Matrix B ("+ed+")");var eg=eu[0],ey=eu[1],eb=V,ew=0,eS=H;"string"==typeof ec&&ec===em&&(K=ec,eb=$.find(V,[K,K]),ew=$.convert(0,K),eS=$.find(H,[K,K]));var e_=ei&&ep?[]:void 0,eN=[],ek=[],eI=e_?[]:void 0,eT=[];for(ee=0;ee<ey;ee++){ek[ee]=eN.length;var eC=ee+1;if(eI)for(en=ef[ee],ea=ef[ee+1],et=en;et<ea;et++)eT[Z=eh[et]]=eC,eI[Z]=ep[et];for(en=es[ee],ea=es[ee+1],et=en;et<ea;et++)if(Z=eo[et],eI){var eE=eT[Z]===eC?eI[Z]:ew,eA=eS(ei[et],eE);eb(eA,ew)||(eN.push(Z),e_.push(eA))}else eN.push(Z)}return ek[ey]=eN.length,F.createSparseMatrix({values:e_,index:eN,ptr:ek,size:[eg,ey],datatype:K})}},V(63228)),nC="compareNatural",nE=factory_factory(nC,["typed","compare"],F=>{var{typed:$,compare:V}=F,G=V.signatures["boolean,boolean"];return $(nC,{"any, any":function(F,$){var H,K=typeOf(F),Z=typeOf($);if(("number"===K||"BigNumber"===K||"Fraction"===K)&&("number"===Z||"BigNumber"===Z||"Fraction"===Z))return"0"!==(H=V(F,$)).toString()?H>0?1:-1:nT(K,Z);if("Array"===K||"Matrix"===K||"Array"===Z||"Matrix"===Z)return 0!==(H=compareMatricesAndArrays(this,F,$))?H:nT(K,Z);if(K!==Z)return nT(K,Z);if("Complex"===K)return compareComplexNumbers(F,$);if("Unit"===K)return F.equalBase($)?this(F.value,$.value):compareArrays(this,F.formatUnits(),$.formatUnits());if("boolean"===K)return G(F,$);if("string"===K)return nT(F,$);if("Object"===K)return compareObjects(this,F,$);if("null"===K||"undefined"===K)return 0;throw TypeError('Unsupported type of value "'+K+'"')}});function compareMatricesAndArrays(F,$,V){return isSparseMatrix($)&&isSparseMatrix(V)?compareArrays(F,$.toJSON().values,V.toJSON().values):isSparseMatrix($)?compareMatricesAndArrays(F,$.toArray(),V):isSparseMatrix(V)?compareMatricesAndArrays(F,$,V.toArray()):isDenseMatrix($)?compareMatricesAndArrays(F,$.toJSON().data,V):isDenseMatrix(V)?compareMatricesAndArrays(F,$,V.toJSON().data):Array.isArray($)?Array.isArray(V)?compareArrays(F,$,V):compareMatricesAndArrays(F,$,[V]):compareMatricesAndArrays(F,[$],V)}function compareArrays(F,$,V){for(var G=0,H=Math.min($.length,V.length);G<H;G++){var K=F($[G],V[G]);if(0!==K)return K}return $.length>V.length?1:$.length<V.length?-1:0}function compareObjects(F,$,V){var G=Object.keys($),H=Object.keys(V);G.sort(nT),H.sort(nT);var K=compareArrays(F,G,H);if(0!==K)return K;for(var Z=0;Z<G.length;Z++){var ee=F($[G[Z]],V[H[Z]]);if(0!==ee)return ee}return 0}});function compareComplexNumbers(F,$){return F.re>$.re?1:F.re<$.re?-1:F.im>$.im?1:F.im<$.im?-1:0}var nA="deepEqual",nD="dot",nM=factory_factory(nD,["typed","addScalar","multiplyScalar","conj","size"],F=>{var{typed:$,addScalar:V,multiplyScalar:G,conj:H,size:K}=F;return $(nD,{"Array | DenseMatrix, Array | DenseMatrix":_denseDot,"SparseMatrix, SparseMatrix":_sparseDot});function _validateDim(F,$){var V,G,H=_size(F),K=_size($);if(1===H.length)V=H[0];else if(2===H.length&&1===H[1])V=H[0];else throw RangeError("Expected a column vector, instead got a matrix of size ("+H.join(", ")+")");if(1===K.length)G=K[0];else if(2===K.length&&1===K[1])G=K[0];else throw RangeError("Expected a column vector, instead got a matrix of size ("+K.join(", ")+")");if(V!==G)throw RangeError("Vectors must have equal length ("+V+" != "+G+")");if(0===V)throw RangeError("Cannot calculate the dot product of empty vectors");return V}function _denseDot(F,K){var Z=_validateDim(F,K),ee=isMatrix(F)?F._data:F,et=isMatrix(F)?F._datatype:void 0,en=isMatrix(K)?K._data:K,ea=isMatrix(K)?K._datatype:void 0,ei=2===_size(F).length,eo=2===_size(K).length,es=V,eu=G;if(et&&ea&&et===ea&&"string"==typeof et){var ec=et;es=$.find(V,[ec,ec]),eu=$.find(G,[ec,ec])}if(!ei&&!eo){for(var ep=eu(H(ee[0]),en[0]),eh=1;eh<Z;eh++)ep=es(ep,eu(H(ee[eh]),en[eh]));return ep}if(!ei&&eo){for(var ef=eu(H(ee[0]),en[0][0]),ed=1;ed<Z;ed++)ef=es(ef,eu(H(ee[ed]),en[ed][0]));return ef}if(ei&&!eo){for(var em=eu(H(ee[0][0]),en[0]),eg=1;eg<Z;eg++)em=es(em,eu(H(ee[eg][0]),en[eg]));return em}if(ei&&eo){for(var ey=eu(H(ee[0][0]),en[0][0]),eb=1;eb<Z;eb++)ey=es(ey,eu(H(ee[eb][0]),en[eb][0]));return ey}}function _sparseDot(F,$){_validateDim(F,$);for(var H=F._index,K=F._values,Z=$._index,ee=$._values,et=0,en=V,ea=G,ei=0,eo=0;ei<H.length&&eo<Z.length;){var es=H[ei],eu=Z[eo];if(es<eu){ei++;continue}if(es>eu){eo++;continue}es===eu&&(et=en(et,ea(K[ei],ee[eo])),ei++,eo++)}return et}function _size(F){return isMatrix(F)?F.size():K(F)}}),nR="floor",nF=["typed","config","round","matrix","equalScalar","zeros","DenseMatrix"],nO=factory_factory(nR,["typed","config","round"],F=>{var{typed:$,config:V,round:G}=F;return $(nR,{number:function(F){return number_nearlyEqual(F,G(F),V.epsilon)?G(F):Math.floor(F)},"number, number":function(F,$){if(number_nearlyEqual(F,G(F,$),V.epsilon))return G(F,$);var[H,K]="".concat(F,"e").split("e"),Z=Math.floor(Number("".concat(H,"e").concat(Number(K)+$)));return[H,K]="".concat(Z,"e").split("e"),Number("".concat(H,"e").concat(Number(K)-$))}})}),nP=factory_factory(nR,nF,F=>{var{typed:$,config:V,round:G,matrix:H,equalScalar:K,zeros:Z,DenseMatrix:ee}=F,et=rC({typed:$,equalScalar:K}),en=rE({typed:$,DenseMatrix:ee}),ea=rD({typed:$}),ei=nO({typed:$,config:V,round:G});return $("floor",{number:ei.signatures.number,"number,number":ei.signatures["number,number"],Complex:function(F){return F.floor()},"Complex, number":function(F,$){return F.floor($)},"Complex, BigNumber":function(F,$){return F.floor($.toNumber())},BigNumber:function(F){return nearlyEqual_nearlyEqual(F,G(F),V.epsilon)?G(F):F.floor()},"BigNumber, BigNumber":function(F,$){return nearlyEqual_nearlyEqual(F,G(F,$),V.epsilon)?G(F,$):F.toDecimalPlaces($.toNumber(),eL.ROUND_FLOOR)},Fraction:function(F){return F.floor()},"Fraction, number":function(F,$){return F.floor($)},"Fraction, BigNumber":function(F,$){return F.floor($.toNumber())},"Array | Matrix":function(F){return deepMap(F,this,!0)},"Array, number | BigNumber":function(F,$){return deepMap(F,F=>this(F,$),!0)},"SparseMatrix, number | BigNumber":function(F,$){return et(F,$,this,!1)},"DenseMatrix, number | BigNumber":function(F,$){return ea(F,$,this,!1)},"number | Complex | Fraction | BigNumber, Array":function(F,$){return ea(H($),F,this,!0).valueOf()},"number | Complex | Fraction | BigNumber, Matrix":function(F,$){return K(F,0)?Z($.size(),$.storage()):"dense"===$.storage()?ea($,F,this,!0):en($,F,this,!0)}})}),nB="identity",n$=factory_factory(nB,["typed","config","matrix","BigNumber","DenseMatrix","SparseMatrix"],F=>{var{typed:$,config:V,matrix:G,BigNumber:H,DenseMatrix:K,SparseMatrix:Z}=F;return $(nB,{"":function(){return"Matrix"===V.matrix?G([]):[]},string:function(F){return G(F)},"number | BigNumber":function(F){return _identity(F,F,"Matrix"===V.matrix?"dense":void 0)},"number | BigNumber, string":function(F,$){return _identity(F,F,$)},"number | BigNumber, number | BigNumber":function(F,$){return _identity(F,$,"Matrix"===V.matrix?"dense":void 0)},"number | BigNumber, number | BigNumber, string":function(F,$,V){return _identity(F,$,V)},Array:function(F){return _identityVector(F)},"Array, string":function(F,$){return _identityVector(F,$)},Matrix:function(F){return _identityVector(F.valueOf(),F.storage())},"Matrix, string":function(F,$){return _identityVector(F.valueOf(),$)}});function _identityVector(F,$){switch(F.length){case 0:return $?G($):[];case 1:return _identity(F[0],F[0],$);case 2:return _identity(F[0],F[1],$);default:throw Error("Vector containing two values expected")}}function _identity(F,$,V){var G=isBigNumber(F)||isBigNumber($)?H:null;if(isBigNumber(F)&&(F=F.toNumber()),isBigNumber($)&&($=$.toNumber()),!isInteger(F)||F<1||!isInteger($)||$<1)throw Error("Parameters in function identity must be positive integers");var ee=G?new H(1):1,et=G?new G(0):0,en=[F,$];if(V){if("sparse"===V)return Z.diagonal(en,ee,0,et);if("dense"===V)return K.diagonal(en,ee,0,et);throw TypeError('Unknown matrix type "'.concat(V,'"'))}for(var ea=array_resize([],en,et),ei=F<$?F:$,eo=0;eo<ei;eo++)ea[eo][eo]=ee;return ea}}),nL="larger",nV=factory_factory(nL,["typed","config","matrix","DenseMatrix"],F=>{var{typed:$,config:V,matrix:G,DenseMatrix:H}=F,K=rI({typed:$}),Z=r$({typed:$,DenseMatrix:H}),ee=rE({typed:$,DenseMatrix:H}),et=rA({typed:$}),en=rD({typed:$});return $(nL,{"boolean, boolean":function(F,$){return F>$},"number, number":function(F,$){return F>$&&!number_nearlyEqual(F,$,V.epsilon)},"BigNumber, BigNumber":function(F,$){return F.gt($)&&!nearlyEqual_nearlyEqual(F,$,V.epsilon)},"Fraction, Fraction":function(F,$){return 1===F.compare($)},"Complex, Complex":function(){throw TypeError("No ordering relation is defined for complex numbers")},"Unit, Unit":function(F,$){if(!F.equalBase($))throw Error("Cannot compare units with different base");return this(F.value,$.value)},"SparseMatrix, SparseMatrix":function(F,$){return Z(F,$,this)},"SparseMatrix, DenseMatrix":function(F,$){return K($,F,this,!0)},"DenseMatrix, SparseMatrix":function(F,$){return K(F,$,this,!1)},"DenseMatrix, DenseMatrix":function(F,$){return et(F,$,this)},"Array, Array":function(F,$){return this(G(F),G($)).valueOf()},"Array, Matrix":function(F,$){return this(G(F),$)},"Matrix, Array":function(F,$){return this(F,G($))},"SparseMatrix, any":function(F,$){return ee(F,$,this,!1)},"DenseMatrix, any":function(F,$){return en(F,$,this,!1)},"any, SparseMatrix":function(F,$){return ee($,F,this,!0)},"any, DenseMatrix":function(F,$){return en($,F,this,!0)},"Array, any":function(F,$){return en(G(F),$,this,!1).valueOf()},"any, Array":function(F,$){return en(G($),F,this,!0).valueOf()}})}),nU="log",nW="multiply",nj=factory_factory(nW,["typed","matrix","addScalar","multiplyScalar","equalScalar","dot"],F=>{var{typed:$,matrix:V,addScalar:G,multiplyScalar:H,equalScalar:K,dot:Z}=F,ee=rC({typed:$,equalScalar:K}),et=rD({typed:$});function _validateMatrixDimensions(F,$){switch(F.length){case 1:switch($.length){case 1:if(F[0]!==$[0])throw RangeError("Dimension mismatch in multiplication. Vectors must have the same length");break;case 2:if(F[0]!==$[0])throw RangeError("Dimension mismatch in multiplication. Vector length ("+F[0]+") must match Matrix rows ("+$[0]+")");break;default:throw Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+$.length+" dimensions)")}break;case 2:switch($.length){case 1:if(F[1]!==$[0])throw RangeError("Dimension mismatch in multiplication. Matrix columns ("+F[1]+") must match Vector length ("+$[0]+")");break;case 2:if(F[1]!==$[0])throw RangeError("Dimension mismatch in multiplication. Matrix A columns ("+F[1]+") must match Matrix B rows ("+$[0]+")");break;default:throw Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+$.length+" dimensions)")}break;default:throw Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has "+F.length+" dimensions)")}}function _multiplyVectorVector(F,$,V){if(0===V)throw Error("Cannot multiply two empty vectors");return Z(F,$)}function _multiplyVectorMatrix(F,$){if("dense"!==$.storage())throw Error("Support for SparseMatrix not implemented");return _multiplyVectorDenseMatrix(F,$)}function _multiplyVectorDenseMatrix(F,V){var K,Z=F._data,ee=F._size,et=F._datatype,en=V._data,ea=V._size,ei=V._datatype,eo=ee[0],es=ea[1],eu=G,ec=H;et&&ei&&et===ei&&"string"==typeof et&&(K=et,eu=$.find(G,[K,K]),ec=$.find(H,[K,K]));for(var ep=[],eh=0;eh<es;eh++){for(var ef=ec(Z[0],en[0][eh]),ed=1;ed<eo;ed++)ef=eu(ef,ec(Z[ed],en[ed][eh]));ep[eh]=ef}return F.createDenseMatrix({data:ep,size:[es],datatype:K})}var en=$("_multiplyMatrixVector",{"DenseMatrix, any":_multiplyDenseMatrixVector,"SparseMatrix, any":_multiplySparseMatrixVector}),ea=$("_multiplyMatrixMatrix",{"DenseMatrix, DenseMatrix":_multiplyDenseMatrixDenseMatrix,"DenseMatrix, SparseMatrix":_multiplyDenseMatrixSparseMatrix,"SparseMatrix, DenseMatrix":_multiplySparseMatrixDenseMatrix,"SparseMatrix, SparseMatrix":_multiplySparseMatrixSparseMatrix});function _multiplyDenseMatrixVector(F,V){var K,Z=F._data,ee=F._size,et=F._datatype,en=V._data,ea=V._datatype,ei=ee[0],eo=ee[1],es=G,eu=H;et&&ea&&et===ea&&"string"==typeof et&&(K=et,es=$.find(G,[K,K]),eu=$.find(H,[K,K]));for(var ec=[],ep=0;ep<ei;ep++){for(var eh=Z[ep],ef=eu(eh[0],en[0]),ed=1;ed<eo;ed++)ef=es(ef,eu(eh[ed],en[ed]));ec[ep]=ef}return F.createDenseMatrix({data:ec,size:[ei],datatype:K})}function _multiplyDenseMatrixDenseMatrix(F,V){var K,Z=F._data,ee=F._size,et=F._datatype,en=V._data,ea=V._size,ei=V._datatype,eo=ee[0],es=ee[1],eu=ea[1],ec=G,ep=H;et&&ei&&et===ei&&"string"==typeof et&&(K=et,ec=$.find(G,[K,K]),ep=$.find(H,[K,K]));for(var eh=[],ef=0;ef<eo;ef++){var ed=Z[ef];eh[ef]=[];for(var em=0;em<eu;em++){for(var eg=ep(ed[0],en[0][em]),ey=1;ey<es;ey++)eg=ec(eg,ep(ed[ey],en[ey][em]));eh[ef][em]=eg}}return F.createDenseMatrix({data:eh,size:[eo,eu],datatype:K})}function _multiplyDenseMatrixSparseMatrix(F,V){var Z,ee=F._data,et=F._size,en=F._datatype,ea=V._values,ei=V._index,eo=V._ptr,es=V._size,eu=V._datatype;if(!ea)throw Error("Cannot multiply Dense Matrix times Pattern only Matrix");var ec=et[0],ep=es[1],eh=G,ef=H,ed=K,em=0;en&&eu&&en===eu&&"string"==typeof en&&(Z=en,eh=$.find(G,[Z,Z]),ef=$.find(H,[Z,Z]),ed=$.find(K,[Z,Z]),em=$.convert(0,Z));for(var eg=[],ey=[],eb=[],ew=V.createSparseMatrix({values:eg,index:ey,ptr:eb,size:[ec,ep],datatype:Z}),eS=0;eS<ep;eS++){eb[eS]=ey.length;var e_=eo[eS],eN=eo[eS+1];if(eN>e_)for(var ek=0,eI=0;eI<ec;eI++){for(var eT=eI+1,eC=void 0,eE=e_;eE<eN;eE++){var eA=ei[eE];ek!==eT?(eC=ef(ee[eI][eA],ea[eE]),ek=eT):eC=eh(eC,ef(ee[eI][eA],ea[eE]))}ek!==eT||ed(eC,em)||(ey.push(eI),eg.push(eC))}}return eb[ep]=ey.length,ew}function _multiplySparseMatrixVector(F,V){var Z,ee=F._values,et=F._index,en=F._ptr,ea=F._datatype;if(!ee)throw Error("Cannot multiply Pattern only Matrix times Dense Matrix");var ei=V._data,eo=V._datatype,es=F._size[0],eu=V._size[0],ec=[],ep=[],eh=[],ef=G,ed=H,em=K,eg=0;ea&&eo&&ea===eo&&"string"==typeof ea&&(Z=ea,ef=$.find(G,[Z,Z]),ed=$.find(H,[Z,Z]),em=$.find(K,[Z,Z]),eg=$.convert(0,Z));var ey=[],eb=[];eh[0]=0;for(var ew=0;ew<eu;ew++){var eS=ei[ew];if(!em(eS,eg))for(var e_=en[ew],eN=en[ew+1],ek=e_;ek<eN;ek++){var eI=et[ek];eb[eI]?ey[eI]=ef(ey[eI],ed(eS,ee[ek])):(eb[eI]=!0,ep.push(eI),ey[eI]=ed(eS,ee[ek]))}}for(var eT=ep.length,eC=0;eC<eT;eC++){var eE=ep[eC];ec[eC]=ey[eE]}return eh[1]=ep.length,F.createSparseMatrix({values:ec,index:ep,ptr:eh,size:[es,1],datatype:Z})}function _multiplySparseMatrixDenseMatrix(F,V){var Z,ee=F._values,et=F._index,en=F._ptr,ea=F._datatype;if(!ee)throw Error("Cannot multiply Pattern only Matrix times Dense Matrix");var ei=V._data,eo=V._datatype,es=F._size[0],eu=V._size[0],ec=V._size[1],ep=G,eh=H,ef=K,ed=0;ea&&eo&&ea===eo&&"string"==typeof ea&&(Z=ea,ep=$.find(G,[Z,Z]),eh=$.find(H,[Z,Z]),ef=$.find(K,[Z,Z]),ed=$.convert(0,Z));for(var em=[],eg=[],ey=[],eb=F.createSparseMatrix({values:em,index:eg,ptr:ey,size:[es,ec],datatype:Z}),ew=[],eS=[],e_=0;e_<ec;e_++){ey[e_]=eg.length;for(var eN=e_+1,ek=0;ek<eu;ek++){var eI=ei[ek][e_];if(!ef(eI,ed))for(var eT=en[ek],eC=en[ek+1],eE=eT;eE<eC;eE++){var eA=et[eE];eS[eA]!==eN?(eS[eA]=eN,eg.push(eA),ew[eA]=eh(eI,ee[eE])):ew[eA]=ep(ew[eA],eh(eI,ee[eE]))}}for(var eD=ey[e_],eM=eg.length,eR=eD;eR<eM;eR++){var eF=eg[eR];em[eR]=ew[eF]}}return ey[ec]=eg.length,eb}function _multiplySparseMatrixSparseMatrix(F,V){var K,Z,ee,et,en,ea,ei,eo,es,eu=F._values,ec=F._index,ep=F._ptr,eh=F._datatype,ef=V._values,ed=V._index,em=V._ptr,eg=V._datatype,ey=F._size[0],eb=V._size[1],ew=eu&&ef,eS=G,e_=H;eh&&eg&&eh===eg&&"string"==typeof eh&&(K=eh,eS=$.find(G,[K,K]),e_=$.find(H,[K,K]));for(var eN=ew?[]:void 0,ek=[],eI=[],eT=F.createSparseMatrix({values:eN,index:ek,ptr:eI,size:[ey,eb],datatype:K}),eC=ew?[]:void 0,eE=[],eA=0;eA<eb;eA++){eI[eA]=ek.length;var eD=eA+1;for(ea=em[eA],ei=em[eA+1],en=ea;en<ei;en++)if(es=ed[en],ew)for(ee=ep[es],et=ep[es+1],Z=ee;Z<et;Z++)eE[eo=ec[Z]]!==eD?(eE[eo]=eD,ek.push(eo),eC[eo]=e_(ef[en],eu[Z])):eC[eo]=eS(eC[eo],e_(ef[en],eu[Z]));else for(ee=ep[es],et=ep[es+1],Z=ee;Z<et;Z++)eE[eo=ec[Z]]!==eD&&(eE[eo]=eD,ek.push(eo));if(ew)for(var eM=eI[eA],eR=ek.length,eF=eM;eF<eR;eF++){var eO=ek[eF];eN[eF]=eC[eO]}}return eI[eb]=ek.length,eT}return $(nW,extend({"Array, Array":function(F,$){_validateMatrixDimensions(arraySize(F),arraySize($));var G=this(V(F),V($));return isMatrix(G)?G.valueOf():G},"Matrix, Matrix":function(F,$){var V=F.size(),G=$.size();return(_validateMatrixDimensions(V,G),1===V.length)?1===G.length?_multiplyVectorVector(F,$,V[0]):_multiplyVectorMatrix(F,$):1===G.length?en(F,$):ea(F,$)},"Matrix, Array":function(F,$){return this(F,V($))},"Array, Matrix":function(F,$){return this(V(F,$.storage()),$)},"SparseMatrix, any":function(F,$){return ee(F,$,H,!1)},"DenseMatrix, any":function(F,$){return et(F,$,H,!1)},"any, SparseMatrix":function(F,$){return ee($,F,H,!0)},"any, DenseMatrix":function(F,$){return et($,F,H,!0)},"Array, any":function(F,$){return et(V(F),$,H,!1).valueOf()},"any, Array":function(F,$){return et(V($),F,H,!0).valueOf()},"any, any":H,"any, any, ...any":function(F,$,V){for(var G=this(F,$),H=0;H<V.length;H++)G=this(G,V[H]);return G}},H.signatures))}),nG="qr",nq=factory_factory(nG,["typed","matrix","zeros","identity","isZero","equal","sign","sqrt","conj","unaryMinus","addScalar","divideScalar","multiplyScalar","subtract","complex"],F=>{var{typed:$,matrix:V,zeros:G,identity:H,isZero:K,equal:Z,sign:ee,sqrt:et,conj:en,unaryMinus:ea,addScalar:ei,divideScalar:eo,multiplyScalar:es,subtract:eu,complex:ec}=F;return _extends($(nG,{DenseMatrix:function(F){return _denseQR(F)},SparseMatrix:function(F){return _sparseQR(F)},Array:function(F){var $=_denseQR(V(F));return{Q:$.Q.valueOf(),R:$.R.valueOf()}}}),{_denseQRimpl});function _denseQRimpl(F){var $,V,ec,ep=F._size[0],eh=F._size[1],ef=H([ep],"dense"),ed=ef._data,em=F.clone(),eg=em._data,ey=G([ep],"");for(ec=0;ec<Math.min(eh,ep);++ec){var eb=eg[ec][ec],ew=ea(Z(eb,0)?1:ee(eb)),eS=en(ew),e_=0;for($=ec;$<ep;$++)e_=ei(e_,es(eg[$][ec],en(eg[$][ec])));var eN=es(ew,et(e_));if(!K(eN)){var ek=eu(eb,eN);for(ey[ec]=1,$=ec+1;$<ep;$++)ey[$]=eo(eg[$][ec],ek);var eI=ea(en(eo(ek,eN))),eT=void 0;for(V=ec;V<eh;V++){for(eT=0,$=ec;$<ep;$++)eT=ei(eT,es(en(ey[$]),eg[$][V]));for(eT=es(eT,eI),$=ec;$<ep;$++)eg[$][V]=es(eu(eg[$][V],es(ey[$],eT)),eS)}for($=0;$<ep;$++){for(eT=0,V=ec;V<ep;V++)eT=ei(eT,es(ed[$][V],ey[V]));for(eT=es(eT,eI),V=ec;V<ep;++V)ed[$][V]=eo(eu(ed[$][V],es(eT,en(ey[V]))),eS)}}}return{Q:ef,R:em,toString:function(){return"Q: "+this.Q.toString()+"\nR: "+this.R.toString()}}}function _denseQR(F){var $=_denseQRimpl(F),V=$.R._data;if(F._data.length>0)for(var G="Complex"===V[0][0].type?ec(0):0,H=0;H<V.length;++H)for(var K=0;K<H&&K<(V[0]||[]).length;++K)V[H][K]=G;return $}function _sparseQR(F){throw Error("qr not implemented for sparse matrices yet")}}),nH="range",nX=factory_factory(nH,["typed","config","?matrix","?bignumber","smaller","smallerEq","larger","largerEq"],F=>{var{typed:$,config:V,matrix:G,bignumber:H,smaller:K,smallerEq:Z,larger:ee,largerEq:et}=F;return $(nH,{string:_strRange,"string, boolean":_strRange,"number, number":function(F,$){return _out(_rangeEx(F,$,1))},"number, number, number":function(F,$,V){return _out(_rangeEx(F,$,V))},"number, number, boolean":function(F,$,V){return V?_out(_rangeInc(F,$,1)):_out(_rangeEx(F,$,1))},"number, number, number, boolean":function(F,$,V,G){return G?_out(_rangeInc(F,$,V)):_out(_rangeEx(F,$,V))},"BigNumber, BigNumber":function(F,$){var V=F.constructor;return _out(_bigRangeEx(F,$,new V(1)))},"BigNumber, BigNumber, BigNumber":function(F,$,V){return _out(_bigRangeEx(F,$,V))},"BigNumber, BigNumber, boolean":function(F,$,V){var G=F.constructor;return V?_out(_bigRangeInc(F,$,new G(1))):_out(_bigRangeEx(F,$,new G(1)))},"BigNumber, BigNumber, BigNumber, boolean":function(F,$,V,G){return G?_out(_bigRangeInc(F,$,V)):_out(_bigRangeEx(F,$,V))}});function _out(F){return"Matrix"===V.matrix?G?G(F):noMatrix():F}function _strRange(F,$){var G,K=_parse(F);if(!K)throw SyntaxError('String "'+F+'" is no valid range');return"BigNumber"===V.number?(void 0===H&&noBignumber(),_out((G=$?_bigRangeInc:_bigRangeEx)(H(K.start),H(K.end),H(K.step)))):_out((G=$?_rangeInc:_rangeEx)(K.start,K.end,K.step))}function _rangeEx(F,$,V){var G=[],H=F;if(V>0)for(;K(H,$);)G.push(H),H+=V;else if(V<0)for(;ee(H,$);)G.push(H),H+=V;return G}function _rangeInc(F,$,V){var G=[],H=F;if(V>0)for(;Z(H,$);)G.push(H),H+=V;else if(V<0)for(;et(H,$);)G.push(H),H+=V;return G}function _bigRangeEx(F,$,V){var G=H(0),Z=[],et=F;if(V.gt(G))for(;K(et,$);)Z.push(et),et=et.plus(V);else if(V.lt(G))for(;ee(et,$);)Z.push(et),et=et.plus(V);return Z}function _bigRangeInc(F,$,V){var G=H(0),K=[],ee=F;if(V.gt(G))for(;Z(ee,$);)K.push(ee),ee=ee.plus(V);else if(V.lt(G))for(;et(ee,$);)K.push(ee),ee=ee.plus(V);return K}function _parse(F){var $=F.split(":").map(function(F){return Number(F)});if($.some(function(F){return isNaN(F)}))return null;switch($.length){case 2:return{start:$[0],end:$[1],step:1};case 3:return{start:$[0],end:$[2],step:$[1]};default:return null}}});function csPermute(F,$,V,G){for(var H=F._values,K=F._index,Z=F._ptr,ee=F._size,et=F._datatype,en=ee[0],ea=ee[1],ei=G&&F._values?[]:null,eo=[],es=[],eu=0,ec=0;ec<ea;ec++){es[ec]=eu;for(var ep=V?V[ec]:ec,eh=Z[ep],ef=Z[ep+1],ed=eh;ed<ef;ed++){var em=$?$[K[ed]]:K[ed];eo[eu]=em,ei&&(ei[eu]=H[ed]),eu++}}return es[ea]=eu,F.createSparseMatrix({values:ei,index:eo,ptr:es,size:[en,ea],datatype:et})}function csTdfs(F,$,V,G,H,K,Z){var ee=0;for(V[Z]=F;ee>=0;){var et=V[Z+ee],en=V[G+et];-1===en?(ee--,K[$++]=et):(V[G+et]=V[H+en],V[Z+ ++ee]=en)}return $}function csPost(F,$){if(!F)return null;var V,G=0,H=[],K=[],Z=0,ee=$,et=2*$;for(V=0;V<$;V++)K[Z+V]=-1;for(V=$-1;V>=0;V--)-1!==F[V]&&(K[ee+V]=K[Z+F[V]],K[Z+F[V]]=V);for(V=0;V<$;V++)-1===F[V]&&(G=csTdfs(V,G,K,Z,ee,H,et));return H}function csEtree(F,$){if(!F)return null;var V,G,H=F._index,K=F._ptr,Z=F._size,ee=Z[0],et=Z[1],en=[],ea=[],ei=0,eo=et;if($)for(V=0;V<ee;V++)ea[eo+V]=-1;for(var es=0;es<et;es++){en[es]=-1,ea[ei+es]=-1;for(var eu=K[es],ec=K[es+1],ep=eu;ep<ec;ep++){var eh=H[ep];for(V=$?ea[eo+eh]:eh;-1!==V&&V<es;V=G)G=ea[ei+V],ea[ei+V]=es,-1===G&&(en[V]=es);$&&(ea[eo+eh]=es)}}return en}function csFkeep(F,$,V){for(var G=F._values,H=F._index,K=F._ptr,Z=F._size[1],ee=0,et=0;et<Z;et++){var en=K[et];for(K[et]=ee;en<K[et+1];en++)$(H[en],et,G?G[en]:1,V)&&(H[ee]=H[en],G&&(G[ee]=G[en]),ee++)}return K[Z]=ee,H.splice(ee,H.length-ee),G&&G.splice(ee,G.length-ee),ee}function csFlip(F){return-F-2}var nK=factory_factory("csAmd",["add","multiply","transpose"],F=>{var{add:$,multiply:V,transpose:G}=F;return function(F,$){if(!$||F<=0||F>3)return null;var V,G,H,K,Z,ee,et,en,ea,ei,eo,es,eu,ec,ep,eh,ef=$._size,ed=ef[0],em=ef[1],eg=0,ey=Math.max(16,10*Math.sqrt(em));ey=Math.min(em-2,ey);var eb=_createTargetMatrix(F,$,ed,em,ey);csFkeep(eb,_diag,null);for(var ew=eb._index,eS=eb._ptr,e_=eS[em],eN=[],ek=[],eI=0,eT=em+1,eC=2*(em+1),eE=3*(em+1),eA=4*(em+1),eD=5*(em+1),eM=6*(em+1),eR=7*(em+1),eF=eN,eO=_initializeQuotientGraph(em,eS,ek,0,eE,eF,eC,eR,eT,eM,eA,eD),eP=_initializeDegreeLists(em,eS,ek,eD,eA,eM,ey,eT,eE,eF,eC),eB=0;eP<em;){for(H=-1;eB<em&&-1===(H=ek[eE+eB]);eB++);-1!==ek[eC+H]&&(eF[ek[eC+H]]=-1),ek[eE+eB]=ek[eC+H];var e$=ek[eA+H],eL=ek[eT+H];eP+=eL;var ez=0;ek[eT+H]=-eL;var eV=eS[H],eU=0===e$?eV:e_,eW=eU;for(K=1;K<=e$+1;K++){for(K>e$?(ee=H,et=eV,en=ek[eI+H]-e$):(et=eS[ee=ew[eV++]],en=ek[eI+ee]),Z=1;Z<=en;Z++)(ea=ek[eT+(V=ew[et++])])<=0||(ez+=ea,ek[eT+V]=-ea,ew[eW++]=V,-1!==ek[eC+V]&&(eF[ek[eC+V]]=eF[V]),-1!==eF[V]?ek[eC+eF[V]]=ek[eC+V]:ek[eE+ek[eD+V]]=ek[eC+V]);ee!==H&&(eS[ee]=csFlip(H),ek[eM+ee]=0)}for(0!==e$&&(e_=eW),ek[eD+H]=ez,eS[H]=eU,ek[eI+H]=eW-eU,ek[eA+H]=-2,eO=_wclear(eO,eg,ek,eM,em),ei=eU;ei<eW;ei++)if(!((eo=ek[eA+(V=ew[ei])])<=0)){var ej=eO-(ea=-ek[eT+V]);for(eV=eS[V],es=eS[V]+eo-1;eV<=es;eV++)ek[eM+(ee=ew[eV])]>=eO?ek[eM+ee]-=ea:0!==ek[eM+ee]&&(ek[eM+ee]=ek[eD+ee]+ej)}for(ei=eU;ei<eW;ei++){for(ep=0,eu=(es=eS[V=ew[ei]])+ek[eA+V]-1,ec=es,eh=0,eV=es;eV<=eu;eV++)if(0!==ek[eM+(ee=ew[eV])]){var eG=ek[eM+ee]-eO;eG>0?(eh+=eG,ew[ec++]=ee,ep+=ee):(eS[ee]=csFlip(H),ek[eM+ee]=0)}ek[eA+V]=ec-es+1;var eH=ec,eX=es+ek[eI+V];for(eV=eu+1;eV<eX;eV++){var eK=ek[eT+(G=ew[eV])];eK<=0||(eh+=eK,ew[ec++]=G,ep+=G)}0===eh?(eS[V]=csFlip(H),ez-=ea=-ek[eT+V],eL+=ea,eP+=ea,ek[eT+V]=0,ek[eA+V]=-1):(ek[eD+V]=Math.min(ek[eD+V],eh),ew[ec]=ew[eH],ew[eH]=ew[es],ew[es]=H,ek[eI+V]=ec-es+1,ep=(ep<0?-ep:ep)%em,ek[eC+V]=ek[eR+ep],ek[eR+ep]=V,eF[V]=ep)}for(ek[eD+H]=ez,eO=_wclear(eO+(eg=Math.max(eg,ez)),eg,ek,eM,em),ei=eU;ei<eW;ei++)if(!(ek[eT+(V=ew[ei])]>=0))for(V=ek[eR+(ep=eF[V])],ek[eR+ep]=-1;-1!==V&&-1!==ek[eC+V];V=ek[eC+V],eO++){for(en=ek[eI+V],eo=ek[eA+V],eV=eS[V]+1;eV<=eS[V]+en-1;eV++)ek[eM+ew[eV]]=eO;var eQ=V;for(G=ek[eC+V];-1!==G;){var eZ=ek[eI+G]===en&&ek[eA+G]===eo;for(eV=eS[G]+1;eZ&&eV<=eS[G]+en-1;eV++)ek[eM+ew[eV]]!==eO&&(eZ=0);eZ?(eS[G]=csFlip(V),ek[eT+V]+=ek[eT+G],ek[eT+G]=0,ek[eA+G]=-1,G=ek[eC+G],ek[eC+eQ]=G):(eQ=G,G=ek[eC+G])}}for(eV=eU,ei=eU;ei<eW;ei++)(ea=-ek[eT+(V=ew[ei])])<=0||(ek[eT+V]=ea,eh=Math.min(eh=ek[eD+V]+ez-ea,em-eP-ea),-1!==ek[eE+eh]&&(eF[ek[eE+eh]]=V),ek[eC+V]=ek[eE+eh],eF[V]=-1,ek[eE+eh]=V,eB=Math.min(eB,eh),ek[eD+V]=eh,ew[eV++]=V);ek[eT+H]=eL,0==(ek[eI+H]=eV-eU)&&(eS[H]=-1,ek[eM+H]=0),0!==e$&&(e_=eV)}for(V=0;V<em;V++)eS[V]=csFlip(eS[V]);for(G=0;G<=em;G++)ek[eE+G]=-1;for(G=em;G>=0;G--)ek[eT+G]>0||(ek[eC+G]=ek[eE+eS[G]],ek[eE+eS[G]]=G);for(ee=em;ee>=0;ee--)ek[eT+ee]<=0||-1===eS[ee]||(ek[eC+ee]=ek[eE+eS[ee]],ek[eE+eS[ee]]=ee);for(H=0,V=0;V<=em;V++)-1===eS[V]&&(H=csTdfs(V,H,ek,eE,eC,eN,eM));return eN.splice(eN.length-1,1),eN};function _createTargetMatrix(F,H,K,Z,ee){var et=G(H);if(1===F&&Z===K)return $(H,et);if(2===F){for(var en=et._index,ea=et._ptr,ei=0,eo=0;eo<K;eo++){var es=ea[eo];if(ea[eo]=ei,!(ea[eo+1]-es>ee))for(var eu=ea[eo+1];es<eu;es++)en[ei++]=en[es]}ea[K]=ei,H=G(et)}return V(et,H)}function _initializeQuotientGraph(F,$,V,G,H,K,Z,ee,et,en,ea,ei){for(var eo=0;eo<F;eo++)V[G+eo]=$[eo+1]-$[eo];V[G+F]=0;for(var es=0;es<=F;es++)V[H+es]=-1,K[es]=-1,V[Z+es]=-1,V[ee+es]=-1,V[et+es]=1,V[en+es]=1,V[ea+es]=0,V[ei+es]=V[G+es];var eu=_wclear(0,0,V,en,F);return V[ea+F]=-2,$[F]=-1,V[en+F]=0,eu}function _initializeDegreeLists(F,$,V,G,H,K,Z,ee,et,en,ea){for(var ei=0,eo=0;eo<F;eo++){var es=V[G+eo];if(0===es)V[H+eo]=-2,ei++,$[eo]=-1,V[K+eo]=0;else if(es>Z)V[ee+eo]=0,V[H+eo]=-1,ei++,$[eo]=csFlip(F),V[ee+F]++;else{var eu=V[et+es];-1!==eu&&(en[eu]=eo),V[ea+eo]=V[et+es],V[et+es]=eo}}return ei}function _wclear(F,$,V,G,H){if(F<2||F+$<0){for(var K=0;K<H;K++)0!==V[G+K]&&(V[G+K]=1);F=2}return F}function _diag(F,$){return F!==$}});function csLeaf(F,$,V,G,H,K,Z){var ee,et,en,ea=0;if(F<=$||V[G+$]<=V[H+F])return -1;V[H+F]=V[G+$];var ei=V[K+F];if(V[K+F]=$,-1===ei)ea=1,en=F;else{for(ea=2,en=ei;en!==V[Z+en];en=V[Z+en]);for(ee=ei;ee!==en;ee=et)et=V[Z+ee],V[Z+ee]=en}return{jleaf:ea,q:en}}var nQ=factory_factory("csCounts",["transpose"],F=>{var{transpose:$}=F;return function(F,V,G,H){if(!F||!V||!G)return null;var K,Z,ee,et,en,ea,ei,eo=F._size,es=eo[0],eu=eo[1],ec=4*eu+(H?eu+es+1:0),ep=[],eh=0,ef=eu,ed=2*eu,em=3*eu,eg=4*eu,ey=5*eu+1;for(ee=0;ee<ec;ee++)ep[ee]=-1;var eb=[],ew=$(F),eS=ew._index,e_=ew._ptr;for(ee=0;ee<eu;ee++)for(eb[Z=G[ee]]=-1===ep[em+Z]?1:0;-1!==Z&&-1===ep[em+Z];Z=V[Z])ep[em+Z]=ee;if(H){for(ee=0;ee<eu;ee++)ep[G[ee]]=ee;for(K=0;K<es;K++){for(ee=eu,ea=e_[K],ei=e_[K+1],en=ea;en<ei;en++)ee=Math.min(ee,ep[eS[en]]);ep[ey+K]=ep[eg+ee],ep[eg+ee]=K}}for(K=0;K<eu;K++)ep[eh+K]=K;for(ee=0;ee<eu;ee++){for(-1!==V[Z=G[ee]]&&eb[V[Z]]--,et=H?ep[eg+ee]:Z;-1!==et;et=H?ep[ey+et]:-1)for(en=e_[et];en<e_[et+1];en++){var eN=csLeaf(K=eS[en],Z,ep,em,ef,ed,eh);eN.jleaf>=1&&eb[Z]++,2===eN.jleaf&&eb[eN.q]--}-1!==V[Z]&&(ep[eh+Z]=V[Z])}for(Z=0;Z<eu;Z++)-1!==V[Z]&&(eb[V[Z]]+=eb[Z]);return eb}}),nZ=factory_factory("csSqr",["add","multiply","transpose"],F=>{var{add:$,multiply:V,transpose:G}=F,H=nK({add:$,multiply:V,transpose:G}),K=nQ({transpose:G});return function(F,$,V){var G,Z=$._ptr,ee=$._size[1],et={};if(et.q=H(F,$),F&&!et.q)return null;if(V){var en=F?csPermute($,null,et.q,0):$;et.parent=csEtree(en,1);var ea=csPost(et.parent,ee);if(et.cp=K(en,et.parent,ea,1),en&&et.parent&&et.cp&&_vcount(en,et))for(et.unz=0,G=0;G<ee;G++)et.unz+=et.cp[G]}else et.unz=4*Z[ee]+ee,et.lnz=et.unz;return et};function _vcount(F,$){var V,G,H,K,Z,ee=F._ptr,et=F._index,en=F._size,ea=en[0],ei=en[1];$.pinv=[],$.leftmost=[];var eo=$.parent,es=$.pinv,eu=$.leftmost,ec=[],ep=0,eh=ea,ef=ea+ei,ed=ea+2*ei;for(G=0;G<ei;G++)ec[eh+G]=-1,ec[ef+G]=-1,ec[ed+G]=0;for(V=0;V<ea;V++)eu[V]=-1;for(G=ei-1;G>=0;G--)for(K=ee[G],Z=ee[G+1],H=K;H<Z;H++)eu[et[H]]=G;for(V=ea-1;V>=0;V--)es[V]=-1,-1!==(G=eu[V])&&(0==ec[ed+G]++&&(ec[ef+G]=V),ec[ep+V]=ec[eh+G],ec[eh+G]=V);for(G=0,$.lnz=0,$.m2=ea;G<ei;G++)if(V=ec[eh+G],$.lnz++,V<0&&(V=$.m2++),es[V]=G,!(--ed[G]<=0)){$.lnz+=ec[ed+G];var em=eo[G];-1!==em&&(0===ec[ed+em]&&(ec[ef+em]=ec[ef+G]),ec[ep+ec[ef+G]]=ec[eh+em],ec[eh+em]=ec[ep+V],ec[ed+em]+=ec[ed+G])}for(V=0;V<ea;V++)es[V]<0&&(es[V]=G++);return!0}});function csMarked(F,$){return F[$]<0}function csMark(F,$){F[$]=csFlip(F[$])}function csUnflip(F){return F<0?csFlip(F):F}function csDfs(F,$,V,G,H){var K,Z,ee,et=$._index,en=$._ptr,ea=$._size[1],ei=0;for(G[0]=F;ei>=0;){F=G[ei];var eo=H?H[F]:F;csMarked(en,F)||(csMark(en,F),G[ea+ei]=eo<0?0:csUnflip(en[eo]));var es=1;for(Z=G[ea+ei],ee=eo<0?0:csUnflip(en[eo+1]);Z<ee;Z++)if(!csMarked(en,K=et[Z])){G[ea+ei]=Z,G[++ei]=K,es=0;break}es&&(ei--,G[--V]=F)}return V}function csReach(F,$,V,G,H){var K,Z,ee,et=F._ptr,en=F._size,ea=$._index,ei=$._ptr,eo=en[1],es=eo;for(Z=ei[V],ee=ei[V+1],K=Z;K<ee;K++){var eu=ea[K];csMarked(et,eu)||(es=csDfs(eu,F,es,G,H))}for(K=es;K<eo;K++)csMark(et,G[K]);return es}var nY=factory_factory("csSpsolve",["divideScalar","multiply","subtract"],F=>{var{divideScalar:$,multiply:V,subtract:G}=F;return function(F,H,K,Z,ee,et,en){var ea,ei,eo,es,eu=F._values,ec=F._index,ep=F._ptr,eh=F._size[1],ef=H._values,ed=H._index,em=H._ptr,eg=csReach(F,H,K,Z,et);for(ea=eg;ea<eh;ea++)ee[Z[ea]]=0;for(ei=em[K],eo=em[K+1],ea=ei;ea<eo;ea++)ee[ed[ea]]=ef[ea];for(var ey=eg;ey<eh;ey++){var eb=Z[ey],ew=et?et[eb]:eb;if(!(ew<0))for(ei=ep[ew],eo=ep[ew+1],ee[eb]=$(ee[eb],eu[en?ei:eo-1]),ea=en?ei+1:ei,es=en?eo:eo-1;ea<es;ea++){var eS=ec[ea];ee[eS]=G(ee[eS],V(eu[ea],ee[eb]))}}return eg}}),nJ=factory_factory("csLu",["abs","divideScalar","multiply","subtract","larger","largerEq","SparseMatrix"],F=>{var{abs:$,divideScalar:V,multiply:G,subtract:H,larger:K,largerEq:Z,SparseMatrix:ee}=F,et=nY({divideScalar:V,multiply:G,subtract:H});return function(F,H,en){if(!F)return null;var ea,ei,eo,es=F._size[1],eu=100,ec=100;H&&(ea=H.q,eu=H.lnz||eu,ec=H.unz||ec);var ep=[],eh=[],ef=[],ed=new ee({values:ep,index:eh,ptr:ef,size:[es,es]}),em=[],eg=[],ey=[],eb=new ee({values:em,index:eg,ptr:ey,size:[es,es]}),ew=[],eS=[],e_=[];for(ei=0;ei<es;ei++)eS[ei]=0,ew[ei]=-1,ef[ei+1]=0;eu=0,ec=0;for(var eN=0;eN<es;eN++){ef[eN]=eu,ey[eN]=ec;var ek=ea?ea[eN]:eN,eI=et(ed,F,ek,e_,eS,ew,1),eT=-1,eC=-1;for(eo=eI;eo<es;eo++)if(ew[ei=e_[eo]]<0){var eE=$(eS[ei]);K(eE,eC)&&(eC=eE,eT=ei)}else eg[ec]=ew[ei],em[ec++]=eS[ei];if(-1===eT||eC<=0)return null;ew[ek]<0&&Z($(eS[ek]),G(eC,en))&&(eT=ek);var eA=eS[eT];for(eg[ec]=eN,em[ec++]=eA,ew[eT]=eN,eh[eu]=eT,ep[eu++]=1,eo=eI;eo<es;eo++)ew[ei=e_[eo]]<0&&(eh[eu]=ei,ep[eu++]=V(eS[ei],eA)),eS[ei]=0}for(eo=0,ef[es]=eu,ey[es]=ec;eo<eu;eo++)eh[eo]=ew[eh[eo]];return ep.splice(eu,ep.length-eu),eh.splice(eu,eh.length-eu),em.splice(ec,em.length-ec),eg.splice(ec,eg.length-ec),{L:ed,U:eb,pinv:ew}}}),n3="slu",n4=(F=>{var{typed:$,abs:V,add:G,multiply:H,transpose:K,divideScalar:Z,subtract:ee,larger:et,largerEq:en,SparseMatrix:ea}=F,ei=nZ({add:G,multiply:H,transpose:K}),eo=nJ({abs:V,divideScalar:Z,multiply:H,subtract:ee,larger:et,largerEq:en,SparseMatrix:ea});return $(n3,{"SparseMatrix, number, number":function(F,$,V){if(!isInteger($)||$<0||$>3)throw Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");if(V<0||V>1)throw Error("Partial pivoting threshold must be a number from 0 to 1");var G=ei($,F,!1),H=eo(F,G,V);return{L:H.L,U:H.U,p:H.pinv,q:G.q,toString:function(){return"L: "+this.L.toString()+"\nU: "+this.U.toString()+"\np: "+this.p.toString()+(this.q?"\nq: "+this.q.toString():"")+"\n"}}}})},"sum"),n6="usolveAll",n5=factory_factory(n6,["typed","matrix","divideScalar","multiplyScalar","subtract","equalScalar","DenseMatrix"],F=>{var{typed:$,matrix:V,divideScalar:G,multiplyScalar:H,subtract:K,equalScalar:Z,DenseMatrix:ee}=F,et=createSolveValidation({DenseMatrix:ee});return $(n6,{"SparseMatrix, Array | Matrix":function(F,$){return _sparseBackwardSubstitution(F,$)},"DenseMatrix, Array | Matrix":function(F,$){return _denseBackwardSubstitution(F,$)},"Array, Array | Matrix":function(F,$){return _denseBackwardSubstitution(V(F),$).map(F=>F.valueOf())}});function _denseBackwardSubstitution(F,$){for(var V=[et(F,$,!0)._data.map(F=>F[0])],en=F._data,ea=F._size[0],ei=F._size[1],eo=ei-1;eo>=0;eo--)for(var es=V.length,eu=0;eu<es;eu++){var ec=V[eu];if(Z(en[eo][eo],0)){if(Z(ec[eo],0)){if(0===eu){var ep=[...ec];ep[eo]=1;for(var eh=eo-1;eh>=0;eh--)ep[eh]=K(ep[eh],en[eh][eo]);V.push(ep)}}else{if(0===eu)return[];V.splice(eu,1),eu-=1,es-=1}}else{ec[eo]=G(ec[eo],en[eo][eo]);for(var ef=eo-1;ef>=0;ef--)ec[ef]=K(ec[ef],H(ec[eo],en[ef][eo]))}}return V.map(F=>new ee({data:F.map(F=>[F]),size:[ea,1]}))}function _sparseBackwardSubstitution(F,$){for(var V=[et(F,$,!0)._data.map(F=>F[0])],en=F._size[0],ea=F._size[1],ei=F._values,eo=F._index,es=F._ptr,eu=ea-1;eu>=0;eu--)for(var ec=V.length,ep=0;ep<ec;ep++){for(var eh=V[ep],ef=[],ed=[],em=es[eu],eg=es[eu+1],ey=0,eb=eg-1;eb>=em;eb--){var ew=eo[eb];ew===eu?ey=ei[eb]:ew<eu&&(ef.push(ei[eb]),ed.push(ew))}if(Z(ey,0)){if(Z(eh[eu],0)){if(0===ep){var eS=[...eh];eS[eu]=1;for(var e_=0,eN=ed.length;e_<eN;e_++){var ek=ed[e_];eS[ek]=K(eS[ek],ef[e_])}V.push(eS)}}else{if(0===ep)return[];V.splice(ep,1),ep-=1,ec-=1}}else{eh[eu]=G(eh[eu],ey);for(var eI=0,eT=ed.length;eI<eT;eI++){var eC=ed[eI];eh[eC]=K(eh[eC],H(eh[eu],ef[eI]))}}}return V.map(F=>new ee({data:F.map(F=>[F]),size:[en,1]}))}}),n9="ceil",n8=["typed","config","round","matrix","equalScalar","zeros","DenseMatrix"],n7=factory_factory(n9,["typed","config","round"],F=>{var{typed:$,config:V,round:G}=F;return $(n9,{number:function(F){return number_nearlyEqual(F,G(F),V.epsilon)?G(F):Math.ceil(F)},"number, number":function(F,$){if(number_nearlyEqual(F,G(F,$),V.epsilon))return G(F,$);var[H,K]="".concat(F,"e").split("e"),Z=Math.ceil(Number("".concat(H,"e").concat(Number(K)+$)));return[H,K]="".concat(Z,"e").split("e"),Number("".concat(H,"e").concat(Number(K)-$))}})}),ae=factory_factory(n9,n8,F=>{var{typed:$,config:V,round:G,matrix:H,equalScalar:K,zeros:Z,DenseMatrix:ee}=F,et=rC({typed:$,equalScalar:K}),en=rE({typed:$,DenseMatrix:ee}),ea=rD({typed:$}),ei=n7({typed:$,config:V,round:G});return $("ceil",{number:ei.signatures.number,"number,number":ei.signatures["number,number"],Complex:function(F){return F.ceil()},"Complex, number":function(F,$){return F.ceil($)},"Complex, BigNumber":function(F,$){return F.ceil($.toNumber())},BigNumber:function(F){return nearlyEqual_nearlyEqual(F,G(F),V.epsilon)?G(F):F.ceil()},"BigNumber, BigNumber":function(F,$){return nearlyEqual_nearlyEqual(F,G(F,$),V.epsilon)?G(F,$):F.toDecimalPlaces($.toNumber(),eL.ROUND_CEIL)},Fraction:function(F){return F.ceil()},"Fraction, number":function(F,$){return F.ceil($)},"Fraction, BigNumber":function(F,$){return F.ceil($.toNumber())},"Array | Matrix":function(F){return deepMap(F,this,!0)},"Array, number | BigNumber":function(F,$){return deepMap(F,F=>this(F,$),!0)},"SparseMatrix, number | BigNumber":function(F,$){return et(F,$,this,!1)},"DenseMatrix, number | BigNumber":function(F,$){return ea(F,$,this,!1)},"number | Complex | Fraction | BigNumber, Array":function(F,$){return ea(H($),F,this,!0).valueOf()},"number | Complex | Fraction | BigNumber, Matrix":function(F,$){return K(F,0)?Z($.size(),$.storage()):"dense"===$.storage()?ea($,F,this,!0):en($,F,this,!0)}})}),ar="det",an=factory_factory(ar,["typed","matrix","subtract","multiply","divideScalar","isZero","unaryMinus"],F=>{var{typed:$,matrix:V,subtract:G,multiply:H,divideScalar:K,isZero:Z,unaryMinus:ee}=F;return $(ar,{any:function(F){return object_clone(F)},"Array | Matrix":function(F){var $;switch(($=isMatrix(F)?F.size():Array.isArray(F)?(F=V(F)).size():[]).length){case 0:return object_clone(F);case 1:if(1===$[0])return object_clone(F.valueOf()[0]);throw RangeError("Matrix must be square (size: "+string_format($)+")");case 2:var G=$[0],H=$[1];if(G===H)return _det(F.clone().valueOf(),G,H);throw RangeError("Matrix must be square (size: "+string_format($)+")");default:throw RangeError("Matrix must be two dimensional (size: "+string_format($)+")")}}});function _det(F,$,V){if(1===$)return object_clone(F[0][0]);if(2===$)return G(H(F[0][0],F[1][1]),H(F[1][0],F[0][1]));for(var et=!1,en=Array($).fill(0).map((F,$)=>$),ea=0;ea<$;ea++){var ei=en[ea];if(Z(F[ei][ea])){var eo=void 0;for(eo=ea+1;eo<$;eo++)if(!Z(F[en[eo]][ea])){ei=en[eo],en[eo]=en[ea],en[ea]=ei,et=!et;break}if(eo===$)return F[ei][ea]}for(var es=F[ei][ea],eu=0===ea?1:F[en[ea-1]][ea-1],ec=ea+1;ec<$;ec++)for(var ep=en[ec],eh=ea+1;eh<$;eh++)F[ep][eh]=K(G(H(F[ep][eh],es),H(F[ep][ea],F[ei][eh])),eu)}var ef=F[en[$-1]][$-1];return et?ee(ef):ef}}),aa=factory_factory("FibonacciHeap",["smaller","larger"],F=>{var{smaller:$,larger:V}=F,G=1/Math.log((1+Math.sqrt(5))/2);function FibonacciHeap(){if(!(this instanceof FibonacciHeap))throw SyntaxError("Constructor must be called with the new operator");this._minimum=null,this._size=0}function _decreaseKey(F,V,G){V.key=G;var H=V.parent;return H&&$(V.key,H.key)&&(_cut(F,V,H),_cascadingCut(F,H)),$(V.key,F.key)&&(F=V),F}function _cut(F,$,V){$.left.right=$.right,$.right.left=$.left,V.degree--,V.child===$&&(V.child=$.right),0===V.degree&&(V.child=null),$.left=F,$.right=F.right,F.right=$,$.right.left=$,$.parent=null,$.mark=!1}function _cascadingCut(F,$){var V=$.parent;V&&($.mark?(_cut(F,$,V),_cascadingCut(V)):$.mark=!0)}FibonacciHeap.prototype.type="FibonacciHeap",FibonacciHeap.prototype.isFibonacciHeap=!0,FibonacciHeap.prototype.insert=function(F,V){var G={key:F,value:V,degree:0};if(this._minimum){var H=this._minimum;G.left=H,G.right=H.right,H.right=G,G.right.left=G,$(F,H.key)&&(this._minimum=G)}else G.left=G,G.right=G,this._minimum=G;return this._size++,G},FibonacciHeap.prototype.size=function(){return this._size},FibonacciHeap.prototype.clear=function(){this._minimum=null,this._size=0},FibonacciHeap.prototype.isEmpty=function(){return 0===this._size},FibonacciHeap.prototype.extractMinimum=function(){var F=this._minimum;if(null===F)return F;for(var $=this._minimum,V=F.degree,G=F.child;V>0;){var H=G.right;G.left.right=G.right,G.right.left=G.left,G.left=$,G.right=$.right,$.right=G,G.right.left=G,G.parent=null,G=H,V--}return F.left.right=F.right,F.right.left=F.left,$=F===F.right?null:_findMinimumNode($=F.right,this._size),this._size--,this._minimum=$,F},FibonacciHeap.prototype.remove=function(F){this._minimum=_decreaseKey(this._minimum,F,-1),this.extractMinimum()};var _linkNodes=function(F,$){F.left.right=F.right,F.right.left=F.left,F.parent=$,$.child?(F.left=$.child,F.right=$.child.right,$.child.right=F,F.right.left=F):($.child=F,F.right=F,F.left=F),$.degree++,F.mark=!1};function _findMinimumNode(F,H){var K,Z=Math.floor(Math.log(H)*G)+1,ee=Array(Z),et=0,en=F;if(en)for(et++,en=en.right;en!==F;)et++,en=en.right;for(;et>0;){for(var ea=en.degree,ei=en.right;K=ee[ea];){if(V(en.key,K.key)){var eo=K;K=en,en=eo}_linkNodes(K,en),ee[ea]=null,ea++}ee[ea]=en,en=ei,et--}F=null;for(var es=0;es<Z;es++)(K=ee[es])&&(F?(K.left.right=K.right,K.right.left=K.left,K.left=F,K.right=F.right,F.right=K,K.right.left=K,$(K.key,F.key)&&(F=K)):F=K);return F}return FibonacciHeap},{isClass:!0}),ai="fix",ao=["typed","Complex","matrix","ceil","floor","equalScalar","zeros","DenseMatrix"],as=factory_factory(ai,["typed","ceil","floor"],F=>{var{typed:$,ceil:V,floor:G}=F;return $(ai,{number:function(F){return F>0?G(F):V(F)},"number, number":function(F,$){return F>0?G(F,$):V(F,$)}})}),au=(F=>{var{typed:$,Complex:V,matrix:G,ceil:H,floor:K,equalScalar:Z,zeros:ee,DenseMatrix:et}=F,en=rE({typed:$,DenseMatrix:et}),ea=rD({typed:$}),ei=as({typed:$,ceil:H,floor:K});return $("fix",{number:ei.signatures.number,"number, number | BigNumber":ei.signatures["number,number"],Complex:function(F){return new V(F.re>0?Math.floor(F.re):Math.ceil(F.re),F.im>0?Math.floor(F.im):Math.ceil(F.im))},"Complex, number":function(F,$){return new V(F.re>0?K(F.re,$):H(F.re,$),F.im>0?K(F.im,$):H(F.im,$))},"Complex, BigNumber":function(F,$){var G=$.toNumber();return new V(F.re>0?K(F.re,G):H(F.re,G),F.im>0?K(F.im,G):H(F.im,G))},BigNumber:function(F){return F.isNegative()?H(F):K(F)},"BigNumber, number | BigNumber":function(F,$){return F.isNegative()?H(F,$):K(F,$)},Fraction:function(F){return F.s<0?F.ceil():F.floor()},"Fraction, number | BigNumber":function(F,$){return F.s<0?H(F,$):K(F,$)},"Array | Matrix":function(F){return deepMap(F,this,!0)},"Array | Matrix, number | BigNumber":function(F,$){return deepMap(F,F=>this(F,$),!0)},"number | Complex | Fraction | BigNumber, Array":function(F,$){return ea(G($),F,this,!0).valueOf()},"number | Complex | Fraction | BigNumber, Matrix":function(F,$){return Z(F,0)?ee($.size(),$.storage()):"dense"===$.storage()?ea($,F,this,!0):en($,F,this,!0)}})},factory_factory("ImmutableDenseMatrix",["smaller","DenseMatrix"],F=>{var{smaller:$,DenseMatrix:V}=F;function ImmutableDenseMatrix(F,$){if(!(this instanceof ImmutableDenseMatrix))throw SyntaxError("Constructor must be called with the new operator");if($&&!is_isString($))throw Error("Invalid datatype: "+$);if(isMatrix(F)||ez(F)){var G=new V(F,$);this._data=G._data,this._size=G._size,this._datatype=G._datatype,this._min=null,this._max=null}else if(F&&ez(F.data)&&ez(F.size))this._data=F.data,this._size=F.size,this._datatype=F.datatype,this._min=void 0!==F.min?F.min:null,this._max=void 0!==F.max?F.max:null;else if(F)throw TypeError("Unsupported type of data ("+typeOf(F)+")");else this._data=[],this._size=[0],this._datatype=$,this._min=null,this._max=null}return ImmutableDenseMatrix.prototype=new V,ImmutableDenseMatrix.prototype.type="ImmutableDenseMatrix",ImmutableDenseMatrix.prototype.isImmutableDenseMatrix=!0,ImmutableDenseMatrix.prototype.subset=function(F){switch(arguments.length){case 1:var $=V.prototype.subset.call(this,F);if(isMatrix($))return new ImmutableDenseMatrix({data:$._data,size:$._size,datatype:$._datatype});return $;case 2:case 3:throw Error("Cannot invoke set subset on an Immutable Matrix instance");default:throw SyntaxError("Wrong number of arguments")}},ImmutableDenseMatrix.prototype.set=function(){throw Error("Cannot invoke set on an Immutable Matrix instance")},ImmutableDenseMatrix.prototype.resize=function(){throw Error("Cannot invoke resize on an Immutable Matrix instance")},ImmutableDenseMatrix.prototype.reshape=function(){throw Error("Cannot invoke reshape on an Immutable Matrix instance")},ImmutableDenseMatrix.prototype.clone=function(){return new ImmutableDenseMatrix({data:object_clone(this._data),size:object_clone(this._size),datatype:this._datatype})},ImmutableDenseMatrix.prototype.toJSON=function(){return{mathjs:"ImmutableDenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},ImmutableDenseMatrix.fromJSON=function(F){return new ImmutableDenseMatrix(F)},ImmutableDenseMatrix.prototype.swapRows=function(){throw Error("Cannot invoke swapRows on an Immutable Matrix instance")},ImmutableDenseMatrix.prototype.min=function(){if(null===this._min){var F=null;this.forEach(function(V){(null===F||$(V,F))&&(F=V)}),this._min=null!==F?F:void 0}return this._min},ImmutableDenseMatrix.prototype.max=function(){if(null===this._max){var F=null;this.forEach(function(V){(null===F||$(F,V))&&(F=V)}),this._max=null!==F?F:void 0}return this._max},ImmutableDenseMatrix},{isClass:!0})),ac=factory_factory("Index",["ImmutableDenseMatrix"],F=>{var{ImmutableDenseMatrix:$}=F;function Index(F){if(!(this instanceof Index))throw SyntaxError("Constructor must be called with the new operator");this._dimensions=[],this._isScalar=!0;for(var $=0,V=arguments.length;$<V;$++){var G=arguments[$];if(isRange(G))this._dimensions.push(G),this._isScalar=!1;else if(Array.isArray(G)||isMatrix(G)){var H=_createImmutableMatrix(G.valueOf());this._dimensions.push(H);var K=H.size();(1!==K.length||1!==K[0])&&(this._isScalar=!1)}else if("number"==typeof G)this._dimensions.push(_createImmutableMatrix([G]));else if("string"==typeof G)this._dimensions.push(G);else throw TypeError("Dimension must be an Array, Matrix, number, string, or Range")}}function _createImmutableMatrix(F){for(var V=0,G=F.length;V<G;V++)if("number"!=typeof F[V]||!isInteger(F[V]))throw TypeError("Index parameters must be positive integer numbers");return new $(F)}return Index.prototype.type="Index",Index.prototype.isIndex=!0,Index.prototype.clone=function(){var F=new Index;return F._dimensions=object_clone(this._dimensions),F._isScalar=this._isScalar,F},Index.create=function(F){var $=new Index;return Index.apply($,F),$},Index.prototype.size=function(){for(var F=[],$=0,V=this._dimensions.length;$<V;$++){var G=this._dimensions[$];F[$]="string"==typeof G?1:G.size()[0]}return F},Index.prototype.max=function(){for(var F=[],$=0,V=this._dimensions.length;$<V;$++){var G=this._dimensions[$];F[$]="string"==typeof G?G:G.max()}return F},Index.prototype.min=function(){for(var F=[],$=0,V=this._dimensions.length;$<V;$++){var G=this._dimensions[$];F[$]="string"==typeof G?G:G.min()}return F},Index.prototype.forEach=function(F){for(var $=0,V=this._dimensions.length;$<V;$++)F(this._dimensions[$],$,this)},Index.prototype.dimension=function(F){return this._dimensions[F]||null},Index.prototype.isObjectProperty=function(){return 1===this._dimensions.length&&"string"==typeof this._dimensions[0]},Index.prototype.getObjectProperty=function(){return this.isObjectProperty()?this._dimensions[0]:null},Index.prototype.isScalar=function(){return this._isScalar},Index.prototype.toArray=function(){for(var F=[],$=0,V=this._dimensions.length;$<V;$++){var G=this._dimensions[$];F.push("string"==typeof G?G:G.toArray())}return F},Index.prototype.valueOf=Index.prototype.toArray,Index.prototype.toString=function(){for(var F=[],$=0,V=this._dimensions.length;$<V;$++){var G=this._dimensions[$];"string"==typeof G?F.push(JSON.stringify(G)):F.push(G.toString())}return"["+F.join(", ")+"]"},Index.prototype.toJSON=function(){return{mathjs:"Index",dimensions:this._dimensions}},Index.fromJSON=function(F){return Index.create(F.dimensions)},Index},{isClass:!0}),ap="max",ad=(F=>{var{typed:$,config:V,numeric:G,larger:H}=F;return $(ap,{"Array | Matrix":_max,"Array | Matrix, number | BigNumber":function(F,$){return reduce(F,$.valueOf(),_largest)},"...":function(F){if(containsCollections(F))throw TypeError("Scalar values expected in function max");return _max(F)}});function _largest(F,$){try{return H(F,$)?F:$}catch(F){throw improveErrorMessage(F,"max",$)}}function _max(F){var $;if(deepForEach(F,function(F){try{isNaN(F)&&"number"==typeof F?$=NaN:(void 0===$||H(F,$))&&($=F)}catch($){throw improveErrorMessage($,"max",F)}}),void 0===$)throw Error("Cannot calculate max of an empty array");return"string"==typeof $&&($=G($,V.number)),$}},factory_factory("quantileSeq",["typed","add","multiply","partitionSelect","compare"],F=>{var{typed:$,add:V,multiply:G,partitionSelect:H,compare:K}=F;function quantileSeq(F,$,V){var G,H,K;if(arguments.length<2||arguments.length>3)throw SyntaxError("Function quantileSeq requires two or three parameters");if(isCollection(F)&&"boolean"==typeof(V=V||!1)){if(H=F.valueOf(),is_isNumber($)){if($<0)throw Error("N/prob must be non-negative");if($<=1)return _quantileSeq(H,$,V);if($>1){if(!isInteger($))throw Error("N must be a positive integer");var Z=$+1;G=Array($);for(var ee=0;ee<$;)G[ee]=_quantileSeq(H,++ee/Z,V);return G}}if(isBigNumber($)){var et=$.constructor;if($.isNegative())throw Error("N/prob must be non-negative");if(K=new et(1),$.lte(K))return new et(_quantileSeq(H,$,V));if($.gt(K)){if(!$.isInteger())throw Error("N must be a positive integer");var en=$.toNumber();if(en>4294967295)throw Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");var ea=new et(en+1);G=Array(en);for(var ei=0;ei<en;)G[ei]=new et(_quantileSeq(H,new et(++ei).div(ea),V));return G}}if(Array.isArray($)){G=Array($.length);for(var eo=0;eo<G.length;++eo){var es=$[eo];if(is_isNumber(es)){if(es<0||es>1)throw Error("Probability must be between 0 and 1, inclusive")}else if(isBigNumber(es)){if(K=new es.constructor(1),es.isNegative()||es.gt(K))throw Error("Probability must be between 0 and 1, inclusive")}else throw TypeError("Unexpected type of argument in function quantileSeq");G[eo]=_quantileSeq(H,es,V)}return G}}throw TypeError("Unexpected type of argument in function quantileSeq")}function _quantileSeq(F,$,ee){var et,en,ea=flatten(F),ei=ea.length;if(0===ei)throw Error("Cannot calculate quantile of an empty sequence");if(is_isNumber($)){var eo,es,eu=$*(ei-1),ec=eu%1;if(0===ec){var ep=ee?ea[eu]:H(ea,eu);return Z(ep),ep}var eh=Math.floor(eu);if(ee)eo=ea[eh],es=ea[eh+1];else{es=H(ea,eh+1),eo=ea[eh];for(var ef=0;ef<eh;++ef)K(ea[ef],eo)>0&&(eo=ea[ef])}return Z(eo),Z(es),V(G(eo,1-ec),G(es,ec))}var ed=$.times(ei-1);if(ed.isInteger()){ed=ed.toNumber();var em=ee?ea[ed]:H(ea,ed);return Z(em),em}var eg=ed.floor(),ey=ed.minus(eg),eb=eg.toNumber();if(ee)et=ea[eb],en=ea[eb+1];else{en=H(ea,eb+1),et=ea[eb];for(var ew=0;ew<eb;++ew)K(ea[ew],et)>0&&(et=ea[ew])}return Z(et),Z(en),V(G(et,new ey.constructor(1).minus(ey)),G(en,ey))}var Z=$({"number | BigNumber | Unit":function(F){return F}});return quantileSeq})),am="column",ag=factory_factory(am,["typed","Index","matrix","range"],F=>{var{typed:$,Index:V,matrix:G,range:H}=F;return $(am,{"Matrix, number":_column,"Array, number":function(F,$){return _column(G(object_clone(F)),$).valueOf()}});function _column(F,$){if(2!==F.size().length)throw Error("Only two dimensional matrix is supported");validateIndex($,F.size()[1]);var G=H(0,F.size()[0]),K=new V(G,$);return F.subset(K)}}),ay="inv",ab=factory_factory(ay,["typed","matrix","divideScalar","addScalar","multiply","unaryMinus","det","identity","abs"],F=>{var{typed:$,matrix:V,divideScalar:G,addScalar:H,multiply:K,unaryMinus:Z,det:ee,identity:et,abs:en}=F;return $(ay,{"Array | Matrix":function(F){var $=isMatrix(F)?F.size():arraySize(F);switch($.length){case 1:if(1===$[0]){if(isMatrix(F))return V([G(1,F.valueOf()[0])]);return[G(1,F[0])]}throw RangeError("Matrix must be square (size: "+string_format($)+")");case 2:var H=$[0],K=$[1];if(H===K){if(isMatrix(F))return V(_inv(F.valueOf(),H,K),F.storage());return _inv(F,H,K)}throw RangeError("Matrix must be square (size: "+string_format($)+")");default:throw RangeError("Matrix must be two dimensional (size: "+string_format($)+")")}},any:function(F){return G(1,F)}});function _inv(F,$,V){if(1===$){if(0===(es=F[0][0]))throw Error("Cannot calculate inverse, determinant is zero");return[[G(1,es)]]}if(2===$){var ea,ei,eo,es,eu,ec=ee(F);if(0===ec)throw Error("Cannot calculate inverse, determinant is zero");return[[G(F[1][1],ec),G(Z(F[0][1]),ec)],[G(Z(F[1][0]),ec),G(F[0][0],ec)]]}var ep=F.concat();for(ea=0;ea<$;ea++)ep[ea]=ep[ea].concat();for(var eh=et($).valueOf(),ef=0;ef<V;ef++){var ed=en(ep[ef][ef]),em=ef;for(ea=ef+1;ea<$;)en(ep[ea][ef])>ed&&(ed=en(ep[ea][ef]),em=ea),ea++;if(0===ed)throw Error("Cannot calculate inverse, determinant is zero");(ea=em)!==ef&&(eu=ep[ef],ep[ef]=ep[ea],ep[ea]=eu,eu=eh[ef],eh[ef]=eh[ea],eh[ea]=eu);var eg=ep[ef],ey=eh[ef];for(ea=0;ea<$;ea++){var eb=ep[ea],ew=eh[ea];if(ea!==ef){if(0!==eb[ef]){for(eo=G(Z(eb[ef]),eg[ef]),ei=ef;ei<V;ei++)eb[ei]=H(eb[ei],K(eo,eg[ei]));for(ei=0;ei<V;ei++)ew[ei]=H(ew[ei],K(eo,ey[ei]))}}else{for(eo=eg[ef],ei=ef;ei<V;ei++)eb[ei]=G(eb[ei],eo);for(ei=0;ei<V;ei++)ew[ei]=G(ew[ei],eo)}}}return eh}}),aw="pow",aS=factory_factory(aw,["typed","config","identity","multiply","matrix","inv","fraction","number","Complex"],F=>{var{typed:$,config:V,identity:G,multiply:H,matrix:K,inv:Z,number:ee,fraction:et,Complex:en}=F;return $(aw,{"number, number":_pow,"Complex, Complex":function(F,$){return F.pow($)},"BigNumber, BigNumber":function(F,$){return $.isInteger()||F>=0||V.predictable?F.pow($):new en(F.toNumber(),0).pow($.toNumber(),0)},"Fraction, Fraction":function(F,$){var G=F.pow($);if(null!=G)return G;if(!V.predictable)return _pow(F.valueOf(),$.valueOf());throw Error("Result of pow is non-rational and cannot be expressed as a fraction")},"Array, number":_powArray,"Array, BigNumber":function(F,$){return _powArray(F,$.toNumber())},"Matrix, number":_powMatrix,"Matrix, BigNumber":function(F,$){return _powMatrix(F,$.toNumber())},"Unit, number | BigNumber":function(F,$){return F.pow($)}});function _pow(F,$){if(V.predictable&&!isInteger($)&&F<0)try{var G=et($),H=ee(G);if(($===H||1e-14>Math.abs(($-H)/$))&&G.d%2==1)return(G.n%2==0?1:-1)*Math.pow(-F,$)}catch(F){}return V.predictable&&(F<-1&&$===1/0||F>-1&&F<0&&$===-1/0)?NaN:isInteger($)||F>=0||V.predictable?powNumber(F,$):F*F<1&&$===1/0||F*F>1&&$===-1/0?0:new en(F,0).pow($,0)}function _powArray(F,$){if(!isInteger($))throw TypeError("For A^b, b must be an integer (value is "+$+")");var V=arraySize(F);if(2!==V.length)throw Error("For A^b, A must be 2 dimensional (A has "+V.length+" dimensions)");if(V[0]!==V[1])throw Error("For A^b, A must be square (size is "+V[0]+"x"+V[1]+")");if($<0)try{return _powArray(Z(F),-$)}catch(F){if("Cannot calculate inverse, determinant is zero"===F.message)throw TypeError("For A^b, when A is not invertible, b must be a positive integer (value is "+$+")");throw F}for(var K=G(V[0]).valueOf(),ee=F;$>=1;)(1&$)==1&&(K=H(ee,K)),$>>=1,ee=H(ee,ee);return K}function _powMatrix(F,$){return K(_powArray(F.valueOf(),$))}}),a_="setDifference";function _typeof(F){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(F){return typeof F}:function(F){return F&&"function"==typeof Symbol&&F.constructor===Symbol&&F!==Symbol.prototype?"symbol":typeof F})(F)}function toPrimitive(F,$){if("object"!=_typeof(F)||!F)return F;var V=F[Symbol.toPrimitive];if(void 0!==V){var G=V.call(F,$||"default");if("object"!=_typeof(G))return G;throw TypeError("@@toPrimitive must return a primitive value.")}return("string"===$?String:Number)(F)}function toPropertyKey(F){var $=toPrimitive(F,"string");return"symbol"==_typeof($)?$:String($)}function _defineProperty(F,$,V){return($=toPropertyKey($))in F?Object.defineProperty(F,$,{value:V,enumerable:!0,configurable:!0,writable:!0}):F[$]=V,F}function ownKeys(F,$){var V=Object.keys(F);if(Object.getOwnPropertySymbols){var G=Object.getOwnPropertySymbols(F);$&&(G=G.filter(function($){return Object.getOwnPropertyDescriptor(F,$).enumerable})),V.push.apply(V,G)}return V}function _objectSpread(F){for(var $=1;$<arguments.length;$++){var V=null!=arguments[$]?arguments[$]:{};$%2?ownKeys(Object(V),!0).forEach(function($){_defineProperty(F,$,V[$])}):Object.getOwnPropertyDescriptors?Object.defineProperties(F,Object.getOwnPropertyDescriptors(V)):ownKeys(Object(V)).forEach(function($){Object.defineProperty(F,$,Object.getOwnPropertyDescriptor(V,$))})}return F}F=>{var{typed:$,size:V,subset:G,compareNatural:H,Index:K,DenseMatrix:Z}=F;return $(a_,{"Array | Matrix, Array | Matrix":function(F,$){var ee;if(0===G(V(F),new K(0)))ee=[];else{if(0===G(V($),new K(0)))return flatten(F.toArray());var et,en=identify(flatten(Array.isArray(F)?F:F.toArray()).sort(H)),ea=identify(flatten(Array.isArray($)?$:$.toArray()).sort(H));ee=[];for(var ei=0;ei<en.length;ei++){et=!1;for(var eo=0;eo<ea.length;eo++)if(0===H(en[ei].value,ea[eo].value)&&en[ei].identifier===ea[eo].identifier){et=!0;break}et||ee.push(en[ei])}}return Array.isArray(F)&&Array.isArray($)?generalize(ee):new Z(generalize(ee))}})},F=>{var{addScalar:$,equalScalar:V,FibonacciHeap:G}=F;function Spa(){if(!(this instanceof Spa))throw SyntaxError("Constructor must be called with the new operator");this._values=[],this._heap=new G}return Spa.prototype.type="Spa",Spa.prototype.isSpa=!0,Spa.prototype.set=function(F,$){if(this._values[F])this._values[F].value=$;else{var V=this._heap.insert(F,$);this._values[F]=V}},Spa.prototype.get=function(F){var $=this._values[F];return $?$.value:0},Spa.prototype.accumulate=function(F,V){var G=this._values[F];G?G.value=$(G.value,V):(G=this._heap.insert(F,V),this._values[F]=G)},Spa.prototype.forEach=function(F,$,G){var H=this._heap,K=this._values,Z=[],ee=H.extractMinimum();for(ee&&Z.push(ee);ee&&ee.key<=$;)ee.key>=F&&!V(ee.value,0)&&G(ee.key,ee.value,this),(ee=H.extractMinimum())&&Z.push(ee);for(var et=0;et<Z.length;et++){var en=Z[et];K[(ee=H.insert(en.key,en.value)).key]=ee}},Spa.prototype.swap=function(F,$){var V=this._values[F],G=this._values[$];if(!V&&G)V=this._heap.insert(F,G.value),this._heap.remove(G),this._values[F]=V,this._values[$]=void 0;else if(V&&!G)G=this._heap.insert($,V.value),this._heap.remove(V),this._values[$]=G,this._values[F]=void 0;else if(V&&G){var H=V.value;V.value=G.value,G.value=H}},Spa};var aN="gamma",ak=factory_factory(aN,["typed","config","multiplyScalar","pow","BigNumber","Complex"],F=>{var{typed:$,config:V,multiplyScalar:G,pow:H,BigNumber:K,Complex:Z}=F;return $(aN,{number:gammaNumber,Complex:function(F){if(0===F.im)return this(F.re);if(F.re<.5){var $=new Z(1-F.re,-F.im),V=new Z(Math.PI*F.re,Math.PI*F.im);return new Z(Math.PI).div(V.sin()).div(this($))}F=new Z(F.re-1,F.im);for(var G=new Z(tq[0],0),H=1;H<tq.length;++H){var K=new Z(tq[H],0);G=G.add(K.div(F.add(H)))}var ee=new Z(F.re+tG+.5,F.im),et=Math.sqrt(2*Math.PI),en=ee.pow(F.add(.5)),ea=ee.neg().exp();return G.mul(et).mul(en).mul(ea)},BigNumber:function(F){if(F.isInteger())return F.isNegative()||F.isZero()?new K(1/0):bigFactorial(F.minus(1));if(!F.isFinite())return new K(F.isNegative()?NaN:1/0);throw Error("Integer BigNumber expected")},"Array | Matrix":function(F){return deepMap(F,this)}});function bigFactorial(F){if(F<8)return new K([1,1,2,6,24,120,720,5040][F]);var $=V.precision+(0|Math.log(F.toNumber())),G=K.clone({precision:$});if(F%2==1)return F.times(bigFactorial(new K(F-1)));for(var H=F,Z=new G(F),ee=F.toNumber();H>2;)H-=2,ee+=H,Z=Z.times(ee);return new K(Z.toPrecision(K.precision))}}),aI="setIntersect",aT=(F=>{var{typed:$,size:V,subset:G,compareNatural:H,Index:K,DenseMatrix:Z}=F;return $(aI,{"Array | Matrix, Array | Matrix":function(F,$){var ee;if(0===G(V(F),new K(0))||0===G(V($),new K(0)))ee=[];else{var et=identify(flatten(Array.isArray(F)?F:F.toArray()).sort(H)),en=identify(flatten(Array.isArray($)?$:$.toArray()).sort(H));ee=[];for(var ea=0;ea<et.length;ea++)for(var ei=0;ei<en.length;ei++)if(0===H(et[ea].value,en[ei].value)&&et[ea].identifier===en[ei].identifier){ee.push(et[ea]);break}}return Array.isArray(F)&&Array.isArray($)?generalize(ee):new Z(generalize(ee))}})},factory_factory("divide",["typed","matrix","multiply","equalScalar","divideScalar","inv"],F=>{var{typed:$,matrix:V,multiply:G,equalScalar:H,divideScalar:K,inv:Z}=F,ee=rC({typed:$,equalScalar:H}),et=rD({typed:$});return $("divide",extend({"Array | Matrix, Array | Matrix":function(F,$){return G(F,Z($))},"DenseMatrix, any":function(F,$){return et(F,$,K,!1)},"SparseMatrix, any":function(F,$){return ee(F,$,K,!1)},"Array, any":function(F,$){return et(V(F),$,K,!1).valueOf()},"any, Array | Matrix":function(F,$){return G(F,Z($))}},K.signatures))})),aC="factorial",aE=(F=>{var{typed:$,gamma:V}=F;return $(aC,{number:function(F){if(F<0)throw Error("Value must be non-negative");return V(F+1)},BigNumber:function(F){if(F.isNegative())throw Error("Value must be non-negative");return V(F.plus(1))},"Array | Matrix":function(F){return deepMap(F,this)}})},"lup"),aA="stirlingS2";function createComplexEigs(F){var{addScalar:$,subtract:V,flatten:G,multiply:H,multiplyScalar:K,divideScalar:Z,sqrt:ee,abs:et,bignumber:en,diag:ea,inv:ei,qr:eo,usolve:es,usolveAll:eu,equal:ec,complex:ep,larger:eh,smaller:ef,matrixFromColumns:ed,dot:em}=F;function balance(F,V,G,H,ee){var ei,eo="BigNumber"===H,es="Complex"===H,eu=eo?en(0):0,ed=eo?en(1):es?ep(1):1,em=eo?en(1):1,eg=eo?en(10):2,ey=K(eg,eg);ee&&(ei=Array(V).fill(ed));for(var eb=!1;!eb;){eb=!0;for(var ew=0;ew<V;ew++){for(var eS=eu,e_=eu,eN=0;eN<V;eN++)if(ew!==eN){var ek=et(F[ew][eN]);eS=$(eS,ek),e_=$(e_,ek)}if(!ec(eS,0)&&!ec(e_,0)){for(var eI=em,eT=eS,eC=Z(e_,eg),eE=K(e_,eg);ef(eT,eC);)eT=K(eT,ey),eI=K(eI,eg);for(;eh(eT,eE);)eT=Z(eT,ey),eI=Z(eI,eg);if(ef(Z($(eT,e_),eI),K($(eS,e_),.95))){eb=!1;for(var eA=Z(1,eI),eD=0;eD<V;eD++)ew!==eD&&(F[ew][eD]=K(F[ew][eD],eI),F[eD][ew]=K(F[eD][ew],eA));ee&&(ei[ew]=K(ei[ew],eI))}}}}return ea(ei)}function reduceToHessenberg(F,G,H,ee,ea,ei){var eo="BigNumber"===ee,es="Complex"===ee,eu=eo?en(0):es?ep(0):0;eo&&(H=en(H));for(var ec=0;ec<G-2;ec++){for(var eh=0,ed=eu,em=ec+1;em<G;em++){var eg=F[em][ec];ef(et(ed),et(eg))&&(ed=eg,eh=em)}if(!ef(et(ed),H)){if(eh!==ec+1){var ey=F[eh];F[eh]=F[ec+1],F[ec+1]=ey;for(var eb=0;eb<G;eb++){var ew=F[eb][eh];F[eb][eh]=F[eb][ec+1],F[eb][ec+1]=ew}if(ea){var eS=ei[eh];ei[eh]=ei[ec+1],ei[ec+1]=eS}}for(var e_=ec+2;e_<G;e_++){var eN=Z(F[e_][ec],ed);if(0!==eN){for(var ek=0;ek<G;ek++)F[e_][ek]=V(F[e_][ek],K(eN,F[ec+1][ek]));for(var eI=0;eI<G;eI++)F[eI][ec+1]=$(F[eI][ec+1],K(eN,F[eI][e_]));if(ea)for(var eT=0;eT<G;eT++)ei[e_][eT]=V(ei[e_][eT],K(eN,ei[ec+1][eT]))}}}}return ei}function iterateUntilTriangular(F,G,K,Z,ee){var ei="BigNumber"===Z,es="Complex"===Z,eu=ei?en(1):es?ep(1):1;ei&&(K=en(K));for(var ec=object_clone(F),eh=[],ed=G,em=[],eg=ee?ea(Array(G).fill(eu)):void 0,ey=ee?ea(Array(ed).fill(eu)):void 0,eb=0;eb<=100;){eb+=1;for(var ew=0,eS=0;eS<ed;eS++)ec[eS][eS]=V(ec[eS][eS],ew);var{Q:e_,R:eN}=eo(ec);ec=H(eN,e_);for(var ek=0;ek<ed;ek++)ec[ek][ek]=$(ec[ek][ek],ew);if(ee&&(ey=H(ey,e_)),1===ed||ef(et(ec[ed-1][ed-2]),K)){eb=0,eh.push(ec[ed-1][ed-1]),ee&&(em.unshift([[1]]),inflateMatrix(ey,G),eg=H(eg,ey),ed>1&&(ey=ea(Array(ed-1).fill(eu)))),ed-=1,ec.pop();for(var eI=0;eI<ed;eI++)ec[eI].pop()}else if(2===ed||ef(et(ec[ed-2][ed-3]),K)){eb=0;var eT=eigenvalues2x2(ec[ed-2][ed-2],ec[ed-2][ed-1],ec[ed-1][ed-2],ec[ed-1][ed-1]);eh.push(...eT),ee&&(em.unshift(jordanBase2x2(ec[ed-2][ed-2],ec[ed-2][ed-1],ec[ed-1][ed-2],ec[ed-1][ed-1],eT[0],eT[1],K,Z)),inflateMatrix(ey,G),eg=H(eg,ey),ed>2&&(ey=ea(Array(ed-2).fill(eu)))),ed-=2,ec.pop(),ec.pop();for(var eC=0;eC<ed;eC++)ec[eC].pop(),ec[eC].pop()}if(0===ed)break}if(eh.sort((F,$)=>+V(et(F),et($))),eb>100){var eE=Error("The eigenvalues failed to converge. Only found these eigenvalues: "+eh.join(", "));throw eE.values=eh,eE.vectors=[],eE}return{values:eh,C:ee?H(eg,blockDiag(em,G)):void 0}}function findEigenvectors(F,$,K,Z,ee,et,eo){var es=H(ei(K),F,K),eh="BigNumber"===eo,ef="Complex"===eo,ed=eh?en(0):ef?ep(0):0,em=eh?en(1):ef?ep(1):1,eg=[],ey=[];for(var eb of ee){var ew=indexOf(eg,eb,ec);-1===ew?(eg.push(eb),ey.push(1)):ey[ew]+=1}for(var eS=[],e_=eg.length,eN=Array($).fill(ed),ek=ea(Array($).fill(em)),eI=[],_loop=function(F){var ee=eg[F],en=V(es,H(ee,ek)),ea=eu(en,eN);for(ea.shift();ea.length<ey[F];){var ec=inverseIterate(en,$,ea,et,eo);if(null==ec){eI.push(ee);break}ea.push(ec)}var ep=H(ei(Z),K);ea=ea.map(F=>H(ep,F)),eS.push(...ea.map(F=>G(F)))},eT=0;eT<e_;eT++)_loop(eT);if(0!==eI.length){var eC=Error("Failed to find eigenvectors for the following eigenvalues: "+eI.join(", "));throw eC.values=ee,eC.vectors=eS,eC}return eS}function eigenvalues2x2(F,G,H,Z){var et=$(F,Z),en=V(K(F,Z),K(G,H)),ea=K(et,.5),ei=K(ee(V(K(et,et),K(4,en))),.5);return[$(ea,ei),V(ea,ei)]}function jordanBase2x2(F,$,G,H,K,Z,ee,ea){var ei="BigNumber"===ea,eo="Complex"===ea,es=ei?en(0):eo?ep(0):0,eu=ei?en(1):eo?ep(1):1;if(ef(et(G),ee))return[[eu,es],[es,eu]];if(eh(et(V(K,Z)),ee))return[[V(K,H),V(Z,H)],[G,G]];var ec=V(F,K),ed=V($,K),em=V(G,K),eg=V(H,K);return ef(et(ed),ee)?[[ec,eu],[em,es]]:[[ed,es],[eg,eu]]}function inflateMatrix(F,$){for(var V=0;V<F.length;V++)F[V].push(...Array($-F[V].length).fill(0));for(var G=F.length;G<$;G++)F.push(Array($).fill(0)),F[G][G]=1;return F}function blockDiag(F,$){for(var V=[],G=0;G<$;G++)V[G]=Array($).fill(0);var H=0;for(var K of F){for(var Z=K.length,ee=0;ee<Z;ee++)for(var et=0;et<Z;et++)V[H+ee][H+et]=K[ee][et];H+=Z}return V}function indexOf(F,$,V){for(var G=0;G<F.length;G++)if(V(F[G],$))return G;return -1}function inverseIterate(F,$,V,G,H){for(var K,Z="BigNumber"===H?en(1e3):1e3,ee=0;!eh(norm(K=es(F,K=randomOrthogonalVector($,V,H))),Z);)if(++ee>=5)return null;for(ee=0;;){var et=es(F,K);if(ef(norm(orthogonalComplement(K,[et])),G))break;if(++ee>=10)return null;K=normalize(et)}return K}function randomOrthogonalVector(F,$,V){var G="BigNumber"===V,H="Complex"===V,K=Array(F).fill(0).map(F=>2*Math.random()-1);return G&&(K=K.map(F=>en(F))),H&&(K=K.map(F=>ep(F))),normalize(K=orthogonalComplement(K,$),V)}function orthogonalComplement(F,$){for(var G of $)F=V(F,H(Z(em(G,F),em(G,G)),G));return F}function norm(F){return et(ee(em(F,F)))}function normalize(F,$){var V="BigNumber"===$,G="Complex"===$;return H(Z(V?en(1):G?ep(1):1,norm(F)),F)}return function(F,$,V,G,H){void 0===H&&(H=!0);var K,Z=balance(F,$,V,G,H);reduceToHessenberg(F,$,V,G,H,Z);var{values:ee,C:et}=iterateUntilTriangular(F,$,V,G,H);return H&&(K=ed(...K=findEigenvectors(F,$,et,Z,ee,V,G))),{values:ee,vectors:K}}}function createRealSymmetric(F){var{config:$,addScalar:V,subtract:G,abs:H,atan:K,cos:Z,sin:ee,multiplyScalar:et,inv:en,bignumber:ea,multiply:ei,add:eo}=F;function diag(F,$){for(var V,G=F.length,H=Math.abs($/G),K=Array(G),Z=0;Z<G;Z++)K[Z]=createArray(G,0),K[Z][Z]=1;for(var ee=getAij(F);Math.abs(ee[1])>=Math.abs(H);){var et=ee[0][0],en=ee[0][1];V=getTheta(F[et][et],F[en][en],F[et][en]),F=x1(F,V,et,en),K=Sij1(K,V,et,en),ee=getAij(F)}for(var ea=createArray(G,0),ei=0;ei<G;ei++)ea[ei]=F[ei][ei];return sorting(object_clone(ea),object_clone(K))}function diagBig(F,$){for(var V,G=F.length,K=H($/G),Z=Array(G),ee=0;ee<G;ee++)Z[ee]=createArray(G,0),Z[ee][ee]=1;for(var et=getAijBig(F);H(et[1])>=H(K);){var en=et[0][0],ea=et[0][1];V=getThetaBig(F[en][en],F[ea][ea],F[en][ea]),F=x1Big(F,V,en,ea),Z=Sij1Big(Z,V,en,ea),et=getAijBig(F)}for(var ei=createArray(G,0),eo=0;eo<G;eo++)ei[eo]=F[eo][eo];return sorting(object_clone(ei),object_clone(Z))}function getTheta(F,V,G){return Math.abs(V-F)<=$.epsilon?Math.PI/4:.5*Math.atan(2*G/(V-F))}function getThetaBig(F,V,Z){var ee=G(V,F);return H(ee)<=$.epsilon?ea(-1).acos().div(4):et(.5,K(ei(2,Z,en(ee))))}function Sij1(F,$,V,G){for(var H=F.length,K=Math.cos($),Z=Math.sin($),ee=createArray(H,0),et=createArray(H,0),en=0;en<H;en++)ee[en]=K*F[en][V]-Z*F[en][G],et[en]=Z*F[en][V]+K*F[en][G];for(var ea=0;ea<H;ea++)F[ea][V]=ee[ea],F[ea][G]=et[ea];return F}function Sij1Big(F,$,H,K){for(var en=F.length,ei=Z($),eo=ee($),es=createArray(en,ea(0)),eu=createArray(en,ea(0)),ec=0;ec<en;ec++)es[ec]=G(et(ei,F[ec][H]),et(eo,F[ec][K])),eu[ec]=V(et(eo,F[ec][H]),et(ei,F[ec][K]));for(var ep=0;ep<en;ep++)F[ep][H]=es[ep],F[ep][K]=eu[ep];return F}function x1Big(F,$,H,K){for(var en=F.length,es=ea(Z($)),eu=ea(ee($)),ec=et(es,es),ep=et(eu,eu),eh=createArray(en,ea(0)),ef=createArray(en,ea(0)),ed=ei(ea(2),es,eu,F[H][K]),em=V(G(et(ec,F[H][H]),ed),et(ep,F[K][K])),eg=eo(et(ep,F[H][H]),ed,et(ec,F[K][K])),ey=0;ey<en;ey++)eh[ey]=G(et(es,F[H][ey]),et(eu,F[K][ey])),ef[ey]=V(et(eu,F[H][ey]),et(es,F[K][ey]));F[H][H]=em,F[K][K]=eg,F[H][K]=ea(0),F[K][H]=ea(0);for(var eb=0;eb<en;eb++)eb!==H&&eb!==K&&(F[H][eb]=eh[eb],F[eb][H]=eh[eb],F[K][eb]=ef[eb],F[eb][K]=ef[eb]);return F}function x1(F,$,V,G){for(var H=F.length,K=Math.cos($),Z=Math.sin($),ee=K*K,et=Z*Z,en=createArray(H,0),ea=createArray(H,0),ei=ee*F[V][V]-2*K*Z*F[V][G]+et*F[G][G],eo=et*F[V][V]+2*K*Z*F[V][G]+ee*F[G][G],es=0;es<H;es++)en[es]=K*F[V][es]-Z*F[G][es],ea[es]=Z*F[V][es]+K*F[G][es];F[V][V]=ei,F[G][G]=eo,F[V][G]=0,F[G][V]=0;for(var eu=0;eu<H;eu++)eu!==V&&eu!==G&&(F[V][eu]=en[eu],F[eu][V]=en[eu],F[G][eu]=ea[eu],F[eu][G]=ea[eu]);return F}function getAij(F){for(var $=F.length,V=0,G=[0,1],H=0;H<$;H++)for(var K=H+1;K<$;K++)Math.abs(V)<Math.abs(F[H][K])&&(V=Math.abs(F[H][K]),G=[H,K]);return[G,V]}function getAijBig(F){for(var $=F.length,V=0,G=[0,1],K=0;K<$;K++)for(var Z=K+1;Z<$;Z++)H(V)<H(F[K][Z])&&(V=H(F[K][Z]),G=[K,Z]);return[G,V]}function sorting(F,$){for(var V=F.length,G=Array(V),K=Array(V),Z=0;Z<V;Z++)K[Z]=Array(V);for(var ee=0;ee<V;ee++){for(var et=0,en=F[0],ea=0;ea<F.length;ea++)H(F[ea])<H(en)&&(en=F[et=ea]);G[ee]=F.splice(et,1)[0];for(var ei=0;ei<V;ei++)K[ei][ee]=$[ei][et],$[ei].splice(et,1)}return{values:G,vectors:K}}function createArray(F,$){for(var V=Array(F),G=0;G<F;G++)V[G]=$;return V}return function(F,V){var G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:$.epsilon,H=arguments.length>3?arguments[3]:void 0;if("number"===H)return diag(F,G);if("BigNumber"===H)return diagBig(F,G);throw TypeError("Unsupported data type: "+H)}}F=>{var{config:$,typed:V,matrix:G,addScalar:H,subtract:K,equal:Z,abs:ee,atan:et,cos:en,sin:ea,multiplyScalar:ei,divideScalar:eo,inv:es,bignumber:eu,multiply:ec,add:ep,larger:eh,column:ef,flatten:ed,number:em,complex:eg,sqrt:ey,diag:eb,qr:ew,usolve:eS,usolveAll:e_,im:eN,re:ek,smaller:eI,matrixFromColumns:eT,dot:eC}=F,eE=createRealSymmetric({config:$,addScalar:H,subtract:K,column:ef,flatten:ed,equal:Z,abs:ee,atan:et,cos:en,sin:ea,multiplyScalar:ei,inv:es,bignumber:eu,complex:eg,multiply:ec,add:ep}),eA=createComplexEigs({config:$,addScalar:H,subtract:K,multiply:ec,multiplyScalar:ei,flatten:ed,divideScalar:eo,sqrt:ey,abs:ee,bignumber:eu,diag:eb,qr:ew,inv:es,usolve:eS,usolveAll:e_,equal:Z,complex:eg,larger:eh,smaller:eI,matrixFromColumns:eT,dot:eC});return V("eigs",{Array:function(F){return computeValuesAndVectors(G(F))},"Array, number|BigNumber":function(F,$){return computeValuesAndVectors(G(F),$)},Matrix:function(F){var{values:$,vectors:V}=computeValuesAndVectors(F);return{values:G($),vectors:G(V)}},"Matrix, number|BigNumber":function(F,$){var{values:V,vectors:H}=computeValuesAndVectors(F,$);return{values:G(V),vectors:G(H)}}});function computeValuesAndVectors(F,V){void 0===V&&(V=$.epsilon);var G=F.size();if(2!==G.length||G[0]!==G[1])throw RangeError("Matrix must be square (size: "+string_format(G)+")");var H=F.toArray(),K=G[0];if(isReal(H,K,V)&&(coerceReal(H,K),isSymmetric(H,K,V))){var Z=coerceTypes(F,H,K);return eE(H,K,V,Z)}var ee=coerceTypes(F,H,K);return eA(H,K,V,ee)}function isSymmetric(F,$,V){for(var G=0;G<$;G++)for(var H=G;H<$;H++)if(eh(eu(ee(K(F[G][H],F[H][G]))),V))return!1;return!0}function isReal(F,$,V){for(var G=0;G<$;G++)for(var H=0;H<$;H++)if(eh(eu(ee(eN(F[G][H]))),V))return!1;return!0}function coerceReal(F,$){for(var V=0;V<$;V++)for(var G=0;G<$;G++)F[V][G]=ek(F[V][G])}function coerceTypes(F,$,V){var G=F.datatype();if("number"===G||"BigNumber"===G||"Complex"===G)return G;for(var H=!1,K=!1,Z=!1,ee=0;ee<V;ee++)for(var et=0;et<V;et++){var en=$[ee][et];if(is_isNumber(en)||isFraction(en))H=!0;else if(isBigNumber(en))K=!0;else if(isComplex(en))Z=!0;else throw TypeError("Unsupported type in Matrix: "+typeOf(en))}if(K&&Z&&console.warn("Complex BigNumbers not supported, this operation will lose precission."),Z){for(var ea=0;ea<V;ea++)for(var ei=0;ei<V;ei++)$[ea][ei]=eg($[ea][ei]);return"Complex"}if(K){for(var eo=0;eo<V;eo++)for(var es=0;es<V;es++)$[eo][es]=eu($[eo][es]);return"BigNumber"}if(H){for(var ec=0;ec<V;ec++)for(var ep=0;ep<V;ep++)$[ec][ep]=em($[ec][ep]);return"number"}throw TypeError("Matrix contains unsupported types only.")}};var aD="setSymDifference",aM="median",aR=factory_factory(aM,["typed","add","divide","compare","partitionSelect"],F=>{var{typed:$,add:V,divide:G,compare:H,partitionSelect:K}=F;function _median(F){try{var $=(F=flatten(F.valueOf())).length;if(0===$)throw Error("Cannot calculate median of an empty array");if($%2==0){for(var V=$/2-1,G=K(F,V+1),et=F[V],en=0;en<V;++en)H(F[en],et)>0&&(et=F[en]);return ee(et,G)}var ea=K(F,($-1)/2);return Z(ea)}catch(F){throw improveErrorMessage(F,"median")}}var Z=$({"number | BigNumber | Complex | Unit":function(F){return F}}),ee=$({"number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit":function(F,$){return G(V(F,$),2)}});return $(aM,{"Array | Matrix":_median,"Array | Matrix, number | BigNumber":function(F,$){throw Error("median(A, dim) is not yet supported")},"...":function(F){if(containsCollections(F))throw TypeError("Scalar values expected in function median");return _median(F)}})}),aF="unbiased",aO="variance",aP="norm",aB=(F=>{var{typed:$,abs:V,add:G,pow:H,conj:K,sqrt:Z,multiply:ee,equalScalar:et,larger:en,smaller:ea,matrix:ei,ctranspose:eo,eigs:es}=F;return $(aP,{number:Math.abs,Complex:function(F){return F.abs()},BigNumber:function(F){return F.abs()},boolean:function(F){return Math.abs(F)},Array:function(F){return _norm(ei(F),2)},Matrix:function(F){return _norm(F,2)},"number | Complex | BigNumber | boolean, number | BigNumber | string":function(F){return this(F)},"Array, number | BigNumber | string":function(F,$){return _norm(ei(F),$)},"Matrix, number | BigNumber | string":function(F,$){return _norm(F,$)}});function _vectorNormPlusInfinity(F){var $=0;return F.forEach(function(F){var G=V(F);en(G,$)&&($=G)},!0),$}function _vectorNormMinusInfinity(F){var $;return F.forEach(function(F){var G=V(F);(!$||ea(G,$))&&($=G)},!0),$||0}function _vectorNorm(F,$){if($===Number.POSITIVE_INFINITY||"inf"===$)return _vectorNormPlusInfinity(F);if($===Number.NEGATIVE_INFINITY||"-inf"===$)return _vectorNormMinusInfinity(F);if("fro"===$)return _norm(F,2);if("number"==typeof $&&!isNaN($)){if(!et($,0)){var K=0;return F.forEach(function(F){K=G(H(V(F),$),K)},!0),H(K,1/$)}return Number.POSITIVE_INFINITY}throw Error("Unsupported parameter value")}function _matrixNormFrobenius(F){var $=0;return F.forEach(function(F,V){$=G($,ee(F,K(F)))}),V(Z($))}function _matrixNormOne(F){var $=[],H=0;return F.forEach(function(F,K){var Z=K[1],ee=G($[Z]||0,V(F));en(ee,H)&&(H=ee),$[Z]=ee},!0),H}function _matrixNormTwo(F){var $=F.size();if($[0]!==$[1])throw RangeError("Invalid matrix dimensions");var G=es(ee(eo(F),F)).values.toArray();return V(Z(G[G.length-1]))}function _matrixNormInfinity(F){var $=[],H=0;return F.forEach(function(F,K){var Z=K[0],ee=G($[Z]||0,V(F));en(ee,H)&&(H=ee),$[Z]=ee},!0),H}function _matrixNorm(F,$){if(1===$)return _matrixNormOne(F);if($===Number.POSITIVE_INFINITY||"inf"===$)return _matrixNormInfinity(F);if("fro"===$)return _matrixNormFrobenius(F);if(2===$)return _matrixNormTwo(F);throw Error("Unsupported parameter value "+$)}function _norm(F,$){var V=F.size();if(1===V.length)return _vectorNorm(F,$);if(2===V.length){if(V[0]&&V[1])return _matrixNorm(F,$);throw RangeError("Invalid matrix dimensions")}}},"rotationMatrix"),a$=eV({config:config}),az=e1({}),aV=e8({}),aU=e7({}),aW=te({Matrix:aU}),aj=ta({BigNumber:a$,Complex:az,DenseMatrix:aW,Fraction:aV}),aG=tc({typed:aj}),aq=tm({typed:aj}),aH=ty({BigNumber:a$,typed:aj}),aX=t_({Complex:az,typed:aj}),aK=tk({typed:aj}),aQ=tT({config:config,typed:aj}),aZ=tj({typed:aj}),aY=tY({typed:aj}),aJ=t5({typed:aj}),a0=ra({BigNumber:a$,Fraction:aV,complex:aX,typed:aj}),a6=ru({Matrix:aU,equalScalar:aQ,typed:aj}),a9=rg({typed:aj}),a8=ry({Complex:az,config:config,typed:aj}),a7=rx({typed:aj}),ie=rv({Fraction:aV,typed:aj}),ir=rS({typed:aj}),io=rN({DenseMatrix:aW,Matrix:aU,SparseMatrix:a6,typed:aj}),is=rF({bignumber:aH,fraction:ie,number:aJ}),iu=rB({matrix:io,config:config,typed:aj}),il=rV({DenseMatrix:aW,config:config,matrix:io,typed:aj}),ip=rq({DenseMatrix:aW,addScalar:aq,equalScalar:aQ,matrix:io,typed:aj,unaryMinus:a7}),ih=rQ({BigNumber:a$,config:config,matrix:io,typed:aj}),ig=rY({BigNumber:a$,DenseMatrix:aW,Fraction:aV,config:config,equalScalar:aQ,matrix:io,typed:aj}),iy=r5({numeric:is,typed:aj}),ix=r7({DenseMatrix:aW,equalScalar:aQ,matrix:io,typed:aj}),iv=nr({matrix:io,typed:aj}),iw=no({DenseMatrix:aW,config:config,matrix:io,typed:aj}),iS=nf({compare:ig,isNaN:a9,isNumeric:ir,typed:aj}),iN=ny({BigNumber:a$,DenseMatrix:aW,equalScalar:aQ,matrix:io,typed:aj,zeros:ih}),ik=nw({DenseMatrix:aW,config:config,matrix:io,typed:aj}),iI=nI({DenseMatrix:aW,SparseMatrix:a6,addScalar:aq,equalScalar:aQ,matrix:io,typed:aj}),iT=nM({addScalar:aq,conj:aK,multiplyScalar:aY,size:iu,typed:aj}),iC=n$({BigNumber:a$,DenseMatrix:aW,SparseMatrix:a6,config:config,matrix:io,typed:aj}),iE=nV({DenseMatrix:aW,config:config,matrix:io,typed:aj}),iA=nj({addScalar:aq,dot:iT,equalScalar:aQ,matrix:io,multiplyScalar:aY,typed:aj}),iD=nX({bignumber:aH,matrix:io,config:config,larger:iE,largerEq:iw,smaller:il,smallerEq:ik,typed:aj}),iM=an({divideScalar:iy,isZero:aZ,matrix:io,multiply:iA,subtract:ip,typed:aj,unaryMinus:a7}),iR=ac({ImmutableDenseMatrix:au({DenseMatrix:aW,smaller:il})}),iF=ad({add:iI,compare:ig,multiply:iA,partitionSelect:iS,typed:aj}),iO=ab({abs:aG,addScalar:aq,det:iM,divideScalar:iy,identity:iC,matrix:io,multiply:iA,typed:aj,unaryMinus:a7}),iP=aS({Complex:az,config:config,fraction:ie,identity:iC,inv:iO,matrix:io,multiply:iA,number:aJ,typed:aj}),iB=aR({add:iI,compare:ig,divide:aT({divideScalar:iy,equalScalar:aQ,inv:iO,matrix:io,multiply:iA,typed:aj}),partitionSelect:iS,typed:aj});/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let DummyRegressor=class DummyRegressor extends RegressorMixin{strategy;constant;quantile;name="DummyRegressor";tf;constructor({strategy:F="mean",constant:$,quantile:V}={}){super(),this.tf=tf_singleton_getBackend(),this.strategy=F,this.constant=$,this.quantile=V}fit(F,$){typesUtils_assert(isScikit1D($),"y variable can not be converted to a 1D Tensor."),typesUtils_assert(["mean","median","constant","quantile"].includes(this.strategy),`Strategy ${this.strategy} not supported. We support 'mean', 'median', 'constant', and 'quantile'`);let V=convertToNumericTensor1D($);return"mean"===this.strategy?this.constant=V.mean().dataSync()[0]:"median"===this.strategy?this.constant=iB(V.arraySync()):"quantile"===this.strategy&&(typesUtils_assert("number"==typeof this.quantile&&!isNaN(this.quantile)&&isFinite(this.quantile),"quantile is not set to a number. Please set it to a value between 0 and 1 in the constructor"),typesUtils_assert(this.quantile<0||this.quantile>1,"quantile must be set to a value between 0 and 1"),this.constant=iF(V.arraySync(),this.quantile)),this}predict(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F).shape[0];return this.tf.tensor1d(Array($).fill(this.constant))}};function modeFast(F){for(var $,V=new Map,G=0,H=0;H<F.length;H++){var K=V.get(F[H]);void 0===K?K=1:K++,K>G&&($=F[H],G=K),V.set(F[H],K)}if(0===G)throw Error("mode requires at last one data point");return $}var BayesianClassifier=function(){this.totalCount=0,this.data={}};BayesianClassifier.prototype.train=function(F,$){for(var V in this.data[$]||(this.data[$]={}),F){var G=F[V];void 0===this.data[$][V]&&(this.data[$][V]={}),void 0===this.data[$][V][G]&&(this.data[$][V][G]=0),this.data[$][V][G]++}this.totalCount++},BayesianClassifier.prototype.score=function(F){var $,V={};for(var G in F){var H=F[G];for($ in this.data)V[$]={},this.data[$][G]?V[$][G+"_"+H]=(this.data[$][G][H]||0)/this.totalCount:V[$][G+"_"+H]=0}var K={};for($ in V)for(var Z in K[$]=0,V[$])K[$]+=V[$][Z];return K};var PerceptronModel=function(){this.weights=[],this.bias=0};PerceptronModel.prototype.predict=function(F){if(F.length!==this.weights.length)return null;for(var $=0,V=0;V<this.weights.length;V++)$+=this.weights[V]*F[V];return($+=this.bias)>0?1:0},PerceptronModel.prototype.train=function(F,$){if(0!==$&&1!==$)return null;F.length!==this.weights.length&&(this.weights=F,this.bias=1);var V=this.predict(F);if("number"==typeof V&&V!==$){for(var G=$-V,H=0;H<this.weights.length;H++)this.weights[H]+=G*F[H];this.bias+=G}return this};var i$=Math.sqrt(2*Math.PI);function cumulativeDistribution(F){for(var $=F,V=F,G=1;G<15;G++)V*=F*F/(2*G+1),$+=V;return Math.round((.5+$/i$*Math.exp(-F*F/2))*1e4)/1e4}for(var iL=[],iz=0;iz<=3.09;iz+=.01)iL.push(cumulativeDistribution(iz));var iV=V(95534),iU=V.n(iV);/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let DummyClassifier=class DummyClassifier extends ClassifierMixin{constant;strategy;classes;name="DummyClassifier";tf;constructor({strategy:F="mostFrequent",constant:$=0}={}){super(),this.tf=tf_singleton_getBackend(),this.constant=$,this.strategy=F,this.classes=[]}fit(F,$){typesUtils_assert(isScikit1D($),"Data can not be converted to a 1D or 2D matrix."),typesUtils_assert(["mostFrequent","uniform","constant"].includes(this.strategy),`Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`);let V=convertToNumericTensor1D($);return this.classes=Z()(V.arraySync()),"mostFrequent"===this.strategy&&(this.constant=modeFast(V.arraySync())),this}predictProba(F){return typesUtils_assert(isScikit2D(F),"Data can not be converted to a 1D or 2D matrix."),typesUtils_assert(["mostFrequent","uniform","constant"].includes(this.strategy),`Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`),this.tf.oneHot(this.predict(F).toInt(),this.classes.length)}predict(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 1D or 2D matrix."),typesUtils_assert(["mostFrequent","uniform","constant"].includes(this.strategy),`Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`);let $=convertToNumericTensor2D(F).shape[0];if("mostFrequent"===this.strategy||"constant"===this.strategy)return this.tf.tensor1d(Array($).fill(this.constant));let V=[];for(let F=0;F<$;F++)V.push(iU()(this.classes));return this.tf.tensor1d(V)}};function tensorMin(F,$,V){let G=tf_singleton_getBackend();return V?G.tidy(()=>G.where(F.isNaN(),1/0,F).min($)):F.min($)}function tensorMax(F,$,V){let G=tf_singleton_getBackend();return V?G.tidy(()=>G.where(F.isNaN(),-1/0,F).max($)):F.min($)}function tensorSum(F,$,V){let G=tf_singleton_getBackend();return V?G.tidy(()=>G.where(F.isNaN(),0,F).sum($)):F.sum($)}function tensorCount(F,$,V){let G=tf_singleton_getBackend();return V?G.tidy(()=>G.logicalNot(F.isNaN()).sum($)):G.onesLike(F).sum($)}function tensorMean(F,$,V,G){let H=tf_singleton_getBackend();return V?G?H.tidy(()=>tensorSum(F,$,V).div(turnZerosToOnes(tensorCount(F,$,V)))):H.tidy(()=>tensorSum(F,$,V).div(tensorCount(F,$,V))):F.mean($)}function tensorStd(F,$,V){return typesUtils_assert(!!V,"We only need to call this function when ignoreNaN is true"),tf_singleton_getBackend().tidy(()=>{let G=tensorMean(F,$,V),H=tensorCount(F,$,V),K=tensorSum(F.sub(G).square(),$,V),Z=turnZerosToOnes(H);return K.div(Z).sqrt()})}function turnZerosToOnes(F){let $=tf_singleton_getBackend();return $.tidy(()=>{let V=$.zerosLike(F),G=F.equal(V);return F.add(G)})}/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let MinMaxScaler=class MinMaxScaler extends TransformerMixin{featureRange;scale;min;dataMin;dataMax;dataRange;nFeaturesIn;nSamplesSeen;featureNamesIn;name="MinMaxScaler";constructor({featureRange:F=[0,1]}={}){super(),this.tf=tf_singleton_getBackend(),this.featureRange=F,this.scale=this.tf.tensor1d([]),this.min=this.tf.tensor1d([]),this.dataMin=this.tf.tensor1d([]),this.dataMax=this.tf.tensor1d([]),this.dataRange=this.tf.tensor1d([]),this.nFeaturesIn=0,this.nSamplesSeen=0,this.featureNamesIn=[]}isNumber(F){return"number"==typeof F&&isFinite(F)}fit(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix."),typesUtils_assert(this.isNumber(this.featureRange[0])&&this.isNumber(this.featureRange[1])&&this.featureRange[0]<this.featureRange[1],"featureRange needs to contain exactly two numbers where the first is less than the second");let $=convertToNumericTensor2D(F),V=tensorMax($,0,!0),G=tensorMin($,0,!0),H=V.sub(G);return this.scale=this.tf.div(this.featureRange[1]-this.featureRange[0],turnZerosToOnes(H)),this.min=this.tf.sub(this.featureRange[0],G.mul(this.scale)),this.dataMin=G,this.dataMax=V,this.dataRange=H,this.nSamplesSeen=$.shape[0],this.nFeaturesIn=$.shape[1],typesUtils_isDataFrameInterface(F)&&(this.featureNamesIn=[...F.columns]),this}transform(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F),V=$.mul(this.scale).add(this.min);return V}inverseTransform(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F),V=$.sub(this.min).div(this.scale);return V}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let StandardScaler=class StandardScaler extends TransformerMixin{scale;mean;withMean;withStd;nFeaturesIn;nSamplesSeen;featureNamesIn;name="StandardScaler";constructor({withMean:F=!0,withStd:$=!0}={}){super(),this.tf=tf_singleton_getBackend(),this.withMean=F,this.withStd=$,this.scale=this.tf.tensor1d([]),this.mean=this.tf.tensor1d([]),this.nFeaturesIn=0,this.nSamplesSeen=0,this.featureNamesIn=[]}fit(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F);if(this.withMean&&(this.mean=tensorMean($,0,!0)),this.withStd){let F=tensorStd($,0,!0);this.scale=turnZerosToOnes(F)}return this.nSamplesSeen=$.shape[0],this.nFeaturesIn=$.shape[1],typesUtils_isDataFrameInterface(F)&&(this.featureNamesIn=[...F.columns]),this}transform(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F);return this.withMean&&($=$.sub(this.mean)),this.withStd&&($=$.div(this.scale)),$}inverseTransform(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F);return this.withStd&&($=$.mul(this.scale)),this.withMean&&($=$.add(this.mean)),$}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let MaxAbsScaler=class MaxAbsScaler extends TransformerMixin{scale;nFeaturesIn;nSamplesSeen;featureNamesIn;name="MaxAbsScaler";constructor(){super(),this.tf=tf_singleton_getBackend(),this.scale=this.tf.tensor1d([]),this.nFeaturesIn=0,this.nSamplesSeen=0,this.featureNamesIn=[]}fit(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F),V=tensorMax($.abs(),0,!0);return this.scale=turnZerosToOnes(V),this.nSamplesSeen=$.shape[0],this.nFeaturesIn=$.shape[1],typesUtils_isDataFrameInterface(F)&&(this.featureNamesIn=[...F.columns]),this}transform(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F),V=$.div(this.scale);return V}inverseTransform(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F),V=$.mul(this.scale);return V}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/function isEmpty(F){return null==F||isNaN(F)&&"string"!=typeof F}function removeMissingValuesFromArray(F){let $=F.filter(F=>!isEmpty(F));return $}let SimpleImputer=class SimpleImputer extends TransformerMixin{missingValues;fillValue;strategy;statistics;name="SimpleImputer";tf;constructor({strategy:F="mean",fillValue:$,missingValues:V=NaN}={}){super(),this.tf=tf_singleton_getBackend(),this.missingValues=V,this.strategy=F,this.fillValue=$,this.statistics=this.tf.tensor1d([])}fit(F){if("constant"===this.strategy)return this;if("mean"===this.strategy){let $=convertToNumericTensor2D(F),V=tensorMean($,0,!0);return this.statistics=V,this}if("mostFrequent"===this.strategy){let $=convertToNumericTensor2D(F),V=$.transpose().arraySync().map(F=>modeFast(removeMissingValuesFromArray(F)));return this.statistics=this.tf.tensor1d(V),this}if("median"===this.strategy){let $=convertToNumericTensor2D(F),V=$.transpose().arraySync().map(F=>iB(removeMissingValuesFromArray(F)));return this.statistics=this.tf.tensor1d(V),this}throw Error(`Strategy ${this.strategy} is unsupported. Supported strategies are 'mean', 'median', 'mostFrequent', and 'constant'`)}transform(F){if("constant"===this.strategy){let $=convertToTensor2D(F);return void 0===this.fillValue?"string"!==$.dtype?this.tf.where($.isNaN(),0,$):this.tf.where($.isNaN(),"missing_value",$):this.tf.where($.isNaN(),this.fillValue,$)}let $=convertToNumericTensor2D(F);return this.tf.where($.isNaN(),this.statistics.reshape([1,-1]),$)}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let LabelEncoder=class LabelEncoder extends Serialize{classes;name="LabelEncoder";tf;constructor(){super(),this.tf=tf_singleton_getBackend(),this.classes=[]}convertTo1DArray(F){return typesUtils_isSeriesInterface(F)?F.values:typesUtils_isTensor(F)?F.arraySync():F}classesToMapping(F){let $=new Map;return F.forEach((F,V)=>{$.set(F,V)}),$}fit(F){let $=this.convertTo1DArray(F),V=Array.from(new Set($));return this.classes=V,this}transform(F){let $=this.convertTo1DArray(F),V=this.classesToMapping(this.classes),G=$.map(F=>{let $=V.get(F);return void 0===$?-1:$});return this.tf.tensor1d(G)}fitTransform(F){return this.fit(F).transform(F)}inverseTransform(F){let $=this.convertTo1DArray(F),V=this.classesToMapping(this.classes),G=new Map(Array.from(V,F=>F.reverse())),H=$.map(F=>void 0===G.get(F)?null:G.get(F));return H}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let OrdinalEncoder=class OrdinalEncoder extends TransformerMixin{categories;handleUnknown;unknownValue;categoriesParam;nFeaturesIn;featureNamesIn;name="OrdinalEncoder";constructor({categories:F="auto",handleUnknown:$="error",unknownValue:V=NaN}={}){super(),this.tf=tf_singleton_getBackend(),this.categoriesParam=F,this.categories=[],this.handleUnknown=$,this.unknownValue=V,this.nFeaturesIn=0,this.featureNamesIn=[]}classesToMapping(F){let $=new Map;return F.forEach((F,V)=>{$.set(F,V)}),$}loopOver2DArrayToSetLabels(F){for(let $=0;$<F[0].length;$++){let V=new Set;for(let G=0;G<F.length;G++)V.add(F[G][$]);let G=Array.from(V);this.categories.push(G)}}fit(F,$){let V=convertScikit2DToArray(F);return"auto"===this.categoriesParam?this.loopOver2DArrayToSetLabels(V):(this.categories=this.categoriesParam,this.nFeaturesIn=0===V.length?0:V[0].length||0,typesUtils_isDataFrameInterface(F)&&(this.featureNamesIn=[...F.columns])),this}loopOver2DArrayToUseLabels(F){let $=this.categories.map(F=>this.classesToMapping(F)),V=[];for(let G=0;G<F.length;G++){let H=[];for(let V=0;V<F[0].length;V++){let K=F[G][V],Z=$[V].get(K);if(void 0===Z){if("error"===this.handleUnknown)throw Error(`Unknown value ${K} encountered while transforming. Not encountered in training data`);Z=this.unknownValue}H.push(Z)}V.push(H)}return V}transform(F,$){let V=convertScikit2DToArray(F),G=this.loopOver2DArrayToUseLabels(V);return this.tf.tensor2d(G,void 0,"int32")}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let Normalizer=class Normalizer extends TransformerMixin{norm;nFeaturesIn;featureNamesIn;name="Normalizer";constructor({norm:F="l2"}={}){super(),this.tf=tf_singleton_getBackend(),this.norm=F,this.nFeaturesIn=0,this.featureNamesIn=[]}fit(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F);return this.nFeaturesIn=$.shape[1],typesUtils_isDataFrameInterface(F)&&(this.featureNamesIn=[...F.columns]),this}transform(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F);if("l1"===this.norm){let F=this.tf.abs($).sum(1).reshape([-1,1]);return $.divNoNan(F)}if("l2"===this.norm){let F=$.square().sum(1).sqrt().reshape([-1,1]);return $.divNoNan(F)}let V=this.tf.abs($).max(1).reshape([-1,1]);return $.divNoNan(V)}};let Pipeline=class Pipeline extends Serialize{steps;name="Pipeline";constructor({steps:F=[]}={}){super(),this.steps=F,this.validateSteps(this.steps)}isTransformer(F){return"passthrough"===F||"function"==typeof F.fit&&"function"==typeof F.transform&&"function"==typeof F.fitTransform}isEstimator(F){return"passthrough"===F||"function"==typeof F.fit}validateSteps(F){if(typesUtils_assert(Array.isArray(F),`steps is not an array. It is ${F}`),0===F.length)return;for(let $=0;$<F.length-1;$++){let V=F[$];typesUtils_assert(Array.isArray(V),`A single step in your pipeline must be an array containing a string as the first argument, and the transformer in the second. Something akin to ['minmaxscaler', new MinMaxScaler()]. Instead it is ${V}`),typesUtils_assert(this.isTransformer(V[1]),`The ${$}th step in your pipeline isn't an array containing a name and a Transformer. Instead it is ${F[$]}.`)}let $=F[F.length-1];typesUtils_assert(Array.isArray($),`The last element in your pipeline must be a 2-element array that contains a string as the first argument, and an estimator as the second. Instead it is ${$}`),typesUtils_assert(this.isEstimator($[1]),`The last element in your pipeline should be an Estimator. Instead it is ${$}`)}transformExceptLast(F){let $=F;for(let F=0;F<this.steps.length-1;F++){let[,V]=this.steps[F];"passthrough"!==V&&($=V.transform($))}return $}fitTransformExceptLast(F){let $=F;for(let F=0;F<this.steps.length-1;F++){let[,V]=this.steps[F];"passthrough"!==V&&($=V.fitTransform($))}return $}getLastEstimator(){return 0===this.steps.length?null:this.steps[this.steps.length-1][1]}assertEstimatorHasFunction(F,$){typesUtils_assert(null!==F,`Your final Estimator is null and therefore you can't call ${$}`),typesUtils_assert("function"==typeof F[$],`Estimator ${F} doesn't implement the function ${$}`)}async fit(F,$){this.validateSteps(this.steps);let V=this.getLastEstimator();this.assertEstimatorHasFunction(V,"fit");let G=this.fitTransformExceptLast(F);return await V.fit(G,$),this}transform(F){this.validateSteps(this.steps);let $=this.getLastEstimator();this.assertEstimatorHasFunction($,"transform");let V=this.transformExceptLast(F);return $.transform(V)}fitTransform(F,$){this.validateSteps(this.steps);let V=this.getLastEstimator();this.assertEstimatorHasFunction(V,"fitTransform");let G=this.fitTransformExceptLast(F);return V.fitTransform(G)}predict(F){this.validateSteps(this.steps);let $=this.getLastEstimator();this.assertEstimatorHasFunction($,"predict");let V=this.transformExceptLast(F);return $.predict(V)}async fitPredict(F,$){this.validateSteps(this.steps);let V=this.getLastEstimator();this.assertEstimatorHasFunction(V,"fitPredict");let G=this.fitTransformExceptLast(F);return await V.fitPredict(G,$)}};function makePipeline(...F){let $=[];for(let V=0;V<F.length;V++){let G=F[V];$.push([G.name,G])}return new Pipeline({steps:$})}function isStringArray(F){return Array.isArray(F)&&"string"==typeof F[0]}let ColumnTransformer=class ColumnTransformer extends Serialize{transformers;remainder;name="ColumnTransformer";tf;constructor({transformers:F=[],remainder:$="drop"}={}){super(),this.tf=tf_singleton_getBackend(),this.transformers=F,this.remainder=$}fit(F,$){for(let V=0;V<this.transformers.length;V++){let[,G,H]=this.transformers[V],K=this.getColumns(F,H);G.fit(K,$)}return this}transform(F,$){let V=[];for(let G=0;G<this.transformers.length;G++){let[,H,K]=this.transformers[G],Z=this.getColumns(F,K);V.push(H.transform(Z,$))}return this.tf.concat(V,1)}fitTransform(F,$){let V=[];for(let G=0;G<this.transformers.length;G++){let[,H,K]=this.transformers[G],Z=this.getColumns(F,K);V.push(H.fitTransform(Z,$))}return this.tf.concat(V,1)}getColumns(F,$){if(typesUtils_isDataFrameInterface(F))return isStringArray($)?F.loc({columns:$}).tensor:Array.isArray($)?F.iloc({columns:$}).tensor:"string"==typeof $?F[$].tensor:F.iloc({columns:[$]}).tensor;if(isStringArray($)||"string"==typeof $)throw Error("Can't pass string selected columns when not a DataFrame");if("number"==typeof $){let V=this.tf.tensor1d([$]);return F.gather(V,1)}{let V=this.tf.tensor1d($);return F.gather(V,1)}}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/function RobustScaler_isEmpty(F){return null==F||isNaN(F)&&"string"!=typeof F}function RobustScaler_removeMissingValuesFromArray(F){let $=F.filter(F=>!RobustScaler_isEmpty(F));return $}let RobustScaler=class RobustScaler extends TransformerMixin{scale;center;nFeaturesIn;featureNamesIn;quantileRange;withScaling;withCentering;name="RobustScaler";constructor({quantileRange:F=[25,75],withCentering:$=!0,withScaling:V=!0}={}){super(),this.tf=tf_singleton_getBackend(),this.scale=this.tf.tensor1d([]),this.center=this.tf.tensor1d([]),this.quantileRange=F,this.withScaling=V,this.withCentering=$,this.nFeaturesIn=0,this.featureNamesIn=[]}isNumber(F){return"number"==typeof F&&isFinite(F)}fit(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix."),typesUtils_assert(this.isNumber(this.quantileRange[0])&&this.isNumber(this.quantileRange[1]),"quantileRange values must be numbers");let $=this.quantileRange[0],V=this.quantileRange[1];typesUtils_assert($<V&&0<=$&&$<=100&&0<=V&&V<=100,"quantileRange numbers must be between 0 and 100");let G=convertToNumericTensor2D(F),H=G.transpose().arraySync();if(this.withCentering){let F=H.map(F=>iF(RobustScaler_removeMissingValuesFromArray(F),.5));this.center=this.tf.tensor1d(F)}if(this.withScaling){let F=H.map(F=>iF(RobustScaler_removeMissingValuesFromArray(F),[$/100,V/100])),G=this.tf.tensor1d(F.map(F=>F[1]-F[0]));this.scale=turnZerosToOnes(G)}return this.nFeaturesIn=G.shape[1],typesUtils_isDataFrameInterface(F)&&(this.featureNamesIn=[...F.columns]),this}transform(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F);return this.withCentering&&($=$.sub(this.center)),this.withScaling&&($=$.div(this.scale)),$}inverseTransform(F){typesUtils_assert(isScikit2D(F),"Data can not be converted to a 2D matrix.");let $=convertToNumericTensor2D(F);return this.withScaling&&($=$.mul(this.scale)),this.withCentering&&($=$.add(this.center)),$}};let KMeans=class KMeans extends Serialize{nClusters;init;nInit;maxIter;tol;randomState;clusterCenters;name="KMeans";tf;constructor({nClusters:F=8,init:$="random",maxIter:V=300,tol:G=1e-4,nInit:H=10,randomState:K}={}){super(),this.tf=tf_singleton_getBackend(),this.nClusters=F,this.init=$,this.maxIter=V,this.tol=G,this.randomState=K,this.nInit=H,this.clusterCenters=this.tf.tensor2d([[]])}initCentroids(F){if("random"===this.init){let $=sampleWithoutReplacement(F.shape[0],this.nClusters,this.randomState);this.clusterCenters=this.tf.gather(F,$);return}throw Error(`init ${this.init} is not currently implemented`)}closestCentroid(F){return this.tf.tidy(()=>{let $=this.tf.expandDims(F,1),V=this.tf.expandDims(this.clusterCenters,0);return this.tf.squaredDifference($,V).sum(2).argMin(1)})}updateCentroids(F,$){return this.tf.tidy(()=>{let V=[];for(let G=0;G<this.nClusters;G++){let H=this.tf.equal($,this.tf.scalar(G).toInt()),K=this.tf.div(this.tf.sum(this.tf.mul(this.tf.expandDims(H.toFloat(),1),F),0),this.tf.sum(H.toFloat()));V.push(K)}return this.tf.stack(V)})}fit(F){let $=convertToNumericTensor2D(F);this.initCentroids($);for(let F=0;F<this.maxIter;F++){let F=this.closestCentroid($);this.clusterCenters=this.updateCentroids($,F)}return this}predict(F){let $=convertToNumericTensor2D(F);return this.closestCentroid($)}transform(F){return this.tf.tidy(()=>{let $=convertToNumericTensor2D(F),V=this.tf.expandDims($,1),G=this.tf.expandDims(this.clusterCenters,0);return this.tf.squaredDifference(V,G).sum(2).sqrt()})}fitPredict(F){return this.fit(F).predict(F)}fitTransform(F){return this.fit(F).transform(F)}score(F){return this.tf.tidy(()=>{let $=convertToNumericTensor2D(F),V=this.tf.expandDims($,1),G=this.tf.expandDims(this.clusterCenters,0);return this.tf.squaredDifference(V,G).sum(2).min(1).sqrt().sum()})}};let iW={loadBoston:"http://scikitjs.org/data/boston.csv",loadIris:"http://scikitjs.org/data/iris.csv",loadWine:"http://scikitjs.org/data/wine.csv",loadDiabetes:"http://scikitjs.org/data/diabetes.csv",loadBreastCancer:"http://scikitjs.org/data/breast_cancer.csv",loadDigits:"http://scikitjs.org/data/digits.csv",fetchCaliforniaHousing:"http://scikitjs.org/data/california_housing.csv"};let VotingRegressor=class VotingRegressor extends RegressorMixin{estimators;weights;name="VotingRegressor";constructor({estimators:F=[],weights:$}={}){super(),this.tf=tf_singleton_getBackend(),this.estimators=F,this.weights=$}async fit(F,$){for(let V=0;V<this.estimators?.length;V++){let[G,H]=this.estimators[V];await H.fit(F,$)}return this}predict(F){let $=[],V=this.estimators.length,G=this.weights||Array(V).fill(1/V);for(let H=0;H<V;H++){let[V,K]=this.estimators[H],Z=G[H];$.push(K.predict(F).mul(Z))}return this.tf.addN($)}transform(F){let $=[],V=this.estimators.length;for(let G=0;G<V;G++){let[V,H]=this.estimators[G];$.push(H.predict(F))}return $}async fitTransform(F,$){return(await this.fit(F,$)).transform(F)}};function makeVotingRegressor(...F){let $=[];for(let V=0;V<F.length;V++){let G=F[V];$.push([G.name,G])}return new VotingRegressor({estimators:$})}let VotingClassifier=class VotingClassifier extends ClassifierMixin{estimators;weights;le;name="VotingClassifier";tf;constructor({estimators:F=[],weights:$,voting:V="hard"}={}){super(),this.tf=tf_singleton_getBackend(),this.estimators=F,this.weights=$,this.voting=V,this.le=new LabelEncoder}async fit(F,$){let V=this.le.fitTransform($);for(let $=0;$<this.estimators?.length;$++){let[G,H]=this.estimators[$];await H.fit(F,V)}return this}predictProba(F){let $=[],V=this.estimators.length,G=this.weights||Array(V).fill(1/V);for(let H=0;H<V;H++){let[V,K]=this.estimators[H],Z=G[H];$.push(K.predictProba(F).mul(Z))}return this.tf.addN($)}predict(F){let $=[],V=this.estimators.length,G=this.weights||Array(V).fill(1/V);if("hard"===this.voting){for(let H=0;H<V;H++){let[V,K]=this.estimators[H],Z=G[H],ee=K.predict(F).toInt(),et=this.tf.oneHot(ee,this.le.classes.length);$.push(et.mul(Z))}return this.tf.tensor1d(this.le.inverseTransform(this.tf.addN($).argMax(1)))}for(let H=0;H<V;H++){let[V,K]=this.estimators[H],Z=G[H],ee=K.predictProba(F);$.push(ee.mul(Z))}return this.tf.tensor1d(this.le.inverseTransform(this.tf.addN($).argMax(1)))}transform(F){let $=[],V=this.estimators.length;if("hard"===this.voting){for(let G=0;G<V;G++){let[V,H]=this.estimators[G];$.push(H.predict(F))}return $}for(let G=0;G<V;G++){let[V,H]=this.estimators[G];$.push(H.predictProba(F))}return $}async fitTransform(F,$){return(await this.fit(F,$)).transform(F)}};function makeVotingClassifier(...F){let $=[];for(let V=0;V<F.length;V++){let G=F[V];$.push([G.name,G])}return new VotingClassifier({estimators:$})}/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let BruteNeighborhood=class BruteNeighborhood{_metric;_entries;tf;constructor({metric:F,entries:$}){this._metric=F,this._entries=$,this.tf=tf_singleton_getBackend()}kNearest(F,$){let{_metric:V,_entries:G}=this;return typesUtils_assert(G.shape[1]==$.shape[1],"X_train.shape[1] must equal X_predict.shape[1]"),this.tf.tidy(()=>{let H=this.tf.unstack($).map($=>this.tf.tidy(()=>{let H=V.tensorDistance($,G).neg(),{values:K,indices:Z}=this.tf.topk(H,F);return[K,Z]}));return{distances:this.tf.stack(H.map(F=>F[0])).neg(),indices:this.tf.stack(H.map(F=>F[1]))}})}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let minkowskiTensorDistance=F=>($,V)=>{let G=tf_singleton_getBackend(),H=$.shape[$.rank-1]??NaN,K=V.shape[V.rank-1]??NaN;return typesUtils_assert(H===K,`minkowskiDistance(${F}).tensorDistance(u,v): u.shape[-1] must equal v.shape[-1].`),G.tidy(()=>G.norm(G.sub($,V),F,-1))},minkowskiMetric=F=>{switch(F){case 1:return iG;case 2:return iq;case 1/0:return iH}typesUtils_assert(1<=F,"minkowskiMetric(p): Invalid p.");let $={tensorDistance:minkowskiTensorDistance(F),distance($,V){let G=$.length;if(G!==V.length)throw Error(`minkowskiMetric(${F}).treeMetric(u,v): u and v must have same length.`);let H=0;for(let K=0;K<G;K++)H+=Math.abs($[K]-V[K])**F;return H**(1/F)},distToBBox($,V){if(2*$.length!=V.length)throw Error(`minkowskiMetric(${F}).treeMetric.minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.`);let G=0;for(let H=0,K=0;K<$.length;K++)G+=Math.max(0,V[H++]-$[K],$[K]-V[H++])**F;return G**(1/F)},name:`minkowskiMetric(${F})`,toString(){return this.name}};return Object.freeze($)},iG=Object.freeze({tensorDistance:minkowskiTensorDistance(1),distance(F,$){let V=F.length;if(V!==$.length)throw Error("minkowskiMetric(1).distance(u,v): u and v must have same length.");let G=0;for(let H=0;H<V;H++)G+=Math.abs(F[H]-$[H]);return G},minDistToBBox(F,$){let V=$.length;if(V!==F.length<<1)throw Error("minkowskiMetric(1).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.");let G=0;for(let H=0;H<V;){let V=F[H>>>1],K=$[H++]-V,Z=V-$[H++],ee=.5*(Math.abs(K)+K+(Math.abs(Z)+Z));G+=ee}return G},name:"manhattanMetric",toString(){return this.name}}),iq=Object.freeze({tensorDistance:minkowskiTensorDistance(2),distance(F,$){let V=F.length;if(V!==$.length)throw Error("minkowskiMetric(2).distance(u,v): u and v must have same length.");let G=0;for(let H=0;H<V;H++){let V=F[H]-$[H];G+=V*V}return Math.sqrt(G)},minDistToBBox(F,$){let V=$.length;if(V!==2*F.length)throw Error("minkowskiMetric(2).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.");let G=0;for(let H=0;H<V;){let V=F[H>>>1],K=$[H++]-V,Z=V-$[H++],ee=.5*(Math.abs(K)+K+(Math.abs(Z)+Z));G+=ee*ee}return Math.sqrt(G)},name:"euclideanMetric",toString(){return this.name}}),iH=Object.freeze({tensorDistance:minkowskiTensorDistance(1/0),distance(F,$){let V=F.length;if(V!==$.length)throw Error("minkowskiMetric(Infinity).distance(u,v): u and v must have same length.");let G=0;for(let H=0;H<V;H++){let V=Math.abs(F[H]-$[H]);G=Math.max(G,V)}return G},minDistToBBox(F,$){let V=$.length;if(V!==2*F.length)throw Error("minkowskiMetric(Infinity).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.");let G=-1/0;for(let H=0;H<V;){let V=F[H>>>1],K=$[H++]-V,Z=V-$[H++],ee=.5*(Math.abs(K)+K+(Math.abs(Z)+Z));G=Math.max(G,ee)}return G},name:"chebyshevMetric",toString(){return this.name}});/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/function _prng_restore(F,$,V){let G=V&&V.state;G&&("object"==typeof G&&$.copy(G,$),F.state=()=>$.copy($,{}))}function alea(F,$){let V=new AleaGen(F),prng=()=>V.next();return _prng_restore(prng,V,$),prng}let AleaGen=class AleaGen{c;s0;s1;s2;constructor(F){null==F&&(F=+new Date);let $=4022871197;function mash(F){F=String(F);for(let V=0;V<F.length;V++){let G=.02519603282416938*($+=F.charCodeAt(V));$=G>>>0,G-=$,G*=$,$=G>>>0,G-=$,$+=4294967296*G}return($>>>0)*23283064365386963e-26}this.c=1,this.s0=mash(" "),this.s1=mash(" "),this.s2=mash(" "),this.s0-=mash(F),this.s0<0&&(this.s0+=1),this.s1-=mash(F),this.s1<0&&(this.s1+=1),this.s2-=mash(F),this.s2<0&&(this.s2+=1)}next(){let{c:F,s0:$,s1:V,s2:G}=this,H=2091639*$+23283064365386963e-26*F;return this.s0=V,this.s1=G,this.s2=H-(this.c=0|H)}copy(F,$){return $.c=F.c,$.s0=F.s0,$.s1=F.s1,$.s2=F.s2,$}};let randUtils_createRng=F=>alea(F?.toString()),randUtils_randInt=F=>($,V)=>{if($>=V)throw Error("randInt(rng)(from,until): from must be less than until.");let G=Math.floor($+(V-$)*F());return G===V?G-1:G},randUtils_shuffle=F=>$=>{let V=randUtils_randInt(F);for(let F=$.length;F>1;F--){let G=V(0,F),H=$[F-1];$[F-1]=$[G],$[G]=H}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let CappedMaxHeap=class CappedMaxHeap{_keys;_vals;_pos;constructor(F,$){let V=F.length;typesUtils_assert(V>0,"new CappedMaxHeap(keys,vals): keys.length must be positive."),typesUtils_assert(V===$.length,"new CappedMaxHeap(keys,vals): keys.length must equal vals.length."),F[0]=NaN,this._keys=F,this._vals=$,this._pos=V}get maxKey(){return this._keys[0]}add(F,$){let{_keys:V,_vals:G,_pos:H}=this;if(0<H)this._pos=--H;else if(V[0]<=F)return;let K=V.length-1;for(;;){let $=(H<<1)+1;if($>K||($+=+($<K&&V[$]<V[$+1]),V[$]<=F))break;V[H]=V[$],G[H]=G[$],H=$}V[H]=F,G[H]=$}sort(){let{_keys:F,_vals:$,_pos:V}=this;typesUtils_assert(0===V,"CappedMaxHeap().sort(): Heap is not full yet.");let swap=(V,G)=>{let H=F[V];F[V]=F[G],F[G]=H;let K=$[V];$[V]=$[G],$[G]=K},sort2=$=>{F[$]>F[$+1]&&swap($,$+1)},sort3=$=>{sort2($),F[$+1]>F[$+2]&&(swap($+1,$+2),sort2($))},sort=($,V)=>{switch(V-$){case 0:case 1:return;case 2:return sort2($);case 3:return sort3($)}let G=$+V>>>1;sort3(G-1);let H=F[G];swap($,G);let K=$,Z=$+1;for(let $=Z;$<V;$++){let V=F[$];V<=H&&(swap($,Z),V<H&&swap(K++,Z),Z++)}sort($,K),sort(Z,V)};sort(0,F.length)}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let child=F=>(F<<1)+1,KdTree_parent=F=>F-1>>1,ceilPow2=F=>(typesUtils_assert(0<=F&&F<=1073741824,"ceilPow2(x): x must be in range [0, 1<<30]."),2147483648>>>-1+Math.clz32((F=Math.max(F=Math.ceil(F),1))-1));let KdTree=class KdTree{_nSamples;_nFeatures;_metric;_points;_indices;_bBoxes;_offsets;tf;constructor(F,$,V,G,H,K,Z){this.tf=tf_singleton_getBackend(),this._nSamples=F,this._nFeatures=$,this._metric=V,this._points=G,this._bBoxes=H,this._offsets=K,this._indices=Z,Object.freeze(this)}static async build({metric:F,entries:$,leafSize:V=16}){typesUtils_assert(1<V,"new KdTree({leafSize=16}): leafSize must be a positive number."),typesUtils_assert("function"==typeof F.minDistToBBox,"new KdTree({metric}): metric must implement `minDistToBBox` function.");let[G,H]=$.shape,K=new Int32Array(G);for(let F=0;F<G;F++)K[F]=F;let Z=(await $.data()).slice(),ee=Array.from(K,(F,$)=>Z.subarray(H*$,H*++$)),et=ceilPow2(G/V),en=2*et-1,ea=en-et,ei=new Int32Array(et+1),eo=function(){let F=2*H,$=new Float32Array(en*F),V=[];for(let G=0;G<en;)V.push($.subarray(F*G,F*++G));return V}(),es=randUtils_randInt(alea(`KdTree[${G},${H}]`)),swapIndices=(F,$)=>{let V=K[F];K[F]=K[$],K[$]=V},buildTree=(F,$,V)=>{let G=eo[F];for(let F=0;F<G.length;F++)G[F]=F%2?-1/0:Infinity;for(let F=$;F<V;F++){let $=H*K[F];for(let F=0;F<G.length;){let V=Z[$+(F>>>1)];G[F]=Math.min(G[F++],V),G[F]=Math.max(G[F++],V)}}if(ea<=F){let G=F-ea;ei[G]=$,ei[G+1]=V;return}let ee=function(){let F=0,$=-1/0;for(let V=G.length;V>0;){let H=G[--V]-G[--V];H>$&&($=H,F=V>>>1)}return F}(),et=$+V>>>1;for(let F=$,G=V;;){let $=Z[H*K[es(F,G)]+ee],V=F,en=F;for(let et=F;et<G;et++){let F=Z[H*K[et]+ee];F<=$&&(swapIndices(et,en),F<$&&swapIndices(V++,en),en++)}if(V>et)G=V;else if(en<et)F=en;else break}let en=child(F);buildTree(en,$,et),buildTree(en+1,et,V)};buildTree(0,0,G);let swapData=(F,$)=>{F*=H,$*=H;for(let V=F+H;F<V;F++,$++){let V=Z[F];Z[F]=Z[$],Z[$]=V}};for(let F=K.slice(),$=0;$<G;$++)for(let V=$;;){let G=F[V];if(F[V]=V,G===$)break;swapData(V,V=G)}return new KdTree(G,H,F,ee,eo,ei,K)}kNearest(F,$){let{_nSamples:V,_nFeatures:G,_metric:H,_points:K,_bBoxes:Z,_offsets:ee,_indices:et}=this;F=Math.min(F,V);let[en,ea]=$.shape;typesUtils_assert(G===ea,"KNeighbors: X_train.shape[1] must equal X_predict.shape[1].");let ei=new Float32Array(en*F),eo=new Int32Array(en*F),es=KdTree_parent(Z.length-1)+1;if(0<F&&0<en){let V,G;let eu=$.dataSync(),knn=(F,$)=>{if(!($>=V.maxKey)){if(F<es){let $=child(F),V=H.minDistToBBox(G,Z[$]),K=H.minDistToBBox(G,Z[$+1]);V<=K?(knn($,V),knn($+1,K)):(knn($+1,K),knn($,V))}else{F-=es;let $=ee[F],Z=ee[F+1];for(let F=$;F<Z;F++){let $=H.distance(G,K[F]);V.add($,et[F])}}}};for(let $=0;$<en;$++){G=eu.subarray(ea*$,ea*($+1));let K=F*$,ee=F+K;V=new CappedMaxHeap(ei.subarray(K,ee),eo.subarray(K,ee)),knn(0,H.minDistToBBox(G,Z[0]))}}return{distances:this.tf.tensor2d(ei,[en,F],"float32"),indices:this.tf.tensor2d(eo,[en,F],"int32")}}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let iX={uniform(F){let $=tf_singleton_getBackend(),{shape:V}=F;return $.fill(V,1/V[1])},distance(F){let $=tf_singleton_getBackend();return $.tidy(()=>{let V=F.min(1,!0),G=$.divNoNan(V.toFloat(),F),H=F.lessEqual(0).toFloat(),K=$.where(V.lessEqual(0),H,G),Z=K.sum(1,!0);return K.div(Z)})}},iK={minkowski:F=>minkowskiMetric(F),manhattan:()=>minkowskiMetric(1),euclidean:()=>minkowskiMetric(2),chebyshev:()=>minkowskiMetric(1/0)},iQ={kdTree:KdTree.build,brute:async F=>new BruteNeighborhood(F),auto:F=>"function"==typeof F.metric.minDistToBBox?iQ.kdTree(F):iQ.brute(F)};let KNeighborsBase=class KNeighborsBase extends Serialize{static SUPPORTED_ALGORITHMS=Object.freeze(Object.keys(iQ));_neighborhood;_y;weights;algorithm;leafSize;p;metric;nNeighbors;constructor(F={}){super(),Object.assign(this,F)}_getFitParams(){let{_neighborhood:F,_y:$,nNeighbors:V=5,weights:G="uniform"}=this;typesUtils_assert(0<=V&&V%1==0,"KNeighbors({nNeighbors})::predict(X): nNeighbors must be a positive int."),typesUtils_assert(Object.keys(iX).includes(G),"KNeighbors({weights})::predict(X): invalid weights."),typesUtils_assert(void 0!=F&&void 0!=$,"KNeighbors::predict(X): model not trained yet. Call `await fit(x, y)` first.");let H=iX[G];return{nNeighbors:V,weightsFn:H,neighborhood:F,y:$}}async fit(F,$){let{algorithm:V="auto",metric:G="minkowski",p:H=2,leafSize:K}=this;typesUtils_assert(Object.keys(iK).includes(G),"KNeighbors({metric}).fit(X,y): invalid metric."),typesUtils_assert(Object.keys(iQ).includes(V),"KNeighbors({algorithm}).fit(X,y): invalid algorithm.");let Z=iK[G](H),ee=convertToNumericTensor2D(F);return this._neighborhood=await iQ[V]({entries:ee,metric:Z,leafSize:K}),this._y=convertToNumericTensor1D($),this}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let KNeighborsRegressor=class KNeighborsRegressor extends KNeighborsBase{name="KNeighborsRegressor";predict(F){let $=tf_singleton_getBackend(),{neighborhood:V,y:G,nNeighbors:H,weightsFn:K}=this._getFitParams();return $.tidy(()=>{let Z=convertToNumericTensor2D(F),{distances:ee,indices:et}=V.kNearest(H,Z),en=G.gather(et),ea=K(ee);return $.matMul(en.reshape([-1,1,H]),ea.reshape([-1,H,1])).as1D()})}};/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/function polyfillUnique(F){F.engine().backendNames().includes("tensorflow")&&!F.getKernel("Unique","tensorflow")&&(console.info("[scikit.js] Installing tfjs-node polyfill for tf.unique()."),F.registerKernel({kernelName:"Unique",backendName:"tensorflow",kernelFunc:$=>{let V=$.inputs.x,G=$.backend,{axis:H}=$.attrs,K=F.tensor1d([H],"int32"),Z={float32:G.binding.TF_FLOAT,float64:G.binding.TF_DOUBLE,int32:G.binding.TF_INT32,int64:G.binding.TF_INT64,complex64:G.binding.TF_COMPLEX64,bool:G.binding.TF_BOOL,string:G.binding.TF_STRING};typesUtils_assert(Object.keys(Z).includes(V.dtype),"Unexpected dtype.");try{let F=[{value:Z[V.dtype],name:"T",type:G.binding.TF_ATTR_TYPE},{value:Z.int32,name:"Taxis",type:G.binding.TF_ATTR_TYPE},{value:Z.int32,name:"out_idx",type:G.binding.TF_ATTR_TYPE}];return G.executeMultipleOutputs("UniqueV2",F,[V,K],2)}finally{K.dispose()}}}))}function accuracy(F,$){let V=tf_singleton_getBackend();return V.tidy(()=>{$=utils_convertToTensor1D($);let G=this.predict(F);return V.equal($,G).sum().div($.shape[0])})}/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let KNeighborsClassifier=class KNeighborsClassifier extends KNeighborsBase{classes_;score=accuracy;name="KNeighborsClassifier";predictProba(F){let{neighborhood:$,y:V,nNeighbors:G,weightsFn:H}=this._getFitParams(),[K]=this.classes_?.shape,Z=tf_singleton_getBackend();return Z.tidy(()=>{let ee=convertToNumericTensor2D(F),et=ee.shape[0],{distances:en,indices:ea}=$.kNearest(G,ee),ei=V.gather(ea),eo=H(en),es=Z.oneHot(ei,K);return Z.mul(es.reshape([et,G,K]),eo.reshape([et,G,1])).sum(1)})}predict(F){let $=this.classes_;return tf_singleton_getBackend().tidy(()=>{let V=this.predictProba(F),G=V.argMax(1);return $.gather(G)})}async fit(F,$){let V=tf_singleton_getBackend(),{values:G,indices:H}=V.tidy(()=>{let F=utils_convertToTensor1D($);return polyfillUnique(V),V.unique(F)});return await super.fit(F,H),this.classes_=G,this}};// *  @license
let LinearSVC=class LinearSVC extends SGDClassifier{constructor({penalty:F="l2",C:$=1,fitIntercept:V=!0}={}){let G=tf_singleton_getBackend();super({modelCompileArgs:{optimizer:G.train.adam(.1),loss:G.losses.hingeLoss,metrics:["accuracy"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[G.callbacks.earlyStopping({monitor:"loss",patience:50})]},denseLayerArgs:{units:1,useBias:!!V,activation:"softmax",kernelInitializer:G.initializers.zeros(),biasInitializer:G.initializers.zeros(),kernelRegularizer:"l2"===F?G.regularizers.l2({l2:$}):"l1"===F?G.regularizers.l1({l1:$}):void 0},isClassification:!0,optimizerType:"adam",lossType:"hingeLoss"}),this.name="LinearSVC"}};// *  @license
let LinearSVR=class LinearSVR extends SGDRegressor{constructor({epsilon:F=0,C:$=1,fitIntercept:V=!0}={}){let G=tf_singleton_getBackend();super({modelCompileArgs:{optimizer:G.train.adam(.1),loss:function($,V){return G.abs(G.sub($,V)).sub(F).maximum(0)},metrics:["accuracy"]},modelFitArgs:{batchSize:32,epochs:1e3,verbose:0,callbacks:[G.callbacks.earlyStopping({monitor:"loss",patience:50})]},denseLayerArgs:{units:1,useBias:!!V,kernelRegularizer:G.regularizers.l2({l2:$})},optimizerType:"adam",lossType:"custom"}),this.name="LinearSVR"}};/**
*  @license
* Copyright 2022, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let BaseNaiveBayes=class BaseNaiveBayes extends Serialize{priors;varSmoothing;classes;means;variances;tf;constructor(F={}){super(),this.tf=tf_singleton_getBackend(),this.classes=this.tf.tensor1d([]),this.means=[],this.variances=[],F.priors&&(this.priors=utils_convertToTensor1D(F.priors)),this.varSmoothing=F.varSmoothing?F.varSmoothing:1e-9}async fit(F,$){let V=convertToNumericTensor2D(F),G=utils_convertToTensor1D($),{values:H,meansByLabel:K,variancesByLabel:Z}=this.tf.tidy(()=>{polyfillUnique(this.tf);let F=[],$=[],{values:H}=this.tf.unique(G),{variance:K}=this.tf.moments(V,0),Z=K.max().mul(this.varSmoothing);return this.tf.unstack(H).forEach(H=>{let K=this.tf.equal(G,H).toFloat(),ee=this.tf.sum(K),et=this.tf.mul(V,K.expandDims(1)).sum(0).div(ee),en=this.tf.sub(V,et).mul(K.expandDims(1)).pow(2).sum(0).div(ee).add(Z);F.push(et),$.push(en)}),{values:H,meansByLabel:F,variancesByLabel:$}});return this.classes=H,this.means=K,this.variances=Z,this}predictProba(F){let $=convertToNumericTensor2D(F),V=this.tf.tidy(()=>{let F=[];this.classes.unstack().forEach((V,G)=>{let H=this.means[G],K=this.variances[G],Z=this.kernel($,H,K);F.push(Z)});let V=this.tf.stack(F,1);return this.priors?V.mul(this.priors):V});return V}predict(F){let $=this.predictProba(F);return $.argMax(1)}};/**
*  @license
* Copyright 2022, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let GaussianNB=class GaussianNB extends BaseNaiveBayes{name="GaussianNB";kernel(F,$,V){let G=tf_singleton_getBackend();return G.tidy(()=>G.sub(F,$.expandDims(0)).pow(2).div(V.expandDims(0).mul(-2)).exp().div(V.mul(2*Math.PI).expandDims(0).sqrt()).prod(1))}};function giniCoefficient(F,$){let V=0;for(let $=0;$<F.length;$++)V+=F[$]*F[$];return 1-V/($*$)}function entropy(F,$){let V=0;for(let G=0;G<F.length;G++){let H=F[G];H>0&&(H/=$,V-=H*Math.log2(H))}return V}function mse(F,$,V){let G=$/V;return F/V-G*G}function arrayMax(F){let $=Number.NEGATIVE_INFINITY;for(let V=0;V<F.length;V++)F[V]>$&&($=F[V]);return $}let ClassificationCriterion=class ClassificationCriterion extends Serialize{y;impurityMeasure;start=0;end=0;pos=0;nLabels;labelFreqsTotal=[];labelFreqsLeft=[];labelFreqsRight=[];nSamples=0;nSamplesLeft=0;nSamplesRight=0;name="ClassificationCriterion";constructor({impurityMeasure:F,y:$}){super(),this.impurityMeasure=F,this.nLabels=arrayMax($)+1,this.y=$,this.labelFreqsTotal=Array(this.nLabels).fill(0),this.labelFreqsLeft=Array(this.nLabels).fill(0),this.labelFreqsRight=Array(this.nLabels).fill(0)}init(F,$,V){this.start=F,this.end=$,this.nSamples=$-F,this.labelFreqsTotal=this.labelFreqsTotal.fill(0),this.labelFreqsLeft=this.labelFreqsLeft.fill(0),this.labelFreqsRight=this.labelFreqsRight.fill(0);for(let G=F;G<$;G++){let F=V[G];this.labelFreqsTotal[this.y[F]]+=1}}reset(){this.pos=this.start,this.labelFreqsLeft=this.labelFreqsLeft.fill(0),this.labelFreqsRight=this.labelFreqsRight.fill(0)}update(F,$){for(let V=this.pos;V<F;V++){let F=$[V];this.labelFreqsLeft[this.y[F]]+=1}for(let F=0;F<this.labelFreqsTotal.length;F++)this.labelFreqsRight[F]=this.labelFreqsTotal[F]-this.labelFreqsLeft[F];this.pos=F,this.nSamplesLeft=this.pos-this.start,this.nSamplesRight=this.end-this.pos}childrenImpurities(){let F="gini"===this.impurityMeasure?giniCoefficient:entropy;return{impurityLeft:F(this.labelFreqsLeft,this.nSamplesLeft),impurityRight:F(this.labelFreqsRight,this.nSamplesRight)}}impurityImprovement(){let{impurityLeft:F,impurityRight:$}=this.childrenImpurities();return-this.nSamplesLeft*F-this.nSamplesRight*$}nodeImpurity(){return("gini"===this.impurityMeasure?giniCoefficient:entropy)(this.labelFreqsTotal,this.nSamples)}nodeValue(){return this.labelFreqsTotal}static fromJson(F){let $=JSON.parse(F),V=new ClassificationCriterion({impurityMeasure:$.impurityMeasure,y:$.y});return Object.assign(V,$)}};let RegressionCriterion=class RegressionCriterion extends Serialize{y;impurityMeasure;start=0;end=0;pos=0;squaredSum=0;squaredSumLeft=0;squaredSumRight=0;sumTotal=0;sumTotalLeft=0;sumTotalRight=0;nSamples=0;nSamplesLeft=0;nSamplesRight=0;name="RegressionCriterion";constructor({impurityMeasure:F,y:$}){super(),this.impurityMeasure=F,this.y=$}init(F,$,V){this.sumTotal=0,this.squaredSum=0,this.start=F,this.end=$,this.nSamples=$-F;for(let G=F;G<$;G++){let F=V[G],$=this.y[F];this.sumTotal+=$,this.squaredSum+=$*$}}reset(){this.pos=this.start,this.squaredSumLeft=0,this.sumTotalLeft=0,this.squaredSumRight=0,this.sumTotalRight=0}update(F,$){for(let V=this.pos;V<F;V++){let F=$[V],G=this.y[F];this.sumTotalLeft+=G,this.squaredSumLeft+=G*G}this.sumTotalRight=this.sumTotal-this.sumTotalLeft,this.squaredSumRight=this.squaredSum-this.squaredSumLeft,this.pos=F,this.nSamplesLeft=this.pos-this.start,this.nSamplesRight=this.end-this.pos}childrenImpurities(){let F=mse;return{impurityLeft:F(this.squaredSumLeft,this.sumTotalLeft,this.nSamplesLeft),impurityRight:F(this.squaredSumRight,this.sumTotalRight,this.nSamplesRight)}}impurityImprovement(){let{impurityLeft:F,impurityRight:$}=this.childrenImpurities();return-this.nSamplesLeft*F-this.nSamplesRight*$}nodeImpurity(){return mse(this.squaredSum,this.sumTotal,this.nSamples)}nodeValue(){return[this.sumTotal/this.nSamples]}static fromJson(F){let $=JSON.parse(F),V=new RegressionCriterion({impurityMeasure:$.impurityMeasure,y:$.y});return Object.assign(V,$)}};var iZ=V(69983),iY=V.n(iZ);function makeDefaultSplit(){return{feature:0,threshold:0,pos:-1,impurityLeft:Number.POSITIVE_INFINITY,impurityRight:Number.POSITIVE_INFINITY,foundSplit:!1}}let Splitter=class Splitter extends Serialize{kMinSplitDiff;X;y;criterion;start;end;minSamplesLeaf;maxFeatures;featureOrder;shuffleFeatures;sampleMap;nSamplesTotal;nFeatures;name="Splitter";constructor({X:F,y:$,minSamplesLeaf:V,impurityMeasure:G,maxFeatures:H,samplesSubset:K=[]}){if(super(),this.X=F,this.y=$,this.nFeatures=F[0].length,this.minSamplesLeaf=V,this.maxFeatures=Math.min(H,this.nFeatures),this.shuffleFeatures=H<this.nFeatures,this.sampleMap=new Int32Array(F.length),this.start=0,this.end=0,this.kMinSplitDiff=1e-8,0===K.length){this.nSamplesTotal=F.length;for(let F=0;F<this.nSamplesTotal;F++)this.sampleMap[F]=F}else{this.nSamplesTotal=K.length;for(let F=0;F<this.nSamplesTotal;F++)this.sampleMap[F]=K[F]}"squared_error"===G?this.criterion=new RegressionCriterion({impurityMeasure:G,y:$}):this.criterion=new ClassificationCriterion({impurityMeasure:G,y:$}),this.featureOrder=[];for(let F=0;F<this.nFeatures;F++)this.featureOrder.push(F);this.resetSampleRange(0,this.nSamplesTotal)}resetSampleRange(F,$){this.start=F,this.end=$,this.criterion.init(F,$,this.sampleMap)}splitNode(){let F=makeDefaultSplit(),$=makeDefaultSplit(),V=Number.NEGATIVE_INFINITY,G=Number.NEGATIVE_INFINITY,H=0,K=0;for(F.foundSplit=!1,this.shuffleFeatures&&(this.featureOrder=iY()(this.featureOrder));H<this.maxFeatures;){K=this.featureOrder[H];let Z=new Float32Array(this.end-this.start);for(let F=this.start;F<this.end;F++){let $=this.X[this.sampleMap[F]][K];Z[F-this.start]=$}if(Z.sort(),this.criterion.reset(),this.sampleMap.subarray(this.start,this.end).sort((F,$)=>this.X[F][K]-this.X[$][K]),Z[0]===Z[Z.length-1]){H+=1;continue}let ee=this.start+1;for(;ee<this.end;){for(;ee<this.end&&Z[ee-this.start]<=Z[ee-this.start-1]+this.kMinSplitDiff;)ee++;if(ee===this.end){ee++;continue}!(ee-this.start<this.minSamplesLeaf||this.end-ee<this.minSamplesLeaf)&&(F.pos=ee,this.criterion.update(F.pos,this.sampleMap),(V=this.criterion.impurityImprovement())>G&&(G=V,F.foundSplit=!0,F.feature=K,F.threshold=(Z[ee-this.start-1]+Z[ee-this.start])/2,$=Object.assign({},F))),ee+=1}H+=1}if(!F.foundSplit)return F;{if($.pos<this.end&&K!==$.feature){let F=this.start,V=this.end,G=0;for(;F<V;)this.X[this.sampleMap[F]][$.feature]<=$.threshold?F+=1:(V-=1,G=this.sampleMap[F],this.sampleMap[F]=this.sampleMap[V],this.sampleMap[V]=G)}this.criterion.reset(),this.criterion.update($.pos,this.sampleMap);let{impurityLeft:F,impurityRight:V}=this.criterion.childrenImpurities();return $.impurityLeft=F,$.impurityRight=V,$}}};function validateX(F){if(0===F.length)throw Error(`X can not be empty, but it has a length of 0. It is ${F}.`);for(let $=0;$<F.length;$++){let V=F[$];if(0===V.length)throw Error(`Rows in X can not be empty, but row ${$} in X is ${V}.`);for(let F=0;F<V.length;F++)if("number"!=typeof V[F]||!Number.isFinite(V[F]))throw Error(`X must contain finite non-NaN numbers, but the element at X[${$}][${F}] is ${V[F]}`)}}function validateY(F){if(0===F.length)throw Error(`y can not be empty, but it has a length of 0. It is ${F}.`);for(let $=0;$<F.length;$++){let V=F[$];if(!Number.isSafeInteger(V))throw Error(`Some y values are not an integer. Found ${V} but must be an integer only`)}}function argMax(F){return F.map((F,$)=>[F,$]).reduce((F,$)=>$[0]>F[0]?$:F)[1]}let DecisionTree=class DecisionTree{nodes=[];isBuilt=!1;name="DecisionTree";getLeafNodes(F){let $=[];for(let V=0;V<F.length;V++){let G=0;for(;!this.nodes[G].isLeaf;)G=F[V][this.nodes[G].splitFeature]<=this.nodes[G].threshold?this.nodes[G].leftChildId:this.nodes[G].rightChildId;$.push(G)}return $}populateChildIds(){for(let F=1;F<this.nodes.length;F++)this.nodes[F].isLeft?this.nodes[this.nodes[F].parentId].leftChildId=F:this.nodes[this.nodes[F].parentId].rightChildId=F}predictProba(F){if(!this.isBuilt)throw Error("Decision tree must be built with BuildTree method before predictions can be made.");let $=this.getLeafNodes(F),V=[];for(let F=0;F<$.length;F++){let G=[],H=$[F];for(let F=0;F<this.nodes[0].value.length;F++)G.push(this.nodes[H].value[F]/this.nodes[H].nSamples);V.push(G)}return V}predictClassification(F){if(!this.isBuilt)throw Error("Decision tree must be built with BuildTree method before predictions can be made.");let $=this.getLeafNodes(F),V=[];for(let F=0;F<$.length;F++){let G=$[F];V.push(argMax(this.nodes[G].value))}return V}predictRegression(F){if(!this.isBuilt)throw Error("Decision tree must be built with BuildTree method before predictions can be made.");let $=this.getLeafNodes(F),V=[];for(let F=0;F<$.length;F++){let G=$[F];V.push(this.nodes[G].value[0])}return V}};let DecisionTreeBase=class DecisionTreeBase extends Serialize{splitter;stack=[];minSamplesLeaf;maxDepth;minSamplesSplit;minImpurityDecrease;tree;criterion;maxFeatures;maxFeaturesNumb;X=[];y=[];labelEncoder;name;constructor({criterion:F="gini",maxDepth:$=Number.POSITIVE_INFINITY,minSamplesSplit:V=2,minSamplesLeaf:G=1,maxFeatures:H,minImpurityDecrease:K=0}={}){super(),this.criterion=F,this.maxDepth=void 0===$?Number.POSITIVE_INFINITY:Number($),this.minSamplesSplit=V,this.minSamplesLeaf=G,this.maxFeatures=H,this.minImpurityDecrease=K,this.maxFeaturesNumb=0,this.tree=new DecisionTree,this.name="DecisionTreeBase"}calcMaxFeatures(F,$){return"log2"===$?Math.floor(Math.log2(F)):"sqrt"===$||"auto"===$?Math.floor(Math.sqrt(F)):"number"==typeof $?(typesUtils_assert($>=1,"maxFeatures must be greater than 1"),Math.min(Math.floor($),F)):F}fit(F,$,V){this.X=F,this.y=$;let G=V||[];this.maxFeaturesNumb=this.calcMaxFeatures(F[0].length,this.maxFeatures),this.splitter=new Splitter({X:F,y:$,minSamplesLeaf:this.minSamplesLeaf,impurityMeasure:this.criterion,maxFeatures:this.maxFeaturesNumb,samplesSubset:G});let H={start:0,end:this.splitter.sampleMap.length,depth:0,impurity:0,nSamples:this.splitter.sampleMap.length,parentId:-1,isLeft:!1};this.stack.push(H);let K=!0;for(;0!==this.stack.length;){let F=this.stack.pop();this.splitter.resetSampleRange(F.start,F.end);let $=makeDefaultSplit(),V=!(F.depth<this.maxDepth)||F.nSamples<this.minSamplesSplit||F.nSamples<2*this.minSamplesLeaf;K&&(F.impurity=this.splitter.criterion.nodeImpurity(),K=!1),V||($=this.splitter.splitNode(),V=V||!$.foundSplit||F.impurity<=this.minImpurityDecrease);let G={parentId:F.parentId,impurity:F.impurity,isLeaf:V,isLeft:F.isLeft,nSamples:F.nSamples,splitFeature:$.feature,threshold:$.threshold,value:this.splitter.criterion.nodeValue().slice(),leftChildId:-1,rightChildId:-1};this.tree.nodes.push(G);let H=this.tree.nodes.length-1;if(!V){let V={start:$.pos,end:F.end,nSamples:F.end-$.pos,depth:F.depth+1,parentId:H,isLeft:!1,impurity:$.impurityRight};this.stack.push(V);let G={start:F.start,end:$.pos,nSamples:$.pos-F.start,depth:F.depth+1,parentId:H,isLeft:!0,impurity:$.impurityLeft};this.stack.push(G)}}this.tree.populateChildIds(),this.tree.isBuilt=!0}};let DecisionTreeClassifier=class DecisionTreeClassifier extends DecisionTreeBase{labelEncoder;name;constructor({criterion:F="gini",maxDepth:$,minSamplesSplit:V=2,minSamplesLeaf:G=1,maxFeatures:H,minImpurityDecrease:K=0}={}){typesUtils_assert(["gini","entropy"].includes(F),'For classification must pass either the "gini" or "entropy" criterion'),super({criterion:F,maxDepth:$,minSamplesSplit:V,minSamplesLeaf:G,maxFeatures:H,minImpurityDecrease:K}),this.labelEncoder=new LabelEncoder,this.name="DecisionTreeClassifier"}fit(F,$){typesUtils_assert(isScikit1D($),"y value is not a 1D container"),typesUtils_assert(isScikit2D(F),"X value is not a 2D container");let V=convertScikit2DToArray(F),G=convertScikit1DToArray($);typesUtils_assert(V.length===G.length,"X and y must be the same size"),validateX(V),validateY(G);let H=this.labelEncoder.fitTransform(G);return super.fit(V,convertScikit1DToArray(H)),this}getNLeaves(){return this.tree.nodes.filter(F=>F.isLeaf).length}predict(F){typesUtils_assert(isScikit2D(F),"X value is not a 2D container");let $=convertScikit2DToArray(F);validateX($);let V=this.tree.predictClassification($);return this.labelEncoder.inverseTransform(V)}predictProba(F){return this.tree.predictProba(F)}score(F,$){let V=this.predict(F);return accuracyScore($,V)}};let DecisionTreeRegressor=class DecisionTreeRegressor extends DecisionTreeBase{name;constructor({criterion:F="squared_error",maxDepth:$,minSamplesSplit:V=2,minSamplesLeaf:G=1,maxFeatures:H,minImpurityDecrease:K=0}={}){typesUtils_assert(["squared_error"].includes(F),'Must pass the regression criterion of "squared_error"'),super({criterion:F,maxDepth:$,minSamplesSplit:V,minSamplesLeaf:G,maxFeatures:H,minImpurityDecrease:K}),this.name="DecisionTreeRegressor"}fit(F,$){typesUtils_assert(isScikit1D($),"y value is not a 1D container"),typesUtils_assert(isScikit2D(F),"X value is not a 2D container");let V=convertScikit2DToArray(F),G=convertScikit1DToArray($);return typesUtils_assert(V.length===G.length,"X and y must be the same size"),validateX(V),super.fit(V,G),this}getNLeaves(){return this.tree.nodes.filter(F=>F.isLeaf).length}predict(F){return this.tree.predictRegression(F)}score(F,$){let V=this.predict(F);return r2Score($,V)}};let makeRegression=({nSamples:F=100,nFeatures:$=100,nInformative:V=10,nTargets:G=1,noise:H=1,bias:K=0,effectiveRank:Z=null,tailStrength:ee=.5,shuffle:et=!1,coef:en=!1}={})=>{let ea=tf_singleton_getBackend();return ea.tidy(()=>{let ei;let eo=Math.min($,V);ei=null===Z?ea.randomNormal([F,$]):makeLowRankMatrix({nSamples:F,nFeatures:$,effectiveRank:Z,tailStrength:ee});let es=ea.randomNormal([eo,G]).mul(100),eu=ea.zeros([$-eo,G]),ec=ea.concat([es,eu]),ep=ei.dot(ec).add(K);if(H>0&&(ep=ep.add(ea.randomNormal(ep.shape,void 0,H))),et){let $=ea.util.createShuffledIndices(F);ei=ei.gather($)}return(ep=ea.squeeze(ep),en)?[ei,ep,ea.squeeze(ec)]:[ei,ep]})},makeLowRankMatrix=({nSamples:F=100,nFeatures:$=100,effectiveRank:V=10,tailStrength:G=.5}={})=>{let H=tf_singleton_getBackend();return H.tidy(()=>{let K=Math.min(F,$),[Z]=H.linalg.qr(H.randomNormal([F,K])),[ee]=H.linalg.qr(H.randomNormal([$,K])),et=H.range(0,K),en=et.div(V),ea=H.exp(en.square().neg()).mul(1-G),ei=H.exp(en.mul(-.1)).mul(G),eo=ea.add(ei);return Z.mul(eo).dot(ee.transpose())})};/**
*  @license
* Copyright 2022, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/let KFold=class KFold{nSplits;shuffle;randomState;name;tf;constructor({nSplits:F=5,shuffle:$=!1,randomState:V}={}){typesUtils_assert(Number.isInteger(F=Number(F))&&F>1,"new KFold({nSplits}): nSplits must be an int greater than 1."),this.tf=tf_singleton_getBackend(),this.nSplits=F,this.shuffle=!!$,this.randomState=V,this.name="KFold"}getNumSplits(){return this.nSplits}*split(F,$,V){let{nSplits:G,shuffle:H,randomState:K}=this,Z=getLength(F);typesUtils_assert(G<=Z,"KFold({nSplits})::split(X): nSplits must not be greater than X.shape[0]."),null!=$&&typesUtils_assert(Z===getLength($),"KFold::split(X,y): X.shape[0] must equal y.shape[0]."),null!=V&&typesUtils_assert(Z===getLength(V),"KFold::split(X,y,groups): X.shape[0] must equal groups.shape[0].");let ee=new Int32Array(Z);for(let F=0;F<ee.length;F++)ee[F]=F;if(H){let F=randUtils_createRng(K);randUtils_shuffle(F)(ee)}let et=Math.floor(Z/G),en=Z%G,ea=0;for(;ea<Z;){let F=en-- >0?et+1:et,$=new Int32Array(Z-F);$.set(ee.subarray(0,ea),0),$.set(ee.subarray(ea+F),ea);let V=ee.slice(ea,ea+F);yield{trainIndex:this.tf.tensor1d($,"int32"),testIndex:this.tf.tensor1d(V,"int32")},ea+=F}}};function validateShuffleSplit(F,$,V,G=.1){let H,K;if(typesUtils_assert(void 0===V||"number"==typeof V,`Invalid value for trainSize: ${V}. Must be number or undefined`),typesUtils_assert(void 0===$||"number"==typeof $,`Invalid value for testSize: ${$}. Must be number or undefined`),void 0===$&&void 0===V&&($=G),"number"==typeof $&&(Number.isInteger($)&&($>=F||$<=0)||!Number.isInteger($)&&($<=0||$>=1)))throw Error(`testSize=${$} should be either positive and smaller than the number of samples ${F} or a float in the (0, 1) range`);if("number"==typeof V&&(Number.isInteger(V)&&(V>=F||V<=0)||!Number.isInteger(V)&&(V<=0||V>=1)))throw Error(`trainSize=${V} should be either positive and smaller than the number of samples ${F} or a float in the (0, 1) range`);if(!Number.isInteger(V)&&!Number.isInteger($)&&V&&$&&V+$>1)throw Error(`The sum of testSize and trainSize = ${V+$}, should be in the (0, 1) range. Reduce testSize and/or trainSize.`);if(Number.isInteger($)?H=$:"number"==typeof $&&(H=Math.ceil($*F)),Number.isInteger(V)?K=V:"number"==typeof V&&(K=Math.ceil(V*F)),void 0===V&&(K=F-H),void 0===$&&(H=F-K),"number"!=typeof K||"number"!=typeof H)throw Error("nTrain and nTest must be a number");if(K+H>F)throw Error(`The sum of trainSize and testSize = ${K+H}, should be smaller than the number of samples ${F}. Reduce testSize and/or trainSize.`);if(K=Math.floor(K),H=Math.floor(H),0===K)throw Error(`With nSamples=${F}, testSize=${$} and trainSize=${V}, the resulting train set will be empty. Adjust any of the aforementioned parameters.`);return[K,H]}function getIndices(F,$){let V=tf_singleton_getBackend();return typesUtils_isTensor(F)?V.gather(F,$):typesUtils_isDataFrameInterface(F)?F.iloc({rows:$}):typesUtils_isSeriesInterface(F)?F.iloc($):$.map($=>F[$])}function trainTestSplit(F,$,V=.1,G,H){let K=getLength(F),Z=getLength($);typesUtils_assert(K===Z,"X and y don't have the same number of elements. They are of different size");let[ee,et]=validateShuffleSplit(K,V,G),en=sampleWithoutReplacement(K,K,H),ea=en.slice(0,ee),ei=en.slice(ee);return[getIndices(F,ea),getIndices(F,ei),getIndices($,ea),getIndices($,ei)]}/**
*  @license
* Copyright 2022, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/async function crossValScore(F,$,V,G){let H,K=tf_singleton_getBackend(),Z=null==V||null==G&&!isScikit1D(V);Z&&(G=G??V);let{cv:ee=new KFold,groups:et,scoring:en}=G??{};null==en&&(typesUtils_assert("function"==typeof F.score,"crossValScore(estimator,[X,y],params): Either params.scoring or estimator.score(X,y) must be defined."),en=F.score);let ea=[];en=en.bind(F),K.engine().startScope();try{for(let{trainIndex:G,testIndex:H}of($=convertToTensor2D($),Z||(V=utils_convertToTensor1D(V)),ee.split($,V,et))){let K;let ee=$.gather(G),et=$.gather(H);if(Z)await F.fit(ee),K=en(et);else{let $=V.gather(G),Z=V.gather(H);await F.fit(ee,$),K=en(et,Z),$.dispose(),Z.dispose()}ea.push(K),G.dispose(),H.dispose(),ee.dispose(),et.dispose()}return H=K.stack(ea)}finally{K.engine().endScope(H)}}/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/},36377:function(F,$,V){var G=V(84832),H=V(68652),K=V(90801),Z=V(92030),ee=V(3618),et=V(89049),en=V(51971);en.alea=G,en.xor128=H,en.xorwow=K,en.xorshift7=Z,en.xor4096=ee,en.tychei=et,F.exports=en},84832:function(F,$,V){var G;!function(F,H,K){function Alea(F){var $=this,V=Mash();$.next=function(){var F=2091639*$.s0+23283064365386963e-26*$.c;return $.s0=$.s1,$.s1=$.s2,$.s2=F-($.c=0|F)},$.c=1,$.s0=V(" "),$.s1=V(" "),$.s2=V(" "),$.s0-=V(F),$.s0<0&&($.s0+=1),$.s1-=V(F),$.s1<0&&($.s1+=1),$.s2-=V(F),$.s2<0&&($.s2+=1)}function copy(F,$){return $.c=F.c,$.s0=F.s0,$.s1=F.s1,$.s2=F.s2,$}function impl(F,$){var V=new Alea(F),G=$&&$.state,H=V.next;return H.int32=function(){return 4294967296*V.next()|0},H.double=function(){return H()+(2097152*H()|0)*11102230246251565e-32},H.quick=H,G&&("object"==typeof G&&copy(G,V),H.state=function(){return copy(V,{})}),H}function Mash(){var F=4022871197;return function($){$=String($);for(var V=0;V<$.length;V++){var G=.02519603282416938*(F+=$.charCodeAt(V));F=G>>>0,G-=F,G*=F,F=G>>>0,G-=F,F+=4294967296*G}return(F>>>0)*23283064365386963e-26}}H&&H.exports?H.exports=impl:V.amdD&&V.amdO?void 0!==(G=(function(){return impl}).call($,V,$,H))&&(H.exports=G):this.alea=impl}(0,F=V.nmd(F),V.amdD)},89049:function(F,$,V){var G;!function(F,H,K){function XorGen(F){var $=this,V="";$.next=function(){var F=$.b,V=$.c,G=$.d,H=$.a;return F=F<<25^F>>>7^V,V=V-G|0,G=G<<24^G>>>8^H,H=H-F|0,$.b=F=F<<20^F>>>12^V,$.c=V=V-G|0,$.d=G<<16^V>>>16^H,$.a=H-F|0},$.a=0,$.b=0,$.c=-1640531527,$.d=1367130551,F===Math.floor(F)?($.a=F/4294967296|0,$.b=0|F):V+=F;for(var G=0;G<V.length+20;G++)$.b^=0|V.charCodeAt(G),$.next()}function copy(F,$){return $.a=F.a,$.b=F.b,$.c=F.c,$.d=F.d,$}function impl(F,$){var V=new XorGen(F),G=$&&$.state,prng=function(){return(V.next()>>>0)/4294967296};return prng.double=function(){do var F=((V.next()>>>11)+(V.next()>>>0)/4294967296)/2097152;while(0===F);return F},prng.int32=V.next,prng.quick=prng,G&&("object"==typeof G&&copy(G,V),prng.state=function(){return copy(V,{})}),prng}H&&H.exports?H.exports=impl:V.amdD&&V.amdO?void 0!==(G=(function(){return impl}).call($,V,$,H))&&(H.exports=G):this.tychei=impl}(0,F=V.nmd(F),V.amdD)},68652:function(F,$,V){var G;!function(F,H,K){function XorGen(F){var $=this,V="";$.x=0,$.y=0,$.z=0,$.w=0,$.next=function(){var F=$.x^$.x<<11;return $.x=$.y,$.y=$.z,$.z=$.w,$.w^=$.w>>>19^F^F>>>8},F===(0|F)?$.x=F:V+=F;for(var G=0;G<V.length+64;G++)$.x^=0|V.charCodeAt(G),$.next()}function copy(F,$){return $.x=F.x,$.y=F.y,$.z=F.z,$.w=F.w,$}function impl(F,$){var V=new XorGen(F),G=$&&$.state,prng=function(){return(V.next()>>>0)/4294967296};return prng.double=function(){do var F=((V.next()>>>11)+(V.next()>>>0)/4294967296)/2097152;while(0===F);return F},prng.int32=V.next,prng.quick=prng,G&&("object"==typeof G&&copy(G,V),prng.state=function(){return copy(V,{})}),prng}H&&H.exports?H.exports=impl:V.amdD&&V.amdO?void 0!==(G=(function(){return impl}).call($,V,$,H))&&(H.exports=G):this.xor128=impl}(0,F=V.nmd(F),V.amdD)},3618:function(F,$,V){var G;!function(F,H,K){function XorGen(F){var $=this;$.next=function(){var F,V,G=$.w,H=$.X,K=$.i;return $.w=G=G+1640531527|0,V=H[K+34&127],F=H[K=K+1&127],V^=V<<13,F^=F<<17,V^=V>>>15,F^=F>>>12,V=H[K]=V^F,$.i=K,V+(G^G>>>16)|0},function(F,$){var V,G,H,K,Z,ee=[],et=128;for($===(0|$)?(G=$,$=null):($+="\x00",G=0,et=Math.max(et,$.length)),H=0,K=-32;K<et;++K)$&&(G^=$.charCodeAt((K+32)%$.length)),0===K&&(Z=G),G^=G<<10,G^=G>>>15,G^=G<<4,G^=G>>>13,K>=0&&(Z=Z+1640531527|0,H=0==(V=ee[127&K]^=G+Z)?H+1:0);for(H>=128&&(ee[127&($&&$.length||0)]=-1),H=127,K=512;K>0;--K)G=ee[H+34&127],V=ee[H=H+1&127],G^=G<<13,V^=V<<17,G^=G>>>15,V^=V>>>12,ee[H]=G^V;F.w=Z,F.X=ee,F.i=H}($,F)}function copy(F,$){return $.i=F.i,$.w=F.w,$.X=F.X.slice(),$}function impl(F,$){null==F&&(F=+new Date);var V=new XorGen(F),G=$&&$.state,prng=function(){return(V.next()>>>0)/4294967296};return prng.double=function(){do var F=((V.next()>>>11)+(V.next()>>>0)/4294967296)/2097152;while(0===F);return F},prng.int32=V.next,prng.quick=prng,G&&(G.X&&copy(G,V),prng.state=function(){return copy(V,{})}),prng}H&&H.exports?H.exports=impl:V.amdD&&V.amdO?void 0!==(G=(function(){return impl}).call($,V,$,H))&&(H.exports=G):this.xor4096=impl}(0,F=V.nmd(F),V.amdD)},92030:function(F,$,V){var G;!function(F,H,K){function XorGen(F){var $=this;$.next=function(){var F,V,G=$.x,H=$.i;return F=G[H],F^=F>>>7,V=F^F<<24^((F=G[H+1&7])^F>>>10)^((F=G[H+3&7])^F>>>3)^((F=G[H+4&7])^F<<7),F=G[H+7&7],F^=F<<13,V^=F^F<<9,G[H]=V,$.i=H+1&7,V},function(F,$){var V,G,H=[];if($===(0|$))G=H[0]=$;else for(V=0,$=""+$;V<$.length;++V)H[7&V]=H[7&V]<<15^$.charCodeAt(V)+H[V+1&7]<<13;for(;H.length<8;)H.push(0);for(V=0;V<8&&0===H[V];++V);for(G=8==V?H[7]=-1:H[V],F.x=H,F.i=0,V=256;V>0;--V)F.next()}($,F)}function copy(F,$){return $.x=F.x.slice(),$.i=F.i,$}function impl(F,$){null==F&&(F=+new Date);var V=new XorGen(F),G=$&&$.state,prng=function(){return(V.next()>>>0)/4294967296};return prng.double=function(){do var F=((V.next()>>>11)+(V.next()>>>0)/4294967296)/2097152;while(0===F);return F},prng.int32=V.next,prng.quick=prng,G&&(G.x&&copy(G,V),prng.state=function(){return copy(V,{})}),prng}H&&H.exports?H.exports=impl:V.amdD&&V.amdO?void 0!==(G=(function(){return impl}).call($,V,$,H))&&(H.exports=G):this.xorshift7=impl}(0,F=V.nmd(F),V.amdD)},90801:function(F,$,V){var G;!function(F,H,K){function XorGen(F){var $=this,V="";$.next=function(){var F=$.x^$.x>>>2;return $.x=$.y,$.y=$.z,$.z=$.w,$.w=$.v,($.d=$.d+362437|0)+($.v=$.v^$.v<<4^(F^F<<1))|0},$.x=0,$.y=0,$.z=0,$.w=0,$.v=0,F===(0|F)?$.x=F:V+=F;for(var G=0;G<V.length+64;G++)$.x^=0|V.charCodeAt(G),G==V.length&&($.d=$.x<<10^$.x>>>4),$.next()}function copy(F,$){return $.x=F.x,$.y=F.y,$.z=F.z,$.w=F.w,$.v=F.v,$.d=F.d,$}function impl(F,$){var V=new XorGen(F),G=$&&$.state,prng=function(){return(V.next()>>>0)/4294967296};return prng.double=function(){do var F=((V.next()>>>11)+(V.next()>>>0)/4294967296)/2097152;while(0===F);return F},prng.int32=V.next,prng.quick=prng,G&&("object"==typeof G&&copy(G,V),prng.state=function(){return copy(V,{})}),prng}H&&H.exports?H.exports=impl:V.amdD&&V.amdO?void 0!==(G=(function(){return impl}).call($,V,$,H))&&(H.exports=G):this.xorwow=impl}(0,F=V.nmd(F),V.amdD)},51971:function(F,$,V){var G;!function(H,K,Z){var ee,et=256,en=6,ea=52,ei="random",eo=Z.pow(et,en),es=Z.pow(2,ea),eu=2*es,ec=et-1;function seedrandom(F,$,V){var G=[],H=mixkey(flatten(($=!0==$?{entropy:!0}:$||{}).entropy?[F,tostring(K)]:null==F?autoseed():F,3),G),ee=new ARC4(G),prng=function(){for(var F=ee.g(en),$=eo,V=0;F<es;)F=(F+V)*et,$*=et,V=ee.g(1);for(;F>=eu;)F/=2,$/=2,V>>>=1;return(F+V)/$};return prng.int32=function(){return 0|ee.g(4)},prng.quick=function(){return ee.g(4)/4294967296},prng.double=prng,mixkey(tostring(ee.S),K),($.pass||V||function(F,$,V,G){return(G&&(G.S&&copy(G,ee),F.state=function(){return copy(ee,{})}),V)?(Z[ei]=F,$):F})(prng,H,"global"in $?$.global:this==Z,$.state)}function ARC4(F){var $,V=F.length,G=this,H=0,K=G.i=G.j=0,Z=G.S=[];for(V||(F=[V++]);H<et;)Z[H]=H++;for(H=0;H<et;H++)Z[H]=Z[K=ec&K+F[H%V]+($=Z[H])],Z[K]=$;(G.g=function(F){for(var $,V=0,H=G.i,K=G.j,Z=G.S;F--;)$=Z[H=ec&H+1],V=V*et+Z[ec&(Z[H]=Z[K=ec&K+$])+(Z[K]=$)];return G.i=H,G.j=K,V})(et)}function copy(F,$){return $.i=F.i,$.j=F.j,$.S=F.S.slice(),$}function flatten(F,$){var V,G=[],H=typeof F;if($&&"object"==H)for(V in F)try{G.push(flatten(F[V],$-1))}catch(F){}return G.length?G:"string"==H?F:F+"\x00"}function mixkey(F,$){for(var V,G=F+"",H=0;H<G.length;)$[ec&H]=ec&(V^=19*$[ec&H])+G.charCodeAt(H++);return tostring($)}function autoseed(){try{var F;return ee&&(F=ee.randomBytes)?F=F(et):(F=new Uint8Array(et),(H.crypto||H.msCrypto).getRandomValues(F)),tostring(F)}catch(F){var $=H.navigator,V=$&&$.plugins;return[+new Date,H,V,H.screen,tostring(K)]}}function tostring(F){return String.fromCharCode.apply(0,F)}if(mixkey(Z.random(),K),F.exports){F.exports=seedrandom;try{ee=V(75042)}catch(F){}}else void 0!==(G=(function(){return seedrandom}).call($,V,$,F))&&(F.exports=G)}("undefined"!=typeof self?self:this,[],Math)},32553:function(F,$,V){"use strict";var G=V(40396).Buffer,H=G.isEncoding||function(F){switch((F=""+F)&&F.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function _normalizeEncoding(F){var $;if(!F)return"utf8";for(;;)switch(F){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return F;default:if($)return;F=(""+F).toLowerCase(),$=!0}}function normalizeEncoding(F){var $=_normalizeEncoding(F);if("string"!=typeof $&&(G.isEncoding===H||!H(F)))throw Error("Unknown encoding: "+F);return $||F}function StringDecoder(F){var $;switch(this.encoding=normalizeEncoding(F),this.encoding){case"utf16le":this.text=utf16Text,this.end=utf16End,$=4;break;case"utf8":this.fillLast=utf8FillLast,$=4;break;case"base64":this.text=base64Text,this.end=base64End,$=3;break;default:this.write=simpleWrite,this.end=simpleEnd;return}this.lastNeed=0,this.lastTotal=0,this.lastChar=G.allocUnsafe($)}function utf8CheckByte(F){return F<=127?0:F>>5==6?2:F>>4==14?3:F>>3==30?4:F>>6==2?-1:-2}function utf8CheckIncomplete(F,$,V){var G=$.length-1;if(G<V)return 0;var H=utf8CheckByte($[G]);return H>=0?(H>0&&(F.lastNeed=H-1),H):--G<V||-2===H?0:(H=utf8CheckByte($[G]))>=0?(H>0&&(F.lastNeed=H-2),H):--G<V||-2===H?0:(H=utf8CheckByte($[G]))>=0?(H>0&&(2===H?H=0:F.lastNeed=H-3),H):0}function utf8CheckExtraBytes(F,$,V){if((192&$[0])!=128)return F.lastNeed=0,"";if(F.lastNeed>1&&$.length>1){if((192&$[1])!=128)return F.lastNeed=1,"";if(F.lastNeed>2&&$.length>2&&(192&$[2])!=128)return F.lastNeed=2,""}}function utf8FillLast(F){var $=this.lastTotal-this.lastNeed,V=utf8CheckExtraBytes(this,F,$);return void 0!==V?V:this.lastNeed<=F.length?(F.copy(this.lastChar,$,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):void(F.copy(this.lastChar,$,0,F.length),this.lastNeed-=F.length)}function utf8Text(F,$){var V=utf8CheckIncomplete(this,F,$);if(!this.lastNeed)return F.toString("utf8",$);this.lastTotal=V;var G=F.length-(V-this.lastNeed);return F.copy(this.lastChar,0,G),F.toString("utf8",$,G)}function utf8End(F){var $=F&&F.length?this.write(F):"";return this.lastNeed?$+"":$}function utf16Text(F,$){if((F.length-$)%2==0){var V=F.toString("utf16le",$);if(V){var G=V.charCodeAt(V.length-1);if(G>=55296&&G<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=F[F.length-2],this.lastChar[1]=F[F.length-1],V.slice(0,-1)}return V}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=F[F.length-1],F.toString("utf16le",$,F.length-1)}function utf16End(F){var $=F&&F.length?this.write(F):"";if(this.lastNeed){var V=this.lastTotal-this.lastNeed;return $+this.lastChar.toString("utf16le",0,V)}return $}function base64Text(F,$){var V=(F.length-$)%3;return 0===V?F.toString("base64",$):(this.lastNeed=3-V,this.lastTotal=3,1===V?this.lastChar[0]=F[F.length-1]:(this.lastChar[0]=F[F.length-2],this.lastChar[1]=F[F.length-1]),F.toString("base64",$,F.length-V))}function base64End(F){var $=F&&F.length?this.write(F):"";return this.lastNeed?$+this.lastChar.toString("base64",0,3-this.lastNeed):$}function simpleWrite(F){return F.toString(this.encoding)}function simpleEnd(F){return F&&F.length?this.write(F):""}$.StringDecoder=StringDecoder,StringDecoder.prototype.write=function(F){var $,V;if(0===F.length)return"";if(this.lastNeed){if(void 0===($=this.fillLast(F)))return"";V=this.lastNeed,this.lastNeed=0}else V=0;return V<F.length?$?$+this.text(F,V):this.text(F,V):$||""},StringDecoder.prototype.end=utf8End,StringDecoder.prototype.text=utf8Text,StringDecoder.prototype.fillLast=function(F){if(this.lastNeed<=F.length)return F.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);F.copy(this.lastChar,this.lastTotal-this.lastNeed,0,F.length),this.lastNeed-=F.length}},40396:function(F,$,V){var G=V(21876),H=G.Buffer;function copyProps(F,$){for(var V in F)$[V]=F[V]}function SafeBuffer(F,$,V){return H(F,$,V)}H.from&&H.alloc&&H.allocUnsafe&&H.allocUnsafeSlow?F.exports=G:(copyProps(G,$),$.Buffer=SafeBuffer),copyProps(H,SafeBuffer),SafeBuffer.from=function(F,$,V){if("number"==typeof F)throw TypeError("Argument must not be a number");return H(F,$,V)},SafeBuffer.alloc=function(F,$,V){if("number"!=typeof F)throw TypeError("Argument must be a number");var G=H(F);return void 0!==$?"string"==typeof V?G.fill($,V):G.fill($):G.fill(0),G},SafeBuffer.allocUnsafe=function(F){if("number"!=typeof F)throw TypeError("Argument must be a number");return H(F)},SafeBuffer.allocUnsafeSlow=function(F){if("number"!=typeof F)throw TypeError("Argument must be a number");return G.SlowBuffer(F)}},82287:function(F,$){"use strict";var V,G,H;!function(K,Z){G=[],void 0!==(H="function"==typeof(V=Z)?V.apply($,G):V)&&(F.exports=H)}(0,function(){function ok(){return!0}function notOk(){return!1}function undef(){}function create(){var F=[{name:"number",test:function(F){return"number"==typeof F}},{name:"string",test:function(F){return"string"==typeof F}},{name:"boolean",test:function(F){return"boolean"==typeof F}},{name:"Function",test:function(F){return"function"==typeof F}},{name:"Array",test:Array.isArray},{name:"Date",test:function(F){return F instanceof Date}},{name:"RegExp",test:function(F){return F instanceof RegExp}},{name:"Object",test:function(F){return"object"==typeof F&&null!==F&&F.constructor===Object}},{name:"null",test:function(F){return null===F}},{name:"undefined",test:function(F){return void 0===F}}],$={name:"any",test:ok},V=[],G=[],H={types:F,conversions:G,ignore:V};function findTypeByName(F){var V=findInArray(H.types,function($){return $.name===F});if(V)return V;if("any"===F)return $;var G=findInArray(H.types,function($){return $.name.toLowerCase()===F.toLowerCase()});throw TypeError('Unknown type "'+F+'"'+(G?'. Did you mean "'+G.name+'"?':""))}function findTypeIndex(F){return F===$?999:H.types.indexOf(F)}function findTypeName(F){var $=findInArray(H.types,function($){return $.test(F)});if($)return $.name;throw TypeError("Value has unknown type. Value: "+F)}function find(F,$){if(!F.signatures)throw TypeError("Function is no typed-function");if("string"==typeof $){V=$.split(",");for(var V,G=0;G<V.length;G++)V[G]=V[G].trim()}else if(Array.isArray($))V=$;else throw TypeError("String array or a comma separated string expected");var H=V.join(","),K=F.signatures[H];if(K)return K;throw TypeError("Signature not found (signature: "+(F.name||"unnamed")+"("+V.join(", ")+"))")}function convert(F,$){var V=findTypeName(F);if($===V)return F;for(var G=0;G<H.conversions.length;G++){var K=H.conversions[G];if(K.from===V&&K.to===$)return K.convert(F)}throw Error("Cannot convert from "+V+" to "+$)}function stringifyParams(F){return F.map(function(F){var $=F.types.map(getTypeName);return(F.restParam?"...":"")+$.join("|")}).join(",")}function parseParam(F,$){var V=0===F.indexOf("..."),G=(V?F.length>3?F.slice(3):"any":F).split("|").map(trim).filter(notEmpty).filter(notIgnore),H=filterConversions($,G),K=G.map(function(F){var $=findTypeByName(F);return{name:F,typeIndex:findTypeIndex($),test:$.test,conversion:null,conversionIndex:-1}}),Z=H.map(function(F){var V=findTypeByName(F.from);return{name:F.from,typeIndex:findTypeIndex(V),test:V.test,conversion:F,conversionIndex:$.indexOf(F)}});return{types:K.concat(Z),restParam:V}}function parseSignature(F,$,V){var G=[];return(""!==F.trim()&&(G=F.split(",").map(trim).map(function(F,$,G){var H=parseParam(F,V);if(H.restParam&&$!==G.length-1)throw SyntaxError('Unexpected rest parameter "'+F+'": only allowed for the last parameter');return H})),G.some(isInvalidParam))?null:{params:G,fn:$}}function hasRestParam(F){var $=last(F);return!!$&&$.restParam}function hasConversions(F){return F.types.some(function(F){return null!=F.conversion})}function compileTest(F){if(!F||0===F.types.length)return ok;if(1===F.types.length)return findTypeByName(F.types[0].name).test;if(2===F.types.length){var $=findTypeByName(F.types[0].name).test,V=findTypeByName(F.types[1].name).test;return function(F){return $(F)||V(F)}}var G=F.types.map(function(F){return findTypeByName(F.name).test});return function(F){for(var $=0;$<G.length;$++)if(G[$](F))return!0;return!1}}function compileTests(F){var $,V,G;if(hasRestParam(F)){var H=($=initial(F).map(compileTest)).length,K=compileTest(last(F)),testRestParam=function(F){for(var $=H;$<F.length;$++)if(!K(F[$]))return!1;return!0};return function(F){for(var V=0;V<$.length;V++)if(!$[V](F[V]))return!1;return testRestParam(F)&&F.length>=H+1}}return 0===F.length?function(F){return 0===F.length}:1===F.length?(V=compileTest(F[0]),function(F){return V(F[0])&&1===F.length}):2===F.length?(V=compileTest(F[0]),G=compileTest(F[1]),function(F){return V(F[0])&&G(F[1])&&2===F.length}):($=F.map(compileTest),function(F){for(var V=0;V<$.length;V++)if(!$[V](F[V]))return!1;return F.length===$.length})}function getParamAtIndex(F,$){return $<F.params.length?F.params[$]:hasRestParam(F.params)?last(F.params):null}function getExpectedTypeNames(F,$,V){var G=getParamAtIndex(F,$);return(G?V?G.types.filter(isExactType):G.types:[]).map(getTypeName)}function getTypeName(F){return F.name}function isExactType(F){return null===F.conversion||void 0===F.conversion}function mergeExpectedParams(F,$){var V=uniq(flatMap(F,function(F){return getExpectedTypeNames(F,$,!1)}));return -1!==V.indexOf("any")?["any"]:V}function createError(F,$,V){var G,H,K,Z=F||"unnamed",ee=V;for(K=0;K<$.length;K++){var et=ee.filter(function(F){var V=compileTest(getParamAtIndex(F,K));return(K<F.params.length||hasRestParam(F.params))&&V($[K])});if(0===et.length){if((H=mergeExpectedParams(ee,K)).length>0){var en=findTypeName($[K]);return(G=TypeError("Unexpected type of argument in function "+Z+" (expected: "+H.join(" or ")+", actual: "+en+", index: "+K+")")).data={category:"wrongType",fn:Z,index:K,actual:en,expected:H},G}}else ee=et}var ea=ee.map(function(F){return hasRestParam(F.params)?1/0:F.params.length});if($.length<Math.min.apply(null,ea))return(G=TypeError("Too few arguments in function "+Z+" (expected: "+(H=mergeExpectedParams(ee,K)).join(" or ")+", index: "+$.length+")")).data={category:"tooFewArgs",fn:Z,index:$.length,expected:H},G;var ei=Math.max.apply(null,ea);return $.length>ei?(G=TypeError("Too many arguments in function "+Z+" (expected: "+ei+", actual: "+$.length+")")).data={category:"tooManyArgs",fn:Z,index:$.length,expectedLength:ei}:(G=TypeError('Arguments of type "'+$.join(", ")+'" do not match any of the defined signatures of function '+Z+".")).data={category:"mismatch",actual:$.map(findTypeName)},G}function getLowestTypeIndex(F){for(var $=999,V=0;V<F.types.length;V++)isExactType(F.types[V])&&($=Math.min($,F.types[V].typeIndex));return $}function getLowestConversionIndex(F){for(var $=999,V=0;V<F.types.length;V++)isExactType(F.types[V])||($=Math.min($,F.types[V].conversionIndex));return $}function compareParams(F,$){var V;return 0!=(V=F.restParam-$.restParam)||0!=(V=hasConversions(F)-hasConversions($))||0!=(V=getLowestTypeIndex(F)-getLowestTypeIndex($))?V:getLowestConversionIndex(F)-getLowestConversionIndex($)}function compareSignatures(F,$){var V,G,H=Math.min(F.params.length,$.params.length);if(0!=(G=F.params.some(hasConversions)-$.params.some(hasConversions)))return G;for(V=0;V<H;V++)if(0!=(G=hasConversions(F.params[V])-hasConversions($.params[V])))return G;for(V=0;V<H;V++)if(0!==(G=compareParams(F.params[V],$.params[V])))return G;return F.params.length-$.params.length}function filterConversions(F,$){var V={};return F.forEach(function(F){-1!==$.indexOf(F.from)||-1===$.indexOf(F.to)||V[F.from]||(V[F.from]=F)}),Object.keys(V).map(function(F){return V[F]})}function compileArgsPreprocessing(F,$){var V=$;if(F.some(hasConversions)){var G=hasRestParam(F),H=F.map(compileArgConversion);V=function(){for(var F=[],V=G?arguments.length-1:arguments.length,K=0;K<V;K++)F[K]=H[K](arguments[K]);return G&&(F[V]=arguments[V].map(H[V])),$.apply(this,F)}}var K=V;if(hasRestParam(F)){var Z=F.length-1;K=function(){return V.apply(this,slice(arguments,0,Z).concat([slice(arguments,Z)]))}}return K}function compileArgConversion(F){var $,V,G,H,K=[],Z=[];switch(F.types.forEach(function(F){F.conversion&&(K.push(findTypeByName(F.conversion.from).test),Z.push(F.conversion.convert))}),Z.length){case 0:return function(F){return F};case 1:return $=K[0],G=Z[0],function(F){return $(F)?G(F):F};case 2:return $=K[0],V=K[1],G=Z[0],H=Z[1],function(F){return $(F)?G(F):V(F)?H(F):F};default:return function(F){for(var $=0;$<Z.length;$++)if(K[$](F))return Z[$](F);return F}}}function createSignaturesMap(F){var $={};return F.forEach(function(F){F.params.some(hasConversions)||splitParams(F.params,!0).forEach(function(V){$[stringifyParams(V)]=F.fn})}),$}function splitParams(F,$){function _splitParams(F,V,G){if(!(V<F.length))return[G.map(function($,V){return{types:$,restParam:V===F.length-1&&hasRestParam(F)}})];var H,K=F[V],Z=$?K.types.filter(isExactType):K.types;if(K.restParam){var ee=Z.filter(isExactType);H=ee.length<Z.length?[ee,Z]:[Z]}else H=Z.map(function(F){return[F]});return flatMap(H,function($){return _splitParams(F,V+1,G.concat([$]))})}return _splitParams(F,0,[])}function hasConflictingParams(F,$){for(var V=Math.max(F.params.length,$.params.length),G=0;G<V;G++)if(!hasOverlap(getExpectedTypeNames(F,G,!0),getExpectedTypeNames($,G,!0)))return!1;var H=F.params.length,K=$.params.length,Z=hasRestParam(F.params),ee=hasRestParam($.params);return Z?ee?H===K:K>=H:ee?H>=K:H===K}function createTypedFunction(F,$){if(0===Object.keys($).length)throw SyntaxError("No signatures provided");var V=[];Object.keys($).map(function(F){return parseSignature(F,$[F],H.conversions)}).filter(notNull).forEach(function(F){var $=findInArray(V,function($){return hasConflictingParams($,F)});if($)throw TypeError('Conflicting signatures "'+stringifyParams($.params)+'" and "'+stringifyParams(F.params)+'".');V.push(F)});var G=flatMap(V,function(F){return(F?splitParams(F.params,!1):[]).map(function($){return{params:$,fn:F.fn}})}).filter(notNull);G.sort(compareSignatures);var K=G[0]&&G[0].params.length<=2&&!hasRestParam(G[0].params),Z=G[1]&&G[1].params.length<=2&&!hasRestParam(G[1].params),ee=G[2]&&G[2].params.length<=2&&!hasRestParam(G[2].params),et=G[3]&&G[3].params.length<=2&&!hasRestParam(G[3].params),en=G[4]&&G[4].params.length<=2&&!hasRestParam(G[4].params),ea=G[5]&&G[5].params.length<=2&&!hasRestParam(G[5].params),ei=K&&Z&&ee&&et&&en&&ea,eo=G.map(function(F){return compileTests(F.params)}),es=K?compileTest(G[0].params[0]):notOk,eu=Z?compileTest(G[1].params[0]):notOk,ec=ee?compileTest(G[2].params[0]):notOk,ep=et?compileTest(G[3].params[0]):notOk,eh=en?compileTest(G[4].params[0]):notOk,ef=ea?compileTest(G[5].params[0]):notOk,ed=K?compileTest(G[0].params[1]):notOk,em=Z?compileTest(G[1].params[1]):notOk,eg=ee?compileTest(G[2].params[1]):notOk,ey=et?compileTest(G[3].params[1]):notOk,eb=en?compileTest(G[4].params[1]):notOk,ew=ea?compileTest(G[5].params[1]):notOk,eS=G.map(function(F){return compileArgsPreprocessing(F.params,F.fn)}),e_=K?eS[0]:undef,eN=Z?eS[1]:undef,ek=ee?eS[2]:undef,eI=et?eS[3]:undef,eT=en?eS[4]:undef,eC=ea?eS[5]:undef,eE=K?G[0].params.length:-1,eA=Z?G[1].params.length:-1,eD=ee?G[2].params.length:-1,eM=et?G[3].params.length:-1,eR=en?G[4].params.length:-1,eF=ea?G[5].params.length:-1,eO=ei?6:0,eP=G.length,generic=function(){for(var $=eO;$<eP;$++)if(eo[$](arguments))return eS[$].apply(this,arguments);return H.onMismatch(F,arguments,G)},fn=function fn(F,$){return arguments.length===eE&&es(F)&&ed($)?e_.apply(fn,arguments):arguments.length===eA&&eu(F)&&em($)?eN.apply(fn,arguments):arguments.length===eD&&ec(F)&&eg($)?ek.apply(fn,arguments):arguments.length===eM&&ep(F)&&ey($)?eI.apply(fn,arguments):arguments.length===eR&&eh(F)&&eb($)?eT.apply(fn,arguments):arguments.length===eF&&ef(F)&&ew($)?eC.apply(fn,arguments):generic.apply(fn,arguments)};try{Object.defineProperty(fn,"name",{value:F})}catch(F){}return fn.signatures=createSignaturesMap(G),fn}function _onMismatch(F,$,V){throw createError(F,$,V)}function notIgnore(F){return -1===H.ignore.indexOf(F)}function trim(F){return F.trim()}function notEmpty(F){return!!F}function notNull(F){return null!==F}function isInvalidParam(F){return 0===F.types.length}function initial(F){return F.slice(0,F.length-1)}function last(F){return F[F.length-1]}function slice(F,$,V){return Array.prototype.slice.call(F,$,V)}function contains(F,$){return -1!==F.indexOf($)}function hasOverlap(F,$){for(var V=0;V<F.length;V++)if(contains($,F[V]))return!0;return!1}function findInArray(F,$){for(var V=0;V<F.length;V++)if($(F[V]))return F[V]}function uniq(F){for(var $={},V=0;V<F.length;V++)$[F[V]]=!0;return Object.keys($)}function flatMap(F,$){return Array.prototype.concat.apply([],F.map($))}function getName(F){for(var $="",V=0;V<F.length;V++){var G=F[V];if(("object"==typeof G.signatures||"string"==typeof G.signature)&&""!==G.name){if(""===$)$=G.name;else if($!==G.name){var H=Error("Function names do not match (expected: "+$+", actual: "+G.name+")");throw H.data={actual:G.name,expected:$},H}}}return $}function extractSignatures(F){var $,V={};function validateUnique(F,G){if(V.hasOwnProperty(F)&&G!==V[F])throw($=Error('Signature "'+F+'" is defined twice')).data={signature:F},$}for(var G=0;G<F.length;G++){var H=F[G];if("object"==typeof H.signatures)for(var K in H.signatures)H.signatures.hasOwnProperty(K)&&(validateUnique(K,H.signatures[K]),V[K]=H.signatures[K]);else if("string"==typeof H.signature)validateUnique(H.signature,H),V[H.signature]=H;else throw($=TypeError("Function is no typed-function (index: "+G+")")).data={index:G},$}return V}return(H=createTypedFunction("typed",{"string, Object":createTypedFunction,Object:function(F){var $=[];for(var V in F)F.hasOwnProperty(V)&&$.push(F[V]);return createTypedFunction(getName($),F)},"...Function":function(F){return createTypedFunction(getName(F),extractSignatures(F))},"string, ...Function":function(F,$){return createTypedFunction(F,extractSignatures($))}})).create=create,H.types=F,H.conversions=G,H.ignore=V,H.onMismatch=_onMismatch,H.throwMismatchError=_onMismatch,H.createError=createError,H.convert=convert,H.find=find,H.addType=function(F,$){if(!F||"string"!=typeof F.name||"function"!=typeof F.test)throw TypeError("Object with properties {name: string, test: function} expected");if(!1!==$){for(var V=0;V<H.types.length;V++)if("Object"===H.types[V].name){H.types.splice(V,0,F);return}}H.types.push(F)},H.addConversion=function(F){if(!F||"string"!=typeof F.from||"string"!=typeof F.to||"function"!=typeof F.convert)throw TypeError("Object with properties {from: string, to: string, convert: function} expected");H.conversions.push(F)},H}return create()})}}]);